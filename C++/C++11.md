# 深入理解C++11：C++11新特性解析与应用

## 2.1.1 预定义宏

使用预定义宏，可以查验机器环境对C标准和C库的支持情况：

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Standand Clib: " << __STDC_HOSTED__ << endl; // Standand Clib: 1
    //cout << "Standand C: " << __STDC__ << endl;
    //cout << "Standand C: " << __STDC_VERSION__ << endl;
    //cout << "Standand C: " << __STDC_ISO_10646__ << endl;
    return 0;
}
```

## 2.1.2 \_\_func\_\_预定义标识符

\_\_func\_\_预定义标识符功能，其基本功能就是返回所在函数的名字。

```c++
#include <iostream>
using namespace std;

const char* hello() {
    return __func__;
}

const char* world() {
    return __func__;
}

int main()
{
    cout << hello() << ", " << world() << endl; // hello, world
    return 0;
}
```

按标准定义，编译器会隐匿地在函数定义之后定义\_\_func\_\_标识符。

其实际定义等同于：

```c++
const char* hello() {
 	static const char* __func__ = "hello";
    return __func__;
}
```

\_\_func\_\_预定义标识符允许其使用在类或者结构体中，如下：

```c++
#include <iostream>
using namespace std;

struct TestStruct {
    TestStruct(): name(__func__) {}

    std::string show() {
        return __func__;
    }

    const std::string name;
};

int main()
{
    TestStruct ts;
    cout << ts.name << endl;  // TestStruct
    cout << ts.show() << endl;  // show

    return 0;
}
```

不过将\_\_func\_\_作为函数参数的默认值是不允许的，如下：

```c++
void FuncFail { string func_name = __func__ } {}; // 无法通过编译
```

这是由于参数声明时，\_\_func\_\_还未被定义。

## 2.5.2 静态断言与static_assert

断言assert宏只在程序运行时才能起作用。有的时候，希望在编译时能做一些断言，如下程序，编译时不会报错：

又如：

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}
```

对于上例，可以利用“除0”会导致编译器报错这个特性来实现静态断言：

```c++
#include <iostream>
#include <cassert>
using namespace std;

#define assert_static(e) \
    do { \
        enum {assert_static__ = 1 / (e) }; \
    } while (0)

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert_static(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译失败，报错：
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,1): warning C4804:  “/”: 在操作中使用类型“bool”不安全
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         ]
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): message :  未定义的算术运算导致失败
```

C++11标准中，引入了static_assert断言来解决这个问题，接收两个参数，一个断言表达式，通常需要返回一个bool值；一个则是警告信息，通常也就是一段字符串。上例替换为static_assert：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译报错
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         ]
1>已完成在项目“TestProject.vcxproj”中生成目标“ClCompile”的操作 - 失败。
1>
1>已完成生成项目“TestProject.vcxproj”的操作 - 失败。
1>
1>生成失败。
1>
1>D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>    0 个警告
1>    1 个错误
```

static_assert是编译期的断言，其使用范围不像assert一样受到限制。通过情况下，**static_assert可以用于任何名字空间**，如下：

```c++
#include <iostream>
using namespace std;

static_assert(sizeof(int) == 8, "This 64-bit machine should follow this!"); // 应该为4

int main() {
    return 0;
}
```

必须注意的是，static_assert的断言表达式的结果必须是编译时期可以计算的表达式，即必须是常量表达式。如果使用了变量，则会导致错误，如下：

```c++
#include <iostream>
using namespace std;

int positive(const int n) {
    static_assert(n > 0, "value must > 0");
    return n;
}

int main() {
    positive(-1);
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,21): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  因读取超过生命周期的变量而失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  请参见“n”的用法
```

上例使用了参数变量n（虽然是个const参数），因而static_assert无法通过编译。如果需要的只是运行时的检查，还是应该使用assert宏。

## 2.6 noexcept修饰符和noexcept操作符 P51

`void excpt_func() throw(int, double) { //... }`

动态异常声明throw(int, double)，声明指出了expt_func可能抛出的异常的类型。该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。

noexcept形如其名，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行。

语法上讲，noexcept修饰符有两种形式：

`void excpt_func() noexcept;`

另一种可以接受一个常量表达式作为参数，如下：

`void excpt_func() noexcept (常量表达式);`

不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    try {
        Throw();
    }
    catch (...) {
        cout << "Found throw." << endl;
    }

    try {
        NoBlockThrow();
    }
    catch (...) {
        cout << "Throw is not blocked." << endl;
    }

    try {
        BlockThrow();
    }
    catch (...) {
        cout << "Found throw 1." << endl;
    }
    return 0;
}

// 输出：
Found throw.
Throw is not blocked.
// 出现中止提示框
```

noexcept作为一个操作符时，通常可以用于模板，如：

```c++
template<class T>
void fun() noexcept(nocept(T())) {}
```

这里fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式时，其返回值为false，反之为true。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() throw(int) {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    cout << noexcept(Throw()) << endl; // 0
    cout << noexcept(NoBlockThrow()) << endl; // 0
    cout << noexcept(BlockThrow()) << endl; // 1
    return 0;
}
```

同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的，当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持为默认值。如下：

```c++
#include <iostream>
using namespace std;

struct A {
    ~A() {
        throw 1;
    }
};

struct B {
    ~B() noexcept(false) {
        throw 2;
    }
};

struct C {
    B b;
};

void funA() {
    A a;
}

void funB() {
    B b;
}

void funC() {
    C c;
}

int main() {
    try {
        funB();
    }
    catch (...) {
        cout << "caught funB." << endl; // caught funB.
    }

    try {
        funC();
    }
    catch (...) {
        cout << "caught funC." << endl; // caught funC.
    }

    try {
        funA();
    }
    catch (...) {
        cout << "caught funA." << endl; // terminate called after throwing an instance of 'int'
    }
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): warning C4297:  “A::~A”: 假定函数不引发异常，但确实发生了
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): message :  析构函数或释放器具有一个(可能是隐含的)非引发异常规范
```

无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。

## 2.7 快速初始化成员变量

C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或花括号{}进行就地的非静态成员变量初始化。如：

```c++
#include <iostream>
using namespace std;

struct Init {
    int a = 1;
    double b = 1.2;
    double c{1.2};
};

int main() {
    Init init;
    return 0;
}
```

C++对于初始化表达式的改动发现，花括号式的集合（列表）初始化已经成为C++11中初始化声明的一种通用形式，而其效果类似于C++98中使用圆括号()对自定义变量的表达式列表初始化。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如下：

```c++
struct C {
    C(int i): c(i) {}
    int c;
};

struct Init {
    int a = 1;
    string b{"abc"}; // string b("abc") 无法通过编译
    C c{1}; // C c(1) 无法通过编译
};
```

程序员可以为同一成员变量既声明就地的列表初始化，又在初始化列表中进行初始化，只不过初始化列表问题看起来“后作用于”非静态成员。也就是说，初始化列表的效果总是优先于就地初始化的。

## 2.8 非静态成员的sizeof

```c++
#include <iostream>
using namespace std;

struct People {
    int hand;
    static People* all;
};


int main() {
    People p;
    cout << sizeof(p.hand) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::all) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::hand) << endl; // C++98中错误，C++11中通过
    return 0;
}
```

在C++11中，对非静态成员变量使用sizeof操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行sizeof操作。因此，如果只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员大小，通常会采用以下的代码：

`sizeof(((People*)0) -> hand);`

强制转换0为一个People类的指针，继而通过指针的解引用获得其成员变量，并用sizeof求得该成员变量的大小。在C++11中，无需这样的技巧，因为sizeof可以作用的表达式包括了类成员表达式：

`sizeof(People::hand)`

## 2.9 扩展的friend语法

C++11对friend关键字进行了一些改进：

```c++
class Poly;
typedef Poly P;

class LiLei {
    friend class Poly; // C++98通过，C++11通过
};

class Jim {
    friend Poly; // C++98失败，C++11通过
};

class HanMeiMei {
    friend P; // C++98失败，C++11通过
};
```

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。甚至还使用了Poly的别名P，这同样可行。

可以为类模板声明友元了。这在C++98中无法做到，如下：

```c++
#include <iostream>
using namespace std;

class P;

template<typename T>
class People {
    friend T;
};


int main() {
    People<P> pp; // 类型P在这里是People类型的友元
    People<int> pi; // 对于int类型模板参数，友元声明被忽略
    return 0;
}
```

有个使用friend友元来访问私有成员进行测试的使用样例，在P63。

## 2.10 final/override控制 P63

## 2.11 模板函数的默认模板参数 P67

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，如下：

```c++
void DefParm(int m = 3) {} // C++98编译通过，C++11编译通过

template<typename T = int>
class DefClass {};  // C++98编译通过，C++11编译通过

template<typename T = int>
void DefTempParm() {} // C++98编译失败，C++11编译通过
```

不过在语法上，类模板在为多个默认模板参数声明指定默认值的时候，必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说不是必须的，如下：

```c++
template<typename T1, typename T2 = int>
class DefClass1 {};

template<typename T1 = int, typename T2>
class DefClass2 {};  // 无法编译通过

template<typename T, int i = 0>
class DefClass3 {};

template<int i = 0, typename T>
class DefClass4 {};  // 无法编译通过

template<typename T1 = int, typename T2>
void DefFunc1(T1 a, T2 b);  // 可以编译通过

template<int i = 0, typename T>
void DefFunc2(T a);  // 可以编译通过
```

函数模板的参数推导规则也不复杂。如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。如下：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = 0) {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')
    f(1); // f<int, double>(1, 0)，使用了默认模板参数double
    //f(); // 错误：T无法被推导出来
    f<int>(); // f<int, double>(0, 0)，使用了默认模板参数double
    f<int, char>(); // f<int, char>(0, 0)
    return 0;
}

// 输出：
t type: int, u type: char
t value: 1, u value: c
t type: int, u type: double
t value: 1, u value: 0
t type: int, u type: double
t value: 0, u value: 0
t type: int, u type: char
t value: 0, u value:
```

这个例子可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。

还有一点，模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的，这点在使用中应当注意。

另外，将u = 0改成u = "abc"，有点问题没明白：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = "abc") {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')，output: t type: int, u type: char<Enter>t value: 1, u value: c
    f(1); // f<int, double>(1, 0)，将"abc"转成double，output: output: t type: int, u type: double<Enter>t value: 1, u value: 1.16581e-307
    f<int>(); // 这里编译错误，“f”: 函数不接受 0 个参数，f<int>(1)可以编译通过
    cout << static_cast<double>("abc") << endl; //编译错误，说“static_cast”: 无法从“const char [4]”转换为“double”，所以不知道f(1)里"abc"是如何转成double
    return 0;
}
```

## 2.12.2 显式的实例化与外部模板的声明 P71

```c++
// test.h
template<typename T> void fun(T) {}

// test1.cpp
#include "test.h"
template void fun<int>(int); // 显示地实例化
void test1() { fun(3); }

// test2.cpp
#include "test.h"
extern template void fun<int>(int); // 外部模板的声明
void test1() { fun(3); }
```

这样一来，在test2.o中不会再生成fun\<int\>(int)的实例代码。因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让test1.cpp和test2.cpp共享一份代码位置即可。而同时，编译器也不用每次都产生一份fun\<int\>(int)的代码，所以可以减少编译时间。这里也可以把外部模板声明放在test.h头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。这一点跟使用外部变量声明是完全一致的。

在使用外部模板的时候，还需要注意：**如果外部模板声明出现在某个编译单元中，那么与之对应的显示实例化必须出现在另一个编译单元中或者同一个编译单元的后续代码中**；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。

实际上，C++11中“模板的显式实例化定义、外部模板声明和使用”好比“全局变量的定义、外部声明和使用”方式的再次应用。不过相比于外部变量声明，不使用外部模板声明并不会导致任何问题。

只有在项目比较大的情况下，我们才建议用户进行这样的优化。总的来说，就是在既不忽视模板实例产生的编译及链接开销的同时，也不要过分担心模板展开的开销。

## 2.13 局部和匿名类型作模板实参 P73

C++98中，标准对模板实参的类型还有一些限制。具体讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。如下：

```c++
template<typename T>
class X {};

template<typename T>
void TempFun(T t) {};

struct A {} a;

struct {
    int i;
} b; // b是匿名类型变量

typedef struct {
    int i;
} B; // B是匿名类型

void Fun() {
    struct C {} c; // C是局部类型，c是局部变量
    X<A> x1; // C++98通过，C++11通过
    X<B> x2; // C++98错误，C++11通过
    X<C> x3; // C++98错误，C++11通过
    TempFun(a); // C++98通过，C++11通过
    TempFun(b); // C++98错误，C++11通过
    TempFun(c); // C++98错误，C++11通过
}
```

值得指出的是，虽然匿名类型可以被模板参数所接受了，但并不意味着以下写法可以被接受，如下：

```c++
template<typename T> struct MyTemplate {};

int main() {
    MyTemplate<struct { int a; }> t; // 无法通过编译，匿名类型的声明不能在模板实参位置
    return 0;
}
```

即使是匿名类型的声明，也需要独立的表达式语句。要使用匿名结构作为模板参数，则需要对匿名结构体作别名。此外在第4章还会看到使用C++11独有的类型推导decltype，也可以完成相应的功能。

## 3.1 继承构造函数

基类的非虚函数无法再被派生类使用了， 这条规则对于构造函数也不例外，如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。如下：

```c++
struct A { A(int i) {} };
struct B: A { B(int i): A(i) {} };
```

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成，如下：

```c++
#include <iostream>

using namespace std;

struct Base {
    void f(double i) {
        cout << "Base: " << i << endl;
    }
};

struct Derived : Base {
    using Base::f;

    void f(int i) {
        cout << "Derived: " << i << endl;
    }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5

    Derived d;
    d.f(4.5);  // Base: 4.5
    d.f(10);  // Derived: 10
    return 0;
}
```

这里使用了using声明，声明派生类Derived也使用基类版本的函数f。这样，派生类中实际就拥有了两个f函数的版本。

在C++中，这个想法被扩展到了构造函数中。子类可以通过使用using声明来声明继承基类的构造函数。如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A::A;
    B(const string& s): A(10) {}  // B类如果有自己的构造函数，则还是需要调用基类A构造函数
    virtual void ExtraInterface() {}
};


int main() {
    B b(10);  // 如果没有using A::A;，则编译报错
    return 0;
}
```

通过using A::A的声明，把基类中的构造函数悉数继承到派生类B中。更为精巧的是，C++11标准继承构造函数被设计为跟派生类中的各种默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会被化基类成员变量，对于派生类中的成员变量，则无能为力。不过配置2.7节中的类成员的初始化表达式，为派生类成员变量设定一个默认值还是没有问题的。

如下代码同时使用了继承构造函数和成员变量初始化两个C++11的特性。这样就可以解决一些继承构造函数无法初始化的派生类成员问题。如果这样仍然无法满足需求的话，程序员只能自动来实现一个构造函数，以达到基类和成员变量都能够初始化的目的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char *c) {}
};

struct B : A {
    using A::A;
    int d{0};
};


int main() {
    B b(356);  // b.d被初始化为0
    return 0;
}
```

有时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，**参数的默认值是不会被继承**的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int a = 3, double b = 2.4) : a_(a), b_(b) {}

    int a_;
    double b_;
};

struct B : A {
    using A::A;
};


int main() {
    B b1;
    cout << "b1.a_: " << b1.a_ << endl;
    cout << "b1.b_: " << b1.b_ << endl;

    B b2(10);
    cout << "b2.a_: " << b2.a_ << endl;
    cout << "b2.b_: " << b2.b_ << endl;

    return 0;
}
//输出：
b1.a_: 3
b1.b_: 2.4
b2.a_: 10
b2.b_: 2.4
```

参数默认值会导致多个构造函数版本的产生，因此程序员在使用有参数默认值的构造函数的基类时，必须小心。

有时，有继承构造函数“冲突”的情况。通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有时，也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。

A和B的构造函数会导致C中重复定义相同类型的继承构造函数。这种，情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐匿生成相应的继承构造函数来解决冲突，如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct B {
    B(int i) {
        cout << "B.i: " << i << endl;
    }
};

struct C : A, B {
    using A::A;
    using B::B;

    C(int i): A(i), B(i){  // 书中写为C(int) {}，感觉不对，因为A和B都没有无参数的构造函数
        cout << "C.i: " << i << endl;
    }
};


int main() {
    C c(10);
    return 0;
}
```

如果基类的构造函数被声明为私有成员函数（本地试验保护成员函数也不行），或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

```c++
#include <iostream>

using namespace std;

struct A {
protected:
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct C : A {
    using A::A;
    //C(int i) : A(10) {}  // 这里如果注释掉则编译报错
};


int main() {
    C c(10);
    return 0;
}
```

## 3.2 委派构造函数 P81

在C++11中，可以使用委派构造函数来达到期望的效果。委派构造函数是在构造函数的初始化列表位置进行构造、委派的。如下：

```c++
#include <iostream>

using namespace std;

class Info {
public:
    // 目标构造函数（target constructor）
    Info() {
        cout << "Info() type: " << type << endl;
        InitRest();
    }

    // 委派构造函数（delegating constructor）
    Info(int i) : Info() {  // 这里type是1
        type = i;  //这里经过赋值后，type是i，所以type还是多赋值了一次
    }

    // 委派构造函数（delegating constructor）
    Info(char c) : Info() {
        name = c;
    }

private:
    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type{1};
    char name{'a'};
};

int main() {
    Info info(10);
    return 0;
}
// 输出
Info() type: 1
Info::InitRest()
```

在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。

委派构造函数只能在函数体中为type、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。在C++中，构造函数不能同时“委派”和使用初始化列表，所以**如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。

这样，上述代码的初始化就不那么令人满意了，因为初始化列表的初始化方式总是等于构造函数完成的（实际在编译完成时就已经决定了），这会可能使程序员犯错（见下分析）。可以稍微改造下目标构造函数，使得委派构造函数依然可以在初始化列表中初始化所有成员，如下：

```c++
class Info {
public:
    Info() : Info(1, 'a') {}

    Info(int i) : Info(i, 'a') {}

    Info(char c) : Info(1, c) {}

private:
    Info(int i, char c) : type(i), name(c) {
        InitRest();
    }

    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type;
    char name;
};
```

如上定义了一个私有的目标构造函数Info(int, char)，接受两个参数，并将参数在初始化列表中初始化。

在使用委派构造函数的时候，建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。如在InitReset()函数中做了：

`type += 1;`

则第1份代码中Info f(3)构造出来的对象其f.type=3，第2份代码中Info f(3)构造出来的对象其f.type=4，从代码编写角度看，第2份代码中Info的行为会更加正确。这是由于在C++11中，目标构造函数的执行总是等于委派构造函数而造成的。因此避免目标构造函数和委托构造函数体中初始化同样的成员通常是必要的，否则可能发生第1份代码的错误。

构造函数比较多时，可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样，就可能在委派构造函数中形成链状的委派构造关系。有一点必须程序，就是不能形成委托环（delegation cycle），如：

```c++
struct Rule2 {
    int i, c;
    Rule(): Rule2(2) {}
    Rule(int i): Rule2('c') {}
    Rule(char c): Rule2(2) {}
};
```

Rule2定义中，Rule2()、Rule2(int)和Rule2(char)都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。

委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，如代码清单：

```c++
#include <iostream>
#include <list>
#include <vector>
#include <deque>

using namespace std;

class TDConstructed {
public:
    TDConstructed(vector<short>& v) : TDConstructed(v.begin(), v.end()) {}

    TDConstructed(deque<int>& d) : TDConstructed(d.begin(), d.end()) {}

private:
    template<class T>
    TDConstructed(T first, T last): l(first, last) {}

private:
    list<int> l;
};

int main() {
    vector<short> v = {4, 5, 6};
    TDConstructed tdConstructed1(v);

    deque<int> d = {1, 2, 3};
    TDConstructed tdConstructed2(d);
    return 0;
}
```

如上代码定义了一个构造函数模板。通过两个委派构造函数的委托，构造函数模板会被实例化。T会被推导为vector\<short\>::iterator和deque\<int\>::iterator两种类型。这比罗列不同类型的构造函数方便了很多。可以心，委托构造使得构造函数的泛型编程也成为了一种可能。

如果在委派构造函数中使用try，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。如下：

```c++
#include <iostream>

using namespace std;

class DCExcept {
public:
    DCExcept(double d)
    try : DCExcept(1, d) {
        cout << "Run the body." << endl;
    }
    catch (...) {
        cout << "caught exception." << endl;
    }

private:
    DCExcept(int i, double d) {
        cout << "going to throw!" << endl;
        throw 0;
    }

private:
    int type;
    double data;

};

int main() {
    DCExcept a(1.2);
    return 0;
}
// 输出：
going to throw!
terminate called after throwing an instance of 'int'
caught exception.
```

## 3.3 右值引用：移动语义和完美转发

### 3.3.2 移动语义

在C++11中，“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。可以理解为“移为已用”。我们可以看看如下代码是如何实现这种移动语义的：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

    HasPtrMem(HasPtrMem&& h) : d(h.d) {
        h.d = nullptr;
        cout << "Move construct: " << ++n_mvtr << endl;
    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1  // HasPtrMem h;
Resource from GetTemp: 0x6a1480
Move construct: 1  // move(h);
Destruct: 1  // h析构
Move construct: 2  // move(GetTemp());
Destruct: 2  // GetTemp返回的HasPtrMem临时变量析构
Resource from main: 0x6a1480
Destruct: 3  // a析构
```

本地试验，如果不加两个move，则只有一个构造函数调用一个析构函数调用，应该是编译器优化，直接将h赋给a，如下：

```c++
HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return h;
}

int main() {
    HasPtrMem a = GetTemp();
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1
Resource from GetTemp: 0xe81480
Resource from main: 0xe81480
Destruct: 1
```

另外，本地试验，如果不提供移动构造函数，只提供拷贝构造函数，在使用move时，会调用拷贝构造函数，如下：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

//    HasPtrMem(HasPtrMem&& h) : d(h.d) {
//        h.d = nullptr;
//        cout << "Move construct: " << ++n_mvtr << endl;
//    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出:
Construct: 1
Resource from GetTemp: 0xf01480
Copy construct: 1
Destruct: 1
Copy construct: 2
Destruct: 2
Resource from main: 0xf01480
Destruct: 3
```





为什么费力地添加移动构造函数，完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差。不过从使用的方便性来讲效果不好。如果函数返回临时值的话，可以在单条语句里完成很多计算，比如可以很自动地写出如下语句：

`Calculate(GetTemp(), SomeOther(Maybe(), Useful(Values, 2)));`

------

本地验证使用move来移动构造map：

```c++
int main() {
    map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
    map<string, int> nameValueMap2 = move(nameValueMap1);  // move之后，map1内已经没有对象了

    cout << "map1: \n";
    for_each(nameValueMap1.begin(), nameValueMap1.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });

    cout << "map2: \n";
    for_each(nameValueMap2.begin(), nameValueMap2.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });
    return 0;
}
// 输出：
map1:
map2:
a, 10
b, 20
```

如果不使用move，则调用的map的拷贝构造函数，如下：

```c++
map<string, int> nameValueMap2 = nameValueMap1;
// 输出：
map1:
a, 10
b, 20
map2:
a, 10
b, 20
```



### 3.3.3 左值、右值与右值引用



