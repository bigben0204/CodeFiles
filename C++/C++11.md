# 深入理解C++11：C++11新特性解析与应用

## 2.1.1 预定义宏

使用预定义宏，可以查验机器环境对C标准和C库的支持情况：

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Standand Clib: " << __STDC_HOSTED__ << endl; // Standand Clib: 1
    //cout << "Standand C: " << __STDC__ << endl;
    //cout << "Standand C: " << __STDC_VERSION__ << endl;
    //cout << "Standand C: " << __STDC_ISO_10646__ << endl;
    return 0;
}
```

## 2.1.2 \_\_func\_\_预定义标识符

\_\_func\_\_预定义标识符功能，其基本功能就是返回所在函数的名字。

```c++
#include <iostream>
using namespace std;

const char* hello() {
    return __func__;
}

const char* world() {
    return __func__;
}

int main()
{
    cout << hello() << ", " << world() << endl; // hello, world
    return 0;
}
```

按标准定义，编译器会隐匿地在函数定义之后定义\_\_func\_\_标识符。

其实际定义等同于：

```c++
const char* hello() {
 	static const char* __func__ = "hello";
    return __func__;
}
```

\_\_func\_\_预定义标识符允许其使用在类或者结构体中，如下：

```c++
#include <iostream>
using namespace std;

struct TestStruct {
    TestStruct(): name(__func__) {}

    std::string show() {
        return __func__;
    }

    const std::string name;
};

int main()
{
    TestStruct ts;
    cout << ts.name << endl;  // TestStruct
    cout << ts.show() << endl;  // show

    return 0;
}
```

不过将\_\_func\_\_作为函数参数的默认值是不允许的，如下：

```c++
void FuncFail { string func_name = __func__ } {}; // 无法通过编译
```

这是由于参数声明时，\_\_func\_\_还未被定义。

## 2.5.2 静态断言与static_assert

断言assert宏只在程序运行时才能起作用。有的时候，希望在编译时能做一些断言，如下程序，编译时不会报错：

又如：

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}
```

对于上例，可以利用“除0”会导致编译器报错这个特性来实现静态断言：

```c++
#include <iostream>
#include <cassert>
using namespace std;

#define assert_static(e) \
    do { \
        enum {assert_static__ = 1 / (e) }; \
    } while (0)

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert_static(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译失败，报错：
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,1): warning C4804:  “/”: 在操作中使用类型“bool”不安全
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         ]
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): message :  未定义的算术运算导致失败
```

C++11标准中，引入了static_assert断言来解决这个问题，接收两个参数，一个断言表达式，通常需要返回一个bool值；一个则是警告信息，通常也就是一段字符串。上例替换为static_assert：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译报错
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         ]
1>已完成在项目“TestProject.vcxproj”中生成目标“ClCompile”的操作 - 失败。
1>
1>已完成生成项目“TestProject.vcxproj”的操作 - 失败。
1>
1>生成失败。
1>
1>D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>    0 个警告
1>    1 个错误
```

static_assert是编译期的断言，其使用范围不像assert一样受到限制。通过情况下，**static_assert可以用于任何名字空间**，如下：

```c++
#include <iostream>
using namespace std;

static_assert(sizeof(int) == 8, "This 64-bit machine should follow this!"); // 应该为4

int main() {
    return 0;
}
```

必须注意的是，static_assert的断言表达式的结果必须是编译时期可以计算的表达式，即必须是常量表达式。如果使用了变量，则会导致错误，如下：

```c++
#include <iostream>
using namespace std;

int positive(const int n) {
    static_assert(n > 0, "value must > 0");
    return n;
}

int main() {
    positive(-1);
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,21): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  因读取超过生命周期的变量而失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  请参见“n”的用法
```

上例使用了参数变量n（虽然是个const参数），因而static_assert无法通过编译。如果需要的只是运行时的检查，还是应该使用assert宏。

## 2.6 noexcept修饰符和noexcept操作符 P51

`void excpt_func() throw(int, double) { //... }`

动态异常声明throw(int, double)，声明指出了expt_func可能抛出的异常的类型。该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。

noexcept形如其名，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行。

语法上讲，noexcept修饰符有两种形式：

`void excpt_func() noexcept;`

另一种可以接受一个常量表达式作为参数，如下：

`void excpt_func() noexcept (常量表达式);`

不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    try {
        Throw();
    }
    catch (...) {
        cout << "Found throw." << endl;
    }

    try {
        NoBlockThrow();
    }
    catch (...) {
        cout << "Throw is not blocked." << endl;
    }

    try {
        BlockThrow();
    }
    catch (...) {
        cout << "Found throw 1." << endl;
    }
    return 0;
}

// 输出：
Found throw.
Throw is not blocked.
// 出现中止提示框
```

noexcept作为一个操作符时，通常可以用于模板，如：

```c++
template<class T>
void fun() noexcept(nocept(T())) {}
```

这里fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式时，其返回值为false，反之为true。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() throw(int) {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    cout << noexcept(Throw()) << endl; // 0
    cout << noexcept(NoBlockThrow()) << endl; // 0
    cout << noexcept(BlockThrow()) << endl; // 1
    return 0;
}
```

同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的，当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持为默认值。如下：

```c++
#include <iostream>
using namespace std;

struct A {
    ~A() {
        throw 1;
    }
};

struct B {
    ~B() noexcept(false) {
        throw 2;
    }
};

struct C {
    B b;
};

void funA() {
    A a;
}

void funB() {
    B b;
}

void funC() {
    C c;
}

int main() {
    try {
        funB();
    }
    catch (...) {
        cout << "caught funB." << endl; // caught funB.
    }

    try {
        funC();
    }
    catch (...) {
        cout << "caught funC." << endl; // caught funC.
    }

    try {
        funA();
    }
    catch (...) {
        cout << "caught funA." << endl; // terminate called after throwing an instance of 'int'
    }
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): warning C4297:  “A::~A”: 假定函数不引发异常，但确实发生了
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): message :  析构函数或释放器具有一个(可能是隐含的)非引发异常规范
```

无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。

## 2.7 快速初始化成员变量

C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或花括号{}进行就地的非静态成员变量初始化。如：

```c++
#include <iostream>
using namespace std;

struct Init {
    int a = 1;
    double b = 1.2;
    double c{1.2};
};

int main() {
    Init init;
    return 0;
}
```

C++对于初始化表达式的改动发现，花括号式的集合（列表）初始化已经成为C++11中初始化声明的一种通用形式，而其效果类似于C++98中使用圆括号()对自定义变量的表达式列表初始化。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如下：

```c++
struct C {
    C(int i): c(i) {}
    int c;
};

struct Init {
    int a = 1;
    string b{"abc"}; // string b("abc") 无法通过编译
    C c{1}; // C c(1) 无法通过编译
};
```

程序员可以为同一成员变量既声明就地的列表初始化，又在初始化列表中进行初始化，只不过初始化列表问题看起来“后作用于”非静态成员。也就是说，初始化列表的效果总是优先于就地初始化的。

## 2.8 非静态成员的sizeof

```c++
#include <iostream>
using namespace std;

struct People {
    int hand;
    static People* all;
};


int main() {
    People p;
    cout << sizeof(p.hand) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::all) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::hand) << endl; // C++98中错误，C++11中通过
    return 0;
}
```

在C++11中，对非静态成员变量使用sizeof操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行sizeof操作。因此，如果只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员大小，通常会采用以下的代码：

`sizeof(((People*)0) -> hand);`

强制转换0为一个People类的指针，继而通过指针的解引用获得其成员变量，并用sizeof求得该成员变量的大小。在C++11中，无需这样的技巧，因为sizeof可以作用的表达式包括了类成员表达式：

`sizeof(People::hand)`

## 2.9 扩展的friend语法

C++11对friend关键字进行了一些改进：

```c++
class Poly;
typedef Poly P;

class LiLei {
    friend class Poly; // C++98通过，C++11通过
};

class Jim {
    friend Poly; // C++98失败，C++11通过
};

class HanMeiMei {
    friend P; // C++98失败，C++11通过
};
```

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。甚至还使用了Poly的别名P，这同样可行。

可以为类模板声明友元了。这在C++98中无法做到，如下：

```c++
#include <iostream>
using namespace std;

class P;

template<typename T>
class People {
    friend T;
};


int main() {
    People<P> pp; // 类型P在这里是People类型的友元
    People<int> pi; // 对于int类型模板参数，友元声明被忽略
    return 0;
}
```

有个使用friend友元来访问私有成员进行测试的使用样例，在P63。

## 2.10 final/override控制 P63

## 2.11 模板函数的默认模板参数 P67

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，如下：

```c++
void DefParm(int m = 3) {} // C++98编译通过，C++11编译通过

template<typename T = int>
class DefClass {};  // C++98编译通过，C++11编译通过

template<typename T = int>
void DefTempParm() {} // C++98编译失败，C++11编译通过
```

不过在语法上，类模板在为多个默认模板参数声明指定默认值的时候，必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说不是必须的，如下：

```c++
template<typename T1, typename T2 = int>
class DefClass1 {};

template<typename T1 = int, typename T2>
class DefClass2 {};  // 无法编译通过

template<typename T, int i = 0>
class DefClass3 {};

template<int i = 0, typename T>
class DefClass4 {};  // 无法编译通过

template<typename T1 = int, typename T2>
void DefFunc1(T1 a, T2 b);  // 可以编译通过

template<int i = 0, typename T>
void DefFunc2(T a);  // 可以编译通过
```

函数模板的参数推导规则也不复杂。如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。如下：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = 0) {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')
    f(1); // f<int, double>(1, 0)，使用了默认模板参数double
    //f(); // 错误：T无法被推导出来
    f<int>(); // f<int, double>(0, 0)，使用了默认模板参数double
    f<int, char>(); // f<int, char>(0, 0)
    return 0;
}

// 输出：
t type: int, u type: char
t value: 1, u value: c
t type: int, u type: double
t value: 1, u value: 0
t type: int, u type: double
t value: 0, u value: 0
t type: int, u type: char
t value: 0, u value:
```

这个例子可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。

还有一点，模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的，这点在使用中应当注意。

另外，将u = 0改成u = "abc"，有点问题没明白：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = "abc") {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')，output: t type: int, u type: char<Enter>t value: 1, u value: c
    f(1); // f<int, double>(1, 0)，将"abc"转成double，output: output: t type: int, u type: double<Enter>t value: 1, u value: 1.16581e-307
    f<int>(); // 这里编译错误，“f”: 函数不接受 0 个参数，f<int>(1)可以编译通过
    cout << static_cast<double>("abc") << endl; //编译错误，说“static_cast”: 无法从“const char [4]”转换为“double”，所以不知道f(1)里"abc"是如何转成double
    return 0;
}
```

## 2.12.2 显式的实例化与外部模板的声明 P71

```c++
// test.h
template<typename T> void fun(T) {}

// test1.cpp
#include "test.h"
template void fun<int>(int); // 显示地实例化
void test1() { fun(3); }

// test2.cpp
#include "test.h"
extern template void fun<int>(int); // 外部模板的声明
void test1() { fun(3); }
```

这样一来，在test2.o中不会再生成fun\<int\>(int)的实例代码。因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让test1.cpp和test2.cpp共享一份代码位置即可。而同时，编译器也不用每次都产生一份fun\<int\>(int)的代码，所以可以减少编译时间。这里也可以把外部模板声明放在test.h头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。这一点跟使用外部变量声明是完全一致的。

在使用外部模板的时候，还需要注意：**如果外部模板声明出现在某个编译单元中，那么与之对应的显示实例化必须出现在另一个编译单元中或者同一个编译单元的后续代码中**；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。

实际上，C++11中“模板的显式实例化定义、外部模板声明和使用”好比“全局变量的定义、外部声明和使用”方式的再次应用。不过相比于外部变量声明，不使用外部模板声明并不会导致任何问题。

只有在项目比较大的情况下，我们才建议用户进行这样的优化。总的来说，就是在既不忽视模板实例产生的编译及链接开销的同时，也不要过分担心模板展开的开销。

## 2.13 局部和匿名类型作模板实参 P73

C++98中，标准对模板实参的类型还有一些限制。具体讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。如下：

```c++
template<typename T>
class X {};

template<typename T>
void TempFun(T t) {};

struct A {} a;

struct {
    int i;
} b; // b是匿名类型变量

typedef struct {
    int i;
} B; // B是匿名类型

void Fun() {
    struct C {} c; // C是局部类型，c是局部变量
    X<A> x1; // C++98通过，C++11通过
    X<B> x2; // C++98错误，C++11通过
    X<C> x3; // C++98错误，C++11通过
    TempFun(a); // C++98通过，C++11通过
    TempFun(b); // C++98错误，C++11通过
    TempFun(c); // C++98错误，C++11通过
}
```

值得指出的是，虽然匿名类型可以被模板参数所接受了，但并不意味着以下写法可以被接受，如下：

```c++
template<typename T> struct MyTemplate {};

int main() {
    MyTemplate<struct { int a; }> t; // 无法通过编译，匿名类型的声明不能在模板实参位置
    return 0;
}
```

即使是匿名类型的声明，也需要独立的表达式语句。要使用匿名结构作为模板参数，则需要对匿名结构体作别名。此外在第4章还会看到使用C++11独有的类型推导decltype，也可以完成相应的功能。

## 3.1 继承构造函数

基类的非虚函数无法再被派生类使用了， 这条规则对于构造函数也不例外，如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。如下：

```c++
struct A { A(int i) {} };
struct B: A { B(int i): A(i) {} };
```

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成，如下：

```c++
#include <iostream>

using namespace std;

struct Base {
    void f(double i) {
        cout << "Base: " << i << endl;
    }
};

struct Derived : Base {
    using Base::f;

    void f(int i) {
        cout << "Derived: " << i << endl;
    }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5

    Derived d;
    d.f(4.5);  // Base: 4.5
    d.f(10);  // Derived: 10
    return 0;
}
```

这里使用了using声明，声明派生类Derived也使用基类版本的函数f。这样，派生类中实际就拥有了两个f函数的版本。

在C++中，这个想法被扩展到了构造函数中。子类可以通过使用using声明来声明继承基类的构造函数。如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A::A;
    B(const string& s): A(10) {}  // B类如果有自己的构造函数，则还是需要调用基类A构造函数
    virtual void ExtraInterface() {}
};


int main() {
    B b(10);  // 如果没有using A::A;，则编译报错
    return 0;
}
```

通过using A::A的声明，把基类中的构造函数悉数继承到派生类B中。更为精巧的是，C++11标准继承构造函数被设计为跟派生类中的各种默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会被化基类成员变量，对于派生类中的成员变量，则无能为力。不过配置2.7节中的类成员的初始化表达式，为派生类成员变量设定一个默认值还是没有问题的。

如下代码同时使用了继承构造函数和成员变量初始化两个C++11的特性。这样就可以解决一些继承构造函数无法初始化的派生类成员问题。如果这样仍然无法满足需求的话，程序员只能自动来实现一个构造函数，以达到基类和成员变量都能够初始化的目的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char *c) {}
};

struct B : A {
    using A::A;
    int d{0};
};


int main() {
    B b(356);  // b.d被初始化为0
    return 0;
}
```

有时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，**参数的默认值是不会被继承**的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int a = 3, double b = 2.4) : a_(a), b_(b) {}

    int a_;
    double b_;
};

struct B : A {
    using A::A;
};


int main() {
    B b1;
    cout << "b1.a_: " << b1.a_ << endl;
    cout << "b1.b_: " << b1.b_ << endl;

    B b2(10);
    cout << "b2.a_: " << b2.a_ << endl;
    cout << "b2.b_: " << b2.b_ << endl;

    return 0;
}
//输出：
b1.a_: 3
b1.b_: 2.4
b2.a_: 10
b2.b_: 2.4
```

参数默认值会导致多个构造函数版本的产生，因此程序员在使用有参数默认值的构造函数的基类时，必须小心。

有时，有继承构造函数“冲突”的情况。通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有时，也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。

A和B的构造函数会导致C中重复定义相同类型的继承构造函数。这种，情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐匿生成相应的继承构造函数来解决冲突，如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct B {
    B(int i) {
        cout << "B.i: " << i << endl;
    }
};

struct C : A, B {
    using A::A;
    using B::B;

    C(int i): A(i), B(i){  // 书中写为C(int) {}，感觉不对，因为A和B都没有无参数的构造函数
        cout << "C.i: " << i << endl;
    }
};


int main() {
    C c(10);
    return 0;
}
```

如果基类的构造函数被声明为私有成员函数（本地试验保护成员函数也不行），或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

```c++
#include <iostream>

using namespace std;

struct A {
protected:
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct C : A {
    using A::A;
    //C(int i) : A(10) {}  // 这里如果注释掉则编译报错
};


int main() {
    C c(10);
    return 0;
}
```

## 3.2 委派构造函数 P81

在C++11中，可以使用委派构造函数来达到期望的效果。委派构造函数是在构造函数的初始化列表位置进行构造、委派的。如下：

```c++
#include <iostream>

using namespace std;

class Info {
public:
    // 目标构造函数（target constructor）
    Info() {
        cout << "Info() type: " << type << endl;
        InitRest();
    }

    // 委派构造函数（delegating constructor）
    Info(int i) : Info() {  // 这里type是1
        type = i;  //这里经过赋值后，type是i，所以type还是多赋值了一次
    }

    // 委派构造函数（delegating constructor）
    Info(char c) : Info() {
        name = c;
    }

private:
    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type{1};
    char name{'a'};
};

int main() {
    Info info(10);
    return 0;
}
// 输出
Info() type: 1
Info::InitRest()
```

在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。

委派构造函数只能在函数体中为type、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。在C++中，构造函数不能同时“委派”和使用初始化列表，所以**如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。

这样，上述代码的初始化就不那么令人满意了，因为初始化列表的初始化方式总是等于构造函数完成的（实际在编译完成时就已经决定了），这会可能使程序员犯错（见下分析）。可以稍微改造下目标构造函数，使得委派构造函数依然可以在初始化列表中初始化所有成员，如下：

```c++
class Info {
public:
    Info() : Info(1, 'a') {}

    Info(int i) : Info(i, 'a') {}

    Info(char c) : Info(1, c) {}

private:
    Info(int i, char c) : type(i), name(c) {
        InitRest();
    }

    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type;
    char name;
};
```

如上定义了一个私有的目标构造函数Info(int, char)，接受两个参数，并将参数在初始化列表中初始化。

在使用委派构造函数的时候，建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。如在InitReset()函数中做了：

`type += 1;`

则第1份代码中Info f(3)构造出来的对象其f.type=3，第2份代码中Info f(3)构造出来的对象其f.type=4，从代码编写角度看，第2份代码中Info的行为会更加正确。这是由于在C++11中，目标构造函数的执行总是等于委派构造函数而造成的。因此避免目标构造函数和委托构造函数体中初始化同样的成员通常是必要的，否则可能发生第1份代码的错误。

构造函数比较多时，可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样，就可能在委派构造函数中形成链状的委派构造关系。有一点必须程序，就是不能形成委托环（delegation cycle），如：

```c++
struct Rule2 {
    int i, c;
    Rule(): Rule2(2) {}
    Rule(int i): Rule2('c') {}
    Rule(char c): Rule2(2) {}
};
```

Rule2定义中，Rule2()、Rule2(int)和Rule2(char)都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。

委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，如代码清单：

```c++
#include <iostream>
#include <list>
#include <vector>
#include <deque>

using namespace std;

class TDConstructed {
public:
    TDConstructed(vector<short>& v) : TDConstructed(v.begin(), v.end()) {}

    TDConstructed(deque<int>& d) : TDConstructed(d.begin(), d.end()) {}

private:
    template<class T>
    TDConstructed(T first, T last): l(first, last) {}

private:
    list<int> l;
};

int main() {
    vector<short> v = {4, 5, 6};
    TDConstructed tdConstructed1(v);

    deque<int> d = {1, 2, 3};
    TDConstructed tdConstructed2(d);
    return 0;
}
```

如上代码定义了一个构造函数模板。通过两个委派构造函数的委托，构造函数模板会被实例化。T会被推导为vector\<short\>::iterator和deque\<int\>::iterator两种类型。这比罗列不同类型的构造函数方便了很多。可以心，委托构造使得构造函数的泛型编程也成为了一种可能。

如果在委派构造函数中使用try，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。如下：

```c++
#include <iostream>

using namespace std;

class DCExcept {
public:
    DCExcept(double d)
    try : DCExcept(1, d) {
        cout << "Run the body." << endl;
    }
    catch (...) {
        cout << "caught exception." << endl;
    }

private:
    DCExcept(int i, double d) {
        cout << "going to throw!" << endl;
        throw 0;
    }

private:
    int type;
    double data;

};

int main() {
    DCExcept a(1.2);
    return 0;
}
// 输出：
going to throw!
terminate called after throwing an instance of 'int'
caught exception.
```

## 3.3 右值引用：移动语义和完美转发

### 3.3.2 移动语义

在C++11中，“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。可以理解为“移为已用”。我们可以看看如下代码是如何实现这种移动语义的：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

    HasPtrMem(HasPtrMem&& h) : d(h.d) {
        h.d = nullptr;
        cout << "Move construct: " << ++n_mvtr << endl;
    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1  // HasPtrMem h;
Resource from GetTemp: 0x6a1480
Move construct: 1  // move(h);
Destruct: 1  // h析构
Move construct: 2  // move(GetTemp());
Destruct: 2  // GetTemp返回的HasPtrMem临时变量析构
Resource from main: 0x6a1480
Destruct: 3  // a析构
```

本地试验，如果不加两个move，则只有一个构造函数调用一个析构函数调用，应该是编译器优化，直接将h赋给a，如下：

```c++
HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return h;
}

int main() {
    HasPtrMem a = GetTemp();
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1
Resource from GetTemp: 0xe81480
Resource from main: 0xe81480
Destruct: 1
```

另外，本地试验，如果不提供移动构造函数，只提供拷贝构造函数，在使用move时，会调用拷贝构造函数，如下：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

//    HasPtrMem(HasPtrMem&& h) : d(h.d) {
//        h.d = nullptr;
//        cout << "Move construct: " << ++n_mvtr << endl;
//    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出:
Construct: 1
Resource from GetTemp: 0xf01480
Copy construct: 1
Destruct: 1
Copy construct: 2
Destruct: 2
Resource from main: 0xf01480
Destruct: 3
```





为什么费力地添加移动构造函数，完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差。不过从使用的方便性来讲效果不好。如果函数返回临时值的话，可以在单条语句里完成很多计算，比如可以很自动地写出如下语句：

`Calculate(GetTemp(), SomeOther(Maybe(), Useful(Values, 2)));`

------

本地验证使用move来移动构造map：

```c++
int main() {
    map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
    map<string, int> nameValueMap2 = move(nameValueMap1);  // move之后，map1内已经没有对象了

    cout << "map1: \n";
    for_each(nameValueMap1.begin(), nameValueMap1.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });

    cout << "map2: \n";
    for_each(nameValueMap2.begin(), nameValueMap2.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });
    return 0;
}
// 输出：
map1:
map2:
a, 10
b, 20
```

如果不使用move，则调用的map的拷贝构造函数，如下：

```c++
map<string, int> nameValueMap2 = nameValueMap1;
// 输出：
map1:
a, 10
b, 20
map2:
a, 10
b, 20
```

### 3.3.3 左值、右值与右值引用

在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。如：

`a = b + c`
这个赋值表达式中，a就是一个左值，而b+c则是一个右值。这种识别左值、右值的方法在C++中依然有效。不过C++中还有一个被广泛认同的说法，就是可以取地址的、有名字的就是左值。反之，不能取地址的、没有名字的就是右值。

这些差别方法通常都非常有效。在C++11中，右值是由两个概念构成的，一个是将亡值（xvalue, eXpiring Value），另一个则是纯右值（prvalue, Pure Rvalue）。

其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。

而将亡值则是C++11新增的跟右值引用相关的表达式，这样的表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

在C++11程序中，所有的值必属于左值、将亡值、纯右值三者之一。

在C++11中，右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。通常情况下，我们只能是从右值表达式获得其引用。比如：

`T&& a = ReturnRvalue();`

这个表达式，假设ReturnRvalue返回一个右值，我们就声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”（lvalue reference）。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

在上面的例子，ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了（通常我们也称其具有表达式生命期），而通过右值引用的声明，该右值又“重获新生”，其生命期将与右值引用类型变量a的生命期一样。只要a还“活着”，该右值临时量将会一直“存活下去”。

所以相比于以下语句的声明方式：

`T b = ReturnRvalue()`

刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为a是右值引用，直接绑定了ReturnRvalue()返回的临时量，而b只是由临时值构造而成的，而临时量在表达式结束会析构因而就会多一次析构和构造的开销。

不过能够声明**右值引用a的前提是ReturnRvalue返回的是一个右值**。通常情况下，右值引用是不能够绑定到任何的左值的。

右值引用&&只能绑定在右值上，所以如下在左值nameValueMap1进行&&右值引用绑定编译失败：

```c++
map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
map<string, int>&& nameValueMap2 = nameValueMap1;
```

相对地，在C++98标准中就已经出现的左值引用是否可以绑定到右值（由右值进行初始化）呢？如：

```c++
T& e = ReturnRvalue();
const T& f = ReturnRvalue();
```

答案是：e的初始化会导致编译时错误，而f则不会。

原因是，常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。而在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过**相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的**。相对的，非常量左值只能接受非常量左值对其进行初始化。

在C++98通过左值引用来绑定一个右值的情况并不少见，比如：

`const bool& judgement = true;`

就是一个使用常量左值引用来绑定右值的例子。不过与如下声明相比看起来似乎差别不大：

`const bool judgement = true;`

从语法上讲，前者直接使用了右值并为其“续命”，而后者的右值在表达式结束后就销毁了。

事实上，即使在C++98中，也常可以使用常量左值引用来减少临时对象的开销，如：

```c++
void show(const string& s) {} // 使用常量左值引用来接临时变量

show("abc");
```

而在C++11中，同样的，也可以右值引用为参数声明如下函数：

`void AcceptRvalueRef(Copyable&& ) {}`

也同样可以减少临时变量拷贝的开销。进一步地，还可以在AcceptRvalueRef中修改该临时值（这时临时值由于被右值引用参数所引用，已经获得了函数时间的生命期）。不过修改一个临时值的意义通常不大，除非像3.3.2节一样使用移动语义。

就本例而言，如果这样实现函数：

```c++
void AcceptRvalueRef(Copyable&& s) {
    Copyable news = std::move(s);
}
```

这里std::move的作用是强制一个左值（s）成为右值（s）。该函数就是使用右值来初始化Copyable变量news。使用移动语义的前提是Copyable还需要添加一个以右值引用为参数的移动构造函数，如：

`Copyable(Copyable&& o) { /*实现移动语义*/ }`

这样，如果Copyable类的临时变量（即ReturnRvalue返回的临时值）中包含一些大块内存的指针，news就可以如同代码清单3-19一样将临时值中的内存“窃”为已用，从而从这个以右值引用参数的AccepRvalueRef函数中获得最大的收益。事实上，**右值引用的由来从来就跟移动语义紧紧相关。这是右值存在的一个最大的价值（另外一个价值是用于转发）**。

如果不声明移动构造函数，而只声明一个常量左值的构造函数会生成什么？如同刚才提到的，常量左值是个“万能”的引用类型，无论左值还是右值，常量还是非常量，一概能够绑定。那么如果Copyable没有移动构造函数，下列一语句：

`Copyable news = std::move(s);`

将调用以常量左值为参数的拷贝构造函数。这是一种非常安全的设计——**移动不成，至少还可以执行拷贝**。因此，通常情况下，程序员会为声明了移动构造函数的类声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，可以使用拷贝构造。

为了语义的完整，C++11中还存在着常量右值引用，如通过如下代码声明一个常量右值引用：

`const T&& crvalueref = ReturnRvalue();`

但是，一来右值引用主要就是为了移动语义，而移动语义需要右值是可以被修改的，那么常量右值引用在移动语义中就没有用武之处；二来如果要引用右值且让右值不可以更改，常量左值引用往往就足够了。因此在现在的情况下，我们还没有看到常量右值引用有何用处。

![](pictures\C++11中引用类型及其可以引用的值类型.png)

有时候，可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用（这在模板中比较常见）。标准库在\<type_traits\>头文件中提供了3个模板类：is_rvalue_reference、is_lvalue_reference、is_reference，可供我们进行判断，如：

```c++
HasPtrMem&& a = GetTemp();
cout << is_rvalue_reference<decltype(a)>::value << "\n";  // 1
cout << is_rvalue_reference<string&&>::value << "\n";  // 1
cout << is_rvalue_reference<map<int, int>&&>::value << "\n";  // 1
```

通过模板类的成员value就可以打印出string&&是否是一个右值引用了。配置第4章中的类型推导操作符decltype，甚至还可以对变量的类型进行判断。

说明：右值引用对象已经是一个左值了，可以使用&获取地址：

```c++
HasPtrMem&& a = GetTemp();
HasPtrMem* p = &a;
```

### 3.3.4 std::move：强制转化为右值 P99

std::move并不能移动任何东西，唯一的功能是将一个左值强制转化为右值引用，继承可以通过右值引用使用该值，用于移动语义。从实现上讲，std::move基本等同于一个类型转换：

`static_cast<&&>(lvalue);`

被转化的左值，其生命期并没有随着左值值的转化而改变，所以被std::move转化的左值变量lvalue不会被立即析构。

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

class Moveable {
public:
    Moveable() : i(new int(3)) {}

    ~Moveable() { delete i; }

    Moveable(Moveable&& m) : i(m.i) {
        m.i = nullptr;
    }

    int* i;
};

int main() {
    Moveable a;
    Moveable c(move(a));  // 会调用移动构造函数，这里move(a)将左值a变成一个右值引用，所以才会调用移动构造函数Moveable(Moveable&& m)
    cout << *a.i << endl;  // 运行时错误
    return 0;
}
```

这 里的a本来是一个左值变量，通过std::move将其转换为右值。这样一来，a.i就被c的移动构造函数设置为指针空值。由于a的生命期实际要到main函数结束才结束，所以对表达式*a.i进行计算就会运行错误。

这里如果不使用move(a)，则使用c(a)，则编译报错：

```c++
Moveable a;
Moveable c(a);  // 编译报错，因为显示声明了移动构造函数，所以拷贝构造函数如果不显示声明，则编译器不会生成拷贝构造函数
Moveable d;  // 编译报错，显示声明了移动构造函数，则编译器不会生成拷贝赋值函数
d = a;
```

事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用std::move转换拥有形如堆内存、文件句柄等资源的成员为右值，这样，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的拷贝构造函数版本也会轻松地实现拷贝构造，因此也不会引用大的问题。

### 3.3.5 移动语义的一些其他问题

移动语义一定是要修改临时变量的值，那么这样声明移动构造函数：

`Moveable(const Moveable&&)`

或者这样声明：

`const Moveable ReturnVal();`

都会使得临时变量常量化，成为一个常量右值，那么临时变量的引用也就无法修改，从而导致无法实现移动语义。因此在实现移动语义一定要注意排除不必要的const关键字。

默认情况下，编译器会为程序隐式地生成一个（隐式表示如果不使用则不生成）移动构造函数。

不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数（本地试验声明了析构函数不会影响默认构造函数的生成）中的一个或者多个，编译器都不会再为程序员生成默认版本。**默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作**。这对实现移动语义来说是不够的。通常情况下，**如果需要移动语义，程序员必须自定义移动构造函数**。对一些简单的、不包含任何资源的类型来说，实现移动语义与否都无关紧要，因为对这样的类型而言，移动就是拷贝，拷贝就是移动。

同样的，声明了移动构造函数、拷贝赋值函数、移动赋值函数和构造函数中的一个或者多个，编译器也不再会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/拷贝赋值和移动构造/移动赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。

```c++
String(const String &other);  // 拷贝构造函数 
String& operator=(const String& other);  // 拷贝赋值函数

//C++ 11的新函数 
String(String &&other);  // 移动构造函数
String& operator=(String&& other);  // 移动赋值函数
```

其实，只现实一种语义在类的编写中也是非常常见的。如只有拷贝语义的类型——在C++11之前我们见过大多数的类型的构造都是只使用拷贝语义的。而只有移动语义的类型则非常有趣，因为只有移动语义表明该类型的变量所拥有的资源只能被移动，而不能被拷贝。那么这样的资源必须是唯一的，因此，只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针、文件流等，都可以视为“资源型”的类型。如标准库中的仅可移动的模板类：unique_ptr。一些编译器，如2011，现在也把ifstream这样的类型实现为仅可移动的。

```c++
unique_ptr<int> p1 = make_unique<int>(3);
unique_ptr<int> p2 = move(p1);  // unique_ptr<int> p2 = p1编译报错，无拷贝构造
```

在标准库的头文件\<type_traits\>里，可以通过一些辅助的模板类来判断一个类型是否可以移动的。如is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible，使用方法仍然是使用其成员value。如：

```c++
cout << is_move_constructible<unique_ptr<int>>::value << "\n";  // 1
cout << is_copy_constructible<unique_ptr<int>>::value << "\n";  // 0
```

而有了移动语义，还有一个比较典型的应用是可以实现高性能的转换（swap）函数。看下面这段swap模板函数代码：

```c++
#include <iostream>
#include <memory>

using namespace std;

template<class T>
void mySwap(T& a, T& b) {
    T tmp(move(a));
    a = move(b);
    b = move(tmp);
}

int main() {
    unique_ptr<int> p1 = make_unique<int>(3);
    unique_ptr<int> p2 = make_unique<int>(5);
    cout << "Before swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    mySwap(p1, p2);
    cout << "After swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    return 0;
}
// 输出：
Before swap, p1: 3, p2: 5
After swap, p1: 5, p2: 3
```

如果T移动，那么移动构造和移动赋值将会被用于这个转换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行转换。这就跟普通的转换语句是相同的。在移动语义的支持下，仅仅通过一个通用的模板，就可能更高效地完成转换，这对于泛型编程来说，无疑是具有积极意义的。

另外一个关于移动构造的话题是异常。对于移动构造函数来说，抛出异常是件危险的事。因为可能移动语义还没完成，一个异常抛出来，这就会导致一些指针成为悬挂指针。因此应该尽量编写不抛出异常的移动构造函数，通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用ternimate程序终止运行。而标准库中，还可以用一个std::move_if_noexcept的模板函数替代move函数。该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义。如下：

```c++
#include <iostream>

using namespace std;

struct MayThrow {
    MayThrow() {}

    MayThrow(const MayThrow&) {
        cout << "Maythrow copy constructor." << endl;
    }

    MayThrow(const MayThrow&&) {
        cout << "Maythrow move constructor." << endl;
    }
};

struct NoThrow {
    NoThrow() {}

    NoThrow(const NoThrow&) noexcept {
        cout << "NoThrow copy constructor." << endl;
    }

    NoThrow(const NoThrow&&) noexcept {
        cout << "NoThrow move constructor." << endl;
    }
};

int main() {
    MayThrow m;
    NoThrow n;

    MayThrow mt = move_if_noexcept(m);  // Maythrow copy constructor.
    NoThrow nt = move_if_noexcept(n);  // NoThrow move constructor.

    return 0;
}
```

move_if_noexcept是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用noexcept进行描述，否则就会损失更多的性能。

编译器中被称为RVO/NRVO的优化（RVO，Return Value Optimization，返回值优化，或者NRVO，Named Return Value Optimization）。在本节中大量的代码都使用了-fno-elide-constructors选项在g++/clang++中关闭这个优化，这样可以在代码中较为容易地利用函数返回的临时量右值。

但若在编译的时候不使用该选项的话，会发现很多构造和移动都被省略。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从ReturnValue函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了：

```c++
A ReturnRvalue() {
    A a();
    return a;
}

A b = ReturnRvalue();
```

b变量实际就使用了ReturnRvalue函数中a 的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量“霸占”了a变量。这是编译器中一个效果非常好的优化。不过RVO/RNVO并不是对任何情况都有效。有些情况下，一些构造是无法省略的。还有一些情况，即使RVO/NRVO完成了，也不能达到最好的效果。但结论是明显的，移动语义可以解决编译器无法解决的优化问题，因而总是有用的。

关于RVO/RNVO可以参见如下博客：

<https://blog.csdn.net/songchuwang1868/article/details/83622039>

### 3.3.6 完美转发 P104

