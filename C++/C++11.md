# 深入理解C++11：C++11新特性解析与应用

## 2.1 保持与C99兼容

### 2.1.1 预定义宏

使用预定义宏，可以查验机器环境对C标准和C库的支持情况：

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Standand Clib: " << __STDC_HOSTED__ << endl; // Standand Clib: 1
    //cout << "Standand C: " << __STDC__ << endl;
    //cout << "Standand C: " << __STDC_VERSION__ << endl;
    //cout << "Standand C: " << __STDC_ISO_10646__ << endl;
    return 0;
}
```

### 2.1.2 \_\_func\_\_预定义标识符

\_\_func\_\_预定义标识符功能，其基本功能就是返回所在函数的名字。

```c++
#include <iostream>
using namespace std;

const char* hello() {
    return __func__;
}

const char* world() {
    return __func__;
}

int main()
{
    cout << hello() << ", " << world() << endl; // hello, world
    return 0;
}
```

按标准定义，编译器会隐匿地在函数定义之后定义\_\_func\_\_标识符。

其实际定义等同于：

```c++
const char* hello() {
 	static const char* __func__ = "hello";
    return __func__;
}
```

\_\_func\_\_预定义标识符允许其使用在类或者结构体中，如下：

```c++
#include <iostream>
using namespace std;

struct TestStruct {
    TestStruct(): name(__func__) {}

    std::string show() {
        return __func__;
    }

    const std::string name;
};

int main()
{
    TestStruct ts;
    cout << ts.name << endl;  // TestStruct
    cout << ts.show() << endl;  // show

    return 0;
}
```

不过将\_\_func\_\_作为函数参数的默认值是不允许的，如下：

```c++
void FuncFail { string func_name = __func__ } {}; // 无法通过编译
```

这是由于参数声明时，\_\_func\_\_还未被定义。

## 2.5.2 静态断言与static_assert

断言assert宏只在程序运行时才能起作用。有的时候，希望在编译时能做一些断言，如下程序，编译时不会报错：

又如：

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}
```

对于上例，可以利用“除0”会导致编译器报错这个特性来实现静态断言：

```c++
#include <iostream>
#include <cassert>
using namespace std;

#define assert_static(e) \
    do { \
        enum {assert_static__ = 1 / (e) }; \
    } while (0)

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert_static(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译失败，报错：
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,1): warning C4804:  “/”: 在操作中使用类型“bool”不安全
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         ]
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): message :  未定义的算术运算导致失败
```

C++11标准中，引入了static_assert断言来解决这个问题，接收两个参数，一个断言表达式，通常需要返回一个bool值；一个则是警告信息，通常也就是一段字符串。上例替换为static_assert：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译报错
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         ]
1>已完成在项目“TestProject.vcxproj”中生成目标“ClCompile”的操作 - 失败。
1>
1>已完成生成项目“TestProject.vcxproj”的操作 - 失败。
1>
1>生成失败。
1>
1>D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>    0 个警告
1>    1 个错误
```

static_assert是编译期的断言，其使用范围不像assert一样受到限制。通过情况下，**static_assert可以用于任何名字空间**，如下：

```c++
#include <iostream>
using namespace std;

static_assert(sizeof(int) == 8, "This 64-bit machine should follow this!"); // 应该为4

int main() {
    return 0;
}
```

必须注意的是，static_assert的断言表达式的结果必须是编译时期可以计算的表达式，即必须是常量表达式。如果使用了变量，则会导致错误，如下：

```c++
#include <iostream>
using namespace std;

int positive(const int n) {
    static_assert(n > 0, "value must > 0");
    return n;
}

int main() {
    positive(-1);
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,21): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  因读取超过生命周期的变量而失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  请参见“n”的用法
```

上例使用了参数变量n（虽然是个const参数），因而static_assert无法通过编译。如果需要的只是运行时的检查，还是应该使用assert宏。

## 2.6 noexcept修饰符和noexcept操作符 P51

`void excpt_func() throw(int, double) { //... }`

动态异常声明throw(int, double)，声明指出了expt_func可能抛出的异常的类型。该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。

noexcept形如其名，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行。

语法上讲，noexcept修饰符有两种形式：

`void excpt_func() noexcept;`

另一种可以接受一个常量表达式作为参数，如下：

`void excpt_func() noexcept (常量表达式);`

不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    try {
        Throw();
    }
    catch (...) {
        cout << "Found throw." << endl;
    }

    try {
        NoBlockThrow();
    }
    catch (...) {
        cout << "Throw is not blocked." << endl;
    }

    try {
        BlockThrow();
    }
    catch (...) {
        cout << "Found throw 1." << endl;
    }
    return 0;
}

// 输出：
Found throw.
Throw is not blocked.
// 出现中止提示框
```

noexcept作为一个操作符时，通常可以用于模板，如：

```c++
template<class T>
void fun() noexcept(nocept(T())) {}
```

这里fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式时，其返回值为false，反之为true。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() throw(int) {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    cout << noexcept(Throw()) << endl; // 0
    cout << noexcept(NoBlockThrow()) << endl; // 0
    cout << noexcept(BlockThrow()) << endl; // 1
    return 0;
}
```

同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的，当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持为默认值。如下：

```c++
#include <iostream>
using namespace std;

struct A {
    ~A() {
        throw 1;
    }
};

struct B {
    ~B() noexcept(false) {
        throw 2;
    }
};

struct C {
    B b;
};

void funA() {
    A a;
}

void funB() {
    B b;
}

void funC() {
    C c;
}

int main() {
    try {
        funB();
    }
    catch (...) {
        cout << "caught funB." << endl; // caught funB.
    }

    try {
        funC();
    }
    catch (...) {
        cout << "caught funC." << endl; // caught funC.
    }

    try {
        funA();
    }
    catch (...) {
        cout << "caught funA." << endl; // terminate called after throwing an instance of 'int'
    }
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): warning C4297:  “A::~A”: 假定函数不引发异常，但确实发生了
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): message :  析构函数或释放器具有一个(可能是隐含的)非引发异常规范
```

无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。

## 2.7 快速初始化成员变量

C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或花括号{}进行就地的非静态成员变量初始化。如：

```c++
#include <iostream>
using namespace std;

struct Init {
    int a = 1;
    double b = 1.2;
    double c{1.2};
};

int main() {
    Init init;
    return 0;
}
```

C++对于初始化表达式的改动发现，花括号式的集合（列表）初始化已经成为C++11中初始化声明的一种通用形式，而其效果类似于C++98中使用圆括号()对自定义变量的表达式列表初始化。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如下：

```c++
struct C {
    C(int i): c(i) {}
    int c;
};

struct Init {
    int a = 1;
    string b{"abc"}; // string b("abc") 无法通过编译
    C c{1}; // C c(1) 无法通过编译
};
```

程序员可以为同一成员变量既声明就地的列表初始化，又在初始化列表中进行初始化，只不过初始化列表问题看起来“后作用于”非静态成员。也就是说，初始化列表的效果总是优先于就地初始化的。

## 2.8 非静态成员的sizeof

```c++
#include <iostream>
using namespace std;

struct People {
    int hand;
    static People* all;
};


int main() {
    People p;
    cout << sizeof(p.hand) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::all) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::hand) << endl; // C++98中错误，C++11中通过
    return 0;
}
```

在C++11中，对非静态成员变量使用sizeof操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行sizeof操作。因此，如果只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员大小，通常会采用以下的代码：

`sizeof(((People*)0) -> hand);`

强制转换0为一个People类的指针，继而通过指针的解引用获得其成员变量，并用sizeof求得该成员变量的大小。在C++11中，无需这样的技巧，因为sizeof可以作用的表达式包括了类成员表达式：

`sizeof(People::hand)`

## 2.9 扩展的friend语法

C++11对friend关键字进行了一些改进：

```c++
class Poly;
typedef Poly P;

class LiLei {
    friend class Poly; // C++98通过，C++11通过
};

class Jim {
    friend Poly; // C++98失败，C++11通过
};

class HanMeiMei {
    friend P; // C++98失败，C++11通过
};
```

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。甚至还使用了Poly的别名P，这同样可行。

可以为类模板声明友元了。这在C++98中无法做到，如下：

```c++
#include <iostream>
using namespace std;

class P;

template<typename T>
class People {
    friend T;
};


int main() {
    People<P> pp; // 类型P在这里是People类型的友元
    People<int> pi; // 对于int类型模板参数，友元声明被忽略
    return 0;
}
```

有个使用friend友元来访问私有成员进行测试的使用样例，在P63。

## 2.10 final/override控制 P63

## 2.11 模板函数的默认模板参数 P67

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，如下：

```c++
void DefParm(int m = 3) {} // C++98编译通过，C++11编译通过

template<typename T = int>
class DefClass {};  // C++98编译通过，C++11编译通过

template<typename T = int>
void DefTempParm() {} // C++98编译失败，C++11编译通过
```

不过在语法上，类模板在为多个默认模板参数声明指定默认值的时候，必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说不是必须的，如下：

```c++
template<typename T1, typename T2 = int>
class DefClass1 {};

template<typename T1 = int, typename T2>
class DefClass2 {};  // 无法编译通过

template<typename T, int i = 0>
class DefClass3 {};

template<int i = 0, typename T>
class DefClass4 {};  // 无法编译通过

template<typename T1 = int, typename T2>
void DefFunc1(T1 a, T2 b);  // 可以编译通过

template<int i = 0, typename T>
void DefFunc2(T a);  // 可以编译通过
```

函数模板的参数推导规则也不复杂。如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。如下：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = 0) {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')
    f(1); // f<int, double>(1, 0)，使用了默认模板参数double
    //f(); // 错误：T无法被推导出来
    f<int>(); // f<int, double>(0, 0)，使用了默认模板参数double
    f<int, char>(); // f<int, char>(0, 0)
    return 0;
}

// 输出：
t type: int, u type: char
t value: 1, u value: c
t type: int, u type: double
t value: 1, u value: 0
t type: int, u type: double
t value: 0, u value: 0
t type: int, u type: char
t value: 0, u value:
```

这个例子可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。

还有一点，模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的，这点在使用中应当注意。

另外，将u = 0改成u = "abc"，有点问题没明白：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = "abc") {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')，output: t type: int, u type: char<Enter>t value: 1, u value: c
    f(1); // f<int, double>(1, 0)，将"abc"转成double，output: output: t type: int, u type: double<Enter>t value: 1, u value: 1.16581e-307
    f<int>(); // 这里编译错误，“f”: 函数不接受 0 个参数，f<int>(1)可以编译通过
    cout << static_cast<double>("abc") << endl; //编译错误，说“static_cast”: 无法从“const char [4]”转换为“double”，所以不知道f(1)里"abc"是如何转成double
    return 0;
}
```

## 2.12 外部模板

### 2.12.2 显式的实例化与外部模板的声明 P71

```c++
// test.h
template<typename T> void fun(T) {}

// test1.cpp
#include "test.h"
template void fun<int>(int); // 显示地实例化
void test1() { fun(3); }

// test2.cpp
#include "test.h"
extern template void fun<int>(int); // 外部模板的声明
void test1() { fun(3); }
```

这样一来，在test2.o中不会再生成fun\<int\>(int)的实例代码。因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让test1.cpp和test2.cpp共享一份代码位置即可。而同时，编译器也不用每次都产生一份fun\<int\>(int)的代码，所以可以减少编译时间。这里也可以把外部模板声明放在test.h头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。这一点跟使用外部变量声明是完全一致的。

在使用外部模板的时候，还需要注意：**如果外部模板声明出现在某个编译单元中，那么与之对应的显示实例化必须出现在另一个编译单元中或者同一个编译单元的后续代码中**；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。

实际上，C++11中“模板的显式实例化定义、外部模板声明和使用”好比“全局变量的定义、外部声明和使用”方式的再次应用。不过相比于外部变量声明，不使用外部模板声明并不会导致任何问题。

只有在项目比较大的情况下，我们才建议用户进行这样的优化。总的来说，就是在既不忽视模板实例产生的编译及链接开销的同时，也不要过分担心模板展开的开销。

## 2.13 局部和匿名类型作模板实参 P73

C++98中，标准对模板实参的类型还有一些限制。具体讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。如下：

```c++
template<typename T>
class X {};

template<typename T>
void TempFun(T t) {};

struct A {} a;

struct {
    int i;
} b; // b是匿名类型变量

typedef struct {
    int i;
} B; // B是匿名类型

void Fun() {
    struct C {} c; // C是局部类型，c是局部变量
    X<A> x1; // C++98通过，C++11通过
    X<B> x2; // C++98错误，C++11通过
    X<C> x3; // C++98错误，C++11通过
    TempFun(a); // C++98通过，C++11通过
    TempFun(b); // C++98错误，C++11通过
    TempFun(c); // C++98错误，C++11通过
}
```

值得指出的是，虽然匿名类型可以被模板参数所接受了，但并不意味着以下写法可以被接受，如下：

```c++
template<typename T> struct MyTemplate {};

int main() {
    MyTemplate<struct { int a; }> t; // 无法通过编译，匿名类型的声明不能在模板实参位置
    return 0;
}
```

即使是匿名类型的声明，也需要独立的表达式语句。要使用匿名结构作为模板参数，则需要对匿名结构体作别名。此外在第4章还会看到使用C++11独有的类型推导decltype，也可以完成相应的功能。

## 3.1 继承构造函数

基类的非虚函数无法再被派生类使用了， 这条规则对于构造函数也不例外，如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。如下：

```c++
struct A { A(int i) {} };
struct B: A { B(int i): A(i) {} };
```

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成，如下：

```c++
#include <iostream>

using namespace std;

struct Base {
    void f(double i) {
        cout << "Base: " << i << endl;
    }
};

struct Derived : Base {
    using Base::f;

    void f(int i) {
        cout << "Derived: " << i << endl;
    }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5

    Derived d;
    d.f(4.5);  // Base: 4.5
    d.f(10);  // Derived: 10
    return 0;
}
```

这里使用了using声明，声明派生类Derived也使用基类版本的函数f。这样，派生类中实际就拥有了两个f函数的版本。

在C++中，这个想法被扩展到了构造函数中。子类可以通过使用using声明来声明继承基类的构造函数。如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A::A;
    B(const string& s): A(10) {}  // B类如果有自己的构造函数，则还是需要调用基类A构造函数
    virtual void ExtraInterface() {}
};


int main() {
    B b(10);  // 如果没有using A::A;，则编译报错
    return 0;
}
```

通过using A::A的声明，把基类中的构造函数悉数继承到派生类B中。更为精巧的是，C++11标准继承构造函数被设计为跟派生类中的各种默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会被化基类成员变量，对于派生类中的成员变量，则无能为力。不过配置2.7节中的类成员的初始化表达式，为派生类成员变量设定一个默认值还是没有问题的。

如下代码同时使用了继承构造函数和成员变量初始化两个C++11的特性。这样就可以解决一些继承构造函数无法初始化的派生类成员问题。如果这样仍然无法满足需求的话，程序员只能自动来实现一个构造函数，以达到基类和成员变量都能够初始化的目的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char *c) {}
};

struct B : A {
    using A::A;
    int d{0};
};


int main() {
    B b(356);  // b.d被初始化为0
    return 0;
}
```

有时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，**参数的默认值是不会被继承**的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int a = 3, double b = 2.4) : a_(a), b_(b) {}

    int a_;
    double b_;
};

struct B : A {
    using A::A;
};


int main() {
    B b1;
    cout << "b1.a_: " << b1.a_ << endl;
    cout << "b1.b_: " << b1.b_ << endl;

    B b2(10);
    cout << "b2.a_: " << b2.a_ << endl;
    cout << "b2.b_: " << b2.b_ << endl;

    return 0;
}
//输出：
b1.a_: 3
b1.b_: 2.4
b2.a_: 10
b2.b_: 2.4
```

参数默认值会导致多个构造函数版本的产生，因此程序员在使用有参数默认值的构造函数的基类时，必须小心。

有时，有继承构造函数“冲突”的情况。通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有时，也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。

A和B的构造函数会导致C中重复定义相同类型的继承构造函数。这种，情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐匿生成相应的继承构造函数来解决冲突，如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct B {
    B(int i) {
        cout << "B.i: " << i << endl;
    }
};

struct C : A, B {
    using A::A;
    using B::B;

    C(int i): A(i), B(i){  // 书中写为C(int) {}，感觉不对，因为A和B都没有无参数的构造函数
        cout << "C.i: " << i << endl;
    }
};


int main() {
    C c(10);
    return 0;
}
```

如果基类的构造函数被声明为私有成员函数（本地试验保护成员函数也不行），或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

```c++
#include <iostream>

using namespace std;

struct A {
protected:
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct C : A {
    using A::A;
    //C(int i) : A(10) {}  // 这里如果注释掉则编译报错
};


int main() {
    C c(10);
    return 0;
}
```

## 3.2 委派构造函数 P81

在C++11中，可以使用委派构造函数来达到期望的效果。委派构造函数是在构造函数的初始化列表位置进行构造、委派的。如下：

```c++
#include <iostream>

using namespace std;

class Info {
public:
    // 目标构造函数（target constructor）
    Info() {
        cout << "Info() type: " << type << endl;
        InitRest();
    }

    // 委派构造函数（delegating constructor）
    Info(int i) : Info() {  // 这里type是1
        type = i;  //这里经过赋值后，type是i，所以type还是多赋值了一次
    }

    // 委派构造函数（delegating constructor）
    Info(char c) : Info() {
        name = c;
    }

private:
    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type{1};
    char name{'a'};
};

int main() {
    Info info(10);
    return 0;
}
// 输出
Info() type: 1
Info::InitRest()
```

在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。

委派构造函数只能在函数体中为type、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。在C++中，构造函数不能同时“委派”和使用初始化列表，所以**如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。

这样，上述代码的初始化就不那么令人满意了，因为初始化列表的初始化方式总是等于构造函数完成的（实际在编译完成时就已经决定了），这会可能使程序员犯错（见下分析）。可以稍微改造下目标构造函数，使得委派构造函数依然可以在初始化列表中初始化所有成员，如下：

```c++
class Info {
public:
    Info() : Info(1, 'a') {}

    Info(int i) : Info(i, 'a') {}

    Info(char c) : Info(1, c) {}

private:
    Info(int i, char c) : type(i), name(c) {
        InitRest();
    }

    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type;
    char name;
};
```

如上定义了一个私有的目标构造函数Info(int, char)，接受两个参数，并将参数在初始化列表中初始化。

在使用委派构造函数的时候，建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。如在InitReset()函数中做了：

`type += 1;`

则第1份代码中Info f(3)构造出来的对象其f.type=3，第2份代码中Info f(3)构造出来的对象其f.type=4，从代码编写角度看，第2份代码中Info的行为会更加正确。这是由于在C++11中，目标构造函数的执行总是等于委派构造函数而造成的。因此避免目标构造函数和委托构造函数体中初始化同样的成员通常是必要的，否则可能发生第1份代码的错误。

构造函数比较多时，可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样，就可能在委派构造函数中形成链状的委派构造关系。有一点必须程序，就是不能形成委托环（delegation cycle），如：

```c++
struct Rule2 {
    int i, c;
    Rule(): Rule2(2) {}
    Rule(int i): Rule2('c') {}
    Rule(char c): Rule2(2) {}
};
```

Rule2定义中，Rule2()、Rule2(int)和Rule2(char)都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。

委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，如代码清单：

```c++
#include <iostream>
#include <list>
#include <vector>
#include <deque>

using namespace std;

class TDConstructed {
public:
    TDConstructed(vector<short>& v) : TDConstructed(v.begin(), v.end()) {}

    TDConstructed(deque<int>& d) : TDConstructed(d.begin(), d.end()) {}

private:
    template<class T>
    TDConstructed(T first, T last): l(first, last) {}

private:
    list<int> l;
};

int main() {
    vector<short> v = {4, 5, 6};
    TDConstructed tdConstructed1(v);

    deque<int> d = {1, 2, 3};
    TDConstructed tdConstructed2(d);
    return 0;
}
```

如上代码定义了一个构造函数模板。通过两个委派构造函数的委托，构造函数模板会被实例化。T会被推导为vector\<short\>::iterator和deque\<int\>::iterator两种类型。这比罗列不同类型的构造函数方便了很多。可以心，委托构造使得构造函数的泛型编程也成为了一种可能。

如果在委派构造函数中使用try，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。如下：

```c++
#include <iostream>

using namespace std;

class DCExcept {
public:
    DCExcept(double d)
    try : DCExcept(1, d) {
        cout << "Run the body." << endl;
    }
    catch (...) {
        cout << "caught exception." << endl;
    }

private:
    DCExcept(int i, double d) {
        cout << "going to throw!" << endl;
        throw 0;
    }

private:
    int type;
    double data;

};

int main() {
    DCExcept a(1.2);
    return 0;
}
// 输出：
going to throw!
terminate called after throwing an instance of 'int'
caught exception.
```

## 3.3 右值引用：移动语义和完美转发

### 3.3.2 移动语义

在C++11中，“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。可以理解为“移为已用”。我们可以看看如下代码是如何实现这种移动语义的：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

    HasPtrMem(HasPtrMem&& h) : d(h.d) {
        h.d = nullptr;
        cout << "Move construct: " << ++n_mvtr << endl;
    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1  // HasPtrMem h;
Resource from GetTemp: 0x6a1480
Move construct: 1  // move(h);
Destruct: 1  // h析构
Move construct: 2  // move(GetTemp());
Destruct: 2  // GetTemp返回的HasPtrMem临时变量析构
Resource from main: 0x6a1480
Destruct: 3  // a析构
```

本地试验，如果不加两个move，则只有一个构造函数调用一个析构函数调用，应该是编译器优化，直接将h赋给a，如下：

```c++
HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return h;
}

int main() {
    HasPtrMem a = GetTemp();
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1
Resource from GetTemp: 0xe81480
Resource from main: 0xe81480
Destruct: 1
```

另外，本地试验，如果不提供移动构造函数，只提供拷贝构造函数，在使用move时，会调用拷贝构造函数，如下：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

//    HasPtrMem(HasPtrMem&& h) : d(h.d) {
//        h.d = nullptr;
//        cout << "Move construct: " << ++n_mvtr << endl;
//    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出:
Construct: 1
Resource from GetTemp: 0xf01480
Copy construct: 1
Destruct: 1
Copy construct: 2
Destruct: 2
Resource from main: 0xf01480
Destruct: 3
```





为什么费力地添加移动构造函数，完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差。不过从使用的方便性来讲效果不好。如果函数返回临时值的话，可以在单条语句里完成很多计算，比如可以很自动地写出如下语句：

`Calculate(GetTemp(), SomeOther(Maybe(), Useful(Values, 2)));`

------

本地验证使用move来移动构造map：

```c++
int main() {
    map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
    map<string, int> nameValueMap2 = move(nameValueMap1);  // move之后，map1内已经没有对象了

    cout << "map1: \n";
    for_each(nameValueMap1.begin(), nameValueMap1.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });

    cout << "map2: \n";
    for_each(nameValueMap2.begin(), nameValueMap2.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });
    return 0;
}
// 输出：
map1:
map2:
a, 10
b, 20
```

如果不使用move，则调用的map的拷贝构造函数，如下：

```c++
map<string, int> nameValueMap2 = nameValueMap1;
// 输出：
map1:
a, 10
b, 20
map2:
a, 10
b, 20
```

### 3.3.3 左值、右值与右值引用

在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。如：

`a = b + c`
这个赋值表达式中，a就是一个左值，而b+c则是一个右值。这种识别左值、右值的方法在C++中依然有效。不过C++中还有一个被广泛认同的说法，就是可以取地址的、有名字的就是左值。反之，不能取地址的、没有名字的就是右值。

这些差别方法通常都非常有效。在C++11中，右值是由两个概念构成的，一个是将亡值（xvalue, eXpiring Value），另一个则是纯右值（prvalue, Pure Rvalue）。

其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。

而将亡值则是C++11新增的跟右值引用相关的表达式，这样的表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

在C++11程序中，所有的值必属于左值、将亡值、纯右值三者之一。

在C++11中，右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。通常情况下，我们只能是从右值表达式获得其引用。比如：

`T&& a = ReturnRvalue();`

这个表达式，假设ReturnRvalue返回一个右值，我们就声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”（lvalue reference）。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

在上面的例子，ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了（通常我们也称其具有表达式生命期），而通过右值引用的声明，该右值又“重获新生”，其生命期将与右值引用类型变量a的生命期一样。只要a还“活着”，该右值临时量将会一直“存活下去”。

所以相比于以下语句的声明方式：

`T b = ReturnRvalue()`

刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为a是右值引用，直接绑定了ReturnRvalue()返回的临时量，而b只是由临时值构造而成的，而临时量在表达式结束会析构因而就会多一次析构和构造的开销。

不过能够声明**右值引用a的前提是ReturnRvalue返回的是一个右值**。通常情况下，右值引用是不能够绑定到任何的左值的。

右值引用&&只能绑定在右值上，所以如下在左值nameValueMap1进行&&右值引用绑定编译失败：

```c++
map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
map<string, int>&& nameValueMap2 = nameValueMap1;
```

相对地，在C++98标准中就已经出现的左值引用是否可以绑定到右值（由右值进行初始化）呢？如：

```c++
T& e = ReturnRvalue();
const T& f = ReturnRvalue();
```

答案是：e的初始化会导致编译时错误，而f则不会。

原因是，常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。而在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过**相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的**。相对的，非常量左值只能接受非常量左值对其进行初始化。

在C++98通过左值引用来绑定一个右值的情况并不少见，比如：

`const bool& judgement = true;`

就是一个使用常量左值引用来绑定右值的例子。不过与如下声明相比看起来似乎差别不大：

`const bool judgement = true;`

从语法上讲，前者直接使用了右值并为其“续命”，而后者的右值在表达式结束后就销毁了。

事实上，即使在C++98中，也常可以使用常量左值引用来减少临时对象的开销，如：

```c++
void show(const string& s) {} // 使用常量左值引用来接临时变量

show("abc");
```

而在C++11中，同样的，也可以右值引用为参数声明如下函数：

`void AcceptRvalueRef(Copyable&& ) {}`

也同样可以减少临时变量拷贝的开销。进一步地，还可以在AcceptRvalueRef中修改该临时值（这时临时值由于被右值引用参数所引用，已经获得了函数时间的生命期）。不过修改一个临时值的意义通常不大，除非像3.3.2节一样使用移动语义。

就本例而言，如果这样实现函数：

```c++
void AcceptRvalueRef(Copyable&& s) {
    Copyable news = std::move(s);
}
```

这里std::move的作用是强制一个左值（s）成为右值（s）。该函数就是使用右值来初始化Copyable变量news。使用移动语义的前提是Copyable还需要添加一个以右值引用为参数的移动构造函数，如：

`Copyable(Copyable&& o) { /*实现移动语义*/ }`

这样，如果Copyable类的临时变量（即ReturnRvalue返回的临时值）中包含一些大块内存的指针，news就可以如同代码清单3-19一样将临时值中的内存“窃”为已用，从而从这个以右值引用参数的AccepRvalueRef函数中获得最大的收益。事实上，**右值引用的由来从来就跟移动语义紧紧相关。这是右值存在的一个最大的价值（另外一个价值是用于转发）**。

如果不声明移动构造函数，而只声明一个常量左值的构造函数会生成什么？如同刚才提到的，常量左值是个“万能”的引用类型，无论左值还是右值，常量还是非常量，一概能够绑定。那么如果Copyable没有移动构造函数，下列一语句：

`Copyable news = std::move(s);`

将调用以常量左值为参数的拷贝构造函数。这是一种非常安全的设计——**移动不成，至少还可以执行拷贝**。因此，通常情况下，程序员会为声明了移动构造函数的类声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，可以使用拷贝构造。

为了语义的完整，C++11中还存在着常量右值引用，如通过如下代码声明一个常量右值引用：

`const T&& crvalueref = ReturnRvalue();`

但是，一来右值引用主要就是为了移动语义，而移动语义需要右值是可以被修改的，那么常量右值引用在移动语义中就没有用武之处；二来如果要引用右值且让右值不可以更改，常量左值引用往往就足够了。因此在现在的情况下，我们还没有看到常量右值引用有何用处。表3-1：

![](pictures\C++11中引用类型及其可以引用的值类型.png)

有时候，可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用（这在模板中比较常见）。标准库在\<type_traits\>头文件中提供了3个模板类：is_rvalue_reference、is_lvalue_reference、is_reference，可供我们进行判断，如：

```c++
HasPtrMem&& a = GetTemp();
cout << is_rvalue_reference<decltype(a)>::value << "\n";  // 1
cout << is_rvalue_reference<string&&>::value << "\n";  // 1
cout << is_rvalue_reference<map<int, int>&&>::value << "\n";  // 1
```

通过模板类的成员value就可以打印出string&&是否是一个右值引用了。配置第4章中的类型推导操作符decltype，甚至还可以对变量的类型进行判断。

说明：右值引用对象已经是一个左值了，可以使用&获取地址：

```c++
HasPtrMem&& a = GetTemp();
HasPtrMem* p = &a;
```

### 3.3.4 std::move：强制转化为右值 P99

std::move并不能移动任何东西，唯一的功能是将一个左值强制转化为右值引用，继承可以通过右值引用使用该值，用于移动语义。从实现上讲，std::move基本等同于一个类型转换：

`static_cast<&&>(lvalue);`

被转化的左值，其生命期并没有随着左值值的转化而改变，所以被std::move转化的左值变量lvalue不会被立即析构。

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

class Moveable {
public:
    Moveable() : i(new int(3)) {}

    ~Moveable() { delete i; }

    Moveable(Moveable&& m) : i(m.i) {
        m.i = nullptr;
    }

    int* i;
};

int main() {
    Moveable a;
    Moveable c(move(a));  // 会调用移动构造函数，这里move(a)将左值a变成一个右值引用，所以才会调用移动构造函数Moveable(Moveable&& m)
    cout << *a.i << endl;  // 运行时错误
    return 0;
}
```

这里的a本来是一个左值变量，通过std::move将其转换为右值。这样一来，a.i就被c的移动构造函数设置为指针空值。由于a的生命期实际要到main函数结束才结束，所以对表达式*a.i进行计算就会运行错误。

这里如果不使用move(a)，则使用c(a)，则编译报错：

```c++
Moveable a;
Moveable c(a);  // 编译报错，因为显示声明了移动构造函数，所以拷贝构造函数如果不显示声明，则编译器不会生成拷贝构造函数
Moveable d;  // 编译报错，显示声明了移动构造函数，则编译器不会生成拷贝赋值函数
d = a;
```

事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用std::move转换拥有形如堆内存、文件句柄等资源的成员为右值，这样，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的拷贝构造函数版本也会轻松地实现拷贝构造，因此也不会引用大的问题。

### 3.3.5 移动语义的一些其他问题

移动语义一定是要修改临时变量的值，那么这样声明移动构造函数：

`Moveable(const Moveable&&)`

或者这样声明：

`const Moveable ReturnVal();`

都会使得临时变量常量化，成为一个常量右值，那么临时变量的引用也就无法修改，从而导致无法实现移动语义。因此在实现移动语义一定要注意排除不必要的const关键字。

默认情况下，编译器会为程序隐式地生成一个（隐式表示如果不使用则不生成）移动构造函数。

不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数（本地试验声明了析构函数不会影响默认构造函数的生成）中的一个或者多个，编译器都不会再为程序员生成默认版本。**默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作**。这对实现移动语义来说是不够的。通常情况下，**如果需要移动语义，程序员必须自定义移动构造函数**。对一些简单的、不包含任何资源的类型来说，实现移动语义与否都无关紧要，因为对这样的类型而言，移动就是拷贝，拷贝就是移动。

同样的，声明了移动构造函数、拷贝赋值函数、移动赋值函数和构造函数中的一个或者多个，编译器也不再会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/拷贝赋值和移动构造/移动赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。

```c++
String(const String &other);  // 拷贝构造函数 
String& operator=(const String& other);  // 拷贝赋值函数

//C++ 11的新函数 
String(String &&other);  // 移动构造函数
String& operator=(String&& other);  // 移动赋值函数
```

其实，只现实一种语义在类的编写中也是非常常见的。如只有拷贝语义的类型——在C++11之前我们见过大多数的类型的构造都是只使用拷贝语义的。而只有移动语义的类型则非常有趣，因为只有移动语义表明该类型的变量所拥有的资源只能被移动，而不能被拷贝。那么这样的资源必须是唯一的，因此，只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针、文件流等，都可以视为“资源型”的类型。如标准库中的仅可移动的模板类：unique_ptr。一些编译器，如2011，现在也把ifstream这样的类型实现为仅可移动的。

```c++
unique_ptr<int> p1 = make_unique<int>(3);
unique_ptr<int> p2 = move(p1);  // unique_ptr<int> p2 = p1编译报错，无拷贝构造
```

在标准库的头文件\<type_traits\>里，可以通过一些辅助的模板类来判断一个类型是否可以移动的。如is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible，使用方法仍然是使用其成员value。如：

```c++
cout << is_move_constructible<unique_ptr<int>>::value << "\n";  // 1
cout << is_copy_constructible<unique_ptr<int>>::value << "\n";  // 0
```

而有了移动语义，还有一个比较典型的应用是可以实现高性能的转换（swap）函数。看下面这段swap模板函数代码：

```c++
#include <iostream>
#include <memory>

using namespace std;

template<class T>
void mySwap(T& a, T& b) {
    T tmp(move(a));
    a = move(b);
    b = move(tmp);
}

int main() {
    unique_ptr<int> p1 = make_unique<int>(3);
    unique_ptr<int> p2 = make_unique<int>(5);
    cout << "Before swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    mySwap(p1, p2);
    cout << "After swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    return 0;
}
// 输出：
Before swap, p1: 3, p2: 5
After swap, p1: 5, p2: 3
```

如果T移动，那么移动构造和移动赋值将会被用于这个转换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行转换。这就跟普通的转换语句是相同的。在移动语义的支持下，仅仅通过一个通用的模板，就可能更高效地完成转换，这对于泛型编程来说，无疑是具有积极意义的。

另外一个关于移动构造的话题是异常。对于移动构造函数来说，抛出异常是件危险的事。因为可能移动语义还没完成，一个异常抛出来，这就会导致一些指针成为悬挂指针。因此应该尽量编写不抛出异常的移动构造函数，通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用ternimate程序终止运行。而标准库中，还可以用一个std::move_if_noexcept的模板函数替代move函数。该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义。如下：

```c++
#include <iostream>

using namespace std;

struct MayThrow {
    MayThrow() {}

    MayThrow(const MayThrow&) {
        cout << "Maythrow copy constructor." << endl;
    }

    MayThrow(const MayThrow&&) {
        cout << "Maythrow move constructor." << endl;
    }
};

struct NoThrow {
    NoThrow() {}

    NoThrow(const NoThrow&) noexcept {
        cout << "NoThrow copy constructor." << endl;
    }

    NoThrow(const NoThrow&&) noexcept {
        cout << "NoThrow move constructor." << endl;
    }
};

int main() {
    MayThrow m;
    NoThrow n;

    MayThrow mt = move_if_noexcept(m);  // Maythrow copy constructor.
    NoThrow nt = move_if_noexcept(n);  // NoThrow move constructor.

    return 0;
}
```

move_if_noexcept是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用noexcept进行描述，否则就会损失更多的性能。

编译器中被称为RVO/NRVO的优化（RVO，Return Value Optimization，返回值优化，或者NRVO，Named Return Value Optimization）。在本节中大量的代码都使用了-fno-elide-constructors选项在g++/clang++中关闭这个优化，这样可以在代码中较为容易地利用函数返回的临时量右值。

但若在编译的时候不使用该选项的话，会发现很多构造和移动都被省略。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从ReturnValue函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了：

```c++
A ReturnRvalue() {
    A a();
    return a;
}

A b = ReturnRvalue();
```

b变量实际就使用了ReturnRvalue函数中a 的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量“霸占”了a变量。这是编译器中一个效果非常好的优化。不过RVO/RNVO并不是对任何情况都有效。有些情况下，一些构造是无法省略的。还有一些情况，即使RVO/NRVO完成了，也不能达到最好的效果。但结论是明显的，移动语义可以解决编译器无法解决的优化问题，因而总是有用的。

关于RVO/RNVO可以参见如下博客：

<https://blog.csdn.net/songchuwang1868/article/details/83622039>

### 3.3.6 完美转发 P104

C++是通过引用一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。

在C++11以前，形如下列语句：

```c++
typedef const int T;
typedef T& TR;
TR& v = 1;  // 该声明在C++98中会导致编译错误
```

其中`TR& v = 1`这样的表达式会被编译器认为是不合法的表达式，而在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式，如下表3-2所示：

![](\pictures\C++11中的引用折叠规则.png)

这个规则不难记忆，因为一旦定义中出现了左值引用，引用折叠问题优先将其折叠为左值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为X&类型，而转发函数的实参是类型X的一个右值引用的话，那么模板的参数被推导为X&&类型。结合以上的引用折叠规则，就能确定出参数的实际类型。进一步，可以把转发函数写成如下形式：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(static_cast<T&&>(t));
}
```

注意一下，不仅在参数部分使用了T&&这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。如我们调用转发函数时传入了一个X类型的左值引用，可以想象，转发函数将被实例化为如下形式：

```c++
void IamForwarding(X& && t) {
    IrunCodeActually(static_cast<X& &&>(t));
}
```

引用折叠规则，就是：

```c++
void IamForwarding(X& t) {
    IrunCodeActually(static_cast<X&>(t));
}
```

这样，左值传递就毫无问题了。实际使用的时候，IrunCodeActually如果接受左值引用的话，就可以直接调用转发函数。这里调用前的static_cast没有什么作用。事实上，这里的static_cast是留给传递右值用的。

如果调用转发函数时传入了一个X类型的右值引用的话，转发函数将被实例化为：

```c++
void IamForwording(X&& && t) {
    IrunCodeActually(static_cast<X&& &&>(t));
}
```

应用上引用折叠规则，就是：

```c++
void IamForwarding(X&& t) {
    IrunCodeActually(static_cast<X&&>(t));
}
```

这里看到了static_cast的重要性。对于一个右值而言，当它使用右值引用表达式引用的时候，该右值引用却是个左值，那么想在函数调用中继续传递右值，就需要使用std::move来进行左右值的转换。而std::move通常就是一个static_cast。不过在C++11中，用于完美转发的函数却不再叫作move，而是另外一个名字：forward。所以可以把转发函数写成这样：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(forward(t));
}
```

move和forward在实际实现上差别并不大。不过标准库这么设计，也许是为了让每个名字对应于不同的用途，以应对未来可能的扩展（虽然现在使用move可能也能通过完美转发函数的编译，但这并不是推荐的做法）。

来看个完美转发的例子，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(int&& m) { cout << "rvalue ref" << endl; }

void RunCode(int& m) { cout << "lvalue ref" << endl; }

void RunCode(const int&& m) { cout << "const rvalue ref" << endl; }

void RunCode(const int& m) { cout << "const lvalue ref" << endl; }

template<typename T>
void PerfectForward(T&& t) {
    RunCode(forward<T>(t));
}

int main() {
    int a;
    int b;
    const int c = 1;
    const int d = 0;

    PerfectForward(a);  // lvalue ref 。a是一个左值，而左值无法转为int&&，所以这里类型左值引用int& &&， PerfectForward<int&>(a);
    PerfectForward(move(b));  // rvalue ref
    PerfectForward(c);  // const lvalue ref
    PerfectForward(move(d));  // const rvalue ref
    return 0;
}
```

完美转发的一个作用就是做包装函数，这是一个很方便的功能。对上述代码清单的转发函数稍作修改，就可以用很少的代码记录单参数函数的参数传递况，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(double&& m) {}

void RunHome(double&& h) {}

void RunComp(double&& c) {}


template<typename T, typename U>
void PerfectForward(T&& t, U& func) {
    cout << t << "\tforwarded..." << endl;
    func(forward<T>(t));
}

int main() {
    PerfectForward(1.5, RunComp);  // 1.5	forwarded...
    PerfectForward(8, RunCode);  // 8	forwarded...
    PerfectForward(1.0, RunHome);  // 1	forwarded...
    return 0;
}
```

在C++11标准库中可以看到大量完美转发的实际应用，一些很小巧好用的函数，如make_pair、make_unique等在C++都通过完美转发实现了。这样减少了一些函数版本的重复（const和非const版本的重复），并能够充分利用移动语义。无论从运行性能的提高还是从代码编写的简化上，完美转发都堪称完美。

博客：C++11完美转发介绍 <http://ju.outofmemory.cn/entry/330864>

## 3.4 显式转换操作符

C++中，隐式类型转换的“自动性”可以让程序员免于层层构造类型。但是也会有不易发现的错误：

```c++
#include <iostream>

using namespace std;

struct Rational1 {
    Rational1(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

struct Rational2 {
    explicit Rational2(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

void Display1(Rational1 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

void Display2(Rational2 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

int main() {
    Rational1 r1_1 = 11;  // Rational1(11/1)
    Rational1 r1_2(12);  // Rational1(21/1)

//    Rational2 r2_1 = 21;  // 无法通过编译
    Rational2 r2_2(22);  // Rational2(22/1)

    Display1(1);  // Rational1(1/1) Numerator: 1 Denominator: 1
//    Display2(2);  // 无法通过编译
    Display2(Rational2(2)); // Rational2(2/1) Numerator: 2 Denominator: 1
    return 0;
}
```

使用了explicit这个关键字保证对象的显式构造在一些情况下都是必须的。

不过同样的机制并没有出现在自定义的类型转换符上。这就允许了一个逆向的过程，从自定义类型转向一个已知类型。这样虽然出现问题的几率远小于从已知类型构造自定义类型，不过有的时候，确实应该阻止会产生歧义的隐式转换。如下：

```c++
#include <iostream>

using namespace std;

template<typename T>
class Ptr {
public:
    Ptr(T* p) : p_(p) {}

    operator bool() const {
        return p_ != 0;
    }

private:
    T* p_;
};

int main() {
    int a;
    Ptr<int> p(&a);

    if (p) {  // 自动转换为bool型，没有问题
        cout << "valid pointer." << endl;  // valid pointer
    } else {
        cout << "invalid pointer." << endl;
    }

    Ptr<double> pd(0);
    cout << p + pd << endl;  // 调用bool类型转换函数后得到1+0=1

    double d;
    Ptr<double> pd1(&d);
    cout << p + pd1 << endl;  // 调用bool类型转换函数后得到1+1=2
    return 0;
}
```

定义了指针模型类型Ptr。为方便判断指针是否有效，为指针编写了自定义类型转换到bool类型的函数，可以通过if(p)这样的表达式来判断指针是否有效。不过这样的转换使得Ptr\<int\>和Ptr\<double\>两个指针加法运算获得了语法上的允许。不过明显地，我们无法看出其语义上的意义。

在C++11中，标准将explicit的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”。explicit关键字作用于类型转换操作符上，意味着只有在**直接构造目标类型**或**显式类型转换**的时候可以使用该类型。如下：

```c++
class ConvertTo {};

class Convertable {
public:
    // 自定义类型转换，转换为ConvertTo类型
    explicit operator ConvertTo() const { return ConvertTo(); }
};

void Func(ConvertTo ct) {}

void test() {
    Convertable c;
    ConvertTo ct(c);  // 直接初始化，通过，表明把c显示转换为ConvertTo类型
//    ConvertTo ct2 = c;  // 拷贝构造初始化，编译失败，如果去掉explicit则可以编译通过
    ConvertTo ct3 = static_cast<ConvertTo>(c);  // 强制转化，通过
//    Func(c);  // 拷贝构造初始化，编译失败
}
```

上述代码中，定义了两个类型ConvertTo和Convertable，Convertable定义了一个显式转换到ConvertTo类型的类型转换符。那么对于test函数中ConvertTo类型的ct变量而言，由于其直接初始化构造于Convertable变量c，所以可以编译通过。而做强制类型转换的ct3同样通过了编译。而ct2由于从c中拷贝构造，因而不能通过编译。使用函数Func的时候，传入Convertable的变量c也会导致参数的拷贝构造，也不能通过编译。

如果把explicit加到Ptr::operator bool() const方法上，则if(p)可以通过编译，因为可以通过p直接构造出bool类型的变量。而p+pd这样的语句就无法通过编译，这是由于全局的operator+并不接受bool类型变量为参数，而Ptr类也不能直接构造出适用于operator+的int类型的变量造成的（不过可以尝试一下使用p&&pd这样的表达式，是能够通过编译的）。这样一来，程序的行为将更加良好。

```c++
int a;
Ptr<int> p(&a);

Ptr<double> pd(0);
cout << (p && pd) << endl;  // 0, true && false

double d;
Ptr<double> pd1(&d);
cout << (p && pd1) << endl;  // 1, true && true
```

可以看到，所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。通常通过赋值表达式和函数参数进行的转换有可能是程序员的一时疏忽，而并非本意。那么使用了显式类型转换，这样的问题就会暴露出来，也是需要显式转换操作符的一个重要原因。

## 3.5 列表初始化 P111

### 3.5.1 初始化列表

 有一种初始化形式就是使用花括号的集合（列表）初始化。事实上，在C++11中，集合（列表）的初始化已经成为C++语言的一个基本功能，在C++11中，这种初始化的方法被称为“初始化列表”（initializer list）。如下：

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main() {
    int a[] = {1, 3, 5};  // C++98通过，C++11通过
    int b[]{1, 3, 5};  // C++98失败，C++11通过
    vector<int> c{1, 3, 5};  // C++98失败，C++11通过
    map<int, float> d = {{1, 1.0f}, {2, 2.0f}, {5, 3.2f}};  // C++98失败，C++11通过
    return 0;
}
```

变量b、c、d在C++98中均无法通过编译，在C++11中，由于列表初始化的存在而可以通过编译。这里，列表初始化可以在“{}”花括号之前使用等号，其效果与不带使用等号的初始化相同。

这样，自动变量和全局变量的初始化在C++11中被丰富了。可以使用以下几种形式完成初始化的工作：

- 等号“=”加上赋值表达式（assignment-expression），比如int a = 3 + 4。
- 等号“=”加上花括号式的初始化列表，比如int a = {3 + 4}。
- 圆括号式的表达式列表（expression-list），比如int a(3 + 4)。
- 花括号式的初始化列表，比如int a{3 + 4}。

而后两种形式也可以用于获取堆内存new操作符中，如：

```c++
int* i = new int(3);
double* d = new double{1.2f};
```

这在C++11中也是合法的表达式。

初始化列表不是专属于内置类型、数组，以及标准模板库中容器的功能。

在C++11中，标准总是倾向于使用更通用的方式来支持新的特性。标准模板库中窗口对初始化列表的支持源自\<initializer_list\>这个头文件中initialize_list类模板的支持。程序员只要`#include<initializer_list>`头文件，并且声明一个以initializer_list\<T\>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

enum Gender { boy, girl };

class People {
public:
    People(initializer_list<pair<string, Gender>> l) : data_(l) {}  // initializer_list的构造函数

private:
    vector<pair<string, Gender>> data_;
};


int main() {
    People ship2012 = {{"Garfield", boy}, {"HelloKitty", girl}};
    return 0;
}
```

同样，函数的参数列表也可以使用初始化列表，如下：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void Fun(initializer_list<int> iv) {
    for_each(iv.begin(), iv.end(), [](const auto& e) { cout << e << ", "; });
}

int main() {
    Fun({1, 2});  // 1, 2,
    Fun({});
    return 0;
}
```

上述代码定义了一个可以接受初始化列表的函数Fun。同理，类和结构体的成员函数也可以使用初始化列表，包括一些操作符的重载函数。在如下代码示例，利用了初始化列表重载了operator[]，并且重载了operator=以及使用辅助的数组。虽然例子比较复杂，但重载的效果还是能够让人感觉眼前一亮的：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>

using namespace std;

class Mydata {
public:
    Mydata& operator[](const initializer_list<int>& l) {  // 书中这里类型为initializer_list<int>
        for (auto i = l.begin(); i != l.end(); ++i) {  // auto类型为initializer_list<int>::iterator
            idx_.push_back(*i);
        }
        return *this;
    }

    Mydata& operator=(int v) {
        if (!idx_.empty()) {  // 如果调用过operator[]，则idx_中存入了修改的index列表
            for (auto i = idx_.begin(); i != idx_.end(); ++i) {
                d_.resize(max<int>(*i, d_.size()));
                d_[*i - 1] = v;
            }
            idx_.clear();
        } else {  // 如果没有调用过operator[]，则给d全部赋值
            d_.assign(d_.size(), v);
        }
        return *this;
    }

    void Print() {
        copy(d_.begin(), d_.end(), ostream_iterator<int>(cout, " "));
    }

private:
    vector<int> idx_;  // 辅助数据，用于记录index
    vector<int> d_;
};

int main() {
    Mydata d;
    d[{2, 3, 5}] = 7;  // 先调用operator[]，再调用operator=
    d[{1, 4, 5, 8}] = 4;
    d.Print();  // 4 7 7 4 4 0 0 4
    d = 10;  // 只调用operator=
    d.Print();  // 10 10 10 10 10 10 10 10
    return 0;
}
```

上述代码中，看到自定义类型Mydata拥有一个以前所有C++代码都不具备的功能，即可以在[]符号中使用列表，将设置数组中的部分为一个指定值。先把数组的第2、3、5位设为数值7，而后又将其1、4、5、8位设为数值4。最终得到数组的内容为“4 7 7 4 4 0 0 4”。当然，由于内置的数组不能重载operator[]，也就无法为其实现相应的功能。

初始化列表还可以用于函数返回的情况。返回一个初始化列表，通常会导致构造一个临时变量，如：

`vector<int> Func() { return {1, 3}; }`

当然，跟声明时采用列表初始化一样，列表初始化构造成什么类型是依据返回类型的，如：

`deque<int> Func2() { return {3, 5}; }`

上面的返回值就是deque\<int\>列表初始化构造函数而构造的。面跟普通的字面量相同，如果返回值是一个引用类型的话，则会返回一个临时变量的引用。如：

`const vector<int>& Func1() { return {3, 5}; }`

这里注意，必须要加const限制符。该规则与返回一个字面常量是一样的。

而本地试验，上述Func1函数可以编译过，但是有编译告警，运行错误，如下：

```c++
//const Mydata& getMydata1() {
//    Mydata d;
//    d[{2, 3, 5}] = 7;
//    return d;  // 编译告警，返回局部变量引用
//}
//
//const Mydata& getMydata2() {
//    return Mydata();  // 无论返回const Mydata&还是Mydata&&，都有编译告警，返回局部变量引用
//}

//const vector<int>& Func1() {  // 如果返回值是vector<int>&，编译错误：不能把非常量左值引用绑定在右值类型std::vector<int>
//    return {3, 5};  // 同样编译告警，返回局部变量引用，这样理解的话，应该是先用{3, 5}构造出来一个同样是局部变量的vector<int>，然后再return
//}

void test1(const vector<int>& ints) {
//    ints.push_back(10);  // 编译错误，常量左值引用无法修改
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

void test2(vector<int>&& ints) {
    ints.push_back(10);
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

int main() {
//    const Mydata& d1 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d1.Print();
//    const Mydata& d2 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d2.Print();
//    const vector<int>& ints = Func1();  // 运行错误，常量左值引用的是函数返回对象，而函数返回对象又是引用函数局部变量，该局部变量已经构造
//    cout << ints.size() << endl;
    test1({1, 2, 3});  // 1 2 3
    test2({1, 2, 3});  // 1 2 3 10
    return 0;
}
```

### 3.5.2 防止类型收窄

使用列表初始化还有一个最大优势是可以防止类型收窄（narrowing）。类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。

如果变量a从类型A转化为类型B，其值在B中也是可以被表示的，且再转化回类型A能获得原有值的话，那么这种类型转换也不能叫作类型收窄。所以类型收窄也可以简单地理解为新类型无法表示原有类型数据的值的情况。

在C++11中，使用初始化列表进行初始化的数据编译器是会松本其是否发生类型收窄。如下：

```c++
const int x = 1024;
const int y = 10;

char a = x;  // 收窄，但可以通过编译
char* b = new char(1024);  // 收窄，但可以通过编译

char c = {x};  // 收窄，无法通过编译
char d = {y};  // 可以通过编译
unsigned char e{-1};  // 收窄，无法通过编译

float f{7};  // 可以通过编译
int g{2.0f};  // 收窄，无法通过编译
float* h = new float{1e48};  // 收窄，无法通过编译
float i = 1.2l;  // 可以通过编译，l是什么意思？
```

对于变量a和*b而言，由于其采用的是赋值表达符及圆括号的表达式初始化，所以虽然它们的数据类型明显收窄（char通常取值范围为-128到127），却不会引发编译失败（事实上，在我们的实验机上会得到编译器的警告）。而使用初始化列表的情况则不一样，对于变量c，由于其类型收窄，则会导致编译器报错。而对于变量d来说，其初始化使用了常量值10，而10是可以由char类型表示的，因此这里不会发生收窄，编译可以通过。

在C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。这也是列表初始化区别于其他初始化方式的地方。事实上，现在编译器大多数会在发生类型收窄的时候提示用户，因为类型收窄通常是代码可能出现问题的征兆。C++将列表初始化设定为可以防范类型收窄，也是为了加强类型使用的安全性。

总的来说，列表初始化改变了C++中对类型初始化的一些基本模式，将标准程序库跟语言拉得更近了。这样的做法有效地统一了内置类型和自定义类型的行为。也是C++11设计所遵循的一个思想，即通用为本，专用为末。

## 3.6 POD类型 P117

C++11将POD划分为两个基本概念的合集，即：平凡的（trivial）和标准布局的（standard layout）。

通常情况下，一个平凡的类或结构体应该符合以下定义：

1. 拥有的默认构造函数（trivial constructor）和析构函数（trivial destructor）
2. 拥有的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）
3. 拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）
4. 不能包含虚函数以及虚基类。

以上4点虽然看似复杂，不过在C++11中，可以通过一些辅助的类模板来帮我们进行以上属性的判断。

类模板is_trivial的成员value可以用于判断T的类型是否是一个平凡的类型。除了类和结构体外，is_trivial还可以对内置的标题类型数据（比如int、float都属性平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

```c++
#include <iostream>

using namespace std;

struct Trivial1 {};
struct Trivial2 {
public:
    int a;
private:
    int b;
};

struct Trivial3 {
    Trivial1 a;
    Trivial2 b;
};

struct Trivial4 {
    Trivial2 a[23];
};

struct Trivial5 {
    int x;
    static int y;
};

struct NonTrivial1 {
    NonTrivial1() : z(42) {}

    int z;
};

struct NonTrivial2 {
    NonTrivial2();

    int w;
};

NonTrivial2::NonTrivial2() = default;

struct NonTrivial3 {
    Trivial5 c;

    virtual void f();
};

int main() {
    cout << is_trivial<Trivial1>::value << endl;  // 1
    cout << is_trivial<Trivial2>::value << endl;  // 1
    cout << is_trivial<Trivial3>::value << endl;  // 1
    cout << is_trivial<Trivial4>::value << endl;  // 1
    cout << is_trivial<Trivial5>::value << endl;  // 1
    cout << is_trivial<NonTrivial1>::value << endl;  // 0
    cout << is_trivial<NonTrivial2>::value << endl;  // 0
    cout << is_trivial<NonTrivial3>::value << endl;  // 0
    return 0;
}
```

POD包含的另外一个概念是标准布局。标准布局的类或结构体应该符合以下定义：

1. 所有非静态成员有相同的访问权限（public, private, protected）。

   如下匿名结构体不是标准布局的：

   ```c++
   struct {
   public:
       int a;
   private:
       int b;
   };
   ```

   如果去掉private关键字的话，该匿名结构体就符合标准布局的定义了。

2. 在类或者结构体继承时，满足以下两种情况之一：

   - 派生类中有非静态成员，且只有一个仅包含静态成员的基类。

   - 基类有非静态成员，而派生类没有非静态成员。
   
   这样的类或者结构体，也是标准布局的。
   
3. 类中的第一个非静态成员的类型与其基类不同。

   这条规则非常特别，用于形如：

   ```c++
   struct A : B {
       B b;
   }
   ```

   这样的情况。这里的A类型不是一个标准布局的类型，因为第一个非静态成员变量b的类型跟A所继承的类型B相同。而形如：

   ```c++
   struct C : B {
       int a;
       B b;
   }
   ```

   则是一个标准布局的类型。
   
4. 没有虚函数和虚基类。

5. 没有非静态数据成员均符合标准布局类型，其基类也符合标准布局。这是一个递归的定义，没什么好特别解释的。

以上5点构成了标准布局的定义，最为重要的应该是前两条。

同样，在C++11中，可以使用模板类来帮忙判断类型是否是一个标准布局的类型。

通过is_standard_layout模板类的成员value(`is_standard_layout<T>::value`)，可以在代码中打印出类型的标准布局属性。如下：

```c++
#include <iostream>

using namespace std;

struct SLayout1 {};
struct SLayout2 {
private:
    int x;
    int y;
};

struct SLayout3 : SLayout1 {
    int x;
    int y;

    void f();
};

struct SLayout4 : SLayout1 {
    int x;
    SLayout1 y;
};

struct SLayout5 : SLayout1, SLayout3 {};  // warning: direct base 'SLayout1' inaccessible in 'SLayout5' due to ambiguity

struct SLayout6 { static int y; };

struct SLayout7 : SLayout6 { int x; };

// 违反3，第一个非静态成员类型与基类相同
struct NonSLayout1 : SLayout1 {
    SLayout1 x;
    int i;
};

// 违反2，基类和派生类同时有非静态成员
struct NonSLayout2 : SLayout2 { int z; };

// 违反5，基类不符合标准布局
struct NonSLayout3 : NonSLayout2 {};

// 违反1，非静态成员访问权限不同
struct NonSLayout4 {
public:
    int x;
private:
    int y;
};

int main() {
    cout << is_standard_layout<SLayout1>::value << endl;  // 1
    cout << is_standard_layout<SLayout2>::value << endl;  // 1
    cout << is_standard_layout<SLayout3>::value << endl;  // 1
    cout << is_standard_layout<SLayout4>::value << endl;  // 1
    cout << is_standard_layout<SLayout5>::value << endl;  // 1
    cout << is_standard_layout<SLayout6>::value << endl;  // 1
    cout << is_standard_layout<SLayout7>::value << endl;  // 1

    cout << is_standard_layout<NonSLayout1>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout2>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout3>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout4>::value << endl;   // 0
    return 0;
}
```

对于POD而言，在C++11中的定义就是平凡的和标准布局的两个方面。标准库中的\<type_traits\>头文件也为程序员提供了模板类。

可以使用std::is_pod\<T\>::value来判定一个类型是否是POD，如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

union U {};

// 违反平凡默认构造函数
union U1 { U1() {}};

enum E {};
typedef double* DA;

typedef void (* PF)(int, double);

int main() {
    cout << is_pod<U>::value << endl;  // 1
    cout << is_pod<U1>::value << endl;  // 0
    cout << is_pod<E>::value << endl;  // 1
    cout << is_pod<int>::value << endl;  // 1
    cout << is_pod<DA>::value << endl;  // 1
    cout << is_pod<PF>::value << endl;  // 1
    return 0;
}
```

如上代码，很多内置类型默认都是POD的。POD最为复杂的地方还是在类或者结构体的判断。使用的POD的好处，大概有如下3点：

1. 字节赋值，代码中可以安全地使用memset和memcpy对POD类型进行初始化和拷贝等操作。

2. 提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的。

3. 保证了静态初始化的安全有效。静态初始化在很多时间能够提高程序的性能，而POD类型的对象初始化往往更加简单（比如放入目标文件的.bss段，在初始化中直接被赋0）。

## 3.7 非受限联合体 P125

在C++98标准中，如果union拥有非POD类型数据成员，则编译失败，也不允许联合体拥有静态或引用类型的成员。

在新的C++11标准中，取消了联合体对于数据成员类型的限制。标准规定，任何非引用类型都可以成为联合体的数据成员，这样的联合体即所谓的非受限联合体（Unrestricted Union）。此外，联合体拥有静态成员（在非匿名联合体中）的限制，也在C++11新标准中被删除了。不过从实践中，发现C++11地规则不允许静态成员变量的存在（否则所有该类型的联合体将共享一个值）。而静态成员函数存在的唯一作用，大概就是为了返回一个常数，如下：

```c++
#include <iostream>

using namespace std;

union T { static long Get() { return 32; }};

int main() {
    cout << T::Get() << endl;
    return 0;
}
```

上述代码定义了一个有静态成员函数的联合体。不过这里的union T更像是一个作用域限制符，并没有太大的实用意义。

在C++11中，标准会默认删除一些非受限联合体的默认函数。比如，非受限联合体有一个非POD的成员，而该POD成员类型拥有非平凡的构造函数，那么非受限联合体成员的默认构造函数将被编译器删除。其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数待，也将遵从此规则。如下例：

```c++
#include <iostream>
#include <string>

using namespace std;

union T {
    string s;  // string有非平凡的构造函数
    int n;
};

int main() {
    T t;  // 构造失败，因为T的构造函数被删除了，error: use of deleted function 'T::T()'
    return 0;
}
```

上述代码中，联合体T拥有一个非POD的成员s。而string有非平凡的构造函数，因此T的构造函数被删除，其类型的变量t也就无法声明成功。解决这个问题的办法是，由程序员自己为非受限联合体定义构造函数。通常情况下，placement new会发挥很好作用，如下：

```c++
#include <iostream>
#include <string>

using namespace std;

union T {
    string s;
    int n;
public:
    // 自定义构造函数和析构函数
    T() { new(&s) string; }

    ~T() { s.~string(); }
};

int main() {
    T t;  // 构造析构成功
    return 0;
}
```

上述代码，定义了union T的构造和析构函数。构造时，采用placement new将s构造在其地址&s上。这里的placement new的唯一作用只是调用了一下string的构造函数。而在析构时，又调用了string的析构函数。必须注意的是，析构的时候union T也必须是一个string对象，否则可能导致析构的错误（或者让析构函数为空，至少不会造成运行时错误）。这样，变量 t的声明就可以通过编译了。

匿名非限联合体可以运行于类的声明中，这样的类也被称为“枚举式的类”（union-like class）。可以看看如下例：

```c++
#include <iostream>
#include <string>

using namespace std;

struct Student {
    Student(bool g, int a) : gender(g), age(a) {}

    bool gender;
    int age;
};

class Singer {
public:
    enum Type { STUDENT, NATIVE, FOREIGNER };

    // 每个构造函数只构造union中的一个成员变量
    Singer(bool g, int a) : s(g, a) { t = STUDENT; }

    Singer(int i) : id(i) { t = NATIVE; }

    Singer(const char* n, int s) {
        int size = (s > 9) ? 9 : s;
        memcpy(name, n, size);
        name[s] = '\0';
        t = FOREIGNER;
    }

    ~Singer() {}

private:
    Type t;
    union {  // 匿名的非受限联合体
        Student s;
        int id;
        char name[10];
    };
};

int main() {
    Singer(true, 13);
    Singer(310217);
    Singer("J Michael", 9);
    return 0;
}
```

如上代码，也把匿名非受限联合体成为类Singer的“变长成员”（variant member）。这样的变长成员给类的编写带来了更大的灵活性，这是C++98标准中无法达到的。

## 3.8 用户自定义字面量 P129

在C/C++程序中，程序员常常会使用结构体或类来创造新的类型，以满足实际的需求。不过，有时候自定义类型也会有些书写的麻烦，尤其是用户想声明一个自定义类型的“字面量”的时候。

```c++
#include <iostream>
#include <string>

using namespace std;

typedef unsigned char uint8;

struct RGBA {
    uint8 r;
    uint8 g;
    uint8 b;
    uint8 a;

    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = 0) : r(R), g(G), b(B), a(A) {
        cout << "RGBA with four parameters" << endl;
    }

//    RGBA(const initializer_list<uint8>& cols) {
//        cout << "RGBA with initializer list" << endl;
//    }
};

ostream& operator<<(ostream& out, RGBA& col) {
    return out << "r: " << (int) col.r
               << " g: " << (int) col.g
               << " b: " << (int) col.b
               << " a: " << (int) col.a;
}

void blend(RGBA& col1, RGBA& col2) {
    cout << "blend" << endl << col1 << col2 << endl;
}

int main() {
    RGBA col1(255, 240, 155);
    RGBA col2({15, 255, 10, 7});  // C++11风格的列表初始化，如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    blend(col1, col2);

    RGBA col3{15, 255, 10, 7};  // 如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    RGBA col4 = {15, 255, 10, 7};  // 如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    return 0;
}
// 输出
RGBA with four parameters
RGBA with four parameters
blend
r: 255 g: 240 b: 155 a: 0r: 15 g: 255 b: 10 a: 7
RGBA with four parameters
RGBA with four parameters
```

试了下函数的多入参改为列表方式，编译报错，说明只有类初始化可以使用列表风格初始化：

```c++
void hello(int i, int j) {
    cout << "i: " << i << ", j: " << j << endl;
}

int main() {
    hello(1, 2);
    hello({3, 4});  // 编译错误，error: cannot convert '<brace-enclosed initializer list>' to 'int'
    return 0;
}
```

上述代码在编写测试用例的时候，常会遇到需要声明较多值确定的RGBA变量。那么这样的声明变量—传值运算的方式是非常麻烦的。如果自定义类可以像内置类型一样向函数传递字面常量，比如向函数func传递字面常量func(2, 5.0f)，无疑这样的测试代码会简化很多。

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

typedef unsigned char uint8;

struct RGBA {
    uint8 r;
    uint8 g;
    uint8 b;
    uint8 a;

    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = 0) : r(R), g(G), b(B), a(A) {}
};

RGBA operator "" _C(const char* col, size_t n) {  // 一个长度为n的字符串col
    const char* p = col;
    const char* end = col + n;
    const char* r = nullptr, * g = nullptr, * b = nullptr, * a = nullptr;

    for (; p != end; ++p) {
        if (*p == 'r') {
            r = p;
        } else if (*p == 'g') {
            g = p;
        } else if (*p == 'b') {
            b = p;
        } else if (*p == 'a') {
            a = p;
        }
    }

    if ((r == nullptr) || (g == nullptr) || (b == nullptr)) {
        throw;
    } else if (a == nullptr) {
        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1));
    } else {
        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1), atoi(a + 1));
    }
}

ostream& operator<<(ostream& out, RGBA& col) {
    return out << "r: " << (int) col.r
               << " g: " << (int) col.g
               << " b: " << (int) col.b
               << " a: " << (int) col.a;
}

void blend(RGBA&& col1, RGBA&& col2) {  // 入参为""_C函数返回的RGBA临时变量，这里要么用常量左值引用const RGBA&，要么用右值引用RGBA&&
    cout << "blend" << endl << col1 << col2 << endl;
}

int main() {
    blend("r255 g240 b155"_C, "r15 g255 b10 a7"_C);
    return 0;
}
// 输出
blend
r: 255 g: 240 b: 155 a: 0r: 15 g: 255 b: 10 a: 7
```

上述代码声明了一个字面量操作符（literal operator）函数：`RGBA operator ""_C(const char* col, size_t n)`函数。这个函数会解析以_C为后缀的字符串，并返回一个RGBA的临时变量。有了这样一个用户字面常量的定义，main函数中不再需要通过声明RGBA类型的声明变量—传值运算的方式来传递实际意义上的常量 。通过声明一个字符串以及一个\_C后缀，operator ""\_C函数会产生临时变量。blend函数就可以通过右值引用获得这些临时值并进行计算了。这样，完成了定义自定义类型的字面常量，main函数中的代码书写显得更加清晰。

除去字符串外，后缀声明也可以作用于数值，如用户可能使用60W、120W的表示方式来标识功率，用50kg来表示质量，用1200N来表示力等。如下：

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

struct Watt {
    unsigned int v;
};

Watt operator "" _w(unsigned long long v) {  // 如果不以_开始，如"" w，则会有编译告警：warning: literal operator suffixes not preceded by '_' are reserved for future standardization [-Wliteral-suffix]，不影响功能
    return {(unsigned int) v};  // 使用初始化列表直接构造Watt
}

// 如果注释掉上面的Watt operator "" _w(unsigned long long v)函数，则如下函数也可工作
Watt operator "" _w(const char* v) {
    return {(unsigned int) atoi(v)};
}

int main() {
    Watt capacity = 1024_w;
    cout << capacity.v << "\n";  // 1024
    return 0;
}
```

验证的初始化列表方式构造struct对象：

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

struct Watt {
    unsigned int v;
    unsigned int w;
    
    // Watt(unsigned int v, unsigned int w) : v(v), w(w) {}
};

int main() {
    Watt w1 = {10};  // 可以直接使用初始化列表来构造struct对象，如果自定义了上面的双入参构造函数，这里编译失败
    cout << w1.v << " " << w1.w << endl;  // 10 0

    Watt w2 = {10, 20};  // 可以直接使用初始化列表来构造struct对象
    cout << w2.v << " " << w2.w << endl;  // 10 20

    return 0;
}
```

这里用_w后缀来标识瓦特。除了整型数，用户自定义字面量还可以用于浮点型数等的字面量。不过必须注意的是，在C++11中，标准要求声明字面量操作符有一定的规则，该规则跟字面量的“类型”密切相关。C++11中具体规则如下：

- 如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者const char*为其参数。当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以\0为结束符的字符串，并调用以const char\*为参数的版本进行处理。
- 如果字面量为浮点型数，则字面量操作符函数只可接受long double或者const char\*为参数。const char\*版本的调用规则同整数一样（过长则使用const char\*版本）。
- 如果字面量为字符串，则字面量操作符函数只可接受const char\*, size_t为参数（已知长度的字符串）。
- 如果字面量为字符，则字面量操作符函数只可接受一个char为参数。

总体来说，用户自定义字面量为代码书写带来了极大的便利。此外，在使用这个特性时，应该注意：

- 在字面量操作符函数的声明中，operator ""与用户自定义后缀之间必须有空格。
- 后缀建议以下划线开始。不宜使用非下划线后缀的用户自定义字符串常量，否则会被编译器警告。因为如果重用形如201203L这样的字面量，后缀“L”放弃系统无法引用一些混乱的状况。为避免混乱，最好只使用下划线开始的后缀名。

## 3.9 内联名字空间

在C++中，引入了名称空间（namespace）概念。目的是分割全局共享的名字空间。程序员在编写程序时可以建立自己的名字空间，使用者可以通过双冒号“空间名::函数/变量名”的形式来引用自己需要的版本。这就解决了C中名字冲突的问题。不过有时，我们会遇到一个名字空间下包含多个子名字空间的状况。子名字空间通常会带来一些使用上的不便。如下：

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};
    }

    namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // 无法通过编译
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;
        Basic::Knife k;
    }
}

// 这是LiLei在使用Jim的库
using namespace Jim;

int main() {
    Toolkit::SwissArmyKnife<Basic::Knife> sknife;
    return 0;
}
// 输出：
Knife in Other.
Knife in Basic.
```

在上述代码中，库编写者Jim用名字空间将自己代码封装起来。通过名字空间的细分，Other名字空间中不能直接引用Basic名字空间中的名字Knife。而Other名字空间中定义了Knife类型，那么变量c的声明就会导致其使用Knife类型是属于名字空间Other中的版本。这样的使用名字空间的方式是非常清楚的。

不过Jim这样会带来一个问题，即库的使用者在使用Jim名字空间的时候，需要知道太多的子名字空间的名字。使用者显然不希望声明一个sknife变量时，需要Toolkit::SwissArmyKnife\<Basic::Knife\>这么长的类型声明，通常也没必要让使用者LiLei看到子名字空间，因此他可能考虑这样修改代码，如下：

代码清单 3-48

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;
        Basic::Knife k;
    }

    // 打开一些内部名字空间
    using namespace Basic;
    using namespace Toolkit;
}

// LiLei决定对该class进行特化
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 编译失败，explicit specialization of 'template<class T> class Jim::Toolkit::SwissArmyKnife' outside its namespace must use a nested-name-specifier [-fpermissive]
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;  // 如果注释掉Jim中的using namespace Basic;，则这里无法识别Knife
    return 0;
}
```

在上述代码中，Jim在名字空间Jim的最后部分，打开了（using）Basic和Toolkit两个名字空间。这样一来在前一个代码中遇到的名字过长的问题就不复存在了。不过又有了新的问题：库的使用者LiLei由于觉得Toolkit中的模板SwissArmyKnife有的时候不太合用，所以决定特化一个SwissArmyKnife\<Knife\>的版本。这个时候，我们编译该例子则会失败。这是由于C++98标准不允许在不同的名字空间中对模板进行特化造成的。

在C++11中，标准了一个新特性，叫做“内联的名字空间”。通过关键字“inline namespace”就可以声明一个内联的名字空间。内联的名字空间允许程序员在父名字空间定义或特化子名字空间的模板。如下：

代码清单3-49

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    inline namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    inline namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // Knife in Basic
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;  // Knife in Other
        Basic::Knife k;  // Knife in Basic
    }
}

// 这是LiLei在使用Jim的库
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 使用inline名字空间后编译通过
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;
    return 0;
}
```

上述代码将名字空间Basic和Toolkit都声明为inline的。此时，LiLei对库中模板的偏特化（SwissArmyKnife\<Knife\>）则可以通过编译。这里再注意一下Other这个名字空间中的状况。可以看到，变量b的声明语句是可以通过编译的，而且其被声明为一个Basic::Knife的类型。换个角度理解的话，在子名字空间Basic中的名字现在看起来就跟在父名字空间Jim中一样。了解了这一点，Jim名字空间中的良好分隔明显被破坏了，要做到这样的效果，只需要把Knife和CorkScrew放到全局名字空间中就可以了，根本不用inline namespace这么复杂。事实上，这跟inline namespace的使用方式有关。如下：

代码清单3-50

```c++
#include <iostream>

using namespace std;

namespace Jim {
#if __cplusplus >= 201103L  // __cplusplus = 201402，所以这里如果写== 201103L，编译报错
    inline
#endif
    namespace cpp11 {
        struct Knife { Knife() { cout << "Knife in c++11." << endl; }};
    }

#if __cplusplus < 201103L
    inline
#endif
    namespace oldcpp {
        struct Knife { Knife() { cout << "Knife in old c++." << endl; }};
    }
}

using namespace Jim;

int main() {
    Knife a;  // Knife in c++11.（默认版本）
    cpp11::Knife b;  // Knife in c++11.（强制使用cpp11版本）
    oldcpp::Knife c;  // Knife in old c++.（强制使用oldcpp版本）
    return 0;
}
```

上述代码中，Jim为它的名字空间设定了两个子名字空间：cpp11和oldcpp。这里用到了在2.1节提到的关于C++的宏\_\_cplusplus。代码的意思是，如果现在的宏\_\_cplusplus大于等于201103这个常数，就将名字空间cpp11内联到Jim中，而如果小于201103，则将名字空间oldcpp内联到Jim中。这样，编译器就可以根据当前编译器对C++支持的情况，选择合适的实现版本。而如果需要的话，依然可以通过名字空间的方式（如cpp11::Knife）来访问相应名字空间中的类型、数据、函数等。这对程序库的发布很有好处，因为需要长期维护的程序库，可能版本间的接口和实现等都随着程序库的发展而发生了变化。那么根据需要将合适的名字空间导入到父名字空间中，无疑会方便库的使用。

还有一点，匿名的名字空间同样可以把其包含的名字内联导入到父名字空间。所以读者可能认为上述代码3-50同样可以通过匿名名字空间与宏组合来实现。不过跟代码清单3-48中使用using打开名字空间的情况一样，匿名名字空间无法允许在父名字空间的模板特化（但是如下代码验证去掉Basic和Toolkit子空间名字后，可以进行模板特化）。不过与在3-49中看到的一样，名字空间的内联会破坏该名字空间本身具有的封闭性，所以程序员不该在需要隔离名字的时候使用inline namespace关键字。

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    inline namespace {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    inline namespace {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // Knife in Basic
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;  // Knife in Other
    }
}

// 这是LiLei在使用Jim的库
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 使用inline名字空间后编译通过
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;
    return 0;
}
```

此外，在代码实践时，可能还会被一些C++的语言特性迷惑，比较典型的是所谓“参数关联名字查找”，即ADL（Argument-Dependent name Lookup）。这个特性允许编译器在名字空间内找不到函数名字的时候，在参数的名字空间内查找函数名字。如下：

```c++
namespace ns_adl {
    struct A {};
    void ADLFunc(A a) {}  // ADLFunc定义在namespace ns_adl中
}

int main() {
    ns_adl::A a;
    ADLFunc(a);  // ADLFunc无需声明名字空间
    return 0;
}
```

函数ADLFunc就无需在使用时声明其所在的名字空间，因为编译器可以在其参数a的名字空间ns_adl中找到ADLFunc，编译也就不会报错了。

ADL带来了一些使用上的便利性，不过也在一定程序上破坏了namespace的封装性。因此，比较好的使用方式，还是在使用任何名字前打开名字空间，或者使用“::”列出变量、函数完整的名字空间。

## 3.10 模板的别名

在C++11中，定义别名不再是typedef的专属能力，使用using同样可以定义类型的别名，而且从语言能力上看，using丝毫不比typedef逊色。如下例：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

using uint = unsigned int;
typedef unsigned int UINT;
using sint = int;

int main() {
    cout << is_same<uint, UINT>::value << endl;  // 1
    return 0;
}
```

上例，使用了C++标准库中的is_same模板类帮忙判断两个类型是否一致。is_same模板类接受两个类型作为模板实例化时的参数，而其成员类型则表示两个参数类型是否一样。using和typedef两者效果相同，或者说，在C++11中，using关键字的能力已经包括了typedef的部分。

在使用模板编程的时候，using的语法甚至比typedef更加灵活。如下例：

```c++
#include <iostream>
#include <map>

using namespace std;

template<typename T> using MapString = std::map<T, const char*>;

int main() {
    MapString<int> numberString;
    numberString.insert(std::make_pair(1, "abc"));
    numberString.insert(std::make_pair(2, "def"));
    
    return 0;
}
```

这里，“模板式”地使用了using关键字，将std::map\<T, const char*\>定义为了一个MapString类型，之后还可以使用类型参数对MapString进行类型的实例化，而使用typedef将无法达到这样的效果。

## 3.11 一般化的SFINEA规则 P138

在C++模板中，有一条著名的规则，即SFINEA - Substitution failure is not an error，中文直译即是“匹配失败不是错误”。更为确切地说，这条规则表示的是对重载的模板的参数进行展开的时候，如果展示导致了一些不匹配，编译器并不会报错。如下例：

```c++
#include <iostream>

using namespace std;

struct Test {
    typedef int foo;
};

template<typename T>
void f(typename T::foo) {
    cout << "f(typename T::foo)" << endl;
}

template<typename T>
void f(T) {
    cout << "f(T)" << endl;
}

int main() {
    f<Test>(10);  // f(typename T::foo)
    f<int>(10);  // f(T)
    return 0;
}
```

上述代码重载了函数模板f的定义。第一个模板f接受的参数类型为T::foo，这里通过typename来使编译器知道T::foo是一个类型。而第二个模板定义则接受一个T类型的参数。在main函数中，分别使用f\<Test\>和f\<int\>对模板进行实例化的时候会发现，对于f\<int\>来讲，虽然不存在 int::foo这样的类型，编译器依然不会报错，相反地，编译器会找到第二个模板定义并对其进行实例化。这样一来，就保证了编译的正确性。

通过上面的例子可以发现，SFINAE规则的作用比起拗口的定义而言更为直观。基本上，这是一个使得C++模板推导规则符合程序员想象的规则。通过SFINAE，能够使得模板匹配更为“精确”，即使得一些模板函数、模板类在实例化时使用特殊的模板版本，而另外一些则使用通过的版本，这样就大大增加了模板设计使用上的灵活性。这样的使用方式在标准库中使用非常普通（当你在标准库中发现一大堆的__enable_if，或者应该想起来这是SFINAE）。因此也可以说，SFINAE也是C++模板推导中非常基础的一个特性。

在C++98中，标准对于SFINAE并没有完全清晰的描述，一些在模板参数中使用表达式的情况，并没有被主流编译器支持。如下来自C++标准提案中的例子：

```c++
template<int I>
struct A {};

char xxx(int);

char xxx(float);

template<class T>
A<sizeof(xxx((T) 0))> f(T) {}

int main() {
    f(1);
    return 0;
}
```

上述代码，在定义函数模板f的时候，其返回值则定义为一个以sizeof(xxx((T) 0))为参数的类模板A。这里值得注意的是，我们使用了sizeof表达式，以及强制的类型转换。事实上，这样的表达式是可以在模板实例化时被计算出来的。不过由于实现上的复杂性，以及标准中并示明确地提及，大多数C++98编译器都会报一个SFINEA失败信息。而事实上，这样灵活的用法却非常有用，如本例中，程序员可以根据参数的长度而定义出不同返回值的模板函数（一种是sizeof((int)0)，一种则是sizeof((float)0)）。如果编译器拒绝了 这样的使用方式，无疑会为泛型编程的应用带来一些限制。

在C++11中，标准对这样的状况，尤其是模板参数替换时使用了表达式的情况进行了明确规定，即表达式中没有出现“外部于表达式本身”的元素，比如说发生一些模板的实例化，或者隐式地产生一些拷贝构造函数的话，这样的模板推导都不会产生SFINAE失败（即编译器报错）。这样，C++11中的一些新特性（比如将在第4章讲到的decltype等）将能够成功地进行广泛的应用。新的STL也将因此受益。

## 4.1 右尖括号>的改进

C++98会将>>优先解析为右移。C++11中，这种限制被取消了。事实上，C++11标准要求编译器智能地去判断在哪些情况下>>不是右移符号。

 过这些“智能”的判断也会带来一些与C++98的有趣的不兼容性。如用户只是想让>>在模板的实例化中表示的是真正的右移，但C++11会把它解析为模板参数界定符。如下：

```c++
#include <iostream>

using namespace std;

template<int i>
class X {};

int main() {
    X<1 >> 5> x;  // 编译错误：error: expected unqualified-id before '>' token
    // 改为X<(1 >> 5)> x;
    return 0;
}
```

如果使用C++98标准进行编译的话，例子会编译通过，因为编译器认为X<1 >> 5> x;中的双尖括号是一个位移操作，那么最终得到一个形如X<0> x的模板实例。而使用C++11标准进行编译，会得到一个编译错误的警告，因为编译器优先将双尖括号中的第一个>与X之后的<进行了配对。

虽然很少有人在模板实例化时同时进行位移操作，但从语法上来说，C++98和C++11确实在这一点不兼容。要避免这样的不兼容性也很简单，使用圆括号将“1 >> 5”括起来，保证右移操作优先，就不会出现类似问题了。

## 4.2 auto类型推导 P143

### 4.2.1 静态类型、动态类型与类型推导

在C++程序员的眼中，每个变量使用前必须定义，这种通常被视为编程语言中的“静态类型”的体现。而对于如Python、Perl、JavaScript等语言中变量不需要声明，而几乎“拿来就用”的变量使用方式，则被视为是编译语言中的“动态类型”的体现。不过从技术上严格地讲，静态类型和动态类型的主要区别在于对变量进行类型检查的时间点。对于所谓的静态类型，类型检查主要发生在编译阶段；而对于动态类型，类型检查主要发生在运行阶段。形如Python等语言中变量“拿来就用”的特性，则需要归功于一个技术，即类型推导。

在C++11中，类型推导的实现方式之一就是重定义了auto关键字，另外一个实现是decltype。

使用C++11的方式书写一下刚才的Python代码，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    auto name = "world.\n";
    cout << "hello, " << name;
    return 0;
}
```

上例使用了auto关键字来要求编译器对变量name的类型进行自动推导。编译器根据它的初始化表达式的类型，推导出name的类型为char*。

事实上，auto关键字在早期的C/C++标准中有着完全不同的含义。声明时使用了auto修饰的变量，按照早期C/C++标准的解决，是具有自动存储期的局部变量。不过现实情况是该关键字几乎无人使用，因为一般函数内没有声明为static的变量总是具有自动存储期的局部变量。因此在C++11中，标准委员会决定赋予auto全新的含义，即auto不再是一个存储类型指示符（storage-class-specifier，如static、extern、thread_local等都是存储类型指示符），而是作为一个新的类型指示符（type-specifier，如int、float等都是类型指示符）来指示编译器，auto声明变量的类型必须由编译器在编译时期推导而得。

如下例了解一下auto类型推导的基本用法：

```c++
#include <iostream>

using namespace std;

int main() {
    double foo();
    auto x = 1;  // x的类型是int
    auto y = foo();  // y的类型是double

    struct m { int i; } str;
    auto str1 = str;  // str1的类型是struct m

    auto z;  // 无法推导，无法通过编译
    return 0;
}
```

上例中，变量x被初始化为1，因为字面常量1的类型为const int，所以编译器推导出x的类型应该为int（这里const类型限制符被去掉了，后面会解释）。同理在变量y的定义中，auto类型的y被推导为double类型；而在auto str1的定义中，其类型被推导为struct m。

auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“点位符”，编译器在编译时期会将auto替代为变量实际的类型。

### 4.2.2 auto的优势

直观地，auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。由于C++的发展，声明变量类型也变得越来越复杂，很多时候，名字空间、模板成为了类型的一部分，导致在使用库的时间如履薄冰。如下：

```c++
#include <iostream>
#include <vector>

void loopover(std::vector<std::string>& vs) {
    std::vector<std::string>::iterator i = vs.begin();
    for (; i < vs.end(); ++i) {
        std::cout << *i << "\n";
    }
}

int main() {
    std::vector<std::string> vs = {"abc", "def"};
    loopover(vs);
    return 0;
}
```

如上例，在不使用using namespace std的情况下（事实上，很多专家建议就是如此）想对一个vector数组进行循环。可以看到，想定义一个迭代器i的时候，必须写出std::vector\<std::string\>::iterator这样长的类型声明。使用auto的话，代码的可读性可以成倍增长，如下：

```c++
#include <iostream>
#include <vector>

void loopover(std::vector<std::string>& vs) {
    for (auto i = vs.begin(); i < vs.end(); ++i) {
        std::cout << *i << "\n";
    }
}
```

如上，使用了auto，可以将i的声明放入for循环，i的类型将由表达式vs.begin()推导出。在C++11中，由于auto的存在，使用STL将会变得更加容易，写出的代码也会更加清晰可读。

auto的第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。在C/C++中，存在着很多隐式或者用户自定义的类型转换规则（比如整形与字符型进行加法运算后，表达式返回的是整型，这是一条隐式规则）。这些规则并非很容易记忆，尤其是在用户自定义了很多操作符之后。这时，auto就有用武之地了。如下：

```c++
#include <iostream>

using namespace std;

class PI {
public:
    double operator*(float v) {
        return (double) val * v;  // 这里精度被扩展了
    }

    const float val = 3.1415927f;
};

int main() {
    float radius = 1.7e10;
    PI pi;
    auto circumference = 2 * (pi * radius);  // 写成radius * pi则无重载操作符*
    cout << circumference << endl;
    return 0;
}
```

上述代码，定义了float型的变量radius（半径）以及一个自定义类型PI变量pi（π值）计算圆周长时，使用了auto类型来定义变量circumference。这里PI在与float类型数据相乘时，其返回值为double。而PI的定义可能是在其它的地方（头文件里），main函数的程序员可能不知道PI的作者为了避免数据上溢或者精度降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，可能享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经自动地做了最好的选择。

值得指出的是，auto并不解决所有的精度问题，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    unsigned int a = 4294967295;  // 最大的unsigned int值
    unsigned int b = 1;
    auto c = a + b;

    cout << "a = " << a << endl;  // a = 4294967295
    cout << "b = " << b << endl;  // b = 1
    cout << "a + b = " << c << endl;  // a + b = 0
    return 0;
}
```

上述代码，程序员可能指望通过声明变量c为auto就能解决a+b溢出的问题，而实际上由于a+b返回的依然是unsigned int的值，故而c的类型依然被推导为unsigned int，auto并不能帮上忙。这跟一些动态语言中数据会自动进行扩展的特性还是不一样的。

auto的第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程。

再回到之前代码，这里假设PI的作者改动了PI的定义，如将operator*返回值变为long double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。

同理，对于不同的平台上的代码维护，auto也会带来一些“泛型”的好处。这里以strlen函数为例，在32位的编译环境下，strlen返回的为一个4字节的整型，而在64位的编译环境下，strlen会返回一个8字节的整型。虽然系统库\<cstring\>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字同样可以达到代码跨平台的效果。

`auto var = strlen("hello world!")`

由于size_t的适用范围往往局限于\<cstring\>中定义的函数，auto的适用范围明显更为广泛。

当auto应用于模板的定义中，其“自定义”性会得到更加充分的体现，如下：

代码清单4-19

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
double Sum(T1& t1, T2& t2) {
    auto s = t1 + t2;  // s的类型会在模板实例化时被推导出来
    return s;
}

int main() {
    int a = 3;
    long b = 5;
    float c = 1.0f, d = 2.3f;

    auto e = Sum<int, long>(a, b);  // s的类型被推导为long
    auto f = Sum<float, float>(c, d);  // s的类型被推导为float
    return 0;
}
```

可以看到，auto与模板一起使用时，其“自适用”特性能够加强C++中“泛型”的能力。不过这个例子中，由于总是返回double类型的数据，所以Sum模板函数的适用范围还是受到了一定的限制，在4.4节，可以看到怎么使用追踪返回类型的函数声明来完全释放Sum泛型的能量。

本地试验，把sum返回值改成auto也可以正常编译运行：

```c++
template<typename T1, typename T2>
auto Sum(T1& t1, T2& t2) {
    auto s = t1 + t2;  // s的类型会在模板实例化时被推导出来
    return s;
}
```

另外，应用auto还会在一些情况下取得意想不到的好效果，如下：

```c++
#include <iostream>

using namespace std;

#define max1(a, b) ((a) > (b)) ? (a) : (b)
#define max2(a, b) ( {\
    auto _a = (a); \
    auto _b = (b); \
    (_a > _b) ? _a : _b; })

int main() {
    int m1 = max1(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);
    int m2 = max2(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);
    cout << m1 << endl;
    cout << m2 << endl;
    return 0;
}
```

上例代码定义了两种类型的宏max1和max2。两者作用相同，都是求a和b中较大者返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为a和b在三元运算符中都出现了两次，无论取a还是取b，其中之一都会被运算两次。而在max2中，将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。

在传统的C++98标准中，由于a和b的类型无法获得，所以无法定义max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。

### 4.2.3 auto的使用细则

首先看看auto类型指示符与指针和引用之间的关系。在C++11中，auto可以与指针和引用结合起来使用，使用的效果基本上会符合C/C++程序员的想象。如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

int num = 100;

int& bar() {
    return num;
}

int main() {
    int x = 11;
    int* y = &x;

    auto* a = &x;  // auto为int，如果定义为auto a = &x;，则auto为int*
    cout << *a << "\n";  // 11
    auto& b = x;  // auto为int
    auto c = y;  // auto为int*
    auto* d = y;  // auto为int
//    auto* e = &foo();  // 编译失败，指针不能指向一个临时变量
//    auto& f = foo();  // 编译失败，nonconst的左值引用不能和一个临时变量绑定，可以改成const左值引用const auto& f = foo();，或右值引用auto&& f = foo();
    auto g = bar();  // auto为int
    auto& h = bar(); // auto为int
    
    return 0;
}
```

本例中，变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、dd一个变量而言，声明其为auto*或auto并没有区别。而如何要使得auto声明的变量是另一个变量的引用，则必须使用auto&，如同本例中的变量b和h一样。

其次，auto与volatile和const之间也存在着一些相互的联系。volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的特殊性，C++11标准规定auto可心与cv限制符一起使用，不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符（**就是说auto声明的变量，不会直接带着为const标识符**）。如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

float num = 100.0;

float* bar() {
    return &num;
}

int main() {
    const auto a = foo();  // a: const double
    const auto& b = foo();  // b: const double&
    volatile auto* c = bar();  // c: volatile float*

    auto d = a;  // d: double
    d = 10;  // 编译通过
    auto& e = a;  // e: const double&
//    e = 10;  // 编译错误，error: assignment of read-only reference 'e'
    auto f = c;  // f: float*
    volatile auto& g = c;  // g: volatile float*&
    return 0;
}
```

上述代码中，可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。

跟其它的变量指针符一样，同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其它的变量。所以不允许这些变量的类型不相同，如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

float num = 100.0;

float* bar() {
    return &num;
}

int main() {
    auto x = 1, y = 2;  // x和y的类型均为int

    // m是一个指向const int类型变量的指针，n是一个int类型的变量
    const auto* m = &x, n = 1;  // auto为int，n为const int
//    n = 2;  // 编译错误，const对象无法修改

    // 如下编译错误，error: inconsistent deduction for 'auto': 'int* const' and then 'const int'
//    const auto m1 = &x, n1 = 1;

//    auto i = 1, j = 3.14f;  // 编译失败，error: inconsistent deduction for 'auto': 'int' and then 'float'
    auto o = 1, &p = o, *q = &p;  // 从左向右推导

    return 0;
}
```

上述代码，使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j时，按照所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了int j = 3.14f，这无疑会导致精度的损失。而对于变量m和n，这里似乎是auto被替换成了int，所以m是一个const int*指针类型，而n只是一个const int类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为int的变量，p是o的引用，而q是p的指针。auto的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”（placeholder）。为了不必要的繁琐记忆，程序员可以选择每一个auto变量的声明写成一行（有些观点也认为这是好的编程规范）。

只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型。包括C++11新引入的初始化列表，以及new，都可以使用auto关键字，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    auto x = 1;
    auto x1(1);
    auto y{1};  // y: int，使用初始化列表的auto
    cout << y << "\n";
//    vector<auto> y{1, 2};  // 编译错误：auto is not allowed in template argument

    auto z = new auto(2);  // 可以用于new，auto z = new auto{2};也可以
    cout << *z << "\n";
    delete z;
    return 0;
}
```

上述代码，auto变量y的初始化使用了初始化列表，编译器可以保证y的类型推导为int。而z指针所指向的堆变量在分配时依然选择让编译器对类型进行推导，同样的，编译器也能够保证这种方式下类型推导的正确性。

不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制。例外的情况写在如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

void fun(auto x = 1) {}  // 1: auto函数参数，无法通过编译

struct str {
    auto var = 10;  // 2: auto非静态成员变量，无法通过编译，const static auto var = 10;可以编译通过
};

int main() {
    char x[3];
    auto y = x;
    auto z[3] = x;  // 3: auto数组，无法通过编译
    auto u[3] = {1, 2, 3};  // 同样编译失败
    // 但是本来数组也无法直接赋值初始化
//    char w[3] = x;  // 编译失败，char数组只能初始化列表初始化或字符串字面量初始化，可改成char* w  = x;
//    int i[3] = {1, 2, 3};
//    int j[3] = i;  // 编译失败，数组只能初始化列表初始化

    // 4: auto模板参数（实例化时），无法通过编译
    vector<auto> v = {1};
    return 0;
}
```

分别来看上述代码中的4种不能推导的情况。

1. 对于函数fun来说，auto不能是其形参类型。可能读者感觉对于fun来说，由于其有默认参数，所以应该推导fun形参x的类型为int型。但事实却无法符合大家想象，因为auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。
2. 对于结构体来说，非静态成员变量的类型不能是auto的。同样的，由于var定义了初始值，读者可能认为auto可以推导str成员var的类型为int的。但编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。
3. 声明auto数组。可以看到main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。
4. 在实例化模板的时候使用auto作为模板参数。虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。

以上4种情况特点基本相似，人为地观察很容易能够推导出auto所在位置应有的类型，但现有的C++11的标准还没有支持这样的使用方式。

由于为了避免和C++98中auto的含义发生混淆，C++11只保留auto作为类型指示符的用法，以下的语句在C++98和C语言中都是合法的，但在C++11中，编译器会报错。

`auto int i = 1;  // error: two or more data types in declaration of 'i'`

总的来说，auto在C++11中是相当关键的特性之一。之后还会在很多地方看到auto，如4.4节中的追踪返回类型的函数声明，以及7.3节中lambda与auto的配合使用等。不过，auto只是C++11中类型推导体现的一部分。其余的，则会在decltype中得到体现。

## 4.3 decltype P153

### 4.3.1 typeid与decltype

与C完全不支持动态类型不同的是，C++在C++98标准中就部分支持动态类型了。C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。

RTTI的机制是为每个类型产生一个type_info类型的数据，程序员可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。而type_info的name成员函数可以返回类型的名字。而在C++11中，又增加了hash_code这个成员函数，返回该类唯一的哈希值，以供程序员对变量的类型随时进行比较。如下：

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

class White {};

class Black {};

int main() {
    White a;
    Black b;

    cout << typeid(a).name() << endl;  // 5White
    cout << typeid(b).name() << endl;  // 5Black

    White c;

    bool a_b_sametype = (typeid(a).hash_code() == typeid(b).hash_code());
    bool a_c_sametype = (typeid(a).hash_code() == typeid(c).hash_code());

    cout << "Same type? " << endl;
    cout << "A and B? " << (int) a_b_sametype << endl;  // 0
    cout << "A and C? " << (int) a_c_sametype << endl;  // 1

    return 0;
}
```

上例定义了两个不同的类型White和Black，以及其类型的变量a和b。使用typeid返回类型的type_info，并分别应用name打印类型的名字（5这样的前缀是g++这类编译器输出的名字，其它编译器可能会打印其它的名字，这个标准并没有明确规定），应用hash_code进行类型的比较。在RTTI的支持下，程序员可以在一定程序上了解程序中类型的信息（这里注意一下，相比于4.1.2节中的**is_same**模板函数的成员函数value在**编译时得到信息**，**hash_code**是**运行时得到的信息**）。

除了typeid外，RTTI还包括了C++中的dynamic_cast等特性。不过，由于RTTI会带来一些运行时的开销，所以一些编译器会让用户选择性地关闭该特性（如XL C/C++编译器的-qnortti，GCC的选项-fno-rttion，或者微软编译器选项/GR-）。而且很多时间，运行时才确定出类型对于程序员来说为时过晚，程序员更多需要的是在编译时期确定出类型（标准库中非常常见）。而通常程序员是要使用这样的类型而不是识别该类型，因此RTTI无法满足需求。

C++的发展中，类型推导是随着模板和泛型编程的广泛使用而引入的。在非泛型的编程中，不用对类型进行推导，因为任何表达式中变量的类型都是明确的，而运算、函数调用等也都有明确的返回类型。而在泛型的编程中，类型成了未知数。

与auto类似地，decltype也能进行类型推导，不过两者的使用方式却有一定的区别。可以看如下代码：

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

int main() {
    int i;
    decltype(i) j = 0;
    cout << typeid(j).name() << endl;  // 打印出“i”，g++表示int

    float a;
    double b;
    decltype(a + b) c;
    cout << typeid(c).name() << endl;  // 打印出“d”，g++表示double

    return 0;
}
```

上述代码，看到变量j的类型由decltype进行声明，表示j的类型跟i相同（或者准确地说，跟i这个表达式返回的类型相同）。而c的类型跟（a+b）这个表达式返回的类型相同。而由于a+b加法表达式返回的类型为double（a会被扩展为double类型与b相加），所以c的类型被decltype推导为double。

从这个例子可以看到，decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。而与auto相同的是，作为一个类型指示符，decltype可以将获得的类型来定义另外一个变量。与auto相同，decltype类型推导也是在编译时进行的。

### 4.3.2 decltype的应用

在C++11中，使用decltype推导类型是非常常见的事情。比较典型的就是decltype与typedef/using的合用。在C++11的头文件中，常能看到以下代码：

```c++
using size_t = decltype(sizeof(0));
using ptrdiff_t = decltype((int*) 0 - (int*) 0);
using nullptr_t = decltype(nullptr);
```

这里size_t以及ptrdiff_t还有nullptr_t（参见7.1节）都是由decltype推导出的类型。在一些常量、基本类型、运算符、操作符等都已经被定义好的情况下，类型可以按照规则被推导出。而使用using，就可以为这些类型取名。这就颠覆了之前类型拓展需要将扩展类型“映射”到基本类型的常规做法。

除此之外，decltype在某些场景下，可以极大地增加代码的可读性。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> vec = {1, 5, 7};
    typedef decltype(vec.begin()) vectype;  // vectype推导为: vector<int>::iterator

    for (vectype i = vec.begin(); i != vec.end(); ++i) {
        cout << *i << " ";
    }

    cout << "\n";
    
    for (decltype(vec)::iterator i = vec.begin(); i != vec.end(); ++i) {
        cout << *i << " ";
    }
    return 0;
}
```

上述代码，定义了vector的iterator的类型。这个类型还可以在main函数中重用。当我们遇到一些具有复杂类型的变量或表达式时，就可以利用decltype和typedef/using的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。此外可以看到decltype(vec)::iterator这样的灵活用法，这看起来跟auto非常类似，也类似于是一种“占位符”式的替代。

在C++中，有时会遇到匿名的类型，而拥有了decltype这个利器之后，重用匿名类型也非难事。如下：

```c++
enum class K { K1, K2, K3 } anon_e;
//enum class { K1, K2, K3 } anon_e;  // 匿名的强类型枚举，但是本地编译错误：error: unnamed scoped enum is not allowed

union {
    decltype(anon_e) key;
    char* name;
} anon_u;  // 匿名的union联合体

struct {
    int d;
    decltype(anon_u) id;
} anon_s[100];  // 匿名的struct数组

int main() {
    decltype(anon_s) as;
    as[0].id.key = decltype(anon_e)::K1;  // 引用匿名强类型枚举中的值
    return 0;
}
```

这里使用了3种不同的匿名类型：匿名的强类型枚举anon_e（请参见5.1节）、匿名的联合体anon_u，以及匿名的结构体数组anon_s。可以看到，只要通过匿名类型的变量名anon_e、anon_u，以及anon_s，decltype可以推导其类型并且进行重用。在一些C代码中，匿名的结构体和联合体并不少见。不过匿名一般都有匿名理由，一般程序员都不希望匿名后的类型被重用。这里的decltype只是提供了一种语法上的可能。

有了decltype，可以适当扩大模板泛型的能力。以代码4-9为例，稍微改变一下函数模板的接口，该模板将适用于更大的范围。如下改进的例子：

代码清单4-20

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
void Sum(T1& t1, T2& t2, decltype(t1 + t2)& s) {
    s = t1 + t2;
}

int main() {
    int a = 3;
    long b = 5;
    float c = 1.0f, d = 2.3f;

    long e;
    float f;
    Sum(a, b, e);  // s的类型被推导为long
    Sum(c, d, f);  // s的类型被推导为float
    return 0;
}
```

相比于代码清单4-19，上述的Sum函数模板增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值。这样，Sum的适用范围增加，因为其返回的类型不再是单一的double类型，而是根据t1+t2推导而来的类型。不过这里还是有一定的限制，可以看到返回值的类型必须一开始就被指定，程序员必须清楚Sum运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。解决的方法是结合decltype与auto关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。在4.4节会看到具体的细节（事实上，**decltype一个最大的用途就是用在追踪返回类型的函数**中）。

有些情况下，模板库的使用人员可能认为一些自然而简单的数据结构，比如数组，也是可以被模板类所包括的。不过，如果t1和t2是两个数组，t1+t2不会是合法的表达式。为了避免不必要的误解，模板库的开发人员应该为这些特殊的情况提供其它的版本，如下：

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
void Sum(T1& t1, T2& t2, decltype(t1 + t2)& s) {
    s = t1 + t2;
}

void Sum(int a[], int b[], int c[]) {
    // 数组版本
}

int main() {
    int a[5], b[5], c[5];
    Sum(a, b, c);  // 选择数组版本

    int d, e, f;
    Sum(d, e, f);  // 选择模板的实例化版本
    return 0;
}
```

上述代码，由于声明了数组版本的Sum，编译器在编译Sum(a, b, c)的时候，会优先选择数组版本，而编译Sum(d, e, f)的时候，依然会对应到模板的实例化版本。这就能够保证Sum模板函数最大的可用性（不过这里的数组版本似乎做不了什么事情，因为数组长度丢失了）。

在实例化一些模板的时候，decltype也可以起到一些作用，如下：

```c++
#include <iostream>
#include <map>

using namespace std;

int myhash(char*);

int main() {
    map<char*, decltype(hash)> dict_key;  // 无法通过编译
    map<char*, decltype(myhash(nullptr))> dict_key1;  // 原书这里hash编译有二义性，与std::hash冲突

    return 0;
}
```

上述代码实例化了标准库中map函数。该map是为了存储字符串以及其对应哈希值的，因此可以通过decltype(hash(nullptr))来确定哈希值的类型。这样的定义非常直观，但是必须要注意的是，decltype只能接受表达式做参数，像函数名做参数的表达式decltype(hash)是无法通过编译的。

decltype在C++11的标准库中也有一些应用，一些标准库的实现也会依赖于decltype的类型推导。一个典型的例子是基于decltype的模板类result_of，其作用是推导函数的返回类型。如下：

```c++
#include <iostream>

using namespace std;

typedef double (* func)();

int main() {
    result_of<func()>::type f;
    cout << typeid(f).name() << endl;  // 由result_of推导函数func()其结果类型为d: doulbe
    return 0;
}
```

这里f的类型最终被推导为double，而result_of并没有真正调用func()这个函数，这是因为底层的实现使用了decltype。result_of的一个可能的实现方式如下：

```c++
template<class>
struct result_of;

template<class F, class... ArgTypes>
struct result_of<F(ArgTypes...)>
{
    typedef decltype(std::declval<F>()(std::declval<ArgTypes>()...))
}
```

请读者忽略declval（实际是STL中的一种语法技巧），这里标准库将decltype作用于函数调用上（使用了变长函数模板），并将函数调用表达式返回的类型typedef为一个名为type的类型。这样，代码中的result_of\<func()\>::type就会被decltype推导为double。

### 4.3.3 decltype推导四规则 P159

大多数时候，decltype的使用看起来非常平易近人，但有时也会落入一些令人疑惑的陷阱。如下：

```c++
#include <iostream>

using namespace std;

int main() {
    int i;
    decltype(i) a;  // a: int
    decltype((i)) b;  // b: int&，无法通过编译
    return 0;
}
```

上例，单单多了一对圆括号，decltype所推导出出的类型居然生成了变化。事实上，C++11中decltype推导返回类型的规则比我们想象的复杂。具体地，用decltype(e)来获取类型时，编译器将依序判断以下四规则：

1. 如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实例的类型。此外，如果e是一个被重载的函数，则会导致编译时错误。
2. 否则，假设e的类型是T，如果e是一个将亡值（xvalue），那么decltype(e)为T&&。
3. 否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&。
4. 否则，假设e的类型是T，则decltype(e)为T。

这里需要解释一下标记符表达式（id-expression）。基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier）。而单个标记符对应的表达式就是标记符表达式。如程序员定义了：

`int arr[4];`

那么arr是一个标记符表达式，而arr[3]+0、arr[3]等，则都不是标记符表达式。

再回到代码上述代码，并结合decltype类型推导的规则，可以知道，decltype(i) a;使用了规则1——因为i是一个标记符表达式，所以类型被推导为int。而decltype((i)) b;中，由于(i)不是一个标记符表达式，但却是一个左值表达式（可以有具名的地址），因此，按照decltype推导规则3，其类型应该是一个int的引用。

上面的规则看起来非常复杂，事实上，实际应用中，decltype类型推导规则中最容易引起迷惑的只有规则1和规则3。通过下例再加深一下理解：

```c++
#include <iostream>

using namespace std;

int main() {
    int i = 4;
    int arr[5] = {0};
    int* ptr = arr;

    struct S { double d; } s;

    void Overloaded(int);
    void Overloaded(char);  // 重载的函数

    int&& RvalRef();

    const bool Func(int);

    // 规则1：单个标记符表达式以及访问类成员，推导为本类型
    decltype(arr) var1;  // int[5]，标记符表达式
    decltype(ptr) var2;  // int*，标记符表达式
    decltype(s.d) var3;  // double，成员访问表达式
//    decltype(Overloaded) var5;  // 无法通过编译，是个重载的函数，如果不是重载函数，则可以通过编译

    // 规则2：将亡值，推导为类型的右值引用
    decltype(RvalRef()) var6 = 1;  // int&&

    // 规则3：左值，推导为类型的引用
    decltype(true ? i : i) var7 = i;  // int&，三元运算符，这里返回一个i的左值
    decltype((i)) var8 = i;  // int&，带圆括号的左值
    decltype(++i) var9 = i;  // int&，++i返回i的左值
    decltype(arr[3]) var10 = i;  // int&，[]操作返回左值
    decltype(*ptr) var11 = i;  // int&，*操作返回左值
    decltype("lval") var12 = "lval";  // const char(&) [9]，字符串字面常量为左值

    // 规则4：以上都不是，推导为本类型
    decltype(1) var13;  // int，除字符串外字面常量为右值
    decltype(i++) var14;  // int，i++返回右值
    decltype((Func(1))) var15;  // const bool，圆括号可以忽略

    return 0;
}
```

上例将四种规则的例子都列了出来。

规则1不但适用于基本数据类型，还适用于指针、数组、结构体，甚至函数类型的推导，事实上，规则1在decltype类型推导中运用的最为广泛。

规则2比较简单，基本上符合程序员的想象。

规则3其实是一个左值规则。decltype的参数不是标志符表达式或者类成员访问表达式，且参数都为左值，推导出的类型均为左值引用。

规则4则是适用于以上都不适用者。这里看到了++i和i++在左右值上的区别，以及字符串字面常量lval、非字符串字面常量1在左右值间的区别。

本地试验1：

```c++
#include <iostream>

using namespace std;

void Overloaded1(int i) {
    cout << "Overloaded1: " << i << endl;
}

void Overloaded2(int i) {
    cout << "Overloaded2: " << i << endl;
}

int main() {
 	// 函数指针类型推导，如果Overload1和Overload2函数签名不同，则编译报错
    decltype(Overloaded1)* fun = Overloaded2;
    fun(10);  // Overloaded2: 10
    return 0;
}
```

本地试验2：

```c++
#include <iostream>

using namespace std;

// std::move的作用就是把左值变为右值引用
int&& RvalRef() {
    return std::move(10);
}

int main() {
    int&& i = RvalRef();
    cout << i << endl;
    return 0;
}
```

看过这些规则，读者可能觉得过于复杂，事实上，如同之前提到的，引起麻烦的只是规则3带来的左值引用的推导。一个简单的能够让编译器提示的方法是，如果使用decltype定义变量，那么先声明这个变量，再在其它语句里对其进行初始化。这样，由于左值引用总是需要初始化的，编译器会报错提示。另外一些时候，C++11标准库中添加的模板类is_lvalue_reference，可以帮忙进行一些推导结果的识别。如下例：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

int i = 4;
int arr[5] = {0};
int* ptr = arr;

int&& RvalRef();

int main() {
    cout << is_rvalue_reference<decltype(RvalRef())>::value << endl;  // 1

    cout << is_lvalue_reference<decltype(true ? i : i)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype((i))>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(++i)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(arr[3])>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(*ptr)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype("lval")>::value << endl;  // 1

    cout << is_lvalue_reference<decltype(i++)>::value << endl;  // 0
    cout << is_rvalue_reference<decltype(i++)>::value << endl;  // 0
    return 0;
}
```

上述代码，使用了模板类is_lvalue_reference的成员value来查看decltype的效果（1表示是左值引用，0则反之）。如所见，凡是符合规则3的，都会被推导为左值引用。如果程序员在程序的书写中不是非常确定decltype是否将类型推导为左值引用，也可以通过这样的小实验来辅助确定。这里还使用了模板函数is_rvalue_reference，同样，也可以通过它来确定decltype是否推导出了右值 引用。

### 4.3.4 cv限制符的继承与冗余的符号 P162

与auto类型推导时不能“带走”cv限制符不同，decltype是能够“带走”表达式的cv限制符的。不过，如果对象的定义中有const或volatile限制，使用decltype进行推导时，其成员不会继承const或volatile限制。如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

const int ic = 0;
volatile int iv;

struct S { int i; };

const S a = {0};

volatile S b;
volatile S* p = &b;

int main() {
    cout << is_const<decltype(ic)>::value << endl;  // 1
    cout << is_volatile<decltype(iv)>::value << endl;  // 1

    cout << is_const<decltype(a)>::value << endl;  // 1
    cout << is_volatile<decltype(b)>::value << endl;  // 1

    cout << is_const<decltype(a.i)>::value << endl;  // 0，成员不是const
    cout << is_volatile<decltype(p->i)>::value << endl;  // 0，成员不是volatile

    return 0;
}
```

上例，使用了C++库提供的is_const和is_volatile来查看类型是否是常量或者易失的。可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的decltype类型推导结果中。

而与auto相同的，decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。如cv限制符以及引用符号&，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略，如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

int i = 1;
int& j = i;
int* p = &i;
const int k = 1;

int main() {
    decltype(i)& var1 = i;
    decltype(j)& var2 = i;  // 冗余的&，被忽略
    cout << is_lvalue_reference<decltype(var1)>::value << endl;  // 1，是左值引用

    cout << is_rvalue_reference<decltype(var2)>::value << endl;  // 0，不是右值引用
    cout << is_lvalue_reference<decltype(var2)>::value << endl;  // 1，是左值引用

//    decltype(p)* var3 = &i;  // 无法通过编译，error: cannot convert 'int*' to 'int**' in initialization
    decltype(p)* var3 = &p;  // var3的类型是int**

    auto* v3 = p;  // v3的类型是int*
    v3 = &i;

    const decltype(k) var4 = 1;  // 冗余的const，被忽略
    return 0;
}
```

上述代码中，定义了类型为decltype(i)&的变量var1，以及类型为decltype(j)&的变量var2。由于i的类型为int，所以这里的引用符号保证var1成为一个int&引用类型。而由于j本来就是一个int&的引用类型，所以decltype之后的&成为了冗余符号，会被编译器忽略，因此j的类型依然是int&。（**注意这里不是int&&类型**）

这城特别要注意的是decltype(p)\*的情况。可以看到，在定义var3变量的时候，由于p的类型是int\*，因此var3被定义为了int\*\*类型。这跟auto声明中，\*也可以是冗余的不同。在decltype后的\*号，并不会被编译器忽略。

此外也可以看到，var4中const可以被冗余的声明，但会被编译器忽略，同样的情况也会生成在volatile限制符上。

decltype算得上是C++11中类型推导使用方式上最灵活的一种。虽然看起来它的推导规则比较复杂，有的时候跟auto推导结果还略有不同，但大多数时候，发现使用decltype还是自然而亲切的。一些细则的区别，读者可以在使用时遇到问题再返回查验。而下面的跟踪返回类型的函数定义，则将整合auto、decltype，将C++11中的泛型能力提升到更高的水平。

## 4.4 追踪返回类型 P164

### 4.4.1 追踪返回类型的引用 P165

追踪返回类型配置auto和decltype会真正释放C++11中泛型编程的能力。

在C++98中，如果一个函数模板的返回类型依赖于实际的入口参数类型，那么该返回类型在模板实例化之前可能都无法确实，这样的话在定义该函数模板时就会遇到麻烦。回想一下代码清单4-9的例子，由于Sum模板函数的两个参数t1和t2的类型没有确定，所以只能简单地设置结果s为double类型并返回。这就限制了Sum的使用范围（大概只能用于数值不算太大的算术运算）。而在代码清单4-20中，改进了Sum模板函数，通过增加decltype(t1+t2)的参数的方式来返回泛型的值。这样做虽然扩大了Sum的适用范围，但改变了Sum的使用方式，在一些情况下，也是不可以接受的。而且由于程序员必须预先知道返回的类型，其使用上的灵活性也就打了一些折扣。

最为直观的解决方式就是对返回类型进行类型推导。而最为直观的书写方式如下所示：

```c++
template<typename T1, typename T2>
decltype(t1 + t2) Sum(T1& t1, T2& t2) {
    return t1 + t2;
}
```

这样的写法虽然看似不错，不过对编译器来说有些小问题。编译器在推导decltype(t1 + t2)时，表达式中的t1和t2都未声明（虽然它们近在咫尺，编译器却只会从左往右地读入符号）。按照C/C++编译器的规则，变更使用前必须已经声明，因此，为了解决这个问题，C++11引入新语法——追踪返回类型，来声明和定义这样的函数：

```c++
template<typename T1, typename T2>
auto Sum(T1& t1, T2& t2) -> decltype(t1 + t2) {
    return t1 + t2;
}
```

如上，把函数的返回值移至参数声明之后，复合符合-> decltype(t1 + t2)被称为追踪返回类型。而原来函数返回值的位置由auto关键字占据。这样，可以让编译器来推导Sum函数模板的返回类型了。而auto占位符和-> return_type也就是构成追踪返回类型的两个基本元素。

### 4.4.2 使用追踪返回类型的函数

追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的兵团。在一般情况下，普通函数的声明方式会明显简单于最终返回类型。如：

`int func(char* a, int b);`

这样的书写会比下面的书写少上不少：

`auto func(char* a, int b) -> int;`

不过有时，追踪返回类型声明的函数也会带给大家一些意外，如下：

```c++
class OuterType {
    struct InnerType { int i; };

    InnerType GetInner();

    InnerType it;
};

// 跟踪返回类型，可以不写 OuterType::InnerType
auto OuterType::GetInner() -> InnerType {
    return it;
}

// 如果不使用追踪返回类型，返回类型必须指定作用域 OuterType::InnerType
//OuterType::InnerType OuterType::GetInner() {
//    return it;
//}
```

上述代码，可以看到使用追踪返回类型的时候，InnerType不必写明其作用域。这对于讨厌写很长作用域的程序员来说，也算得上一个好消息。

返回类型后置，使模板中的一些类型推导就成为了可能。可以看看如下使用追踪返回类型的例子：

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
auto Sum(const T1& t1, const T2& t2) -> decltype(t1 + t2) {
    return t1 + t2;
}

template<typename T1, typename T2>
auto Mul(const T1& t1, const T2& t2) -> decltype(t1 * t2) {
    return t1 * t2;
}

int main() {
    auto a = 3;
    auto b = 4L;
    auto pi = 3.14;

    auto c = Mul(Sum(a, b), pi);
    cout << c << endl;  // 21.98
    return 0;
}
```

上述代码，定义了两个模板函数Sum和Mul，它们的参数的类型和返回值都在实例化时决定。由于main函数中还使用了auto，整个例子中没有看到一个“具体”的类型声明。事实上，这段代码尤其是主函数，看起来有点像是一个动态类型语言的代码，而不像是一个有着严格静态类型的C++代码。这一切都要归功于类型推导帮忙下的泛型编程。程序员在编写代码时无需关心任何时段的类型选择，编译器会合理地进行推导，而简单程序的书写也由此得到了极大的简化。

 除了解决以上所描述的问题，追踪返回类型的另一个优势是简化函数的定义，提高代码的可读性。这种情况常见于函数指针中。如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

// 有的时候，你会发现这是面试题
int (* (* pf())())() {
    return nullptr;
}

// auto (*) () -> int (*) () 一个返回函数指针的函数（假设为a函数）
// auto pf1 () -> auto (*) () -> int (*) () 一个返回a函数的指针的函数
auto pf1() -> auto (*)() -> int (*)() {
    return nullptr;
}

int main() {
    cout << is_same<decltype(pf), decltype(pf1)>::value << endl;  // 1
    return 0;
}
```

 上述代码，定义了两个类型完全一样的函数pf和pf1。其返回的都是一个函数指针。而该函数指针又指向一个返回函数指针的函数。这一点通过is_same的成员value已经能够确定（参见4.1.1）。而仔细看一看函数类型的声明，可以发现老式的声明法可读性非常差。而追踪返回类型只需要依照从左向右（原文这里写从右向左）的方式，就可以将嵌套的声明解析出来。这大大提高了嵌套函数这类代码的可读性。

除此之外，追踪返回类型也被广泛地应用在转发函数中，如下：

```c++
#include <iostream>

using namespace std;

double foo(int a) {
    return (double) a + 0.1;
}

int foo(double b) {
    return (int) b;
}

template<class T>
auto Forward(T t) -> decltype(foo(t)) {
    return foo(t);
}

int main() {
    cout << Forward(2) << endl;  // 2.1
    cout << Forward(0.5) << endl;  // 0
    return 0;
}
```

上述代码，由于使用了追踪返回类型，可以实现参数和返回类型不同时的转发。

追踪返回类型还可以用在函数指针中，其声明方式与追踪返回类型的函数比起来，并没有太大的区别。如：

`auto (*fp)() -> int;`

和

`int (*fp)();`

的函数指针声明是等价的。同样的情况也适用于函数引用，如：

`auto (&fr)() -> int;`

和

`int (&fr)();`

的声明也是等价的。

如下验证代码：

```c++
#include <iostream>

using namespace std;

int foo() {
    return 11;
}

int main() {
    auto (* fp)() -> int = foo;
    cout << fp() << "\n";  // 11

    auto (& fr)() -> int = *foo;
    cout << fr() << "\n";  // 11

    return 0;
}
```

除了以上所描述的函数模板、普通函数、函数指针、函数引用以外，追踪返回类型还可以用在结构或类的成员函数、类模板的成员函数里，其方法大同小异。另外，没有返回值的函数也可以被声明为追踪返回类型，只需要将返回类型声明为void即可。

## 4.5 基于范围的for循环



















