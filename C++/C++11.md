# 深入理解C++11：C++11新特性解析与应用

## 第2章 保证稳定性和兼容性

### 2.1 保持与C99兼容

#### 2.1.1 预定义宏

使用预定义宏，可以查验机器环境对C标准和C库的支持情况：

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Standand Clib: " << __STDC_HOSTED__ << endl; // Standand Clib: 1
    //cout << "Standand C: " << __STDC__ << endl;
    //cout << "Standand C: " << __STDC_VERSION__ << endl;
    //cout << "Standand C: " << __STDC_ISO_10646__ << endl;
    return 0;
}
```

#### 2.1.2 \_\_func\_\_预定义标识符

\_\_func\_\_预定义标识符功能，其基本功能就是返回所在函数的名字。

```c++
#include <iostream>
using namespace std;

const char* hello() {
    return __func__;
}

const char* world() {
    return __func__;
}

int main()
{
    cout << hello() << ", " << world() << endl; // hello, world
    return 0;
}
```

按标准定义，编译器会隐匿地在函数定义之后定义\_\_func\_\_标识符。

其实际定义等同于：

```c++
const char* hello() {
 	static const char* __func__ = "hello";
    return __func__;
}
```

\_\_func\_\_预定义标识符允许其使用在类或者结构体中，如下：

```c++
#include <iostream>
using namespace std;

struct TestStruct {
    TestStruct(): name(__func__) {}

    std::string show() {
        return __func__;
    }

    const std::string name;
};

int main()
{
    TestStruct ts;
    cout << ts.name << endl;  // TestStruct
    cout << ts.show() << endl;  // show

    return 0;
}
```

不过将\_\_func\_\_作为函数参数的默认值是不允许的，如下：

```c++
void FuncFail (string func_name = __func__) {}; // 无法通过编译
```

这是由于参数声明时，\_\_func\_\_还未被定义。

### 2.5 静态断言

#### 2.5.2 静态断言与static_assert

断言assert宏只在程序运行时才能起作用。有的时候，希望在编译时能做一些断言，如下程序，编译时不会报错：

又如：

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}
```

对于上例，可以利用“除0”会导致编译器报错这个特性来实现静态断言：

```c++
#include <iostream>
#include <cassert>
using namespace std;

#define assert_static(e) \
    do { \
        enum {assert_static__ = 1 / (e) }; \
    } while (0)

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert_static(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译失败，报错：
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,1): warning C4804:  “/”: 在操作中使用类型“bool”不安全
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         ]
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): message :  未定义的算术运算导致失败
```

C++11标准中，引入了static_assert断言来解决这个问题，接收两个参数，一个断言表达式，通常需要返回一个bool值；一个则是警告信息，通常也就是一段字符串。上例替换为static_assert：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译报错
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         ]
1>已完成在项目“TestProject.vcxproj”中生成目标“ClCompile”的操作 - 失败。
1>
1>已完成生成项目“TestProject.vcxproj”的操作 - 失败。
1>
1>生成失败。
1>
1>D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>    0 个警告
1>    1 个错误
```

static_assert是编译期的断言，其使用范围不像assert一样受到限制。通过情况下，**static_assert可以用于任何名字空间**，如下：

```c++
#include <iostream>
using namespace std;

static_assert(sizeof(int) == 8, "This 64-bit machine should follow this!"); // 应该为4

int main() {
    return 0;
}
```

必须注意的是，static_assert的断言表达式的结果必须是编译时期可以计算的表达式，即必须是常量表达式。如果使用了变量，则会导致错误，如下：

```c++
#include <iostream>
using namespace std;

int positive(const int n) {
    static_assert(n > 0, "value must > 0");
    return n;
}

int main() {
    positive(-1);
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,21): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  因读取超过生命周期的变量而失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  请参见“n”的用法
```

上例使用了参数变量n（虽然是个const参数），因而static_assert无法通过编译。如果需要的只是运行时的检查，还是应该使用assert宏。

### 2.6 noexcept修饰符和noexcept操作符 P51

`void excpt_func() throw(int, double) { //... }`

动态异常声明throw(int, double)，声明指出了expt_func可能抛出的异常的类型。该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。

noexcept形如其名，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行。

语法上讲，noexcept修饰符有两种形式：

`void excpt_func() noexcept;`

另一种可以接受一个常量表达式作为参数，如下：

`void excpt_func() noexcept (常量表达式);`

不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    try {
        Throw();
    }
    catch (...) {
        cout << "Found throw." << endl;
    }

    try {
        NoBlockThrow();
    }
    catch (...) {
        cout << "Throw is not blocked." << endl;
    }

    try {
        BlockThrow();
    }
    catch (...) {
        cout << "Found throw 1." << endl;
    }
    return 0;
}

// 输出：
Found throw.
Throw is not blocked.
// 出现中止提示框
```

noexcept作为一个操作符时，通常可以用于模板，如：

```c++
template<class T>
void fun() noexcept(nocept(T())) {}
```

这里fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式时，其返回值为false，反之为true。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() throw(int) {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    cout << noexcept(Throw()) << endl; // 0
    cout << noexcept(NoBlockThrow()) << endl; // 0
    cout << noexcept(BlockThrow()) << endl; // 1
    return 0;
}
```

同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的，当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持为默认值。如下：

```c++
#include <iostream>
using namespace std;

struct A {
    ~A() {
        throw 1;
    }
};

struct B {
    ~B() noexcept(false) {
        throw 2;
    }
};

struct C {
    B b;
};

void funA() {
    A a;
}

void funB() {
    B b;
}

void funC() {
    C c;
}

int main() {
    try {
        funB();
    }
    catch (...) {
        cout << "caught funB." << endl; // caught funB.
    }

    try {
        funC();
    }
    catch (...) {
        cout << "caught funC." << endl; // caught funC.
    }

    try {
        funA();
    }
    catch (...) {
        cout << "caught funA." << endl; // terminate called after throwing an instance of 'int'
    }
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): warning C4297:  “A::~A”: 假定函数不引发异常，但确实发生了
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): message :  析构函数或释放器具有一个(可能是隐含的)非引发异常规范
```

无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。

### 2.7 快速初始化成员变量

C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或花括号{}进行就地的非静态成员变量初始化。如：

```c++
#include <iostream>
using namespace std;

struct Init {
    int a = 1;
    double b = 1.2;
    double c{1.2};
};

int main() {
    Init init;
    return 0;
}
```

C++对于初始化表达式的改动发现，花括号式的集合（列表）初始化已经成为C++11中初始化声明的一种通用形式，而其效果类似于C++98中使用圆括号()对自定义变量的表达式列表初始化。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如下：

```c++
struct C {
    C(int i): c(i) {}
    int c;
};

struct Init {
    int a = 1;
    string b{"abc"}; // string b("abc") 无法通过编译
    C c{1}; // C c(1) 无法通过编译
};
```

程序员可以为同一成员变量既声明就地的列表初始化，又在初始化列表中进行初始化，只不过初始化列表问题看起来“后作用于”非静态成员。也就是说，初始化列表的效果总是优先于就地初始化的。

### 2.8 非静态成员的sizeof

```c++
#include <iostream>
using namespace std;

struct People {
    int hand;
    static People* all;
};


int main() {
    People p;
    cout << sizeof(p.hand) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::all) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::hand) << endl; // C++98中错误，C++11中通过
    return 0;
}
```

在C++11中，对非静态成员变量使用sizeof操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行sizeof操作。因此，如果只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员大小，通常会采用以下的代码：

`sizeof(((People*)0) -> hand);`

强制转换0为一个People类的指针，继而通过指针的解引用获得其成员变量，并用sizeof求得该成员变量的大小。在C++11中，无需这样的技巧，因为sizeof可以作用的表达式包括了类成员表达式：

`sizeof(People::hand)`

### 2.9 扩展的friend语法

C++11对friend关键字进行了一些改进：

```c++
class Poly;
typedef Poly P;

class LiLei {
    friend class Poly; // C++98通过，C++11通过
};

class Jim {
    friend Poly; // C++98失败，C++11通过
};

class HanMeiMei {
    friend P; // C++98失败，C++11通过
};
```

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。甚至还使用了Poly的别名P，这同样可行。

可以为类模板声明友元了。这在C++98中无法做到，如下：

```c++
#include <iostream>
using namespace std;

class P;

template<typename T>
class People {
    friend T;
};


int main() {
    People<P> pp; // 类型P在这里是People类型的友元
    People<int> pi; // 对于int类型模板参数，友元声明被忽略
    return 0;
}
```

有个使用friend友元来访问私有成员进行测试的使用样例，在P63。

### 2.10 final/override控制 P63

### 2.11 模板函数的默认模板参数 P67

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，如下：

```c++
void DefParm(int m = 3) {} // C++98编译通过，C++11编译通过

template<typename T = int>
class DefClass {};  // C++98编译通过，C++11编译通过

template<typename T = int>
void DefTempParm() {} // C++98编译失败，C++11编译通过
```

不过在语法上，类模板在为多个默认模板参数声明指定默认值的时候，必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说不是必须的，如下：

```c++
template<typename T1, typename T2 = int>
class DefClass1 {};

template<typename T1 = int, typename T2>
class DefClass2 {};  // 无法编译通过

template<typename T, int i = 0>
class DefClass3 {};

template<int i = 0, typename T>
class DefClass4 {};  // 无法编译通过

template<typename T1 = int, typename T2>
void DefFunc1(T1 a, T2 b);  // 可以编译通过

template<int i = 0, typename T>
void DefFunc2(T a);  // 可以编译通过
```

函数模板的参数推导规则也不复杂。如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。如下：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = 0) {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')
    f(1); // f<int, double>(1, 0)，使用了默认模板参数double
    //f(); // 错误：T无法被推导出来
    f<int>(); // f<int, double>(0, 0)，使用了默认模板参数double
    f<int, char>(); // f<int, char>(0, 0)
    return 0;
}

// 输出：
t type: int, u type: char
t value: 1, u value: c
t type: int, u type: double
t value: 1, u value: 0
t type: int, u type: double
t value: 0, u value: 0
t type: int, u type: char
t value: 0, u value:
```

这个例子可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。

还有一点，模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的，这点在使用中应当注意。

另外，将u = 0改成u = "abc"，有点问题没明白：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = "abc") {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')，output: t type: int, u type: char<Enter>t value: 1, u value: c
    f(1); // f<int, double>(1, 0)，将"abc"转成double，output: output: t type: int, u type: double<Enter>t value: 1, u value: 1.16581e-307
    f<int>(); // 这里编译错误，“f”: 函数不接受 0 个参数，f<int>(1)可以编译通过
    cout << static_cast<double>("abc") << endl; //编译错误，说“static_cast”: 无法从“const char [4]”转换为“double”，所以不知道f(1)里"abc"是如何转成double
    return 0;
}
```

### 2.12 外部模板

#### 2.12.2 显式的实例化与外部模板的声明 P71

```c++
// test.h
template<typename T> void fun(T) {}

// test1.cpp
#include "test.h"
template void fun<int>(int); // 显示地实例化
void test1() { fun(3); }

// test2.cpp
#include "test.h"
extern template void fun<int>(int); // 外部模板的声明
void test1() { fun(3); }
```

这样一来，在test2.o中不会再生成fun\<int\>(int)的实例代码。因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让test1.cpp和test2.cpp共享一份代码位置即可。而同时，编译器也不用每次都产生一份fun\<int\>(int)的代码，所以可以减少编译时间。这里也可以把外部模板声明放在test.h头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。这一点跟使用外部变量声明是完全一致的。

在使用外部模板的时候，还需要注意：**如果外部模板声明出现在某个编译单元中，那么与之对应的显示实例化必须出现在另一个编译单元中或者同一个编译单元的后续代码中**；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。

实际上，C++11中“模板的显式实例化定义、外部模板声明和使用”好比“全局变量的定义、外部声明和使用”方式的再次应用。不过相比于外部变量声明，不使用外部模板声明并不会导致任何问题。

只有在项目比较大的情况下，我们才建议用户进行这样的优化。总的来说，就是在既不忽视模板实例产生的编译及链接开销的同时，也不要过分担心模板展开的开销。

### 2.13 局部和匿名类型作模板实参 P73

C++98中，标准对模板实参的类型还有一些限制。具体讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。如下：

```c++
template<typename T>
class X {};

template<typename T>
void TempFun(T t) {};

struct A {} a;

struct {
    int i;
} b; // b是匿名类型变量

typedef struct {
    int i;
} B; // B是匿名类型

void Fun() {
    struct C {} c; // C是局部类型，c是局部变量
    X<A> x1; // C++98通过，C++11通过
    X<B> x2; // C++98错误，C++11通过
    X<C> x3; // C++98错误，C++11通过
    TempFun(a); // C++98通过，C++11通过
    TempFun(b); // C++98错误，C++11通过
    TempFun(c); // C++98错误，C++11通过
}
```

值得指出的是，虽然匿名类型可以被模板参数所接受了，但并不意味着以下写法可以被接受，如下：

```c++
template<typename T> struct MyTemplate {};

int main() {
    MyTemplate<struct { int a; }> t; // 无法通过编译，匿名类型的声明不能在模板实参位置
    return 0;
}
```

即使是匿名类型的声明，也需要独立的表达式语句。要使用匿名结构作为模板参数，则需要对匿名结构体作别名。此外在第4章还会看到使用C++11独有的类型推导decltype，也可以完成相应的功能。

## 第3章 通用为本，专用为末

### 3.1 继承构造函数

基类的非虚函数无法再被派生类使用了， 这条规则对于构造函数也不例外，如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。如下：

```c++
struct A { A(int i) {} };
struct B: A { B(int i): A(i) {} };
```

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成，如下：

```c++
#include <iostream>

using namespace std;

struct Base {
    void f(double i) {
        cout << "Base: " << i << endl;
    }
};

struct Derived : Base {
    using Base::f;

    void f(int i) {
        cout << "Derived: " << i << endl;
    }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5

    Derived d;
    d.f(4.5);  // Base: 4.5
    d.f(10);  // Derived: 10
    return 0;
}
```

这里使用了using声明，声明派生类Derived也使用基类版本的函数f。这样，派生类中实际就拥有了两个f函数的版本。

在C++中，这个想法被扩展到了构造函数中。子类可以通过使用using声明来声明继承基类的构造函数。如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A::A;
    B(const string& s): A(10) {}  // B类如果有自己的构造函数，则还是需要调用基类A构造函数
    virtual void ExtraInterface() {}
};


int main() {
    B b(10);  // 如果没有using A::A;，则编译报错
    return 0;
}
```

通过using A::A的声明，把基类中的构造函数悉数继承到派生类B中。更为精巧的是，C++11标准继承构造函数被设计为跟派生类中的各种默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会被化基类成员变量，对于派生类中的成员变量，则无能为力。不过配置2.7节中的类成员的初始化表达式，为派生类成员变量设定一个默认值还是没有问题的。

如下代码同时使用了继承构造函数和成员变量初始化两个C++11的特性。这样就可以解决一些继承构造函数无法初始化的派生类成员问题。如果这样仍然无法满足需求的话，程序员只能自动来实现一个构造函数，以达到基类和成员变量都能够初始化的目的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char *c) {}
};

struct B : A {
    using A::A;
    int d{0};
};


int main() {
    B b(356);  // b.d被初始化为0
    return 0;
}
```

有时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，**参数的默认值是不会被继承**的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int a = 3, double b = 2.4) : a_(a), b_(b) {}

    int a_;
    double b_;
};

struct B : A {
    using A::A;
};


int main() {
    B b1;
    cout << "b1.a_: " << b1.a_ << endl;
    cout << "b1.b_: " << b1.b_ << endl;

    B b2(10);
    cout << "b2.a_: " << b2.a_ << endl;
    cout << "b2.b_: " << b2.b_ << endl;

    return 0;
}
//输出：
b1.a_: 3
b1.b_: 2.4
b2.a_: 10
b2.b_: 2.4
```

参数默认值会导致多个构造函数版本的产生，因此程序员在使用有参数默认值的构造函数的基类时，必须小心。

有时，有继承构造函数“冲突”的情况。通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有时，也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。

A和B的构造函数会导致C中重复定义相同类型的继承构造函数。这种，情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐匿生成相应的继承构造函数来解决冲突，如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct B {
    B(int i) {
        cout << "B.i: " << i << endl;
    }
};

struct C : A, B {
    using A::A;
    using B::B;

    C(int i): A(i), B(i){  // 书中写为C(int) {}，感觉不对，因为A和B都没有无参数的构造函数
        cout << "C.i: " << i << endl;
    }
};


int main() {
    C c(10);
    return 0;
}
```

如果基类的构造函数被声明为私有成员函数（本地试验保护成员函数也不行），或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

```c++
#include <iostream>

using namespace std;

struct A {
protected:
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct C : A {
    using A::A;
    //C(int i) : A(10) {}  // 这里如果注释掉则编译报错
};


int main() {
    C c(10);
    return 0;
}
```

### 3.2 委派构造函数 P81

在C++11中，可以使用委派构造函数来达到期望的效果。委派构造函数是在构造函数的初始化列表位置进行构造、委派的。如下：

```c++
#include <iostream>

using namespace std;

class Info {
public:
    // 目标构造函数（target constructor）
    Info() {
        cout << "Info() type: " << type << endl;
        InitRest();
    }

    // 委派构造函数（delegating constructor）
    Info(int i) : Info() {  // 这里type是1
        type = i;  //这里经过赋值后，type是i，所以type还是多赋值了一次
    }

    // 委派构造函数（delegating constructor）
    Info(char c) : Info() {
        name = c;
    }

private:
    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type{1};
    char name{'a'};
};

int main() {
    Info info(10);
    return 0;
}
// 输出
Info() type: 1
Info::InitRest()
```

在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。

委派构造函数只能在函数体中为type、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。在C++中，构造函数不能同时“委派”和使用初始化列表，所以**如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。

这样，上述代码的初始化就不那么令人满意了，因为初始化列表的初始化方式总是等于构造函数完成的（实际在编译完成时就已经决定了），这会可能使程序员犯错（见下分析）。可以稍微改造下目标构造函数，使得委派构造函数依然可以在初始化列表中初始化所有成员，如下：

```c++
class Info {
public:
    Info() : Info(1, 'a') {}

    Info(int i) : Info(i, 'a') {}

    Info(char c) : Info(1, c) {}

private:
    Info(int i, char c) : type(i), name(c) {
        InitRest();
    }

    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type;
    char name;
};
```

如上定义了一个私有的目标构造函数Info(int, char)，接受两个参数，并将参数在初始化列表中初始化。

在使用委派构造函数的时候，建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。如在InitReset()函数中做了：

`type += 1;`

则第1份代码中Info f(3)构造出来的对象其f.type=3，第2份代码中Info f(3)构造出来的对象其f.type=4，从代码编写角度看，第2份代码中Info的行为会更加正确。这是由于在C++11中，目标构造函数的执行总是等于委派构造函数而造成的。因此避免目标构造函数和委托构造函数体中初始化同样的成员通常是必要的，否则可能发生第1份代码的错误。

构造函数比较多时，可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样，就可能在委派构造函数中形成链状的委派构造关系。有一点必须程序，就是不能形成委托环（delegation cycle），如：

```c++
struct Rule2 {
    int i, c;
    Rule(): Rule2(2) {}
    Rule(int i): Rule2('c') {}
    Rule(char c): Rule2(2) {}
};
```

Rule2定义中，Rule2()、Rule2(int)和Rule2(char)都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。

委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，如代码清单：

```c++
#include <iostream>
#include <list>
#include <vector>
#include <deque>

using namespace std;

class TDConstructed {
public:
    TDConstructed(vector<short>& v) : TDConstructed(v.begin(), v.end()) {}

    TDConstructed(deque<int>& d) : TDConstructed(d.begin(), d.end()) {}

private:
    template<class T>
    TDConstructed(T first, T last): l(first, last) {}

private:
    list<int> l;
};

int main() {
    vector<short> v = {4, 5, 6};
    TDConstructed tdConstructed1(v);

    deque<int> d = {1, 2, 3};
    TDConstructed tdConstructed2(d);
    return 0;
}
```

如上代码定义了一个构造函数模板。通过两个委派构造函数的委托，构造函数模板会被实例化。T会被推导为vector\<short\>::iterator和deque\<int\>::iterator两种类型。这比罗列不同类型的构造函数方便了很多。可以心，委托构造使得构造函数的泛型编程也成为了一种可能。

如果在委派构造函数中使用try，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。如下：

```c++
#include <iostream>

using namespace std;

class DCExcept {
public:
    DCExcept(double d)
    try : DCExcept(1, d) {
        cout << "Run the body." << endl;
    }
    catch (...) {
        cout << "caught exception." << endl;
    }

private:
    DCExcept(int i, double d) {
        cout << "going to throw!" << endl;
        throw 0;
    }

private:
    int type;
    double data;

};

int main() {
    DCExcept a(1.2);
    return 0;
}
// 输出：
going to throw!
terminate called after throwing an instance of 'int'
caught exception.
```

### 3.3 右值引用：移动语义和完美转发

#### 3.3.2 移动语义

在C++11中，“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。可以理解为“移为已用”。我们可以看看如下代码是如何实现这种移动语义的：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

    HasPtrMem(HasPtrMem&& h) : d(h.d) {
        h.d = nullptr;
        cout << "Move construct: " << ++n_mvtr << endl;
    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1  // HasPtrMem h;
Resource from GetTemp: 0x6a1480
Move construct: 1  // move(h);
Destruct: 1  // h析构
Move construct: 2  // move(GetTemp());
Destruct: 2  // GetTemp返回的HasPtrMem临时变量析构
Resource from main: 0x6a1480
Destruct: 3  // a析构
```

本地试验，如果不加两个move，则只有一个构造函数调用一个析构函数调用，应该是编译器优化，直接将h赋给a，如下：

```c++
HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return h;
}

int main() {
    HasPtrMem a = GetTemp();
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1
Resource from GetTemp: 0xe81480
Resource from main: 0xe81480
Destruct: 1
```

另外，本地试验，如果不提供移动构造函数，只提供拷贝构造函数，在使用move时，会调用拷贝构造函数，如下：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

//    HasPtrMem(HasPtrMem&& h) : d(h.d) {
//        h.d = nullptr;
//        cout << "Move construct: " << ++n_mvtr << endl;
//    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出:
Construct: 1
Resource from GetTemp: 0xf01480
Copy construct: 1
Destruct: 1
Copy construct: 2
Destruct: 2
Resource from main: 0xf01480
Destruct: 3
```





为什么费力地添加移动构造函数，完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差。不过从使用的方便性来讲效果不好。如果函数返回临时值的话，可以在单条语句里完成很多计算，比如可以很自动地写出如下语句：

`Calculate(GetTemp(), SomeOther(Maybe(), Useful(Values, 2)));`

------

本地验证使用move来移动构造map：

```c++
int main() {
    map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
    map<string, int> nameValueMap2 = move(nameValueMap1);  // move之后，map1内已经没有对象了

    cout << "map1: \n";
    for_each(nameValueMap1.begin(), nameValueMap1.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });

    cout << "map2: \n";
    for_each(nameValueMap2.begin(), nameValueMap2.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });
    return 0;
}
// 输出：
map1:
map2:
a, 10
b, 20
```

如果不使用move，则调用的map的拷贝构造函数，如下：

```c++
map<string, int> nameValueMap2 = nameValueMap1;
// 输出：
map1:
a, 10
b, 20
map2:
a, 10
b, 20
```

#### 3.3.3 左值、右值与右值引用

在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。如：

`a = b + c`
这个赋值表达式中，a就是一个左值，而b+c则是一个右值。这种识别左值、右值的方法在C++中依然有效。不过C++中还有一个被广泛认同的说法，就是可以取地址的、有名字的就是左值。反之，不能取地址的、没有名字的就是右值。

这些差别方法通常都非常有效。在C++11中，右值是由两个概念构成的，一个是将亡值（xvalue, eXpiring Value），另一个则是纯右值（prvalue, Pure Rvalue）。

其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。

而将亡值则是C++11新增的跟右值引用相关的表达式，这样的表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

在C++11程序中，所有的值必属于左值、将亡值、纯右值三者之一。

在C++11中，右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。通常情况下，我们只能是从右值表达式获得其引用。比如：

`T&& a = ReturnRvalue();`

这个表达式，假设ReturnRvalue返回一个右值，我们就声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”（lvalue reference）。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

在上面的例子，ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了（通常我们也称其具有表达式生命期），而通过右值引用的声明，该右值又“重获新生”，其生命期将与右值引用类型变量a的生命期一样。只要a还“活着”，该右值临时量将会一直“存活下去”。

所以相比于以下语句的声明方式：

`T b = ReturnRvalue()`

刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为a是右值引用，直接绑定了ReturnRvalue()返回的临时量，而b只是由临时值构造而成的，而临时量在表达式结束会析构因而就会多一次析构和构造的开销。

不过能够声明**右值引用a的前提是ReturnRvalue返回的是一个右值**。通常情况下，右值引用是不能够绑定到任何的左值的。

右值引用&&只能绑定在右值上，所以如下在左值nameValueMap1进行&&右值引用绑定编译失败：

```c++
map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
map<string, int>&& nameValueMap2 = nameValueMap1;
```

相对地，在C++98标准中就已经出现的左值引用是否可以绑定到右值（由右值进行初始化）呢？如：

```c++
T& e = ReturnRvalue();
const T& f = ReturnRvalue();
```

答案是：e的初始化会导致编译时错误，而f则不会。

原因是，常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。而在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过**相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的**。相对的，非常量左值只能接受非常量左值对其进行初始化。

在C++98通过左值引用来绑定一个右值的情况并不少见，比如：

`const bool& judgement = true;`

就是一个使用常量左值引用来绑定右值的例子。不过与如下声明相比看起来似乎差别不大：

`const bool judgement = true;`

从语法上讲，前者直接使用了右值并为其“续命”，而后者的右值在表达式结束后就销毁了。

事实上，即使在C++98中，也常可以使用常量左值引用来减少临时对象的开销，如：

```c++
void show(const string& s) {} // 使用常量左值引用来接临时变量

show("abc");
```

而在C++11中，同样的，也可以右值引用为参数声明如下函数：

`void AcceptRvalueRef(Copyable&& ) {}`

也同样可以减少临时变量拷贝的开销。进一步地，还可以在AcceptRvalueRef中修改该临时值（这时临时值由于被右值引用参数所引用，已经获得了函数时间的生命期）。不过修改一个临时值的意义通常不大，除非像3.3.2节一样使用移动语义。

就本例而言，如果这样实现函数：

```c++
void AcceptRvalueRef(Copyable&& s) {
    Copyable news = std::move(s);
}
```

这里std::move的作用是强制一个左值（s）成为右值（s）。该函数就是使用右值来初始化Copyable变量news。使用移动语义的前提是Copyable还需要添加一个以右值引用为参数的移动构造函数，如：

`Copyable(Copyable&& o) { /*实现移动语义*/ }`

这样，如果Copyable类的临时变量（即ReturnRvalue返回的临时值）中包含一些大块内存的指针，news就可以如同代码清单3-19一样将临时值中的内存“窃”为已用，从而从这个以右值引用参数的AccepRvalueRef函数中获得最大的收益。事实上，**右值引用的由来从来就跟移动语义紧紧相关。这是右值存在的一个最大的价值（另外一个价值是用于转发）**。

如果不声明移动构造函数，而只声明一个常量左值的构造函数会生成什么？如同刚才提到的，常量左值是个“万能”的引用类型，无论左值还是右值，常量还是非常量，一概能够绑定。那么如果Copyable没有移动构造函数，下列一语句：

`Copyable news = std::move(s);`

将调用以常量左值为参数的拷贝构造函数。这是一种非常安全的设计——**移动不成，至少还可以执行拷贝**。因此，通常情况下，程序员会为声明了移动构造函数的类声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，可以使用拷贝构造。

为了语义的完整，C++11中还存在着常量右值引用，如通过如下代码声明一个常量右值引用：

`const T&& crvalueref = ReturnRvalue();`

但是，一来右值引用主要就是为了移动语义，而移动语义需要右值是可以被修改的，那么常量右值引用在移动语义中就没有用武之处；二来如果要引用右值且让右值不可以更改，常量左值引用往往就足够了。因此在现在的情况下，我们还没有看到常量右值引用有何用处。表3-1：

![](pictures\C++11中引用类型及其可以引用的值类型.png)

有时候，可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用（这在模板中比较常见）。标准库在\<type_traits\>头文件中提供了3个模板类：is_rvalue_reference、is_lvalue_reference、is_reference，可供我们进行判断，如：

```c++
HasPtrMem&& a = GetTemp();
cout << is_rvalue_reference<decltype(a)>::value << "\n";  // 1
cout << is_rvalue_reference<string&&>::value << "\n";  // 1
cout << is_rvalue_reference<map<int, int>&&>::value << "\n";  // 1
```

通过模板类的成员value就可以打印出string&&是否是一个右值引用了。配置第4章中的类型推导操作符decltype，甚至还可以对变量的类型进行判断。

说明：右值引用对象已经是一个左值了，可以使用&获取地址：

```c++
HasPtrMem&& a = GetTemp();
HasPtrMem* p = &a;
```

#### 3.3.4 std::move：强制转化为右值 P99

std::move并不能移动任何东西，唯一的功能是将一个左值强制转化为右值引用，继承可以通过右值引用使用该值，用于移动语义。从实现上讲，std::move基本等同于一个类型转换：

`static_cast<&&>(lvalue);`

被转化的左值，其生命期并没有随着左值值的转化而改变，所以被std::move转化的左值变量lvalue不会被立即析构。

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

class Moveable {
public:
    Moveable() : i(new int(3)) {}

    ~Moveable() { delete i; }

    Moveable(Moveable&& m) : i(m.i) {
        m.i = nullptr;
    }

    int* i;
};

int main() {
    Moveable a;
    Moveable c(move(a));  // 会调用移动构造函数，这里move(a)将左值a变成一个右值引用，所以才会调用移动构造函数Moveable(Moveable&& m)
    cout << *a.i << endl;  // 运行时错误
    return 0;
}
```

这里的a本来是一个左值变量，通过std::move将其转换为右值。这样一来，a.i就被c的移动构造函数设置为指针空值。由于a的生命期实际要到main函数结束才结束，所以对表达式*a.i进行计算就会运行错误。

这里如果不使用move(a)，则使用c(a)，则编译报错：

```c++
Moveable a;
Moveable c(a);  // 编译报错，因为显示声明了移动构造函数，所以拷贝构造函数如果不显示声明，则编译器不会生成拷贝构造函数
Moveable d;  // 编译报错，显示声明了移动构造函数，则编译器不会生成拷贝赋值函数
d = a;
```

事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用std::move转换拥有形如堆内存、文件句柄等资源的成员为右值，这样，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的拷贝构造函数版本也会轻松地实现拷贝构造，因此也不会引用大的问题。

如下写法：

`std::string s = std::move("");`

可以正常编译运行，实际move入参类型为右值引用&&，所以空字符串""先会构造成临时变量std::string("")，然后以右值引用传入std::move函数，之后再将该临时变量std::string("")移动构造为std::string s。

#### 3.3.5 移动语义的一些其他问题

移动语义一定是要修改临时变量的值，那么这样声明移动构造函数：

`Moveable(const Moveable&&)`

或者这样声明：

`const Moveable ReturnVal();`

都会使得临时变量常量化，成为一个常量右值，那么临时变量的引用也就无法修改，从而导致无法实现移动语义。因此在实现移动语义一定要注意排除不必要的const关键字。

默认情况下，编译器会为程序隐式地生成一个（隐式表示如果不使用则不生成）移动构造函数。

不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数（本地试验声明了析构函数不会影响默认构造函数的生成）中的一个或者多个，编译器都不会再为程序员生成默认版本。**默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作**。这对实现移动语义来说是不够的。通常情况下，**如果需要移动语义，程序员必须自定义移动构造函数**。对一些简单的、不包含任何资源的类型来说，实现移动语义与否都无关紧要，因为对这样的类型而言，移动就是拷贝，拷贝就是移动。

同样的，声明了移动构造函数、拷贝赋值函数、移动赋值函数和构造函数中的一个或者多个，编译器也不再会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/拷贝赋值和移动构造/移动赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。

```c++
String(const String &other);  // 拷贝构造函数 
String& operator=(const String& other);  // 拷贝赋值函数

//C++ 11的新函数 
String(String &&other);  // 移动构造函数
String& operator=(String&& other);  // 移动赋值函数
```

其实，只现实一种语义在类的编写中也是非常常见的。如只有拷贝语义的类型——在C++11之前我们见过大多数的类型的构造都是只使用拷贝语义的。而只有移动语义的类型则非常有趣，因为只有移动语义表明该类型的变量所拥有的资源只能被移动，而不能被拷贝。那么这样的资源必须是唯一的，因此，只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针、文件流等，都可以视为“资源型”的类型。如标准库中的仅可移动的模板类：unique_ptr。一些编译器，如2011，现在也把ifstream这样的类型实现为仅可移动的。

```c++
unique_ptr<int> p1 = make_unique<int>(3);
unique_ptr<int> p2 = move(p1);  // unique_ptr<int> p2 = p1编译报错，无拷贝构造
```

在标准库的头文件\<type_traits\>里，可以通过一些辅助的模板类来判断一个类型是否可以移动的。如is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible，使用方法仍然是使用其成员value。如：

```c++
cout << is_move_constructible<unique_ptr<int>>::value << "\n";  // 1
cout << is_copy_constructible<unique_ptr<int>>::value << "\n";  // 0
```

而有了移动语义，还有一个比较典型的应用是可以实现高性能的转换（swap）函数。看下面这段swap模板函数代码：

```c++
#include <iostream>
#include <memory>

using namespace std;

template<class T>
void mySwap(T& a, T& b) {
    T tmp(move(a));
    a = move(b);
    b = move(tmp);
}

int main() {
    unique_ptr<int> p1 = make_unique<int>(3);
    unique_ptr<int> p2 = make_unique<int>(5);
    cout << "Before swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    mySwap(p1, p2);
    cout << "After swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    return 0;
}
// 输出：
Before swap, p1: 3, p2: 5
After swap, p1: 5, p2: 3
```

如果T移动，那么移动构造和移动赋值将会被用于这个转换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行转换。这就跟普通的转换语句是相同的。在移动语义的支持下，仅仅通过一个通用的模板，就可能更高效地完成转换，这对于泛型编程来说，无疑是具有积极意义的。

另外一个关于移动构造的话题是异常。对于移动构造函数来说，抛出异常是件危险的事。因为可能移动语义还没完成，一个异常抛出来，这就会导致一些指针成为悬挂指针。因此应该尽量编写不抛出异常的移动构造函数，通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用ternimate程序终止运行。而标准库中，还可以用一个std::move_if_noexcept的模板函数替代move函数。该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义。如下：

```c++
#include <iostream>

using namespace std;

struct MayThrow {
    MayThrow() {}

    MayThrow(const MayThrow&) {
        cout << "Maythrow copy constructor." << endl;
    }

    MayThrow(const MayThrow&&) {
        cout << "Maythrow move constructor." << endl;
    }
};

struct NoThrow {
    NoThrow() {}

    NoThrow(const NoThrow&) noexcept {
        cout << "NoThrow copy constructor." << endl;
    }

    NoThrow(const NoThrow&&) noexcept {
        cout << "NoThrow move constructor." << endl;
    }
};

int main() {
    MayThrow m;
    NoThrow n;

    MayThrow mt = move_if_noexcept(m);  // Maythrow copy constructor.
    NoThrow nt = move_if_noexcept(n);  // NoThrow move constructor.

    return 0;
}
```

move_if_noexcept是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用noexcept进行描述，否则就会损失更多的性能。

编译器中被称为RVO/NRVO的优化（RVO，Return Value Optimization，返回值优化，或者NRVO，Named Return Value Optimization）。在本节中大量的代码都使用了-fno-elide-constructors选项在g++/clang++中关闭这个优化，这样可以在代码中较为容易地利用函数返回的临时量右值。

但若在编译的时候不使用该选项的话，会发现很多构造和移动都被省略。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从ReturnValue函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了：

```c++
A ReturnRvalue() {
    A a();
    return a;
}

A b = ReturnRvalue();
```

b变量实际就使用了ReturnRvalue函数中a 的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量“霸占”了a变量。这是编译器中一个效果非常好的优化。不过RVO/RNVO并不是对任何情况都有效。有些情况下，一些构造是无法省略的。还有一些情况，即使RVO/NRVO完成了，也不能达到最好的效果。但结论是明显的，移动语义可以解决编译器无法解决的优化问题，因而总是有用的。

关于RVO/RNVO可以参见如下博客：

<https://blog.csdn.net/songchuwang1868/article/details/83622039>

#### 3.3.6 完美转发 P104

C++是通过引用一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。

在C++11以前，形如下列语句：

```c++
typedef const int T;
typedef T& TR;
TR& v = 1;  // 该声明在C++98中会导致编译错误
```

其中`TR& v = 1`这样的表达式会被编译器认为是不合法的表达式，而在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式，如下表3-2所示：

![](\pictures\C++11中的引用折叠规则.png)

这个规则不难记忆，因为一旦定义中出现了左值引用，引用折叠问题优先将其折叠为左值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为X&类型，而转发函数的实参是类型X的一个右值引用的话，那么模板的参数被推导为X&&类型。结合以上的引用折叠规则，就能确定出参数的实际类型。进一步，可以把转发函数写成如下形式：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(static_cast<T&&>(t));
}
```

注意一下，不仅在参数部分使用了T&&这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。如我们调用转发函数时传入了一个X类型的左值引用，可以想象，转发函数将被实例化为如下形式：

```c++
void IamForwarding(X& && t) {
    IrunCodeActually(static_cast<X& &&>(t));
}
```

引用折叠规则，就是：

```c++
void IamForwarding(X& t) {
    IrunCodeActually(static_cast<X&>(t));
}
```

这样，左值传递就毫无问题了。实际使用的时候，IrunCodeActually如果接受左值引用的话，就可以直接调用转发函数。这里调用前的static_cast没有什么作用。事实上，这里的static_cast是留给传递右值用的。

如果调用转发函数时传入了一个X类型的右值引用的话，转发函数将被实例化为：

```c++
void IamForwording(X&& && t) {
    IrunCodeActually(static_cast<X&& &&>(t));
}
```

应用上引用折叠规则，就是：

```c++
void IamForwarding(X&& t) {
    IrunCodeActually(static_cast<X&&>(t));
}
```

这里看到了static_cast的重要性。对于一个右值而言，当它使用右值引用表达式引用的时候，该右值引用却是个左值，那么想在函数调用中继续传递右值，就需要使用std::move来进行左右值的转换。而std::move通常就是一个static_cast。不过在C++11中，用于完美转发的函数却不再叫作move，而是另外一个名字：forward。所以可以把转发函数写成这样：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(forward(t));
}
```

move和forward在实际实现上差别并不大。不过标准库这么设计，也许是为了让每个名字对应于不同的用途，以应对未来可能的扩展（虽然现在使用move可能也能通过完美转发函数的编译，但这并不是推荐的做法）。

来看个完美转发的例子，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(int&& m) { cout << "rvalue ref" << endl; }

void RunCode(int& m) { cout << "lvalue ref" << endl; }

void RunCode(const int&& m) { cout << "const rvalue ref" << endl; }

void RunCode(const int& m) { cout << "const lvalue ref" << endl; }

template<typename T>
void PerfectForward(T&& t) {
    RunCode(forward<T>(t));
}

int main() {
    int a;
    int b;
    const int c = 1;
    const int d = 0;

    PerfectForward(a);  // lvalue ref 。a是一个左值，而左值无法转为int&&，所以这里类型左值引用int& &&， PerfectForward<int&>(a);
    PerfectForward(move(b));  // rvalue ref
    PerfectForward(c);  // const lvalue ref
    PerfectForward(move(d));  // const rvalue ref
    return 0;
}
```

完美转发的一个作用就是做包装函数，这是一个很方便的功能。对上述代码清单的转发函数稍作修改，就可以用很少的代码记录单参数函数的参数传递况，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(double&& m) {}

void RunHome(double&& h) {}

void RunComp(double&& c) {}


template<typename T, typename U>
void PerfectForward(T&& t, U& func) {
    cout << t << "\tforwarded..." << endl;
    func(forward<T>(t));
}

int main() {
    PerfectForward(1.5, RunComp);  // 1.5	forwarded...
    PerfectForward(8, RunCode);  // 8	forwarded...
    PerfectForward(1.0, RunHome);  // 1	forwarded...
    return 0;
}
```

在C++11标准库中可以看到大量完美转发的实际应用，一些很小巧好用的函数，如make_pair、make_unique等在C++都通过完美转发实现了。这样减少了一些函数版本的重复（const和非const版本的重复），并能够充分利用移动语义。无论从运行性能的提高还是从代码编写的简化上，完美转发都堪称完美。

博客：C++11完美转发介绍 <http://ju.outofmemory.cn/entry/330864>

### 3.4 显式转换操作符

C++中，隐式类型转换的“自动性”可以让程序员免于层层构造类型。但是也会有不易发现的错误：

```c++
#include <iostream>

using namespace std;

struct Rational1 {
    Rational1(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

struct Rational2 {
    explicit Rational2(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

void Display1(Rational1 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

void Display2(Rational2 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

int main() {
    Rational1 r1_1 = 11;  // Rational1(11/1)
    Rational1 r1_2(12);  // Rational1(21/1)

//    Rational2 r2_1 = 21;  // 无法通过编译
    Rational2 r2_2(22);  // Rational2(22/1)

    Display1(1);  // Rational1(1/1) Numerator: 1 Denominator: 1
//    Display2(2);  // 无法通过编译
    Display2(Rational2(2)); // Rational2(2/1) Numerator: 2 Denominator: 1
    return 0;
}
```

使用了explicit这个关键字保证对象的显式构造在一些情况下都是必须的。

不过同样的机制并没有出现在自定义的类型转换符上。这就允许了一个逆向的过程，从自定义类型转向一个已知类型。这样虽然出现问题的几率远小于从已知类型构造自定义类型，不过有的时候，确实应该阻止会产生歧义的隐式转换。如下：

```c++
#include <iostream>

using namespace std;

template<typename T>
class Ptr {
public:
    Ptr(T* p) : p_(p) {}

    operator bool() const {
        return p_ != 0;
    }

private:
    T* p_;
};

int main() {
    int a;
    Ptr<int> p(&a);

    if (p) {  // 自动转换为bool型，没有问题
        cout << "valid pointer." << endl;  // valid pointer
    } else {
        cout << "invalid pointer." << endl;
    }

    Ptr<double> pd(0);
    cout << p + pd << endl;  // 调用bool类型转换函数后得到1+0=1

    double d;
    Ptr<double> pd1(&d);
    cout << p + pd1 << endl;  // 调用bool类型转换函数后得到1+1=2
    return 0;
}
```

定义了指针模型类型Ptr。为方便判断指针是否有效，为指针编写了自定义类型转换到bool类型的函数，可以通过if(p)这样的表达式来判断指针是否有效。不过这样的转换使得Ptr\<int\>和Ptr\<double\>两个指针加法运算获得了语法上的允许。不过明显地，我们无法看出其语义上的意义。

在C++11中，标准将explicit的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”。explicit关键字作用于类型转换操作符上，意味着只有在**直接构造目标类型**或**显式类型转换**的时候可以使用该类型。如下：

```c++
class ConvertTo {};

class Convertable {
public:
    // 自定义类型转换，转换为ConvertTo类型
    explicit operator ConvertTo() const { return ConvertTo(); }
};

void Func(ConvertTo ct) {}

void test() {
    Convertable c;
    ConvertTo ct(c);  // 直接初始化，通过，表明把c显示转换为ConvertTo类型
//    ConvertTo ct2 = c;  // 拷贝构造初始化，编译失败，如果去掉explicit则可以编译通过
    ConvertTo ct3 = static_cast<ConvertTo>(c);  // 强制转化，通过
//    Func(c);  // 拷贝构造初始化，编译失败
}
```

上述代码中，定义了两个类型ConvertTo和Convertable，Convertable定义了一个显式转换到ConvertTo类型的类型转换符。那么对于test函数中ConvertTo类型的ct变量而言，由于其直接初始化构造于Convertable变量c，所以可以编译通过。而做强制类型转换的ct3同样通过了编译。而ct2由于从c中拷贝构造，因而不能通过编译。使用函数Func的时候，传入Convertable的变量c也会导致参数的拷贝构造，也不能通过编译。

如果把explicit加到Ptr::operator bool() const方法上，则if(p)可以通过编译，因为可以通过p直接构造出bool类型的变量。而p+pd这样的语句就无法通过编译，这是由于全局的operator+并不接受bool类型变量为参数，而Ptr类也不能直接构造出适用于operator+的int类型的变量造成的（不过可以尝试一下使用p&&pd这样的表达式，是能够通过编译的）。这样一来，程序的行为将更加良好。

```c++
int a;
Ptr<int> p(&a);

Ptr<double> pd(0);
cout << (p && pd) << endl;  // 0, true && false

double d;
Ptr<double> pd1(&d);
cout << (p && pd1) << endl;  // 1, true && true
```

可以看到，所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。通常通过赋值表达式和函数参数进行的转换有可能是程序员的一时疏忽，而并非本意。那么使用了显式类型转换，这样的问题就会暴露出来，也是需要显式转换操作符的一个重要原因。

### 3.5 列表初始化 P111

#### 3.5.1 初始化列表

 有一种初始化形式就是使用花括号的集合（列表）初始化。事实上，在C++11中，集合（列表）的初始化已经成为C++语言的一个基本功能，在C++11中，这种初始化的方法被称为“初始化列表”（initializer list）。如下：

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main() {
    int a[] = {1, 3, 5};  // C++98通过，C++11通过
    int b[]{1, 3, 5};  // C++98失败，C++11通过
    vector<int> c{1, 3, 5};  // C++98失败，C++11通过
    map<int, float> d = {{1, 1.0f}, {2, 2.0f}, {5, 3.2f}};  // C++98失败，C++11通过
    return 0;
}
```

变量b、c、d在C++98中均无法通过编译，在C++11中，由于列表初始化的存在而可以通过编译。这里，列表初始化可以在“{}”花括号之前使用等号，其效果与不带使用等号的初始化相同。

这样，自动变量和全局变量的初始化在C++11中被丰富了。可以使用以下几种形式完成初始化的工作：

- 等号“=”加上赋值表达式（assignment-expression），比如int a = 3 + 4。
- 等号“=”加上花括号式的初始化列表，比如int a = {3 + 4}。
- 圆括号式的表达式列表（expression-list），比如int a(3 + 4)。
- 花括号式的初始化列表，比如int a{3 + 4}。

而后两种形式也可以用于获取堆内存new操作符中，如：

```c++
int* i = new int(3);
double* d = new double{1.2f};
```

这在C++11中也是合法的表达式。

初始化列表不是专属于内置类型、数组，以及标准模板库中容器的功能。

在C++11中，标准总是倾向于使用更通用的方式来支持新的特性。标准模板库中窗口对初始化列表的支持源自\<initializer_list\>这个头文件中initialize_list类模板的支持。程序员只要`#include<initializer_list>`头文件，并且声明一个以initializer_list\<T\>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

enum Gender { boy, girl };

class People {
public:
    People(initializer_list<pair<string, Gender>> l) : data_(l) {}  // initializer_list的构造函数

private:
    vector<pair<string, Gender>> data_;
};


int main() {
    People ship2012 = {{"Garfield", boy}, {"HelloKitty", girl}};
    return 0;
}
```

同样，函数的参数列表也可以使用初始化列表，如下：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void Fun(initializer_list<int> iv) {
    for_each(iv.begin(), iv.end(), [](const auto& e) { cout << e << ", "; });
}

int main() {
    Fun({1, 2});  // 1, 2,
    Fun({});
    return 0;
}
```

上述代码定义了一个可以接受初始化列表的函数Fun。同理，类和结构体的成员函数也可以使用初始化列表，包括一些操作符的重载函数。在如下代码示例，利用了初始化列表重载了operator[]，并且重载了operator=以及使用辅助的数组。虽然例子比较复杂，但重载的效果还是能够让人感觉眼前一亮的：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>

using namespace std;

class Mydata {
public:
    Mydata& operator[](const initializer_list<int>& l) {  // 书中这里类型为initializer_list<int>
        for (auto i = l.begin(); i != l.end(); ++i) {  // auto类型为initializer_list<int>::iterator
            idx_.push_back(*i);
        }
        return *this;
    }

    Mydata& operator=(int v) {
        if (!idx_.empty()) {  // 如果调用过operator[]，则idx_中存入了修改的index列表
            for (auto i = idx_.begin(); i != idx_.end(); ++i) {
                d_.resize(max<int>(*i, d_.size()));
                d_[*i - 1] = v;
            }
            idx_.clear();
        } else {  // 如果没有调用过operator[]，则给d全部赋值
            d_.assign(d_.size(), v);
        }
        return *this;
    }

    void Print() {
        copy(d_.begin(), d_.end(), ostream_iterator<int>(cout, " "));
    }

private:
    vector<int> idx_;  // 辅助数据，用于记录index
    vector<int> d_;
};

int main() {
    Mydata d;
    d[{2, 3, 5}] = 7;  // 先调用operator[]，再调用operator=
    d[{1, 4, 5, 8}] = 4;
    d.Print();  // 4 7 7 4 4 0 0 4
    d = 10;  // 只调用operator=
    d.Print();  // 10 10 10 10 10 10 10 10
    return 0;
}
```

上述代码中，看到自定义类型Mydata拥有一个以前所有C++代码都不具备的功能，即可以在[]符号中使用列表，将设置数组中的部分为一个指定值。先把数组的第2、3、5位设为数值7，而后又将其1、4、5、8位设为数值4。最终得到数组的内容为“4 7 7 4 4 0 0 4”。当然，由于内置的数组不能重载operator[]，也就无法为其实现相应的功能。

初始化列表还可以用于函数返回的情况。返回一个初始化列表，通常会导致构造一个临时变量，如：

`vector<int> Func() { return {1, 3}; }`

当然，跟声明时采用列表初始化一样，列表初始化构造成什么类型是依据返回类型的，如：

`deque<int> Func2() { return {3, 5}; }`

上面的返回值就是deque\<int\>列表初始化构造函数而构造的。面跟普通的字面量相同，如果返回值是一个引用类型的话，则会返回一个临时变量的引用。如：

`const vector<int>& Func1() { return {3, 5}; }`

这里注意，必须要加const限制符。该规则与返回一个字面常量是一样的。

而本地试验，上述Func1函数可以编译过，但是有编译告警，运行错误，如下：

```c++
//const Mydata& getMydata1() {
//    Mydata d;
//    d[{2, 3, 5}] = 7;
//    return d;  // 编译告警，返回局部变量引用
//}
//
//const Mydata& getMydata2() {
//    return Mydata();  // 无论返回const Mydata&还是Mydata&&，都有编译告警，返回局部变量引用
//}

//const vector<int>& Func1() {  // 如果返回值是vector<int>&，编译错误：不能把非常量左值引用绑定在右值类型std::vector<int>
//    return {3, 5};  // 同样编译告警，返回局部变量引用，这样理解的话，应该是先用{3, 5}构造出来一个同样是局部变量的vector<int>，然后再return
//}

void test1(const vector<int>& ints) {
//    ints.push_back(10);  // 编译错误，常量左值引用无法修改
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

void test2(vector<int>&& ints) {
    ints.push_back(10);
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

int main() {
//    const Mydata& d1 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d1.Print();
//    const Mydata& d2 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d2.Print();
//    const vector<int>& ints = Func1();  // 运行错误，常量左值引用的是函数返回对象，而函数返回对象又是引用函数局部变量，该局部变量已经构造
//    cout << ints.size() << endl;
    test1({1, 2, 3});  // 1 2 3
    test2({1, 2, 3});  // 1 2 3 10
    return 0;
}
```

#### 3.5.2 防止类型收窄

使用列表初始化还有一个最大优势是可以防止类型收窄（narrowing）。类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。

如果变量a从类型A转化为类型B，其值在B中也是可以被表示的，且再转化回类型A能获得原有值的话，那么这种类型转换也不能叫作类型收窄。所以类型收窄也可以简单地理解为新类型无法表示原有类型数据的值的情况。

在C++11中，使用初始化列表进行初始化的数据编译器是会松本其是否发生类型收窄。如下：

```c++
const int x = 1024;
const int y = 10;

char a = x;  // 收窄，但可以通过编译
char* b = new char(1024);  // 收窄，但可以通过编译

char c = {x};  // 收窄，无法通过编译
char d = {y};  // 可以通过编译
unsigned char e{-1};  // 收窄，无法通过编译

float f{7};  // 可以通过编译
int g{2.0f};  // 收窄，无法通过编译
float* h = new float{1e48};  // 收窄，无法通过编译
float i = 1.2l;  // 可以通过编译，l是什么意思？
```

对于变量a和*b而言，由于其采用的是赋值表达符及圆括号的表达式初始化，所以虽然它们的数据类型明显收窄（char通常取值范围为-128到127），却不会引发编译失败（事实上，在我们的实验机上会得到编译器的警告）。而使用初始化列表的情况则不一样，对于变量c，由于其类型收窄，则会导致编译器报错。而对于变量d来说，其初始化使用了常量值10，而10是可以由char类型表示的，因此这里不会发生收窄，编译可以通过。

在C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。这也是列表初始化区别于其他初始化方式的地方。事实上，现在编译器大多数会在发生类型收窄的时候提示用户，因为类型收窄通常是代码可能出现问题的征兆。C++将列表初始化设定为可以防范类型收窄，也是为了加强类型使用的安全性。

总的来说，列表初始化改变了C++中对类型初始化的一些基本模式，将标准程序库跟语言拉得更近了。这样的做法有效地统一了内置类型和自定义类型的行为。也是C++11设计所遵循的一个思想，即通用为本，专用为末。

### 3.6 POD类型 P117

C++11将POD划分为两个基本概念的合集，即：平凡的（trivial）和标准布局的（standard layout）。

通常情况下，一个平凡的类或结构体应该符合以下定义：

1. 拥有的默认构造函数（trivial constructor）和析构函数（trivial destructor）
2. 拥有的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）
3. 拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）
4. 不能包含虚函数以及虚基类。

以上4点虽然看似复杂，不过在C++11中，可以通过一些辅助的类模板来帮我们进行以上属性的判断。

类模板is_trivial的成员value可以用于判断T的类型是否是一个平凡的类型。除了类和结构体外，is_trivial还可以对内置的标题类型数据（比如int、float都属性平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

```c++
#include <iostream>

using namespace std;

struct Trivial1 {};
struct Trivial2 {
public:
    int a;
private:
    int b;
};

struct Trivial3 {
    Trivial1 a;
    Trivial2 b;
};

struct Trivial4 {
    Trivial2 a[23];
};

struct Trivial5 {
    int x;
    static int y;
};

struct NonTrivial1 {
    NonTrivial1() : z(42) {}

    int z;
};

struct NonTrivial2 {
    NonTrivial2();

    int w;
};

NonTrivial2::NonTrivial2() = default;

struct NonTrivial3 {
    Trivial5 c;

    virtual void f();
};

int main() {
    cout << is_trivial<Trivial1>::value << endl;  // 1
    cout << is_trivial<Trivial2>::value << endl;  // 1
    cout << is_trivial<Trivial3>::value << endl;  // 1
    cout << is_trivial<Trivial4>::value << endl;  // 1
    cout << is_trivial<Trivial5>::value << endl;  // 1
    cout << is_trivial<NonTrivial1>::value << endl;  // 0
    cout << is_trivial<NonTrivial2>::value << endl;  // 0
    cout << is_trivial<NonTrivial3>::value << endl;  // 0
    return 0;
}
```

POD包含的另外一个概念是标准布局。标准布局的类或结构体应该符合以下定义：

1. 所有非静态成员有相同的访问权限（public, private, protected）。

   如下匿名结构体不是标准布局的：

   ```c++
   struct {
   public:
       int a;
   private:
       int b;
   };
   ```

   如果去掉private关键字的话，该匿名结构体就符合标准布局的定义了。

2. 在类或者结构体继承时，满足以下两种情况之一：

   - 派生类中有非静态成员，且只有一个仅包含静态成员的基类。

   - 基类有非静态成员，而派生类没有非静态成员。
   
   这样的类或者结构体，也是标准布局的。
   
3. 类中的第一个非静态成员的类型与其基类不同。

   这条规则非常特别，用于形如：

   ```c++
   struct A : B {
       B b;
   }
   ```

   这样的情况。这里的A类型不是一个标准布局的类型，因为第一个非静态成员变量b的类型跟A所继承的类型B相同。而形如：

   ```c++
   struct C : B {
       int a;
       B b;
   }
   ```

   则是一个标准布局的类型。
   
4. 没有虚函数和虚基类。

5. 没有非静态数据成员均符合标准布局类型，其基类也符合标准布局。这是一个递归的定义，没什么好特别解释的。

以上5点构成了标准布局的定义，最为重要的应该是前两条。

同样，在C++11中，可以使用模板类来帮忙判断类型是否是一个标准布局的类型。

通过is_standard_layout模板类的成员value(`is_standard_layout<T>::value`)，可以在代码中打印出类型的标准布局属性。如下：

```c++
#include <iostream>

using namespace std;

struct SLayout1 {};
struct SLayout2 {
private:
    int x;
    int y;
};

struct SLayout3 : SLayout1 {
    int x;
    int y;

    void f();
};

struct SLayout4 : SLayout1 {
    int x;
    SLayout1 y;
};

struct SLayout5 : SLayout1, SLayout3 {};  // warning: direct base 'SLayout1' inaccessible in 'SLayout5' due to ambiguity

struct SLayout6 { static int y; };

struct SLayout7 : SLayout6 { int x; };

// 违反3，第一个非静态成员类型与基类相同
struct NonSLayout1 : SLayout1 {
    SLayout1 x;
    int i;
};

// 违反2，基类和派生类同时有非静态成员
struct NonSLayout2 : SLayout2 { int z; };

// 违反5，基类不符合标准布局
struct NonSLayout3 : NonSLayout2 {};

// 违反1，非静态成员访问权限不同
struct NonSLayout4 {
public:
    int x;
private:
    int y;
};

int main() {
    cout << is_standard_layout<SLayout1>::value << endl;  // 1
    cout << is_standard_layout<SLayout2>::value << endl;  // 1
    cout << is_standard_layout<SLayout3>::value << endl;  // 1
    cout << is_standard_layout<SLayout4>::value << endl;  // 1
    cout << is_standard_layout<SLayout5>::value << endl;  // 1
    cout << is_standard_layout<SLayout6>::value << endl;  // 1
    cout << is_standard_layout<SLayout7>::value << endl;  // 1

    cout << is_standard_layout<NonSLayout1>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout2>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout3>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout4>::value << endl;   // 0
    return 0;
}
```

对于POD而言，在C++11中的定义就是平凡的和标准布局的两个方面。标准库中的\<type_traits\>头文件也为程序员提供了模板类。

可以使用std::is_pod\<T\>::value来判定一个类型是否是POD，如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

union U {};

// 违反平凡默认构造函数
union U1 { U1() {}};

enum E {};
typedef double* DA;

typedef void (* PF)(int, double);

int main() {
    cout << is_pod<U>::value << endl;  // 1
    cout << is_pod<U1>::value << endl;  // 0
    cout << is_pod<E>::value << endl;  // 1
    cout << is_pod<int>::value << endl;  // 1
    cout << is_pod<DA>::value << endl;  // 1
    cout << is_pod<PF>::value << endl;  // 1
    return 0;
}
```

如上代码，很多内置类型默认都是POD的。POD最为复杂的地方还是在类或者结构体的判断。使用的POD的好处，大概有如下3点：

1. 字节赋值，代码中可以安全地使用memset和memcpy对POD类型进行初始化和拷贝等操作。

2. 提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的。

3. 保证了静态初始化的安全有效。静态初始化在很多时间能够提高程序的性能，而POD类型的对象初始化往往更加简单（比如放入目标文件的.bss段，在初始化中直接被赋0）。

### 3.7 非受限联合体 P125

在C++98标准中，如果union拥有非POD类型数据成员，则编译失败，也不允许联合体拥有静态或引用类型的成员。

在新的C++11标准中，取消了联合体对于数据成员类型的限制。标准规定，任何非引用类型都可以成为联合体的数据成员，这样的联合体即所谓的非受限联合体（Unrestricted Union）。此外，联合体拥有静态成员（在非匿名联合体中）的限制，也在C++11新标准中被删除了。不过从实践中，发现C++11地规则不允许静态成员变量的存在（否则所有该类型的联合体将共享一个值）。而静态成员函数存在的唯一作用，大概就是为了返回一个常数，如下：

```c++
#include <iostream>

using namespace std;

union T { static long Get() { return 32; }};

int main() {
    cout << T::Get() << endl;
    return 0;
}
```

上述代码定义了一个有静态成员函数的联合体。不过这里的union T更像是一个作用域限制符，并没有太大的实用意义。

在C++11中，标准会默认删除一些非受限联合体的默认函数。比如，非受限联合体有一个非POD的成员，而该POD成员类型拥有非平凡的构造函数，那么非受限联合体成员的默认构造函数将被编译器删除。其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数待，也将遵从此规则。如下例：

```c++
#include <iostream>
#include <string>

using namespace std;

union T {
    string s;  // string有非平凡的构造函数
    int n;
};

int main() {
    T t;  // 构造失败，因为T的构造函数被删除了，error: use of deleted function 'T::T()'
    return 0;
}
```

上述代码中，联合体T拥有一个非POD的成员s。而string有非平凡的构造函数，因此T的构造函数被删除，其类型的变量t也就无法声明成功。解决这个问题的办法是，由程序员自己为非受限联合体定义构造函数。通常情况下，placement new会发挥很好作用，如下：

```c++
#include <iostream>
#include <string>

using namespace std;

union T {
    string s;
    int n;
public:
    // 自定义构造函数和析构函数
    T() { new(&s) string; }

    ~T() { s.~string(); }
};

int main() {
    T t;  // 构造析构成功
    return 0;
}
```

上述代码，定义了union T的构造和析构函数。构造时，采用placement new将s构造在其地址&s上。这里的placement new的唯一作用只是调用了一下string的构造函数。而在析构时，又调用了string的析构函数。必须注意的是，析构的时候union T也必须是一个string对象，否则可能导致析构的错误（或者让析构函数为空，至少不会造成运行时错误）。这样，变量 t的声明就可以通过编译了。

匿名非限联合体可以运行于类的声明中，这样的类也被称为“枚举式的类”（union-like class）。可以看看如下例：

```c++
#include <iostream>
#include <string>

using namespace std;

struct Student {
    Student(bool g, int a) : gender(g), age(a) {}

    bool gender;
    int age;
};

class Singer {
public:
    enum Type { STUDENT, NATIVE, FOREIGNER };

    // 每个构造函数只构造union中的一个成员变量
    Singer(bool g, int a) : s(g, a) { t = STUDENT; }

    Singer(int i) : id(i) { t = NATIVE; }

    Singer(const char* n, int s) {
        int size = (s > 9) ? 9 : s;
        memcpy(name, n, size);
        name[s] = '\0';
        t = FOREIGNER;
    }

    ~Singer() {}

private:
    Type t;
    union {  // 匿名的非受限联合体
        Student s;
        int id;
        char name[10];
    };
};

int main() {
    Singer(true, 13);
    Singer(310217);
    Singer("J Michael", 9);
    return 0;
}
```

如上代码，也把匿名非受限联合体成为类Singer的“变长成员”（variant member）。这样的变长成员给类的编写带来了更大的灵活性，这是C++98标准中无法达到的。

### 3.8 用户自定义字面量 P129

在C/C++程序中，程序员常常会使用结构体或类来创造新的类型，以满足实际的需求。不过，有时候自定义类型也会有些书写的麻烦，尤其是用户想声明一个自定义类型的“字面量”的时候。

```c++
#include <iostream>
#include <string>

using namespace std;

typedef unsigned char uint8;

struct RGBA {
    uint8 r;
    uint8 g;
    uint8 b;
    uint8 a;

    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = 0) : r(R), g(G), b(B), a(A) {
        cout << "RGBA with four parameters" << endl;
    }

//    RGBA(const initializer_list<uint8>& cols) {
//        cout << "RGBA with initializer list" << endl;
//    }
};

ostream& operator<<(ostream& out, RGBA& col) {
    return out << "r: " << (int) col.r
               << " g: " << (int) col.g
               << " b: " << (int) col.b
               << " a: " << (int) col.a;
}

void blend(RGBA& col1, RGBA& col2) {
    cout << "blend" << endl << col1 << col2 << endl;
}

int main() {
    RGBA col1(255, 240, 155);
    RGBA col2({15, 255, 10, 7});  // C++11风格的列表初始化，如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    blend(col1, col2);

    RGBA col3{15, 255, 10, 7};  // 如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    RGBA col4 = {15, 255, 10, 7};  // 如果有RGBA(const initializer_list<uint8>& cols) { 构造函数，则会由该构造函数初始化
    return 0;
}
// 输出
RGBA with four parameters
RGBA with four parameters
blend
r: 255 g: 240 b: 155 a: 0r: 15 g: 255 b: 10 a: 7
RGBA with four parameters
RGBA with four parameters
```

试了下函数的多入参改为列表方式，编译报错，说明只有类初始化可以使用列表风格初始化：

```c++
void hello(int i, int j) {
    cout << "i: " << i << ", j: " << j << endl;
}

int main() {
    hello(1, 2);
    hello({3, 4});  // 编译错误，error: cannot convert '<brace-enclosed initializer list>' to 'int'
    return 0;
}
```

上述代码在编写测试用例的时候，常会遇到需要声明较多值确定的RGBA变量。那么这样的声明变量—传值运算的方式是非常麻烦的。如果自定义类可以像内置类型一样向函数传递字面常量，比如向函数func传递字面常量func(2, 5.0f)，无疑这样的测试代码会简化很多。

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

typedef unsigned char uint8;

struct RGBA {
    uint8 r;
    uint8 g;
    uint8 b;
    uint8 a;

    RGBA(uint8 R, uint8 G, uint8 B, uint8 A = 0) : r(R), g(G), b(B), a(A) {}
};

RGBA operator "" _C(const char* col, size_t n) {  // 一个长度为n的字符串col
    const char* p = col;
    const char* end = col + n;
    const char* r = nullptr, * g = nullptr, * b = nullptr, * a = nullptr;

    for (; p != end; ++p) {
        if (*p == 'r') {
            r = p;
        } else if (*p == 'g') {
            g = p;
        } else if (*p == 'b') {
            b = p;
        } else if (*p == 'a') {
            a = p;
        }
    }

    if ((r == nullptr) || (g == nullptr) || (b == nullptr)) {
        throw;
    } else if (a == nullptr) {
        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1));
    } else {
        return RGBA(atoi(r + 1), atoi(g + 1), atoi(b + 1), atoi(a + 1));
    }
}

ostream& operator<<(ostream& out, RGBA& col) {
    return out << "r: " << (int) col.r
               << " g: " << (int) col.g
               << " b: " << (int) col.b
               << " a: " << (int) col.a;
}

void blend(RGBA&& col1, RGBA&& col2) {  // 入参为""_C函数返回的RGBA临时变量，这里要么用常量左值引用const RGBA&，要么用右值引用RGBA&&
    cout << "blend" << endl << col1 << col2 << endl;
}

int main() {
    blend("r255 g240 b155"_C, "r15 g255 b10 a7"_C);
    return 0;
}
// 输出
blend
r: 255 g: 240 b: 155 a: 0r: 15 g: 255 b: 10 a: 7
```

上述代码声明了一个字面量操作符（literal operator）函数：`RGBA operator ""_C(const char* col, size_t n)`函数。这个函数会解析以_C为后缀的字符串，并返回一个RGBA的临时变量。有了这样一个用户字面常量的定义，main函数中不再需要通过声明RGBA类型的声明变量—传值运算的方式来传递实际意义上的常量 。通过声明一个字符串以及一个\_C后缀，operator ""\_C函数会产生临时变量。blend函数就可以通过右值引用获得这些临时值并进行计算了。这样，完成了定义自定义类型的字面常量，main函数中的代码书写显得更加清晰。

除去字符串外，后缀声明也可以作用于数值，如用户可能使用60W、120W的表示方式来标识功率，用50kg来表示质量，用1200N来表示力等。如下：

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

struct Watt {
    unsigned int v;
};

Watt operator "" _w(unsigned long long v) {  // 如果不以_开始，如"" w，则会有编译告警：warning: literal operator suffixes not preceded by '_' are reserved for future standardization [-Wliteral-suffix]，不影响功能
    return {(unsigned int) v};  // 使用初始化列表直接构造Watt
}

// 如果注释掉上面的Watt operator "" _w(unsigned long long v)函数，则如下函数也可工作
Watt operator "" _w(const char* v) {
    return {(unsigned int) atoi(v)};
}

int main() {
    Watt capacity = 1024_w;
    cout << capacity.v << "\n";  // 1024
    return 0;
}
```

验证的初始化列表方式构造struct对象：

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

struct Watt {
    unsigned int v;
    unsigned int w;
    
    // Watt(unsigned int v, unsigned int w) : v(v), w(w) {}
};

int main() {
    Watt w1 = {10};  // 可以直接使用初始化列表来构造struct对象，如果自定义了上面的双入参构造函数，这里编译失败
    cout << w1.v << " " << w1.w << endl;  // 10 0

    Watt w2 = {10, 20};  // 可以直接使用初始化列表来构造struct对象
    cout << w2.v << " " << w2.w << endl;  // 10 20

    return 0;
}
```

这里用_w后缀来标识瓦特。除了整型数，用户自定义字面量还可以用于浮点型数等的字面量。不过必须注意的是，在C++11中，标准要求声明字面量操作符有一定的规则，该规则跟字面量的“类型”密切相关。C++11中具体规则如下：

- 如果字面量为整型数，那么字面量操作符函数只可接受unsigned long long或者const char*为其参数。当unsigned long long无法容纳该字面量的时候，编译器会自动将该字面量转化为以\0为结束符的字符串，并调用以const char\*为参数的版本进行处理。
- 如果字面量为浮点型数，则字面量操作符函数只可接受long double或者const char\*为参数。const char\*版本的调用规则同整数一样（过长则使用const char\*版本）。
- 如果字面量为字符串，则字面量操作符函数只可接受const char\*, size_t为参数（已知长度的字符串）。
- 如果字面量为字符，则字面量操作符函数只可接受一个char为参数。

总体来说，用户自定义字面量为代码书写带来了极大的便利。此外，在使用这个特性时，应该注意：

- 在字面量操作符函数的声明中，operator ""与用户自定义后缀之间必须有空格。
- 后缀建议以下划线开始。不宜使用非下划线后缀的用户自定义字符串常量，否则会被编译器警告。因为如果重用形如201203L这样的字面量，后缀“L”放弃系统无法引用一些混乱的状况。为避免混乱，最好只使用下划线开始的后缀名。

### 3.9 内联名字空间

在C++中，引入了名称空间（namespace）概念。目的是分割全局共享的名字空间。程序员在编写程序时可以建立自己的名字空间，使用者可以通过双冒号“空间名::函数/变量名”的形式来引用自己需要的版本。这就解决了C中名字冲突的问题。不过有时，我们会遇到一个名字空间下包含多个子名字空间的状况。子名字空间通常会带来一些使用上的不便。如下：

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};
    }

    namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // 无法通过编译
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;
        Basic::Knife k;
    }
}

// 这是LiLei在使用Jim的库
using namespace Jim;

int main() {
    Toolkit::SwissArmyKnife<Basic::Knife> sknife;
    return 0;
}
// 输出：
Knife in Other.
Knife in Basic.
```

在上述代码中，库编写者Jim用名字空间将自己代码封装起来。通过名字空间的细分，Other名字空间中不能直接引用Basic名字空间中的名字Knife。而Other名字空间中定义了Knife类型，那么变量c的声明就会导致其使用Knife类型是属于名字空间Other中的版本。这样的使用名字空间的方式是非常清楚的。

不过Jim这样会带来一个问题，即库的使用者在使用Jim名字空间的时候，需要知道太多的子名字空间的名字。使用者显然不希望声明一个sknife变量时，需要Toolkit::SwissArmyKnife\<Basic::Knife\>这么长的类型声明，通常也没必要让使用者LiLei看到子名字空间，因此他可能考虑这样修改代码，如下：

代码清单 3-48

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;
        Basic::Knife k;
    }

    // 打开一些内部名字空间
    using namespace Basic;
    using namespace Toolkit;
}

// LiLei决定对该class进行特化
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 编译失败，explicit specialization of 'template<class T> class Jim::Toolkit::SwissArmyKnife' outside its namespace must use a nested-name-specifier [-fpermissive]
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;  // 如果注释掉Jim中的using namespace Basic;，则这里无法识别Knife
    return 0;
}
```

在上述代码中，Jim在名字空间Jim的最后部分，打开了（using）Basic和Toolkit两个名字空间。这样一来在前一个代码中遇到的名字过长的问题就不复存在了。不过又有了新的问题：库的使用者LiLei由于觉得Toolkit中的模板SwissArmyKnife有的时候不太合用，所以决定特化一个SwissArmyKnife\<Knife\>的版本。这个时候，我们编译该例子则会失败。这是由于C++98标准不允许在不同的名字空间中对模板进行特化造成的。

在C++11中，标准了一个新特性，叫做“内联的名字空间”。通过关键字“inline namespace”就可以声明一个内联的名字空间。内联的名字空间允许程序员在父名字空间定义或特化子名字空间的模板。如下：

代码清单3-49

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    inline namespace Basic {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    inline namespace Toolkit {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // Knife in Basic
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;  // Knife in Other
        Basic::Knife k;  // Knife in Basic
    }
}

// 这是LiLei在使用Jim的库
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 使用inline名字空间后编译通过
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;
    return 0;
}
```

上述代码将名字空间Basic和Toolkit都声明为inline的。此时，LiLei对库中模板的偏特化（SwissArmyKnife\<Knife\>）则可以通过编译。这里再注意一下Other这个名字空间中的状况。可以看到，变量b的声明语句是可以通过编译的，而且其被声明为一个Basic::Knife的类型。换个角度理解的话，在子名字空间Basic中的名字现在看起来就跟在父名字空间Jim中一样。了解了这一点，Jim名字空间中的良好分隔明显被破坏了，要做到这样的效果，只需要把Knife和CorkScrew放到全局名字空间中就可以了，根本不用inline namespace这么复杂。事实上，这跟inline namespace的使用方式有关。如下：

代码清单3-50

```c++
#include <iostream>

using namespace std;

namespace Jim {
#if __cplusplus >= 201103L  // __cplusplus = 201402，所以这里如果写== 201103L，编译报错
    inline
#endif
    namespace cpp11 {
        struct Knife { Knife() { cout << "Knife in c++11." << endl; }};
    }

#if __cplusplus < 201103L
    inline
#endif
    namespace oldcpp {
        struct Knife { Knife() { cout << "Knife in old c++." << endl; }};
    }
}

using namespace Jim;

int main() {
    Knife a;  // Knife in c++11.（默认版本）
    cpp11::Knife b;  // Knife in c++11.（强制使用cpp11版本）
    oldcpp::Knife c;  // Knife in old c++.（强制使用oldcpp版本）
    return 0;
}
```

上述代码中，Jim为它的名字空间设定了两个子名字空间：cpp11和oldcpp。这里用到了在2.1节提到的关于C++的宏\_\_cplusplus。代码的意思是，如果现在的宏\_\_cplusplus大于等于201103这个常数，就将名字空间cpp11内联到Jim中，而如果小于201103，则将名字空间oldcpp内联到Jim中。这样，编译器就可以根据当前编译器对C++支持的情况，选择合适的实现版本。而如果需要的话，依然可以通过名字空间的方式（如cpp11::Knife）来访问相应名字空间中的类型、数据、函数等。这对程序库的发布很有好处，因为需要长期维护的程序库，可能版本间的接口和实现等都随着程序库的发展而发生了变化。那么根据需要将合适的名字空间导入到父名字空间中，无疑会方便库的使用。

还有一点，匿名的名字空间同样可以把其包含的名字内联导入到父名字空间。所以读者可能认为上述代码3-50同样可以通过匿名名字空间与宏组合来实现。不过跟代码清单3-48中使用using打开名字空间的情况一样，匿名名字空间无法允许在父名字空间的模板特化（但是如下代码验证去掉Basic和Toolkit子空间名字后，可以进行模板特化）。不过与在3-49中看到的一样，名字空间的内联会破坏该名字空间本身具有的封闭性，所以程序员不该在需要隔离名字的时候使用inline namespace关键字。

```c++
#include <iostream>

using namespace std;

// 这是Jim编写的库，用了Jim这个名字空间
namespace Jim {
    inline namespace {
        struct Knife { Knife() { cout << "Knife in Basic." << endl; }};

        class CorkScrew {};
    }

    inline namespace {
        template<typename T>
        class SwissArmyKnife {};
    }

    namespace Other {
        Knife b;  // Knife in Basic
        struct Knife { Knife() { cout << "Knife in Other." << endl; }};

        Knife c;  // Knife in Other
    }
}

// 这是LiLei在使用Jim的库
namespace Jim {
    template<>
    class SwissArmyKnife<Knife> {};  // 使用inline名字空间后编译通过
}

using namespace Jim;

int main() {
    SwissArmyKnife<Knife> sknife;
    return 0;
}
```

此外，在代码实践时，可能还会被一些C++的语言特性迷惑，比较典型的是所谓“参数关联名字查找”，即ADL（Argument-Dependent name Lookup）。这个特性允许编译器在名字空间内找不到函数名字的时候，在参数的名字空间内查找函数名字。如下：

```c++
namespace ns_adl {
    struct A {};
    void ADLFunc(A a) {}  // ADLFunc定义在namespace ns_adl中
}

int main() {
    ns_adl::A a;
    ADLFunc(a);  // ADLFunc无需声明名字空间
    return 0;
}
```

函数ADLFunc就无需在使用时声明其所在的名字空间，因为编译器可以在其参数a的名字空间ns_adl中找到ADLFunc，编译也就不会报错了。

ADL带来了一些使用上的便利性，不过也在一定程序上破坏了namespace的封装性。因此，比较好的使用方式，还是在使用任何名字前打开名字空间，或者使用“::”列出变量、函数完整的名字空间。

### 3.10 模板的别名

在C++11中，定义别名不再是typedef的专属能力，使用using同样可以定义类型的别名，而且从语言能力上看，using丝毫不比typedef逊色。如下例：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

using uint = unsigned int;
typedef unsigned int UINT;
using sint = int;

int main() {
    cout << is_same<uint, UINT>::value << endl;  // 1
    return 0;
}
```

上例，使用了C++标准库中的is_same模板类帮忙判断两个类型是否一致。is_same模板类接受两个类型作为模板实例化时的参数，而其成员类型则表示两个参数类型是否一样。using和typedef两者效果相同，或者说，在C++11中，using关键字的能力已经包括了typedef的部分。

在使用模板编程的时候，using的语法甚至比typedef更加灵活。如下例：

```c++
#include <iostream>
#include <map>

using namespace std;

template<typename T> using MapString = std::map<T, const char*>;

int main() {
    MapString<int> numberString;
    numberString.insert(std::make_pair(1, "abc"));
    numberString.insert(std::make_pair(2, "def"));
    
    return 0;
}
```

这里，“模板式”地使用了using关键字，将std::map\<T, const char*\>定义为了一个MapString类型，之后还可以使用类型参数对MapString进行类型的实例化，而使用typedef将无法达到这样的效果。

### 3.11 一般化的SFINEA规则 P138

在C++模板中，有一条著名的规则，即SFINEA - Substitution failure is not an error，中文直译即是“匹配失败不是错误”。更为确切地说，这条规则表示的是对重载的模板的参数进行展开的时候，如果展示导致了一些不匹配，编译器并不会报错。如下例：

```c++
#include <iostream>

using namespace std;

struct Test {
    typedef int foo;
};

template<typename T>
void f(typename T::foo) {
    cout << "f(typename T::foo)" << endl;
}

template<typename T>
void f(T) {
    cout << "f(T)" << endl;
}

int main() {
    f<Test>(10);  // f(typename T::foo)
    f<int>(10);  // f(T)
    return 0;
}
```

上述代码重载了函数模板f的定义。第一个模板f接受的参数类型为T::foo，这里通过typename来使编译器知道T::foo是一个类型。而第二个模板定义则接受一个T类型的参数。在main函数中，分别使用f\<Test\>和f\<int\>对模板进行实例化的时候会发现，对于f\<int\>来讲，虽然不存在 int::foo这样的类型，编译器依然不会报错，相反地，编译器会找到第二个模板定义并对其进行实例化。这样一来，就保证了编译的正确性。

通过上面的例子可以发现，SFINAE规则的作用比起拗口的定义而言更为直观。基本上，这是一个使得C++模板推导规则符合程序员想象的规则。通过SFINAE，能够使得模板匹配更为“精确”，即使得一些模板函数、模板类在实例化时使用特殊的模板版本，而另外一些则使用通过的版本，这样就大大增加了模板设计使用上的灵活性。这样的使用方式在标准库中使用非常普通（当你在标准库中发现一大堆的__enable_if，或者应该想起来这是SFINAE）。因此也可以说，SFINAE也是C++模板推导中非常基础的一个特性。

在C++98中，标准对于SFINAE并没有完全清晰的描述，一些在模板参数中使用表达式的情况，并没有被主流编译器支持。如下来自C++标准提案中的例子：

```c++
template<int I>
struct A {};

char xxx(int);

char xxx(float);

template<class T>
A<sizeof(xxx((T) 0))> f(T) {}

int main() {
    f(1);
    return 0;
}
```

上述代码，在定义函数模板f的时候，其返回值则定义为一个以sizeof(xxx((T) 0))为参数的类模板A。这里值得注意的是，我们使用了sizeof表达式，以及强制的类型转换。事实上，这样的表达式是可以在模板实例化时被计算出来的。不过由于实现上的复杂性，以及标准中并示明确地提及，大多数C++98编译器都会报一个SFINEA失败信息。而事实上，这样灵活的用法却非常有用，如本例中，程序员可以根据参数的长度而定义出不同返回值的模板函数（一种是sizeof((int)0)，一种则是sizeof((float)0)）。如果编译器拒绝了 这样的使用方式，无疑会为泛型编程的应用带来一些限制。

在C++11中，标准对这样的状况，尤其是模板参数替换时使用了表达式的情况进行了明确规定，即表达式中没有出现“外部于表达式本身”的元素，比如说发生一些模板的实例化，或者隐式地产生一些拷贝构造函数的话，这样的模板推导都不会产生SFINAE失败（即编译器报错）。这样，C++11中的一些新特性（比如将在第4章讲到的decltype等）将能够成功地进行广泛的应用。新的STL也将因此受益。

## 第4章 新手易学，老兵易用

### 4.1 右尖括号>的改进

C++98会将>>优先解析为右移。C++11中，这种限制被取消了。事实上，C++11标准要求编译器智能地去判断在哪些情况下>>不是右移符号。

 过这些“智能”的判断也会带来一些与C++98的有趣的不兼容性。如用户只是想让>>在模板的实例化中表示的是真正的右移，但C++11会把它解析为模板参数界定符。如下：

```c++
#include <iostream>

using namespace std;

template<int i>
class X {};

int main() {
    X<1 >> 5> x;  // 编译错误：error: expected unqualified-id before '>' token
    // 改为X<(1 >> 5)> x;
    return 0;
}
```

如果使用C++98标准进行编译的话，例子会编译通过，因为编译器认为X<1 >> 5> x;中的双尖括号是一个位移操作，那么最终得到一个形如X<0> x的模板实例。而使用C++11标准进行编译，会得到一个编译错误的警告，因为编译器优先将双尖括号中的第一个>与X之后的<进行了配对。

虽然很少有人在模板实例化时同时进行位移操作，但从语法上来说，C++98和C++11确实在这一点不兼容。要避免这样的不兼容性也很简单，使用圆括号将“1 >> 5”括起来，保证右移操作优先，就不会出现类似问题了。

### 4.2 auto类型推导 P143

#### 4.2.1 静态类型、动态类型与类型推导

在C++程序员的眼中，每个变量使用前必须定义，这种通常被视为编程语言中的“静态类型”的体现。而对于如Python、Perl、JavaScript等语言中变量不需要声明，而几乎“拿来就用”的变量使用方式，则被视为是编译语言中的“动态类型”的体现。不过从技术上严格地讲，静态类型和动态类型的主要区别在于对变量进行类型检查的时间点。对于所谓的静态类型，类型检查主要发生在编译阶段；而对于动态类型，类型检查主要发生在运行阶段。形如Python等语言中变量“拿来就用”的特性，则需要归功于一个技术，即类型推导。

在C++11中，类型推导的实现方式之一就是重定义了auto关键字，另外一个实现是decltype。

使用C++11的方式书写一下刚才的Python代码，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    auto name = "world.\n";
    cout << "hello, " << name;
    return 0;
}
```

上例使用了auto关键字来要求编译器对变量name的类型进行自动推导。编译器根据它的初始化表达式的类型，推导出name的类型为char*。

事实上，auto关键字在早期的C/C++标准中有着完全不同的含义。声明时使用了auto修饰的变量，按照早期C/C++标准的解决，是具有自动存储期的局部变量。不过现实情况是该关键字几乎无人使用，因为一般函数内没有声明为static的变量总是具有自动存储期的局部变量。因此在C++11中，标准委员会决定赋予auto全新的含义，即auto不再是一个存储类型指示符（storage-class-specifier，如static、extern、thread_local等都是存储类型指示符），而是作为一个新的类型指示符（type-specifier，如int、float等都是类型指示符）来指示编译器，auto声明变量的类型必须由编译器在编译时期推导而得。

如下例了解一下auto类型推导的基本用法：

```c++
#include <iostream>

using namespace std;

int main() {
    double foo();
    auto x = 1;  // x的类型是int
    auto y = foo();  // y的类型是double

    struct m { int i; } str;
    auto str1 = str;  // str1的类型是struct m

    auto z;  // 无法推导，无法通过编译
    return 0;
}
```

上例中，变量x被初始化为1，因为字面常量1的类型为const int，所以编译器推导出x的类型应该为int（这里const类型限制符被去掉了，后面会解释）。同理在变量y的定义中，auto类型的y被推导为double类型；而在auto str1的定义中，其类型被推导为struct m。

auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。从这个意义上来讲，auto并非一种“类型”声明，而是一个类型声明时的“点位符”，编译器在编译时期会将auto替代为变量实际的类型。

#### 4.2.2 auto的优势

直观地，auto推导的一个最大优势就是在拥有初始化表达式的复杂类型变量声明时简化代码。由于C++的发展，声明变量类型也变得越来越复杂，很多时候，名字空间、模板成为了类型的一部分，导致在使用库的时间如履薄冰。如下：

```c++
#include <iostream>
#include <vector>

void loopover(std::vector<std::string>& vs) {
    std::vector<std::string>::iterator i = vs.begin();
    for (; i < vs.end(); ++i) {
        std::cout << *i << "\n";
    }
}

int main() {
    std::vector<std::string> vs = {"abc", "def"};
    loopover(vs);
    return 0;
}
```

如上例，在不使用using namespace std的情况下（事实上，很多专家建议就是如此）想对一个vector数组进行循环。可以看到，想定义一个迭代器i的时候，必须写出std::vector\<std::string\>::iterator这样长的类型声明。使用auto的话，代码的可读性可以成倍增长，如下：

```c++
#include <iostream>
#include <vector>

void loopover(std::vector<std::string>& vs) {
    for (auto i = vs.begin(); i < vs.end(); ++i) {
        std::cout << *i << "\n";
    }
}
```

如上，使用了auto，可以将i的声明放入for循环，i的类型将由表达式vs.begin()推导出。在C++11中，由于auto的存在，使用STL将会变得更加容易，写出的代码也会更加清晰可读。

auto的第二个优势则在于可以免除程序员在一些类型声明时的麻烦，或者避免一些在类型声明时的错误。在C/C++中，存在着很多隐式或者用户自定义的类型转换规则（比如整形与字符型进行加法运算后，表达式返回的是整型，这是一条隐式规则）。这些规则并非很容易记忆，尤其是在用户自定义了很多操作符之后。这时，auto就有用武之地了。如下：

```c++
#include <iostream>

using namespace std;

class PI {
public:
    double operator*(float v) {
        return (double) val * v;  // 这里精度被扩展了
    }

    const float val = 3.1415927f;
};

int main() {
    float radius = 1.7e10;
    PI pi;
    auto circumference = 2 * (pi * radius);  // 写成radius * pi则无重载操作符*
    cout << circumference << endl;
    return 0;
}
```

上述代码，定义了float型的变量radius（半径）以及一个自定义类型PI变量pi（π值）计算圆周长时，使用了auto类型来定义变量circumference。这里PI在与float类型数据相乘时，其返回值为double。而PI的定义可能是在其它的地方（头文件里），main函数的程序员可能不知道PI的作者为了避免数据上溢或者精度降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，可能享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经自动地做了最好的选择。

值得指出的是，auto并不解决所有的精度问题，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    unsigned int a = 4294967295;  // 最大的unsigned int值
    unsigned int b = 1;
    auto c = a + b;

    cout << "a = " << a << endl;  // a = 4294967295
    cout << "b = " << b << endl;  // b = 1
    cout << "a + b = " << c << endl;  // a + b = 0
    return 0;
}
```

上述代码，程序员可能指望通过声明变量c为auto就能解决a+b溢出的问题，而实际上由于a+b返回的依然是unsigned int的值，故而c的类型依然被推导为unsigned int，auto并不能帮上忙。这跟一些动态语言中数据会自动进行扩展的特性还是不一样的。

auto的第三个优点就是其“自适应”性能够在一定程度上支持泛型的编程。

再回到之前代码，这里假设PI的作者改动了PI的定义，如将operator*返回值变为long double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。

同理，对于不同的平台上的代码维护，auto也会带来一些“泛型”的好处。这里以strlen函数为例，在32位的编译环境下，strlen返回的为一个4字节的整型，而在64位的编译环境下，strlen会返回一个8字节的整型。虽然系统库\<cstring\>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字同样可以达到代码跨平台的效果。

`auto var = strlen("hello world!")`

由于size_t的适用范围往往局限于\<cstring\>中定义的函数，auto的适用范围明显更为广泛。

当auto应用于模板的定义中，其“自定义”性会得到更加充分的体现，如下：

代码清单4-19

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
double Sum(T1& t1, T2& t2) {
    auto s = t1 + t2;  // s的类型会在模板实例化时被推导出来
    return s;
}

int main() {
    int a = 3;
    long b = 5;
    float c = 1.0f, d = 2.3f;

    auto e = Sum<int, long>(a, b);  // s的类型被推导为long
    auto f = Sum<float, float>(c, d);  // s的类型被推导为float
    return 0;
}
```

可以看到，auto与模板一起使用时，其“自适用”特性能够加强C++中“泛型”的能力。不过这个例子中，由于总是返回double类型的数据，所以Sum模板函数的适用范围还是受到了一定的限制，在4.4节，可以看到怎么使用追踪返回类型的函数声明来完全释放Sum泛型的能量。

本地试验，把sum返回值改成auto也可以正常编译运行：

```c++
template<typename T1, typename T2>
auto Sum(T1& t1, T2& t2) {
    auto s = t1 + t2;  // s的类型会在模板实例化时被推导出来
    return s;
}
```

另外，应用auto还会在一些情况下取得意想不到的好效果，如下：

```c++
#include <iostream>

using namespace std;

#define max1(a, b) ((a) > (b)) ? (a) : (b)
#define max2(a, b) ( {\
    auto _a = (a); \
    auto _b = (b); \
    (_a > _b) ? _a : _b; })

int main() {
    int m1 = max1(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);
    int m2 = max2(1 * 2 * 3 * 4, 5 + 6 + 7 + 8);
    cout << m1 << endl;
    cout << m2 << endl;
    return 0;
}
```

上例代码定义了两种类型的宏max1和max2。两者作用相同，都是求a和b中较大者返回。前者采用传统的三元运算符表达式，这可能会带来一定的性能问题。因为a和b在三元运算符中都出现了两次，无论取a还是取b，其中之一都会被运算两次。而在max2中，将a和b都先算出来，再使用三元运算符进行比较，就不会存在这样的问题了。

在传统的C++98标准中，由于a和b的类型无法获得，所以无法定义max2这样高性能的宏。而新的标准中的auto则提供了这种可行性。

#### 4.2.3 auto的使用细则

首先看看auto类型指示符与指针和引用之间的关系。在C++11中，auto可以与指针和引用结合起来使用，使用的效果基本上会符合C/C++程序员的想象。如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

int num = 100;

int& bar() {
    return num;
}

int main() {
    int x = 11;
    int* y = &x;

    auto* a = &x;  // auto为int，如果定义为auto a = &x;，则auto为int*
    cout << *a << "\n";  // 11
    auto& b = x;  // auto为int
    auto c = y;  // auto为int*
    auto* d = y;  // auto为int
//    auto* e = &foo();  // 编译失败，指针不能指向一个临时变量
//    auto& f = foo();  // 编译失败，nonconst的左值引用不能和一个临时变量绑定，可以改成const左值引用const auto& f = foo();，或右值引用auto&& f = foo();
    auto g = bar();  // auto为int
    auto& h = bar(); // auto为int
    
    return 0;
}
```

本例中，变量a、c、d的类型都是指针类型，且都指向变量x。实际上对于a、c、dd一个变量而言，声明其为auto*或auto并没有区别。而如何要使得auto声明的变量是另一个变量的引用，则必须使用auto&，如同本例中的变量b和h一样。

其次，auto与volatile和const之间也存在着一些相互的联系。volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的特殊性，C++11标准规定auto可心与cv限制符一起使用，不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符（**就是说auto声明的变量，不会直接带着为const标识符**）。如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

float num = 100.0;

float* bar() {
    return &num;
}

int main() {
    const auto a = foo();  // a: const double
    const auto& b = foo();  // b: const double&
    volatile auto* c = bar();  // c: volatile float*

    auto d = a;  // d: double
    d = 10;  // 编译通过
    auto& e = a;  // e: const double&
//    e = 10;  // 编译错误，error: assignment of read-only reference 'e'
    auto f = c;  // f: float*
    volatile auto& g = c;  // g: volatile float*&
    return 0;
}
```

上述代码中，可以通过非cv限制的类型初始化一个cv限制的类型，如变量a、b、c所示。不过通过auto声明的变量d、f却无法带走a和f的常量性或者易失性。这里的例外还是引用，可以看出，声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。

跟其它的变量指针符一样，同一个赋值语句中，auto可以用来声明多个变量的类型，不过这些变量的类型必须相同。如果这些变量的类型不相同，编译器则会报错。事实上，用auto来声明多个变量类型时，只有第一个变量用于auto的类型推导，然后推导出来的数据类型被作用于其它的变量。所以不允许这些变量的类型不相同，如下：

```c++
#include <iostream>

using namespace std;

double foo() {
    return 10.0;
}

float num = 100.0;

float* bar() {
    return &num;
}

int main() {
    auto x = 1, y = 2;  // x和y的类型均为int

    // m是一个指向const int类型变量的指针，n是一个int类型的变量
    const auto* m = &x, n = 1;  // auto为int，n为const int
//    n = 2;  // 编译错误，const对象无法修改

    // 如下编译错误，error: inconsistent deduction for 'auto': 'int* const' and then 'const int'
//    const auto m1 = &x, n1 = 1;

//    auto i = 1, j = 3.14f;  // 编译失败，error: inconsistent deduction for 'auto': 'int' and then 'float'
    auto o = 1, &p = o, *q = &p;  // 从左向右推导

    return 0;
}
```

上述代码，使用auto声明了两个类型相同变量x和y，并用逗号进行分隔，这可以通过编译。而在声明变量i和j时，按照所说的第一变量用于推导类型的规则，那么由于x所推导出的类型是int，那么对于变量j而言，其声明就变成了int j = 3.14f，这无疑会导致精度的损失。而对于变量m和n，这里似乎是auto被替换成了int，所以m是一个const int*指针类型，而n只是一个const int类型。同样的情况也发生在变量o、p、q上，这里o是一个类型为int的变量，p是o的引用，而q是p的指针。auto的类型推导按照从左往右，且类似于字面替换的方式进行。事实上，标准里称auto是一个将要推导出的类型的“占位符”（placeholder）。为了不必要的繁琐记忆，程序员可以选择每一个auto变量的声明写成一行（有些观点也认为这是好的编程规范）。

只要能够进行推导的地方，C++11都为auto指定了详细的规则，保证编译器能够正确地推导出变量的类型。包括C++11新引入的初始化列表，以及new，都可以使用auto关键字，如下：

```c++
#include <iostream>

using namespace std;

int main() {
    auto x = 1;
    auto x1(1);
    auto y{1};  // y: int，使用初始化列表的auto
    cout << y << "\n";
//    vector<auto> y{1, 2};  // 编译错误：auto is not allowed in template argument

    auto z = new auto(2);  // 可以用于new，auto z = new auto{2};也可以
    cout << *z << "\n";
    delete z;
    return 0;
}
```

上述代码，auto变量y的初始化使用了初始化列表，编译器可以保证y的类型推导为int。而z指针所指向的堆变量在分配时依然选择让编译器对类型进行推导，同样的，编译器也能够保证这种方式下类型推导的正确性。

不过auto也不是万能的，受制于语法的二义性，或者是实现的困难性，auto往往也会有使用上的限制。例外的情况写在如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

void fun(auto x = 1) {}  // 1: auto函数参数，无法通过编译

struct str {
    auto var = 10;  // 2: auto非静态成员变量，无法通过编译，const static auto var = 10;可以编译通过
};

int main() {
    char x[3];
    auto y = x;
    auto z[3] = x;  // 3: auto数组，无法通过编译
    auto u[3] = {1, 2, 3};  // 同样编译失败
    // 但是本来数组也无法直接赋值初始化
//    char w[3] = x;  // 编译失败，char数组只能初始化列表初始化或字符串字面量初始化，可改成char* w  = x;
//    int i[3] = {1, 2, 3};
//    int j[3] = i;  // 编译失败，数组只能初始化列表初始化

    // 4: auto模板参数（实例化时），无法通过编译
    vector<auto> v = {1};
    return 0;
}
```

分别来看上述代码中的4种不能推导的情况。

1. 对于函数fun来说，auto不能是其形参类型。可能读者感觉对于fun来说，由于其有默认参数，所以应该推导fun形参x的类型为int型。但事实却无法符合大家想象，因为auto是不能做形参的类型的。如果程序员需要泛型的参数，还是需要求助于模板。
2. 对于结构体来说，非静态成员变量的类型不能是auto的。同样的，由于var定义了初始值，读者可能认为auto可以推导str成员var的类型为int的。但编译器阻止auto对结构体中的非静态成员进行推导，即使成员拥有初始值。
3. 声明auto数组。可以看到main中的x是一个数组，y的类型是可以推导的，而声明auto z[3]这样的数组同样会被编译器禁止。
4. 在实例化模板的时候使用auto作为模板参数。虽然读者可能认为这里一眼而知是int类型，但编译器却阻止了编译。

以上4种情况特点基本相似，人为地观察很容易能够推导出auto所在位置应有的类型，但现有的C++11的标准还没有支持这样的使用方式。

由于为了避免和C++98中auto的含义发生混淆，C++11只保留auto作为类型指示符的用法，以下的语句在C++98和C语言中都是合法的，但在C++11中，编译器会报错。

`auto int i = 1;  // error: two or more data types in declaration of 'i'`

总的来说，auto在C++11中是相当关键的特性之一。之后还会在很多地方看到auto，如4.4节中的追踪返回类型的函数声明，以及7.3节中lambda与auto的配合使用等。不过，auto只是C++11中类型推导体现的一部分。其余的，则会在decltype中得到体现。

### 4.3 decltype P153

#### 4.3.1 typeid与decltype

与C完全不支持动态类型不同的是，C++在C++98标准中就部分支持动态类型了。C++98对动态类型支持就是C++中的运行时类型识别（RTTI）。

RTTI的机制是为每个类型产生一个type_info类型的数据，程序员可以在程序中使用typeid随时查询一个变量的类型，typeid就会返回变量相应的type_info数据。而type_info的name成员函数可以返回类型的名字。而在C++11中，又增加了hash_code这个成员函数，返回该类唯一的哈希值，以供程序员对变量的类型随时进行比较。如下：

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

class White {};

class Black {};

int main() {
    White a;
    Black b;

    cout << typeid(a).name() << endl;  // 5White
    cout << typeid(b).name() << endl;  // 5Black

    White c;

    bool a_b_sametype = (typeid(a).hash_code() == typeid(b).hash_code());
    bool a_c_sametype = (typeid(a).hash_code() == typeid(c).hash_code());

    cout << "Same type? " << endl;
    cout << "A and B? " << (int) a_b_sametype << endl;  // 0
    cout << "A and C? " << (int) a_c_sametype << endl;  // 1

    return 0;
}
```

上例定义了两个不同的类型White和Black，以及其类型的变量a和b。使用typeid返回类型的type_info，并分别应用name打印类型的名字（5这样的前缀是g++这类编译器输出的名字，其它编译器可能会打印其它的名字，这个标准并没有明确规定），应用hash_code进行类型的比较。在RTTI的支持下，程序员可以在一定程序上了解程序中类型的信息（这里注意一下，相比于4.1.2节中的**is_same**模板函数的成员函数value在**编译时得到信息**，**hash_code**是**运行时得到的信息**）。

除了typeid外，RTTI还包括了C++中的dynamic_cast等特性。不过，由于RTTI会带来一些运行时的开销，所以一些编译器会让用户选择性地关闭该特性（如XL C/C++编译器的-qnortti，GCC的选项-fno-rttion，或者微软编译器选项/GR-）。而且很多时间，运行时才确定出类型对于程序员来说为时过晚，程序员更多需要的是在编译时期确定出类型（标准库中非常常见）。而通常程序员是要使用这样的类型而不是识别该类型，因此RTTI无法满足需求。

C++的发展中，类型推导是随着模板和泛型编程的广泛使用而引入的。在非泛型的编程中，不用对类型进行推导，因为任何表达式中变量的类型都是明确的，而运算、函数调用等也都有明确的返回类型。而在泛型的编程中，类型成了未知数。

与auto类似地，decltype也能进行类型推导，不过两者的使用方式却有一定的区别。可以看如下代码：

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

int main() {
    int i;
    decltype(i) j = 0;
    cout << typeid(j).name() << endl;  // 打印出“i”，g++表示int

    float a;
    double b;
    decltype(a + b) c;
    cout << typeid(c).name() << endl;  // 打印出“d”，g++表示double

    return 0;
}
```

上述代码，看到变量j的类型由decltype进行声明，表示j的类型跟i相同（或者准确地说，跟i这个表达式返回的类型相同）。而c的类型跟（a+b）这个表达式返回的类型相同。而由于a+b加法表达式返回的类型为double（a会被扩展为double类型与b相加），所以c的类型被decltype推导为double。

从这个例子可以看到，decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，decltype总是以一个普通的表达式为参数，返回该表达式的类型。而与auto相同的是，作为一个类型指示符，decltype可以将获得的类型来定义另外一个变量。与auto相同，decltype类型推导也是在编译时进行的。

#### 4.3.2 decltype的应用

在C++11中，使用decltype推导类型是非常常见的事情。比较典型的就是decltype与typedef/using的合用。在C++11的头文件中，常能看到以下代码：

```c++
using size_t = decltype(sizeof(0));
using ptrdiff_t = decltype((int*) 0 - (int*) 0);
using nullptr_t = decltype(nullptr);
```

这里size_t以及ptrdiff_t还有nullptr_t（参见7.1节）都是由decltype推导出的类型。在一些常量、基本类型、运算符、操作符等都已经被定义好的情况下，类型可以按照规则被推导出。而使用using，就可以为这些类型取名。这就颠覆了之前类型拓展需要将扩展类型“映射”到基本类型的常规做法。

除此之外，decltype在某些场景下，可以极大地增加代码的可读性。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> vec = {1, 5, 7};
    typedef decltype(vec.begin()) vectype;  // vectype推导为: vector<int>::iterator

    for (vectype i = vec.begin(); i != vec.end(); ++i) {
        cout << *i << " ";
    }

    cout << "\n";
    
    for (decltype(vec)::iterator i = vec.begin(); i != vec.end(); ++i) {
        cout << *i << " ";
    }
    return 0;
}
```

上述代码，定义了vector的iterator的类型。这个类型还可以在main函数中重用。当我们遇到一些具有复杂类型的变量或表达式时，就可以利用decltype和typedef/using的组合来将其转化为一个简单的表达式，这样在以后的代码写作中可以提高可读性和可维护性。此外可以看到decltype(vec)::iterator这样的灵活用法，这看起来跟auto非常类似，也类似于是一种“占位符”式的替代。

在C++中，有时会遇到匿名的类型，而拥有了decltype这个利器之后，重用匿名类型也非难事。如下：

```c++
enum class K { K1, K2, K3 } anon_e;
//enum class { K1, K2, K3 } anon_e;  // 匿名的强类型枚举，但是本地编译错误：error: unnamed scoped enum is not allowed

union {
    decltype(anon_e) key;
    char* name;
} anon_u;  // 匿名的union联合体

struct {
    int d;
    decltype(anon_u) id;
} anon_s[100];  // 匿名的struct数组

int main() {
    decltype(anon_s) as;
    as[0].id.key = decltype(anon_e)::K1;  // 引用匿名强类型枚举中的值
    return 0;
}
```

这里使用了3种不同的匿名类型：匿名的强类型枚举anon_e（请参见5.1节）、匿名的联合体anon_u，以及匿名的结构体数组anon_s。可以看到，只要通过匿名类型的变量名anon_e、anon_u，以及anon_s，decltype可以推导其类型并且进行重用。在一些C代码中，匿名的结构体和联合体并不少见。不过匿名一般都有匿名理由，一般程序员都不希望匿名后的类型被重用。这里的decltype只是提供了一种语法上的可能。

有了decltype，可以适当扩大模板泛型的能力。以代码4-9为例，稍微改变一下函数模板的接口，该模板将适用于更大的范围。如下改进的例子：

代码清单4-20

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
void Sum(T1& t1, T2& t2, decltype(t1 + t2)& s) {
    s = t1 + t2;
}

int main() {
    int a = 3;
    long b = 5;
    float c = 1.0f, d = 2.3f;

    long e;
    float f;
    Sum(a, b, e);  // s的类型被推导为long
    Sum(c, d, f);  // s的类型被推导为float
    return 0;
}
```

相比于代码清单4-19，上述的Sum函数模板增加了类型为decltype(t1+t2)的s作为参数，而函数本身不返回任何值。这样，Sum的适用范围增加，因为其返回的类型不再是单一的double类型，而是根据t1+t2推导而来的类型。不过这里还是有一定的限制，可以看到返回值的类型必须一开始就被指定，程序员必须清楚Sum运算的结果使用什么样的类型来存储是合适的，这在一些泛型编程中依然不能满足要求。解决的方法是结合decltype与auto关键字，使用追踪返回类型的函数定义来使得编译器对函数返回值进行推导。在4.4节会看到具体的细节（事实上，**decltype一个最大的用途就是用在追踪返回类型的函数**中）。

有些情况下，模板库的使用人员可能认为一些自然而简单的数据结构，比如数组，也是可以被模板类所包括的。不过，如果t1和t2是两个数组，t1+t2不会是合法的表达式。为了避免不必要的误解，模板库的开发人员应该为这些特殊的情况提供其它的版本，如下：

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
void Sum(T1& t1, T2& t2, decltype(t1 + t2)& s) {
    s = t1 + t2;
}

void Sum(int a[], int b[], int c[]) {
    // 数组版本
}

int main() {
    int a[5], b[5], c[5];
    Sum(a, b, c);  // 选择数组版本

    int d, e, f;
    Sum(d, e, f);  // 选择模板的实例化版本
    return 0;
}
```

上述代码，由于声明了数组版本的Sum，编译器在编译Sum(a, b, c)的时候，会优先选择数组版本，而编译Sum(d, e, f)的时候，依然会对应到模板的实例化版本。这就能够保证Sum模板函数最大的可用性（不过这里的数组版本似乎做不了什么事情，因为数组长度丢失了）。

在实例化一些模板的时候，decltype也可以起到一些作用，如下：

```c++
#include <iostream>
#include <map>

using namespace std;

int myhash(char*);

int main() {
    map<char*, decltype(hash)> dict_key;  // 无法通过编译
    map<char*, decltype(myhash(nullptr))> dict_key1;  // 原书这里hash编译有二义性，与std::hash冲突

    return 0;
}
```

上述代码实例化了标准库中map函数。该map是为了存储字符串以及其对应哈希值的，因此可以通过decltype(hash(nullptr))来确定哈希值的类型。这样的定义非常直观，但是必须要注意的是，decltype只能接受表达式做参数，像函数名做参数的表达式decltype(hash)是无法通过编译的。

decltype在C++11的标准库中也有一些应用，一些标准库的实现也会依赖于decltype的类型推导。一个典型的例子是基于decltype的模板类result_of，其作用是推导函数的返回类型。如下：

```c++
#include <iostream>

using namespace std;

typedef double (* func)();

int main() {
    result_of<func()>::type f;
    cout << typeid(f).name() << endl;  // 由result_of推导函数func()其结果类型为d: doulbe
    return 0;
}
```

这里f的类型最终被推导为double，而result_of并没有真正调用func()这个函数，这是因为底层的实现使用了decltype。result_of的一个可能的实现方式如下：

```c++
template<class>
struct result_of;

template<class F, class... ArgTypes>
struct result_of<F(ArgTypes...)>
{
    typedef decltype(std::declval<F>()(std::declval<ArgTypes>()...))
}
```

请读者忽略declval（实际是STL中的一种语法技巧），这里标准库将decltype作用于函数调用上（使用了变长函数模板），并将函数调用表达式返回的类型typedef为一个名为type的类型。这样，代码中的result_of\<func()\>::type就会被decltype推导为double。

#### 4.3.3 decltype推导四规则 P159

大多数时候，decltype的使用看起来非常平易近人，但有时也会落入一些令人疑惑的陷阱。如下：

```c++
#include <iostream>

using namespace std;

int main() {
    int i;
    decltype(i) a;  // a: int
    decltype((i)) b;  // b: int&，无法通过编译
    return 0;
}
```

上例，单单多了一对圆括号，decltype所推导出出的类型居然生成了变化。事实上，C++11中decltype推导返回类型的规则比我们想象的复杂。具体地，用decltype(e)来获取类型时，编译器将依序判断以下四规则：

1. 如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实例的类型。此外，如果e是一个被重载的函数，则会导致编译时错误。
2. 否则，假设e的类型是T，如果e是一个将亡值（xvalue），那么decltype(e)为T&&。
3. 否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&。
4. 否则，假设e的类型是T，则decltype(e)为T。

这里需要解释一下标记符表达式（id-expression）。基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier）。而单个标记符对应的表达式就是标记符表达式。如程序员定义了：

`int arr[4];`

那么arr是一个标记符表达式，而arr[3]+0、arr[3]等，则都不是标记符表达式。

再回到代码上述代码，并结合decltype类型推导的规则，可以知道，decltype(i) a;使用了规则1——因为i是一个标记符表达式，所以类型被推导为int。而decltype((i)) b;中，由于(i)不是一个标记符表达式，但却是一个左值表达式（可以有具名的地址），因此，按照decltype推导规则3，其类型应该是一个int的引用。

上面的规则看起来非常复杂，事实上，实际应用中，decltype类型推导规则中最容易引起迷惑的只有规则1和规则3。通过下例再加深一下理解：

```c++
#include <iostream>

using namespace std;

int main() {
    int i = 4;
    int arr[5] = {0};
    int* ptr = arr;

    struct S { double d; } s;

    void Overloaded(int);
    void Overloaded(char);  // 重载的函数

    int&& RvalRef();

    const bool Func(int);

    // 规则1：单个标记符表达式以及访问类成员，推导为本类型
    decltype(arr) var1;  // int[5]，标记符表达式
    decltype(ptr) var2;  // int*，标记符表达式
    decltype(s.d) var3;  // double，成员访问表达式
//    decltype(Overloaded) var5;  // 无法通过编译，是个重载的函数，如果不是重载函数，则可以通过编译

    // 规则2：将亡值，推导为类型的右值引用
    decltype(RvalRef()) var6 = 1;  // int&&

    // 规则3：左值，推导为类型的引用
    decltype(true ? i : i) var7 = i;  // int&，三元运算符，这里返回一个i的左值
    decltype((i)) var8 = i;  // int&，带圆括号的左值
    decltype(++i) var9 = i;  // int&，++i返回i的左值
    decltype(arr[3]) var10 = i;  // int&，[]操作返回左值
    decltype(*ptr) var11 = i;  // int&，*操作返回左值
    decltype("lval") var12 = "lval";  // const char(&) [9]，字符串字面常量为左值

    // 规则4：以上都不是，推导为本类型
    decltype(1) var13;  // int，除字符串外字面常量为右值
    decltype(i++) var14;  // int，i++返回右值
    decltype((Func(1))) var15;  // const bool，圆括号可以忽略

    return 0;
}
```

上例将四种规则的例子都列了出来。

规则1不但适用于基本数据类型，还适用于指针、数组、结构体，甚至函数类型的推导，事实上，规则1在decltype类型推导中运用的最为广泛。

规则2比较简单，基本上符合程序员的想象。

规则3其实是一个左值规则。decltype的参数不是标志符表达式或者类成员访问表达式，且参数都为左值，推导出的类型均为左值引用。

规则4则是适用于以上都不适用者。这里看到了++i和i++在左右值上的区别，以及字符串字面常量lval、非字符串字面常量1在左右值间的区别。

本地试验1：

```c++
#include <iostream>

using namespace std;

void Overloaded1(int i) {
    cout << "Overloaded1: " << i << endl;
}

void Overloaded2(int i) {
    cout << "Overloaded2: " << i << endl;
}

int main() {
 	// 函数指针类型推导，如果Overload1和Overload2函数签名不同，则编译报错
    decltype(Overloaded1)* fun = Overloaded2;
    fun(10);  // Overloaded2: 10
    return 0;
}
```

本地试验2：

```c++
#include <iostream>

using namespace std;

// std::move的作用就是把左值变为右值引用
int&& RvalRef() {
    return std::move(10);
}

int main() {
    int&& i = RvalRef();
    cout << i << endl;
    return 0;
}
```

看过这些规则，读者可能觉得过于复杂，事实上，如同之前提到的，引起麻烦的只是规则3带来的左值引用的推导。一个简单的能够让编译器提示的方法是，如果使用decltype定义变量，那么先声明这个变量，再在其它语句里对其进行初始化。这样，由于左值引用总是需要初始化的，编译器会报错提示。另外一些时候，C++11标准库中添加的模板类is_lvalue_reference，可以帮忙进行一些推导结果的识别。如下例：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

int i = 4;
int arr[5] = {0};
int* ptr = arr;

int&& RvalRef();

int main() {
    cout << is_rvalue_reference<decltype(RvalRef())>::value << endl;  // 1

    cout << is_lvalue_reference<decltype(true ? i : i)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype((i))>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(++i)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(arr[3])>::value << endl;  // 1
    cout << is_lvalue_reference<decltype(*ptr)>::value << endl;  // 1
    cout << is_lvalue_reference<decltype("lval")>::value << endl;  // 1

    cout << is_lvalue_reference<decltype(i++)>::value << endl;  // 0
    cout << is_rvalue_reference<decltype(i++)>::value << endl;  // 0
    return 0;
}
```

上述代码，使用了模板类is_lvalue_reference的成员value来查看decltype的效果（1表示是左值引用，0则反之）。如所见，凡是符合规则3的，都会被推导为左值引用。如果程序员在程序的书写中不是非常确定decltype是否将类型推导为左值引用，也可以通过这样的小实验来辅助确定。这里还使用了模板函数is_rvalue_reference，同样，也可以通过它来确定decltype是否推导出了右值 引用。

#### 4.3.4 cv限制符的继承与冗余的符号 P162

与auto类型推导时不能“带走”cv限制符不同，decltype是能够“带走”表达式的cv限制符的。不过，如果对象的定义中有const或volatile限制，使用decltype进行推导时，其成员不会继承const或volatile限制。如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

const int ic = 0;
volatile int iv;

struct S { int i; };

const S a = {0};

volatile S b;
volatile S* p = &b;

int main() {
    cout << is_const<decltype(ic)>::value << endl;  // 1
    cout << is_volatile<decltype(iv)>::value << endl;  // 1

    cout << is_const<decltype(a)>::value << endl;  // 1
    cout << is_volatile<decltype(b)>::value << endl;  // 1

    cout << is_const<decltype(a.i)>::value << endl;  // 0，成员不是const
    cout << is_volatile<decltype(p->i)>::value << endl;  // 0，成员不是volatile

    return 0;
}
```

上例，使用了C++库提供的is_const和is_volatile来查看类型是否是常量或者易失的。可以看到，结构体变量a、b和结构体指针p的cv限制符并没有出现在其成员的decltype类型推导结果中。

而与auto相同的，decltype从表达式推导出类型后，进行类型定义时，也会允许一些冗余的符号。如cv限制符以及引用符号&，通常情况下，如果推导出的类型已经有了这些属性，冗余的符号则会被忽略，如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

int i = 1;
int& j = i;
int* p = &i;
const int k = 1;

int main() {
    decltype(i)& var1 = i;
    decltype(j)& var2 = i;  // 冗余的&，被忽略
    cout << is_lvalue_reference<decltype(var1)>::value << endl;  // 1，是左值引用

    cout << is_rvalue_reference<decltype(var2)>::value << endl;  // 0，不是右值引用
    cout << is_lvalue_reference<decltype(var2)>::value << endl;  // 1，是左值引用

//    decltype(p)* var3 = &i;  // 无法通过编译，error: cannot convert 'int*' to 'int**' in initialization
    decltype(p)* var3 = &p;  // var3的类型是int**

    auto* v3 = p;  // v3的类型是int*
    v3 = &i;

    const decltype(k) var4 = 1;  // 冗余的const，被忽略
    return 0;
}
```

上述代码中，定义了类型为decltype(i)&的变量var1，以及类型为decltype(j)&的变量var2。由于i的类型为int，所以这里的引用符号保证var1成为一个int&引用类型。而由于j本来就是一个int&的引用类型，所以decltype之后的&成为了冗余符号，会被编译器忽略，因此j的类型依然是int&。（**注意这里不是int&&类型**）

这城特别要注意的是decltype(p)\*的情况。可以看到，在定义var3变量的时候，由于p的类型是int\*，因此var3被定义为了int\*\*类型。这跟auto声明中，\*也可以是冗余的不同。在decltype后的\*号，并不会被编译器忽略。

此外也可以看到，var4中const可以被冗余的声明，但会被编译器忽略，同样的情况也会生成在volatile限制符上。

decltype算得上是C++11中类型推导使用方式上最灵活的一种。虽然看起来它的推导规则比较复杂，有的时候跟auto推导结果还略有不同，但大多数时候，发现使用decltype还是自然而亲切的。一些细则的区别，读者可以在使用时遇到问题再返回查验。而下面的跟踪返回类型的函数定义，则将整合auto、decltype，将C++11中的泛型能力提升到更高的水平。

### 4.4 追踪返回类型 P164

#### 4.4.1 追踪返回类型的引用 P165

追踪返回类型配置auto和decltype会真正释放C++11中泛型编程的能力。

在C++98中，如果一个函数模板的返回类型依赖于实际的入口参数类型，那么该返回类型在模板实例化之前可能都无法确实，这样的话在定义该函数模板时就会遇到麻烦。回想一下代码清单4-9的例子，由于Sum模板函数的两个参数t1和t2的类型没有确定，所以只能简单地设置结果s为double类型并返回。这就限制了Sum的使用范围（大概只能用于数值不算太大的算术运算）。而在代码清单4-20中，改进了Sum模板函数，通过增加decltype(t1+t2)的参数的方式来返回泛型的值。这样做虽然扩大了Sum的适用范围，但改变了Sum的使用方式，在一些情况下，也是不可以接受的。而且由于程序员必须预先知道返回的类型，其使用上的灵活性也就打了一些折扣。

最为直观的解决方式就是对返回类型进行类型推导。而最为直观的书写方式如下所示：

```c++
template<typename T1, typename T2>
decltype(t1 + t2) Sum(T1& t1, T2& t2) {
    return t1 + t2;
}
```

这样的写法虽然看似不错，不过对编译器来说有些小问题。编译器在推导decltype(t1 + t2)时，表达式中的t1和t2都未声明（虽然它们近在咫尺，编译器却只会从左往右地读入符号）。按照C/C++编译器的规则，变更使用前必须已经声明，因此，为了解决这个问题，C++11引入新语法——追踪返回类型，来声明和定义这样的函数：

```c++
template<typename T1, typename T2>
auto Sum(T1& t1, T2& t2) -> decltype(t1 + t2) {
    return t1 + t2;
}
```

如上，把函数的返回值移至参数声明之后，复合符合-> decltype(t1 + t2)被称为追踪返回类型。而原来函数返回值的位置由auto关键字占据。这样，可以让编译器来推导Sum函数模板的返回类型了。而auto占位符和-> return_type也就是构成追踪返回类型的两个基本元素。

#### 4.4.2 使用追踪返回类型的函数

追踪返回类型的函数和普通函数的声明最大的区别在于返回类型的兵团。在一般情况下，普通函数的声明方式会明显简单于最终返回类型。如：

`int func(char* a, int b);`

这样的书写会比下面的书写少上不少：

`auto func(char* a, int b) -> int;`

不过有时，追踪返回类型声明的函数也会带给大家一些意外，如下：

```c++
class OuterType {
    struct InnerType { int i; };

    InnerType GetInner();

    InnerType it;
};

// 跟踪返回类型，可以不写 OuterType::InnerType
auto OuterType::GetInner() -> InnerType {
    return it;
}

// 如果不使用追踪返回类型，返回类型必须指定作用域 OuterType::InnerType
//OuterType::InnerType OuterType::GetInner() {
//    return it;
//}
```

上述代码，可以看到使用追踪返回类型的时候，InnerType不必写明其作用域。这对于讨厌写很长作用域的程序员来说，也算得上一个好消息。

返回类型后置，使模板中的一些类型推导就成为了可能。可以看看如下使用追踪返回类型的例子：

```c++
#include <iostream>

using namespace std;

template<typename T1, typename T2>
auto Sum(const T1& t1, const T2& t2) -> decltype(t1 + t2) {
    return t1 + t2;
}

template<typename T1, typename T2>
auto Mul(const T1& t1, const T2& t2) -> decltype(t1 * t2) {
    return t1 * t2;
}

int main() {
    auto a = 3;
    auto b = 4L;
    auto pi = 3.14;

    auto c = Mul(Sum(a, b), pi);
    cout << c << endl;  // 21.98
    return 0;
}
```

上述代码，定义了两个模板函数Sum和Mul，它们的参数的类型和返回值都在实例化时决定。由于main函数中还使用了auto，整个例子中没有看到一个“具体”的类型声明。事实上，这段代码尤其是主函数，看起来有点像是一个动态类型语言的代码，而不像是一个有着严格静态类型的C++代码。这一切都要归功于类型推导帮忙下的泛型编程。程序员在编写代码时无需关心任何时段的类型选择，编译器会合理地进行推导，而简单程序的书写也由此得到了极大的简化。

 除了解决以上所描述的问题，追踪返回类型的另一个优势是简化函数的定义，提高代码的可读性。这种情况常见于函数指针中。如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

// 有的时候，你会发现这是面试题
int (* (* pf())())() {
    return nullptr;
}

// auto (*) () -> int (*) () 一个返回函数指针的函数（假设为a函数）
// auto pf1 () -> auto (*) () -> int (*) () 一个返回a函数的指针的函数
auto pf1() -> auto (*)() -> int (*)() {
    return nullptr;
}

int main() {
    cout << is_same<decltype(pf), decltype(pf1)>::value << endl;  // 1
    return 0;
}
```

 上述代码，定义了两个类型完全一样的函数pf和pf1。其返回的都是一个函数指针。而该函数指针又指向一个返回函数指针的函数。这一点通过is_same的成员value已经能够确定（参见4.1.1）。而仔细看一看函数类型的声明，可以发现老式的声明法可读性非常差。而追踪返回类型只需要依照从左向右（原文这里写从右向左）的方式，就可以将嵌套的声明解析出来。这大大提高了嵌套函数这类代码的可读性。

除此之外，追踪返回类型也被广泛地应用在转发函数中，如下：

```c++
#include <iostream>

using namespace std;

double foo(int a) {
    return (double) a + 0.1;
}

int foo(double b) {
    return (int) b;
}

template<class T>
auto Forward(T t) -> decltype(foo(t)) {
    return foo(t);
}

int main() {
    cout << Forward(2) << endl;  // 2.1
    cout << Forward(0.5) << endl;  // 0
    return 0;
}
```

上述代码，由于使用了追踪返回类型，可以实现参数和返回类型不同时的转发。

追踪返回类型还可以用在函数指针中，其声明方式与追踪返回类型的函数比起来，并没有太大的区别。如：

`auto (*fp)() -> int;`

和

`int (*fp)();`

的函数指针声明是等价的。同样的情况也适用于函数引用，如：

`auto (&fr)() -> int;`

和

`int (&fr)();`

的声明也是等价的。

如下验证代码：

```c++
#include <iostream>

using namespace std;

int foo() {
    return 11;
}

int main() {
    auto (* fp)() -> int = foo;
    cout << fp() << "\n";  // 11

    auto (& fr)() -> int = *foo;
    cout << fr() << "\n";  // 11

    return 0;
}
```

除了以上所描述的函数模板、普通函数、函数指针、函数引用以外，追踪返回类型还可以用在结构或类的成员函数、类模板的成员函数里，其方法大同小异。另外，没有返回值的函数也可以被声明为追踪返回类型，只需要将返回类型声明为void即可。

### 4.5 基于范围的for循环

在C++98标准中，如果要遍历一个数组，通常如下：

```c++
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int* p;
    for (p = arr; p < arr + sizeof(arr) / sizeof(arr[0]); ++p) {
        *p *= 2;
    }

    for (p = arr; p < arr + sizeof(arr) / sizeof(arr[0]); ++p) {
        cout << *p << '\t';
    }

    return 0;
}
```

上述代码，使用指针p来遍历数组arr中的内容，两个循环分别完成每个元素自乘以2和打印工作。如果使用for_each，如下：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

// 原文这里返回值为int
void action1(int& e) {
    e *= 2;
}

void action2(int& e) {
    cout << e << '\t';
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    for_each(arr, arr + sizeof(arr) / sizeof(arr[0]), action1);
    for_each(arr, arr + sizeof(arr) / sizeof(arr[0]), action2);
    
    // 使用lambda表达式
    for_each(arr, arr + sizeof(arr) / sizeof(arr[0]), [](int& e) { e *= 2; });
    for_each(arr, arr + sizeof(arr) / sizeof(arr[0]), [](int& e) { cout << e << '\t'; });
    return 0;
}
```

for_each使用了迭代器的概念，其迭代器就是指针。由于迭代器内含了自增操作的概念，所以上述代码中的++p操作则可以不写在for_each循环中了。不过无论上述两份代码，都需要告诉循环体其界限的范围，即arr到arr + sizeof(arr)/sizeof(arr[0])之间，才能按元素执行操作。

很多时候，对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，也是容易犯错误的。而C++11也引入了基于范围的for循环，可以很好地解决了这个问题。

任何发一下基于范围的for循环改写的例子，如下：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    for (int& e : arr) {
        e *= 2;
    }

    for (int& e : arr) {
        cout << e << '\t';
    }

    return 0;
}
```

上例中，表示是在数组arr中用迭代器e进行遍历。这样，遍历数组和STL容器就非常容易了。

基于范围的for循环中迭代的变量采用了引用的形式，如果迭代变量的值在循环中不会被修改，那完全可以不用引用的方式来做迭代变量。如上例中第二个基于范围的for循环可以被改为：

```c++
for (int e : arr) {
    cout << e << '\t';
}
```

结合之前讲过的auto类型指示符，循环会显得更简练：

```c++
for (auto e : arr) {
    cout << e << '\t';
}
```

基于范围的for循环跟普通循环是一样的，可以用continue语句来跳过循环的本次迭代，而用break语句来跳出整个循环。

值得指出的是，是否能够使用基于范围的for循环，必须依赖于一些条件。首先，就是for循环迭代的范围是可确定的。对于类来说，如果该类有begin()和end()函数，那么begin和end之间就是for循环迭代的范围，对于数组而言，就是数组的第一个和最后一个元素间的范围。其次，基于范围的for循环还要求迭代的对象实现++和==等操作符。对于标准库中的容器，如string、array、vector、deque、list、queue、map、set等，不会有问题，因为标准库总是保证其容器定义 了相关的操作。普通的已知长度的数组也不会有问题。而用户自己写的类，则需要自行操作相关操作。

相反，如果数组大小不能确定的话，是不能使用基于范围的for循环的，如下，会导致编译时的错误：

```c++
#include <iostream>

using namespace std;

void func(int a[]) {
    for (auto e : a) {  // 编译错误：error: 'begin' was not declared in this scope
        cout << e;
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    func(arr);

    return 0;
}
```

上述代码会报错，因为作为参数传递而来的数组a的范围不能确定，因此也就不能使用基于范围循环for循环对其进行迭代的操作。这里其实a是作为一个int*指针变量传入的。

另外一点，习惯了迭代器的C++程序员可能需要注意，就是基于范围的循环使用在标准库的容器中时，如果使用auto来声明迭代的对象的话，那么这个对象不会是迭代器对象，而是容器中保存的变量对象。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;


int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    for (auto i = v.begin(); i != v.end(); ++i) {
        cout << *i << endl;  // i是迭代器对象
    }

    for (auto e : v) {
        cout << e << endl;  // e是解引用后的对象
    }
    return 0;
}
```

需要注意e和*i的区别就可以了。

------

<https://blog.csdn.net/shenwanjiang111/article/details/59511235>

另外，如果想对自定义类型实现基于范围的循环，为了使一个数据具有可迭代性，他必须与STL迭代具有相似的工作属性：

1. 具有begin和end方法，即可以作为成员函数也可以作为独立的函数，函数返回数据结构开始和结束的迭代器。
2. 迭代器必须支持操作符*，！=，++，即可以作为成员函数也可作为独立函数（详细的信息可以参考操作符重载）。
在这里请注意，++操作符必须是前缀的，它被声明为不带参数的operator函数。

就是这样，用这五个函数，你就可以造一个数据结构，能够满足基于范围的for循环。但是begin()和end()方法是非成员函数（begin(container)代替container.begin()），你甚至可以为了适应已经存在的数据结构，不必刻意地支持STL类型的迭代器。你必须做的就是创建你自己的迭代器，它支持*（指针），前缀自加（++）和！=还要定义迭代器的begin和end，就可以了。

因为基于范围的循环是如此漂亮，我猜想那些不支持STL iterator的新容器类，都想添加一个适配器，去允许基于范围的for循环的。下面是一个小程序，创建一个简单的迭代器，然后实现基于范围的for循环。其中，首先创建IntVector类型，大小是100，可以被一个迭代器Iter迭代。代码如下：

```c++
// a simple iterator sample.
#include <iostream>

using namespace std;

// forward-declaration to allow use in Iter
class IntVector;

class Iter {
private:
    int _pos;
    const IntVector* _p_vec;

public:
    Iter(const IntVector* p_vec, int pos) : _pos(pos), _p_vec(p_vec) {}

    // these three methods form the basis of an iterator for use with a range-based for loop
    bool operator!=(const Iter& other) const {
        return _pos != other._pos;
    }

    // this method must be defined after the definition of IntVector since it needs to use it
    int operator*() const;

    const Iter& operator++() {
        ++_pos;
        // although not strictly necessary for a range-based for loop
        // following the normal convention of returning a value from
        // operator++ is a good idea.
        return *this;
    }
};

class IntVector {
private:
    int _data[100];

public:
    IntVector() {}

    int get(int col) const {
        return _data[col];
    }

    Iter begin() const {
        return Iter(this, 0);
    }

    Iter end() const {
        return Iter(this, 100);
    }

    void set(int index, int val) {
        _data[index] = val;
    }
};

int Iter::operator*() const {
    return _p_vec->get(_pos);
}

// sample usage of the range-based for loop on IntVector
int main() {
    IntVector v;

    for (int i = 0; i < 100; i++) {
        v.set(i, i);
    }
    for (int i : v) {
        cout << i << endl;
    }
}
```

 可以看到，这里基于范围的循环遍历的对象，实际是Iter对象，而不是直接的自定义结构。所以begin和end函数用于指定循环的开始对象和结束对象，++操作符用于迭代对象的前移，!=用于判断是否结束，\*操作符用于从迭代对象解引用出实际存储对象。

另有一个例子用于生成像Python一样，基于范围遍历Range(1, 5)对象，如下：

<https://www.cnblogs.com/lidabo/p/3937208.html>

```c++
#include <iostream>

using namespace std;

class FakeIter {
    typedef long _VType;  //数值的类型为long。当然了，也可以写个模板出来
public:

    explicit FakeIter(_VType val)
        : value_(val) {}

    bool operator!=(const FakeIter& other) const {
        return (this->GetValue()) != (other.GetValue());
    }

    _VType operator*() const {
        return GetValue();
    }

    const FakeIter& operator++() {
        ++value_;
        return *this;
    }

private:
    _VType GetValue() const {
        return value_;
    }

    _VType value_;
};

class Range {
    typedef long _VType;    //同样，也可以弄个模板出来，但是就不方便用了
public:
    Range(_VType begin_v, _VType end_v)
        : begin_value_(begin_v), end_value_(end_v) {
        cout << "Range::Range()" << endl;
    }

    ~Range() {
        cout << "Range::~Range()" << endl;
    }

    FakeIter begin() const {
        cout << "Range::begin()" << endl;
        return FakeIter(begin_value_);
    }

    FakeIter end() const {
        cout << "Range::end()" << endl;
        return FakeIter(end_value_);
    }

private:
    _VType begin_value_;
    _VType end_value_;
};

int main() {
    for (auto x: Range(1, 5)) {
        std::cout << x << endl;
    }
    std::cout << "Loop end" << endl;
}
输出：
Range::Range()
Range::begin()
Range::end()
1
2
3
4
Range::~Range()
Loop end
```

## 第5章 提高类型安全

### 5.1 强类型枚举

#### 5.1.1 枚举：分门别类与数值的名字

`enum Gender { Male, Female};`

定义了Gender（性别）的枚举类型。编译器会默认为Male赋值0，为Female赋值1.这是C对名称的简单包装，即将名称对应到数值。

枚举类型也可以是匿名的。如当程序中需要“数值的名字”的时候，常常使用以下3种方式来实现：

第一种方式是宏，如：

```c++
#define Male 0
#define Female 1
```

宏的弱点在于其定义的只是预处理阶段的名字，如果代码中有Male或Female的字符串，无论在什么位置一律将被替换。这有时候会干扰到正常的代码，因此很多时候为了避免这种情况，会让宏全部以大写字母来命名，以区别于正常的代码。

第二种方式——匿名的enum的状况会好些。

`enum { Male, Female };`

这里的匿名枚举中的Male和Female都是编译时期的名字，会得到编译器的检查。相比于宏的实现，匿名枚举不会有干扰正常代码的尴尬。

在C++中，更受推荐的是第三种方式——静态常量。如：

```c++
const static int Male = 0;
const static int Female = 1;
```

Male和Female的名字同样得到编译时期检查。由于是静态常量，其名字作用域也被很好地局限于文件内。不过相比于enum，静态常量不仅仅是一个编译时期的名字，编译器还可能会为Male和Female在目标代码中产生实际的数据，这会增加一点存储空间。相比而言，匿名的枚举似乎更为好用。

虽然enum有些“奇怪”的用途，不过作为“枚举类型”本身而言，enum并非完美。

#### 5.1.2 有缺陷的枚举类型

C/C++的enum有个很“奇怪”的设定，就是具名（有名字）的enum类型的名字，以及enum的成员的名字都是全局可见的。这与C++中具名的namespace、class/struct及union必须通过“名字::成员名”的方式访问相比是格格不入的（namespace等被称为强作用域类型，而enum则是非强作用域类型）。如下面两个枚举：

```c++
enum Type { General, Light, Medium, Heavy };
enum Category { General, Pistol, MachineGun, Cannon };
```

Category中的General和Type中的General都是全局的名字，因此编译会报错。

下面代码，则是通过一个namespace分割了全局空间，但namespace中的成员依然会被enum成员污染的例子。

```c++
#include <iostream>

using namespace std;

namespace T {
    enum Type { General, Light, Medium, Heavy };
}

namespace {
    enum Category { General = 1, Pistol, MachineGun, Cannon };
}

int main() {
    T::Type t = T::Light;
    if (t == General) {  // 会有警告：warning: comparison between 'enum T::Type' and 'enum {anonymous}::Category' [-Wenum-compare]
        cout << "General Weapon" << endl;  // 会打印
    }
    return 0;
}
```

上例中，Category在一个匿名namespace中，所以所有枚举成员名都默认进入全局名字空间。一旦程序员在检查t的值的时候忘记使用了namespace T，就会导致错误的结果（事实上，有的编译器会在这里做出一些警告，但并不会阻止编译，而有的编译器则不会警告）。

另外，由于C中枚举被设计为常量数值的“别名”的本性，所以枚举的成员总是可以被隐式地转换为整形。这也是不安全的。如下：

```c++
#include <iostream>

using namespace std;

enum Type { General, Light, Medium, Heavy };
// enum Category { General = 1, Pistol, MachineGun, Cannon };  // 无法编译通过，重复定义General
enum Category { Pistol, MachineGun, Cannon };

struct Killer {
    Killer(Type t, Category c) : type(t), category(c) {}

    Type type;
    Category category;
};

int main() {
    Killer cool(General, MachineGun);
    // ...其他很多代码...
    if (cool.type >= Pistol) {  // warning: comparison between 'enum Type' and 'enum Category' [-Wenum-compare]
        cout << "It is not a pistol" << endl;
    }

    cout << is_pod<Type>::value << endl;  // 1
    cout << is_pod<Category>::value << endl;  // 1
    return 0;
}
```

上述代码中，类型Killer同时拥有Type和Category两种命名类似的枚举类型成员。程序员错用了成员type与Category比较，这是由于枚举类型数值在进行数值比较运算时，首先被隐式地提升为Int类型数据，然后自由地进行比较运算。当然，程序员本意并非如此（事实上，我们实验机上的编译器会给出警告说不同枚举类型枚举成员间进行了比较，但程序还是编译通过了，因为标准并不阻止这一点）。

为了解决这一问题，目前程序员一般会对枚举类型进行封装。如下改良后的版本：

```c++
#include <iostream>

using namespace std;

class Type {
public:
    enum type { general, light, medium, heavy };
    type val;
public:
    Type(type t) : val(t) {}

    bool operator>=(const Type& t) { return val >= t.val; }

    static const Type General, Light, Medium, Heavy;
};

const Type Type::General(Type::general);
const Type Type::Light(Type::light);
const Type Type::Medium(Type::medium);
const Type Type::Heavy(Type::heavy);

class Category {
public:
    enum category { pistol, machineGun, cannon };
    category val;
public:
    Category(category c) : val(c) {}

    bool operator>=(const Category& c) { return val >= c.val; }

    static const Category Pistol, MachineGun, Cannon;
};

const Category Category::Pistol(Category::pistol);
const Category Category::MachineGun(Category::machineGun);
const Category Category::Cannon(Category::cannon);

struct Killer {
    Killer(Type t, Category c) : type(t), category(c) {}

    Type type;
    Category category;
};

int main() {
    Killer notCool(Type::General, Category::MachineGun);
    // ...其他很多代码...
    if (notCool.type >= Type::General) {  // 可以通过编译
        cout << "It is not general" << endl;
    }
    if (notCool.type >= Category::Pistol) {  // 该句无法编译通过 error: no match for 'operator>=' (operand types are 'Type' and 'const Category')
        cout << "It is not a pistol" << endl;
    }

    cout << is_pod<Type>::value << endl;  // 0
    cout << is_pod<Category>::value << endl;  // 0
    return 0;
}
```

封闭的代码长得让人眼花缭乱，不过简单地说，封装即是使得枚举成员成为class的静态成员。由于class中的数据不会被默认转换为整型数据（除非定义相关操作符函数），所以可以避免被隐式转换。也可以看到，通过封装，枚举的成员也不会再污染全局名字空间了，使用时还必须带上class的名字，之前枚举的一些小毛病都能够得到克服。

不过这种解决方案并非完全，至少可能有三个缺点：

- 一般程序员不会为了简单的enum声明这么复杂的封装。
- 由于封装且采用了静态成员，原本属于POD的enum被封装成了非POD的了（is_pod均返回为0），这会导致一系列的损失（参见3.6节）。
- 大多数系统的ABI规定，传递参数的时候如果参数是个结构体，就不能使用寄存器来传参（只能放在堆栈上），而相对地，整型可以通过寄存器中传递。所以一旦将class封装版本的枚举作为函数参数传递，就可能带来一定的性能损失。

无论上述哪一条，对于封装方案来说都是极为不利的。

此外，枚举类型所占用的空间大小也是一个“不确定量”。标准规定，C++枚举所基于的“基础类型”是由编译器来具体指定实现的，这会导致枚举类型的基本类型的不确定性问题（尤其是符号性）。如下：

```c++
#include <iostream>

using namespace std;

enum C { C1 = 1, C2 = 2 };
enum D { D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U };
enum E { E1 = 1, E2 = 2, Ebig = 0xFFFFFFFFFLL };

int main() {
    cout << sizeof(C1) << endl;  // 4

    cout << Dbig << endl;  // 编译器输出不同，g++: 4294967280
    cout << sizeof(D1) << endl;  // 4
    cout << sizeof(Dbig) << endl;  // 4

    cout << Ebig << endl;  // 68719476735
    cout << sizeof(E1) << endl;  // 8
    return 0;
}
```

上述代码中，编译器会根据数据类型的不同对enum应用不同的数据长度。在对g++的测试中，普通的枚举使用了4字节的内存，而当需要的时候，会扩展为8字节。对于不同的编译器，上例中的Dbig的输出结果将会不同：使用Visual C++编译程序的输出结果为-16，而使用g++来编译输出为4294967280。这是由于Visual C++总是使用无符号类型作为枚举的底层实现，而g++会根据枚举的类型进行变动造成的。

#### 5.1.3 强类型枚举以及C++11对原有枚举类型的扩展

非强类型作用域，允许隐式转换为整型，占用存储空间及符号性不确定，都是枚举类的缺点。针对这些缺点，新标准C++引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”（strong-typed enum）。

声明强类型枚举非常简单，只需要在enum后加上关键字class。如：

`enum class Type { General, Light, Medium, Heavy };`

就声明了一个强类型的枚举Type。强类型枚举具有以下几点优势：

* 强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。

* 转换限制，强类型枚举成员的值不可以与整型隐式地相互转换。

* 可以指定底层类型。强类型枚举默认的底层类型为int，也可以显式地指定底层类型，具体方法为在枚举名称后面加上“: type”，其中type可以是除wchar_t以外的任何整型。比如：

  `enum class Type: char { General, Light, Medium, Heavy };`

  就指定了Type是基于char类型的强类型枚举。

看具体的例子：

```c++
#include <iostream>

using namespace std;

enum class Type { General, Light, Medium, Heavy };
enum class Category { General = 1, Pistol, MachineGun, Cannon };

int main() {
    Type t = Type::Light;
    t = General;  // 编译失败，必须使用强类型名称
    if (t == Category::General) {  // 编译失败，必须使用Type中的General
        cout << "General Weapon" << endl;
    }
    if (t > Type::General) {  // 通过编译
        cout << "Not General Weapon" << endl;
    }
    if (t > 0) {  // 编译失败，无法转换为int类型
        cout << "Not General Weapon" << endl;
    }
    if ((int) t > 0) {  // 通过编译
        cout << "Not General Weapon" << endl;
    }

    cout << is_pod<Type>::value << endl;  // 1
    cout << is_pod<Category>::value << endl;  // 1

    return 0;
}
```

上述代码，两个强类型枚举Type和Category，都包含了一个称为General的成员。由于强类型枚举的名字不会输出到父作用域，因此不会有编译问题。也由于不输出成员名字，所以在使用该类型成员的时候必须加上其所属的枚举类型的名字。此外，可以看到，枚举成员间仍然可以进行数值式的比较，但不能够隐式地转为int型。如果要将强类型枚举转化为其他类型，必须进行显式转换。

强类型枚举制式enum成员和int之间的转换，使得枚举更加符合“枚举”的本来意义，即对同类进行列举的一个集合，而定义其与数值间的关联则使之能够默认拥有一种对成员排列的机制。而制式成员名字输出则进一步避免了名字空间冲突的问题。这两点跟之前我们使用class对枚举进行封装并不二致。不过新的强类型枚举没有任何class封装枚举的缺点。可以看到，Type和Category都是POD类型，不会像class封装版本一样被编译器视为结构体，书写也很简便。在拥有类型安全和强作用域两重优点的情况下，几乎没有任何额外的开销。

由于可以指定底层基于的基本类型，可以避免编译器不同而带来的不可移植性。设置较小的基本类型也可以节省内存空间，如下：

```c++
#include <iostream>

using namespace std;

enum class C : char { C1 = 1, C2 = 2 };
enum class D : unsigned int { D1 = 1, D2 = 2, Dbig = 0xFFFFFFF0U };

int main() {
    cout << sizeof(C::C1) << endl;  // 1

    cout << (unsigned int) D::Dbig << endl;  // 编译器输出一致，4294967280
    cout << sizeof(D::D1) << endl;  // 4
    cout << sizeof(D::Dbig) << endl;  // 4
    return 0;
}
```

上述代码，为强类型枚举C指定底层基本类型为char，因为我们只有C1、C2两个值较小的成员，一个char中心保存所有的枚举成员。而对于强类型枚举D，指定基本类型为unsigned int，则所有编译器都会使用无符号的unsigned int来保存该枚举。故各个编译器都能保证一致的输出。

相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展。

**首先是底层的基本类型方面**。在新标准C++11中，原有枚举类型的底层类型是默认情况下，仍然由编译器来具体指定实现。但也可以跟强类型枚举类一样，显式地由程序员来指定。其指定的方式跟强类型枚举一样，都是枚举名称后面加上“: type”，其中type可以是除wchar_t以外的任何整型。比如：

`enum Type: char { General, Light, Medium, Heavy };`

在C++11中也是一个合法的enum声明。

**第二个扩展则是作用域的**。在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。如：

```c++
enum Type { General, Light, Medium, Heavy };
Type t1 = General;
Type t2 = Type::General;
```

General和Type::General两行都是合法的使用形式。

这两个扩展都保留了向后兼容性，也方便了程序员在代码中同时操作两种枚举类型。

在声明强类型枚举的时候，也可以使用关键字enum struct。事实上，enum struct和enum class在语法上没有任何区别（enum class的成员没有公有私有之分，也不会使用模板来支持泛化的声明）。

对于匿名的enum class，由于enum class是强类型作用域的，故匿名的enum class很可能什么都做不了，如下：

```c++
#include <iostream>

using namespace std;

enum class { General, Light, Medium, Heavy } weapon;  // 编译失败，error: unnamed scoped enum is not allowed

int main() {
    weapon = General;  // 无法编译通过
    bool b = (weapon == weapon::General);  // 无法编译通过
    return 0;
}
```

上述代码声明一个匿名的enum class实例weapon，却无法对其设置值或者比较其值（这和匿名struct是不一样的）。使用enum class的时候，应该总是为enum class提供一个名字（我们实验机上的clang编译器以及XLC编译器甚至会因为用户使用匿名的强类型枚举而阻止编译）。在实际使用中必须注意（当然，程序员还是可以通过decltype来获得匿名强类型枚举的类型并且进行使用，即使这样做没什么太大的意义）。

### 5.2 堆内存管理：智能指针与垃圾回收

#### 5.2.1 显式内存管理 P182

由于程序没有正确处理堆内存的分配与释放，从语言层面来讲，将其归纳为以下：

* 野指针：一些内存单元已被释放，之前指向它的指针却还在使用。这些内存有可能被运行时系统重新分配给程序使用，从而导致了无法预测的错误。
* 重复释放：程序试图去释放已经被释放过的单元，或者释放已经被重新分配过的内存单元，就会导致重复释放错误。通常重复释放内存会导致C/C++运行时系统打印出大量错误及诊断信息。
* 内存泄漏：不再需要使用的内存单元如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，就会导致内存占用剧增。

让程序员摆脱内存管理的细节，在C++中，一个这样的机制就是标准库中的智能指针。在C++11新标准中，智能指针被进行了改进，以更加适应实际的应用需求。而进一步地，标准库还提供了所谓“最小垃圾回收”的支持。

#### 5.2.2 C++11的智能指针 P183

auto_ptr在一定程度上避免了堆内存忘记释放而造成的问题。不过auto_ptr有一些缺点（拷贝时返回一个左值，不能调用delete []等），所以在C++11标准中被废弃了。C++11标准中改用unique_ptr、shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。

看一下C++11中使用新的智能指针的简单例子，如下：

```c++
#include <iostream>
#include <memory>

using namespace std;

int main() {
    unique_ptr<int> up1(new int(11));  // 无法复制的unique_ptr
//    unique_ptr<int> up2 = up1;  // 不能通过编译
    cout << *up1 << endl;  // 11

    unique_ptr<int> up3 = move(up1);  // 现在p3是数据唯一的unique_ptr的智能指针
    cout << up1.get() << endl;  // 0，up1已经是空指针
//    cout << *up1 << endl;  // 运行时错误
    up1.reset();  // 不会导致运行时错误，空指针

    cout << *up3 << endl;  // 11
    up3.reset();  // 显式释放内存
//    cout << *up3 << endl;  // 运行时错误
    up3.reset(new int(12));  // 重新接new出的int*指针
    cout << *up3 << endl;  // 12

    shared_ptr<int> sp1(new int(22));
    shared_ptr<int> sp2 = sp1;
    cout << *sp1 << endl;  // 22
    cout << *sp2 << endl;  // 22
    sp1.reset();
    cout << *sp2 << endl;  // 22
    cout << sp2.get() << endl;  // 打印指针地址：0x191560
    cout << sp2 << endl;  // 同sp2.get()，打印指针地址：0x191560
    return 0;
}
```

每个unique_ptr都是唯一地“拥有”所指向的对象内存，由于up1唯一地占有了new分配的堆内存，所以up2无法共享其“所有权”。事实上，这种“所有权”仅能够通过标准库的move函数来转移。代码中up3的定义，`unique_ptr<int> up3 = move(up1);`一旦“所有权”转移成功了，原来的unique_ptr指针就失去了对象内存的所有权。此时再使用已经“失势”的unique_ptr，就会导致运行时的错误。上例中的后段使用*up1就是很好的例子。

 从实现上讲，unique_ptr是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型（在7.2节可以看到如何删除一个类的拷贝构造函数）。程序员仅可以使用右值对unique_ptr对象进行构造，而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象即刻失去了对指针的“所有权”。

而shared_ptr同样形如其名，允许多个该智能指针共享地“拥有”同一堆分配对象的内存。与unique_ptr不同的是，由于在实现上采用了引用计数，所以一旦一个shared_ptr指针放弃了“所有权”（失效），其他的shared_ptr对对象内存的引用并不会受到影响。上述代码智能指针sp2就很好地说明了这种状况。虽然sp1调用了reset成员函数，但由于sp1和sp2共享了new分配的堆内存，所以sp1调用reset成员函数只会导致引用计数的降低，而不会导致堆内存的释放。只有在引用计数归零的时候，shared_ptr才会真正释放所占有的霍内存的空间。

C++11标准中，智能指针还包括了weak_ptr这个类模板。weak_ptr的使用更为复杂一点，它可以指向shared_ptr指针指向的对象内存，却并不拥有该内存。而使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象。且在所指对象内存已经无效时，返回指针空值（nullptr，参见7.1节）。怕在验证shared_ptr智能指针的有效性上会很有作用，如下：

```c++
#include <iostream>
#include <memory>

using namespace std;

void Check(weak_ptr<int>& wp) {
    shared_ptr<int> sp = wp.lock();  // 转换为shared_ptr<int>
    if (sp != nullptr) {
        cout << "still " << *sp << endl;
        cout << "wp expired: " << wp.expired() << endl;  // 与.lock()返回对象是同样含义，如果返回的shared_ptr不为nullptr，则wp.expired()返回false
    } else {
        cout << "pointer is invalid." << endl;
        cout << "wp expired: " << wp.expired() << endl;  // 如果返回的shared_ptr为nullptr，则wp.expired()返回true
    }
}

int main() {
    shared_ptr<int> sp1(new int(22));
    shared_ptr<int> sp2 = sp1;
    weak_ptr<int> wp = sp1;   // 指向shared_ptr<int>所指对象

    cout << *sp1 << endl;  // 22
    cout << *sp1 << endl;  // 22
    Check(wp);  // still 22

    sp1.reset();
    cout << *sp2 << endl;  // 22
    Check(wp);  // still 22

    sp2.reset();
    Check(wp);  // pointer is invalid.
    return 0;
}
```

上述代码定义了一个共享对象内存的两个shared_ptr——sp1及sp2。而weak_ptr wp同样指向该对象内存。在sp1及sp2都有效的时候，调用wp的lock函数，将返回一个有效的shared_ptr对象供使用，于是Check函数会输出以下内容：

still 22

分别调用了sp1及sp2的reset函数，会导致唯一的堆内存对象的引用计数降至0。而一旦引用计数归0，shared_ptr\<int\>就会释放堆内存空间，使之失效。此时再调用weak_ptr的lock函数时，则返回一个指针空值nullptr。这时Check函数则会打印出：

pointer is invalid

这样的语句了。在整个过程当中，只有shared_ptr参与了引用计数，而weak_ptr没有影响其指向的内存的引用计数。因此可以验证shared_ptr指针的有效性。

简单情况下，用unique_ptr代替以前使用auto_ptr的代码就可以使用C++11中的智能指针。而shared_ptr及weak_ptr则可用在用户需要引用计数的地方。

总地来说，虽然智能指针能帮助用户进行有效的堆内存管理，但还是需要程序员显式地声明智能指针，而完全不需要考虑回收指针类型的内存管理方案可能会更讨人喜欢。当然，这种方案早就有了，就是垃圾回收机制。

------

关于weak_ptr的介绍：

<https://blog.csdn.net/fengbingchun/article/details/52203825>

weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。同样，在weak_ptr析构时也不会导致引用计数的减少，它只是一个静静地观察者。weak_ptr没有重载operator*和->，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。但它可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

weak_ptr用于解决”引用计数”模型循环依赖问题，weak_ptr指向一个对象，并不增减该对象的引用计数器。weak_ptr用于配合shared_ptr使用，并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。weak_ptr提供了**expired()**与**lock()**成员函数，**前者用于判断weak_ptr指向的对象是否已被销毁**，**后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空”shared_ptr)**。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shard_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。

当创建一个weak_ptr时，要用一个shared_ptr来初始化它。不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，**lock返回一个指向共享对象的shared_ptr**。**与任何其它shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在**。见下例：

```c++
#include <iostream>
#include <memory>

using namespace std;

int main() {
    shared_ptr<int> sp1(new int(22));
    shared_ptr<int> sp2 = sp1;
    weak_ptr<int> wp = sp1;   // 指向shared_ptr<int>所指对象

    cout << sp1.use_count() << endl;  // 2
    
	shared_ptr<int> lockSp3 = wp.lock();
    cout << sp1.use_count() << endl;  // 3
    return 0;
}
```

下图列出了weak_ptr支持的操作(来源于C++ Primer Fifth Edition 中文版)：
![](pictures\weak_ptr支持的操作.png)

**weak_ptr指向的是赋值时shared_ptr指针的内存对象**，如果内存对象释放掉即使shared_ptr对象还在，依然weak_ptr也会无效了，如下：

```c++
#include <iostream>
#include <memory>

using namespace std;

int main() {
    shared_ptr<int> sp1(new int(22));
    weak_ptr<int> wp1 = sp1;

    sp1 = make_shared<int>(30);  // 此时wp1指向的shared_ptr内存数据已经释放
    weak_ptr<int> wp2 = sp1;

    cout << wp1.lock().get() << endl;  // 0，空指针
    cout << wp1.expired() << endl;  // true
    cout << wp2.expired() << endl;  // false

    return 0;
}
```

在vector中使用shared_ptr和weak_ptr，如下：

```c++
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>

using namespace std;

class Controller {
public:
    int Num;
    std::string Status;
    std::vector<std::weak_ptr<Controller>> others;

    explicit Controller(int i) : Num(i), Status("On") {
        std::cout << "Creating Controller" << Num << std::endl;
    }

    ~Controller() {
        std::cout << "Destroying Controller" << Num << std::endl;
    }

    // Demonstrates how to test whether the pointed-to memory still exists or not.
    void CheckStatuses() const {
        for_each(others.begin(), others.end(), [](std::weak_ptr<Controller> wp) {
            try {
                auto p = wp.lock();
                std::cout << "Status of " << p->Num << " = " << p->Status << std::endl;
            }
            catch (std::bad_weak_ptr b) {
                std::cout << "Null object" << std::endl;
            }
        });
    }
};

int main() {
    std::vector<std::shared_ptr<Controller>> v;

    v.push_back(std::shared_ptr<Controller>(new Controller(0)));
    v.push_back(std::shared_ptr<Controller>(new Controller(1)));
    v.push_back(std::shared_ptr<Controller>(new Controller(2)));
    v.push_back(std::shared_ptr<Controller>(new Controller(3)));
    v.push_back(std::shared_ptr<Controller>(new Controller(4)));

    // Each controller depends on all others not being deleted.
    // Give each controller a pointer to all the others.
    for (int i = 0; i < v.size(); ++i) {
        for_each(v.begin(), v.end(), [v, i](std::shared_ptr<Controller> p) {
            if (p->Num != i) {
                v[i]->others.push_back(std::weak_ptr<Controller>(p));
                std::cout << "push_back to v[" << i << "]: " << p->Num << std::endl;
            }
        });
    }

    for_each(v.begin(), v.end(), [](std::shared_ptr<Controller>& p) {
        std::cout << "use_count = " << p.use_count() << std::endl;
        p->CheckStatuses();
    });
    return 0;
}
```

使用weak_ptr可以避免循环引用导致的内存泄漏，如下：

```c++
#include <iostream>
#include <memory>

using namespace std;
struct Child;

struct Parent {
    std::shared_ptr<Child> child;

    ~Parent() { std::cout << "Bye Parent" << std::endl; }

    void hi() const { std::cout << "Hello" << std::endl; }
};

struct Child {
    std::weak_ptr<Parent> parent;
    //std::shared_ptr<Parent> parent; // memory leak

    ~Child() { std::cout << "Bye Child" << std::endl; }
};

int main() {

    auto parent = std::make_shared<Parent>();
    auto child = std::make_shared<Child>();

    parent->child = child;
    child->parent = parent;
    child->parent.lock()->hi();
    // child->parent->hi();

    return 0;
}
输出：
Hello
Bye Parent
Bye Child
```

上例中，调用hi()先打印出hello，main函数中的child的shared_ptr对象释放，引用计数减1，然后main函数中的parent的shared_ptr对象释放，引用计数为0，调用Parent析构函数，先打印出Bye Parent，此时再释放child的shared_ptr对象，同时发现引用计数为0，调用Child的析构函数。

如果只构造parent和child两个shared_ptr对象，则析构顺序为child再parent，如下：

```c++
int main() {
    auto parent = std::make_shared<Parent>();
    auto child = std::make_shared<Child>();

    return 0;
}
输出：
Bye Child
Bye Parent
```

如果Child不使用weak_ptr，使用shared_ptr，则Parent和Child对象循环引用，造成内存泄漏，如下：

```c++
struct Child {
//    std::weak_ptr<Parent> parent;
    std::shared_ptr<Parent> parent; // memory leak

    ~Child() { std::cout << "Bye Child" << std::endl; }
};

int main() {

    auto parent = std::make_shared<Parent>();
    auto child = std::make_shared<Child>();

    parent->child = child;
    child->parent = parent;
//    child->parent.lock()->hi();
     child->parent->hi();

    return 0;
}
输出：
Hello
```

再看二叉树使用weak_ptr的情形，如下：

```c++
#include <iostream>
#include <memory>

using namespace std;
class Node
{
    int value;
public:
    std::shared_ptr<Node> leftPtr;
    std::shared_ptr<Node> rightPtr;
    // Just Changed the shared_ptr to weak_ptr
    std::weak_ptr<Node> parentPtr;
    Node(int val) : value(val)     {
        std::cout << "Contructor" << std::endl;
    }
    ~Node()     {
        std::cout << "Destructor" << std::endl;
    }
};

int main() {
    std::shared_ptr<Node> ptr = std::make_shared<Node>(4);
    ptr->leftPtr = std::make_shared<Node>(2);
    ptr->leftPtr->parentPtr = ptr;
    ptr->rightPtr = std::make_shared<Node>(5);
    ptr->rightPtr->parentPtr = ptr;
    std::cout << "ptr reference count = " << ptr.use_count() << std::endl;
    std::cout << "ptr->leftPtr reference count = " << ptr->leftPtr.use_count() << std::endl;
    std::cout << "ptr->rightPtr reference count = " << ptr->rightPtr.use_count() << std::endl;
    std::cout << "ptr->rightPtr->parentPtr reference count = " << ptr->rightPtr->parentPtr.lock().use_count() << std::endl;  // 这里调用了lock()函数构造了一个ptr的shared_ptr，所以引用计数加1为2，但此时的shared_ptr是临时变量，使用完立马释放了，所以下一句ptr.use_count()仍为1
    std::cout << "ptr reference count = " << ptr.use_count() << std::endl;
    std::cout << "ptr->leftPtr->parentPtr reference count = " << ptr->leftPtr->parentPtr.lock().use_count() << std::endl;  // 分析同上，为2
    std::cout << "ptr reference count = " << ptr.use_count() << std::endl;

    return 0;
}
输出：
Contructor
Contructor
Contructor
ptr reference count = 1
ptr->leftPtr reference count = 1
ptr->rightPtr reference count = 1
ptr->rightPtr->parentPtr reference count = 2
ptr reference count = 1
ptr->leftPtr->parentPtr reference count = 2
ptr reference count = 1
Destructor
Destructor
Destructor
```

#### 5.2.3 垃圾回收的分类 P187

垃圾回收的方式主要可以分为两大类：

1. 基于引用计数（reference counting garbage collector）的垃圾回收器

   引用计数做垃圾回收的算法的一个优点是实现很简单，该方法不会造成程序暂停，因为计数的增减与对象的使用是紧密结合的。此外，引用计数也不会对系统的缓存或者交换空间造成 冲突，因此被认为“副作用”较小。但这种方法比较难处理“环形引用”问题，此外计数带来的额外开销也并不小。

2. 基于跟踪处理（tracing garbage collector）的垃圾回收器

   相比于引用计数，跟踪处理的垃圾回收机制被更为广泛地应用。其基本方法是产生跟踪对象的关系图，然后进行垃圾回收。

虽然历来C++都没有公开地支持过垃圾回收机制，但垃圾回收并非某些语言的专利。事实上，C++11标准也开始对垃圾回收做了一定的支持，然后支持的程序还非常有限，但已经看到了C++语言变得更为强大的端倪。

#### 5.2.4 C++与垃圾回收 P188

Boehm和Spertus对初稿进行了简化，仅仅保留了支持垃圾回收的最基本的部分，即通过对语言的约束，来保证安全的垃圾回收。这也是现在看到的C++11标准中的“最小垃圾回收支持”的历史来由。

要保证安全的垃圾回收，首先必须知道C/C++语言中什么样的行为可能导致垃圾回收中出现“不安全”的状况。简单来说，不安全源自于C/C++语言对指针的“放纵”，即允许过分灵活的使用。如下：

```c++
int main() {
    int* p = new int;
    p += 10;  // 移动指针，可能导致垃圾回收器回收原来的指向的内存
    p -= 10;
    *p = 10;  // 再次使用原本相同的指针则可能无效
    return 0;
}
```

上述代码中，对指针p做了自加和自减操作。这在C/C++中被认为是合理的。因为指针有所指向的类型，自加或自减能够使程序员轻松地找到“下一个”同样的对象（实际是一个迭代器的概念，**仅仅是按指针类型移动地址，但是这里做完自加或自减后不能进行赋值操作，因为指针所指向的地址并未new成int**，可能会导致程序异常）。不过对于垃圾回收来说，一旦p指向了别的地址，则可认为p曾指向的内存不再使用。垃圾回收器可以据此对其进行回收。这对之后p的使用(*p = 10)带来的后果将是灾难的。

再看一个例子，如下：

```c++
int main() {
    int* p = new int;
    int* q = (int*) (reinterpret_cast<long long>(p) ^ 2012);  // q隐藏了p

    // 做一些其他工作，垃圾回收器可能已经回收了p指向对象
    q = (int*) (reinterpret_cast<long long>(q) ^ 2012);  // 这里的q == p
    *q = 10;
    return 0;
}
```

上述代码，用指针q隐藏了指针p。而之后又用可逆的异或运算将p“恢复”了出来。在main函数中，p实际指向的内存都是有效的。但由于该指针被隐藏了。垃圾回收器可能早早地将p指向的对象回收掉。同样，语句*q = 10的后果也是灾难性的。

指针的灵活使用可能是C/C++中的一大优势，而对于垃圾回收来说，却会带来很大的困扰。被隐藏的指针会导致编译器在分析指针的可达性（生命周期）时出错。而即使编译器开发出了隐藏指针分析的手段，其带来的编译开销也不会让程序员对编译时间的显著增长视而不见。历史上，解决这种问题的方法通常是新接口。C++11和垃圾回收的解决方案也不例外，就是让程序员利用这样的接口来提示编译器代码中存在指针不安全的区域。

#### 5.2.5 C++11与最小垃圾回收支持

C++新标准为了做到最小的垃圾回收支持，首先对“安全”的指针进行了定义，或者使用C++11中的术语说，安全派生（safely derived）的指针。安全派生的指针是指向由new分配的对象或其子对象的指针。安全派生指针的操作包括：

* 在解引用基础上的引用，比如：&*p。
* 定义明确的指针操作，比如：p+1。
* 定义明确的指针转换，比如：static_cast\<void*\>(p)。
* 指针和整型之间的reinterpret_cast，比如：reinterpret_cast\<intptr_t\>(p)。

------

**注意** intptr_t是C++11中一个可选择实现的类型，其长度等于平台上指针的长度（通过decltype声明）。

------

回头看看之前代码。reinterpret_cast\<long long\>(p)是合法的安全派生操作，而转换后的指针再进行异或操作：reinterpret_cast\<long long\>(p) ^ 2012之后，指针就不再是安全派生的了，这是因为异或操作（^）不是一个安全派生操作。同理，reinterpret_cast\<long long\>(p) ^ 2012也 是安全派生指针。因此，在使用内存回收器的情况下，*q = 10的行为是不确定的，如果程序在此处发生错误也是合理的。

在C++11的规则中，最小垃圾回收支持是基于安全派生指针这个概念的。可以通过get_pointer_safety函数查询来确认编译器是否支持这个特性。原型如下：

```c++
inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }
```

其返回一个pointer_safety类型的值。如果该值为pointer_safety::strict，则表明编译器支持最小垃圾回收及安全派生指针等相关概念，如果该值为pointer_safety::relaxed或pointer_safety::preferred，则表明编译器并不支持，基本上跟没有垃圾回收的C和C++98一样。不过按照一些解释，pointer_safety::preferred和pointer_safety::relaxed也略有不同，前者垃圾回收器可能被用作一些辅助功能，如内存泄露检测或检测对象是否被一个错误的指针解引用。

本地试验：

```c++
#include <iostream>
#include <memory>

using namespace std;

int main() {
    // enum class pointer_safety { relaxed, preferred, strict };
    pointer_safety pointerSafety = get_pointer_safety();
    cout << (int) pointerSafety << endl;  // 0
    return 0;
}
```

如果代码中出现了指针不安全使用的状况，C++11允许程序员通过一些API来通知垃圾回收器不得回收该内存。C++11的最小垃圾回收支持使用了垃圾回收的术语，即需声明该内存为“可到达”的（**不要回收这块内存**）：

```c++
void declare_reachable(void*);

template <typename T>
T* undeclare_reachable(T* p) nonexcept;
```

declare_reachable()显式地通知垃圾回收器某一个对象应该被认为可达的，即使它的所有指针都对回收器不可见。undeclare_reachable()则可以取消这种可达声明。针对之前代码，对隐藏的指针做一些声明，如下（本地运行可成功，因为不支持垃圾回收，所以declare_reachable和undeclare_reachable啥都没做）：

```c++
#include <iostream>
#include <memory>

using namespace std;

int main() {
    int* p = new int;
    declare_reachable(p);  // 在p被隐藏之前声明为可达的
    int* q = (int*) ((long long) p ^ 2012);

    // 解除可达声明
    q = undeclare_reachable<int>((int*) ((long long) q ^ 2012));  // 这里可以不用加<int>，模板函数可以自动推导出参数类型
    *q = 10;
    return 0;
}
```

上述代码可能是一个能够运行的例子。在p指针被不安全派生（隐藏）之前使用declare_reachable声明其是可达的。这样，它会被垃圾回收器忽略而不被回收。在通过可逆的异或运算使得q指针指向p所指对象时，则使用了undeclare_reachable来取消可达声明。注意undeclare_reachable不是通知垃圾回收器p所指对象已经可以回收。实现上，declare_reachable和undeclare_reachable只是确立了一个代码范围，即在两者之间的代码运行中，p所指对象不会被垃圾回收器所回收。

注意一个细节，declare_reachable只需要传入一个简单的void\*指针，但undeclare_reachable却被设计为一个函数模板。这是一个极不对称的设计。但事实上undeclare_reachable使用模板的主要目的是为了返回合适类型以供程序使用。而垃圾回收器本来就知道指针所指向的内存的大小，因此declare_reachable传入void\*指针就已经足够了。

有时程序员会选择在一大片连续的堆内存上进行指针式操作，为了让垃圾回收器不关心该区域，也可以使用declare_no_pointers和undeclare_no_pointers函数来告诉垃圾回收器该内存区域不存在有效的指针。

```c++
void declare_no_pointers(char*, size_t) noexcept;

void undeclare_no_pointers(char*, size_t) noexcept;
```

其使用方式与declare_reachable及undeclare_reachable类似，不过指定的是从p开始的连续n的内存。

本地编译器（gdb version8.1和VS2019）的上述4个函数都是空实现：

```c++
inline void
declare_reachable(void*) { }

template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }

inline void
declare_no_pointers(char*, size_t) { }

inline void
undeclare_no_pointers(char*, size_t) { }
```

#### 5.2.6 垃圾回收的兼容性

尽管在设计C++11标准时想尽可能保证向后兼容性（即现在写的代码在以后可以正常使用），但是对于垃圾回收来说，破坏向后兼容是不可避免的。通过情况下，如果想要程序使用垃圾回收，或者可靠的内存泄漏检测，就必须做出必要的假设来保证垃圾回收器能工作。而为此，必须限制指针的使用或者使用declare_reachable、undeclare_reachable、declare_no_pointers、undeclare_no_pointers来让一些不安全的指针使用免于垃圾回收器检查。因此想让老的代码（以前的旧代码）（在未来）毫不费力地使用垃圾回收，现在情况下对大多数代码还是不可能的。

C++11标准中对指针的垃圾回收支持仅限于系统提供的new操作符分配的内存，而malloc分配的内存则会被认为总是可达的，即无论何时垃圾回收器都不予回收。因此使用malloc等的较老代码的堆内存还是必须由程序员自己控制。

而更为现实的状况是本书写作时，垃圾回收的特性还没有得到任何编译器支持，即使是所谓的“最小垃圾回收”。不过有了最小支持，用户可能在新代码中会注意指针的使用，并对形如指针隐藏的状况使用合适的函数来对被隐藏指针的堆对象进行保护。按照C++的设计，显式地delete使用与垃圾回收并不会形成冲突。如果程序员选择这么做的话，就应该能够保证最大的代码向前兼容性。在未来某个时刻C++垃圾回收支持完成的时候，代码可以直接享受其带来的益处。

## 第6章 提高性能及操作硬件的能力

### 6.1 常量表达式 P193

#### 6.1.1 运行时常量性与编译时常量性 P193

const可以修饰常量，还可以修饰函数参数、函数返回值、函数本身、类等。在不同的使用条件下，const有不同的意义，不过大多数情况下，const描述的都是一些“运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的。如下：

```c++
const int GetCount() { return 1; }

void Constless(int cond) {
    int arr[GetCount()] = {0};  // 无法通过编译

    enum { e1 = GetCount(), e2 };  // 无法通过编译

    switch (cond) {
        case GetCount():  // 无法通过编译
            break;
        default:
            break;
    }
}
```

上述代码，定义了一个返回常数1的函数GetConst。使用const关键字修饰了返回类型。不过编译后发现，无论将GetConst的结果用于需要初始化数据arr的声明中，还是用于匿名枚举中，或用于switch-case的case表达式中，编译器都会报告错误。发生这样错误的原因如上面提到的一样，这些语句都需要的是编译时期的常量值。而const修饰的函数返回值，只保证了运行时期内其值是不可以被更改的。这是两个完全不同的概念。

再看一个BitSet的例子，该例更贴近开发人员的实际状况。如下：

```c++
enum BitSet {
    V0 = 1 << 0,
    V1 = 1 << 1,
    V2 = 1 << 2,
    VMAX = 1 << 3
};

// 重定义操作符“|”，以保证返回的BitSet值不超过枚举的最大值
const BitSet operator|(BitSet x, BitSet y) {
    return static_cast<BitSet>(((int) x | y) & (VMAX - 1));
}

template<int i = V0 | V1>  // 无法通过编译
void LikeConst() {}
```

上述代码，看到一个有限成员的BitSet的枚举类型的定义 （之前代码清单2-7，static_assert来校验枚举值是否列全）。而为了尽可能地保证或操作的有效性，我们重载了operator，该操作除了进行或运算外，还会通过&(VMAX - 1)这样的操作保证该或操作的输出不会超过VMAX枚举值。而此时将V0|V1作为非类型模板函数的默认模板参数，则会导致编译编译错误。这同样是由需要的是编译时常量所导致的。

是否有办法通过更改上面的例子，获得编译时期的常量？最简单的办法是，可以在上述代码的文件开始使用C中的宏替代GetConst函数。

`#define GetConst 1`

这种简单粗暴的做法即使有效，也会把C++拉回“石器时代”。C++11中对编译时期常量的回答是constexpr，即常量表达式（constant expression）。比如要使得代码中的GetConst函数成为一个常量表达式，可以用下面的声明方法：

`constexpr int GetConst() { return 1; }`

即在函数表达式前加上constexpr关键字即可。有了常量表达式这样的声明，编译器就可以在编译时期对GetConst表达式进行值计算（evaluation），从而将其视为一个编译时期的常量（虽然编译器不一定这么做，但至少从语法效果上看是这样，会在后面叙述）。这样一来上述代码的数组arr、匿名枚举的初始化以及switch-case的case表达式通过编译都不再是问题。

在C++11中，常量表达式实际上可以作用的实体不仅限于函数，还可以作用于数据声明，以及类的构造函数等。来分别看一下。

#### 6.1.2 常量表达式函数

通常可以在函数返回类型前加入关键字constexpr来使其成为常量表达式函数。不过并非所有的函数都有资格成为常量表达式函数。事实上，常量表达式函数的要求非常严格，有以下几点：

* 函数体只有单一的return返回语句。
* 函数必须返回值（不能是void函数）。
* 在使用前必须已有定义。
* return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式。

分别解释一下。首先是常量表达式函数中最为明显的限制，就是要求函数体中只有一条语句，且该条语句必须是return语句。这就意味着形如：

`constexpr int data() { const int i = 1; return i; }`

这样的多条语句的写法是无法通过编译的。

但是本地尝试，上述语句也可以编译通过。如果有多个return返回语句，同样可以编译通过。：

```c++
constexpr int GetCount(bool b) {
    if (b) {
        return 3;
    } else {
        return 1;
    }
}

void Constless(int cond) {
    int arr[GetCount(true)] = {0};  // 无法通过编译

    enum { e1 = GetCount(false), e2 };  // 无法通过编译

    switch (cond) {
        case GetCount(true):  // 无法通过编译
            break;
        default:
            break;
    }
}
```

不过一些不会产生实际代码的语句在常量表达式函数中使用下，倒不会导致编译器的“抱怨”。可以看看如下static_assert的情况：

```c++
constexpr int f(int x) {
    static_assert(0 == 0, "assert fail.");
    return x;
}
```

该例子能够通过编译。而其他的，比如using指令、typedef等也通常不会造成问题。

第二点约束，则是常量表达式必须返回值。形如：

`constexpr void f() {}`

这样的不返回值的函数就不能是常量表达式。其原因也很明显，因为无法获得常量的常量表达式是不被认可的。

第三点约束是常量表达式函数在使用前必须被定义。对于普通函数而言，调用函数只需要有函数声明就够了，但常量表达式函数的使用则有所不同。这里应该注意常量表达式“使用”和“调用”的区别，前者讲的是编译时的值计算，而后者讲的是运行时的函数调用，如下：

```c++
constexpr int f();

int a = f();
const int b = f();
constexpr int c = f();  // 无法通过编译

constexpr int f() { return 1; }

constexpr int d = f();
```

上述代码声明了一个常量表达式函数f。在定义该函数之前，定义了变量a、常量b以及常量表达式值c。在a和b的定义中，编译器会将f()转换为一个函数调用，而在c的定义中，由于其是一个常量表达式值，因此会要求编译器进行编译时的值计算。这时候由于f常量表达式还没有定义，就会导致编译错误。而d的定义则没有问题，因为f的定义已经有了。

从上述代码也可以看出，虽然f被定义为一个常量表达式，但是它是否在编译时进行值计算则不一定。在b和c的定义中，f就是标准的函数调用，constexpr也不会使得函数被重写。那么普通情况下，程序员也就不用对声明了constexpr的函数再声明一个没有constexpr的版本了。而事实上，如果这么做还会导致错误发生，如下面的声明会导致编译器报错：

```c++
constexpr int f();
int f();  // error: redeclaration 'int f()' differs in 'constexpr' from previous declaration
```

第四点非常重要，常量表达式中，也不能使用非常量表达式的函数。形如：

```c++
const int e() { return 1; }
constexpr int g() { return e(); }  // error: call to non-'constexpr' function 'const int e()'
```

或者形如：

```c++
int g = 3;
constexpr int h() { return g; }  // error: the value of 'g' is not usable in a constant expression
```

的常量表达式定义是不能通过编译的。这样做的意义也比较明显，即如果要使得g()是一个编译时的常量，那么其return 表达式就不能包含运行才能确定返回值的函数。只有这样，编译器才能够在编译时进行常量表达式函数的值计算。

修改为如下，则可以编译通过：

```c++
constexpr int e() { return 1; }
constexpr int g() { return e(); }

constexpr int g = 3;
constexpr int h() { return g; }
```

当然，作为一个常量表达式函数，return的表达式需要是一个常量表达式也是天经地义的。一些危险的操作，如赋值的操作在常量表达式中也是不允许的，形如：

```c++
constexpr int k(int x) { return x = 1; }

int main() {
    int arr[k(10)] = {0};
    return 0;
}
```

的语句也是无法通过C++11编译器的编译的。（本地试验可以通过编译。）

#### 6.1.3 常量表达式值 P197

由constexpr关键字修饰的“常量”，这样声明的变量就是所谓的常量表达式值（constant-expression value）。通常情况下，常量表达式值必须被一个常量表达式赋值，而跟常量表达式函数一样，常量表达式值在使用前必须被初始化。

而使用constexpr声明的数据最常被问起的问题是，下列两条语句有什么区别：

```c++
const int i = 1;
constexpr int j = 1;
```

事实上，两者在大多数情况下是没有区别的。不过有一点，就是如果i在全局名字空间中，编译器一定会为i产生数据。而对于j，如果不是有代码显式地使用了它的地址，编译器可以选择不为它生成数据，而仅将其当做编译时期的值（是不是想起了光有名字没有产生数据的枚举值，以及不会产生数据的右值字面常量。事实上，它们也都是只是编译时期的常量）。

编译时环境手运行时环境可能有所不同，那么编译时的浮点常量和实际运行时的浮点数常量可能在精度上存在差别。不过在C++11中，编译时的浮点数常量表达式值还是被允许的。标准要求编译时的浮点常量表达式值的精度要至少等于（或者高于）运行时的浮点数常量的精度。

对于自定义类型的数据，要使其成为常量表达式值的话，则不像内置类型这么简单。C++11标准中，constexpr关键字是不能用于修饰自定义类型的。比如下面这样的类型定义和使用：

```c++
constexpr struct MyType { int i; };  // error: 'constexpr' cannot be used for type declarations
constexpr MyType mt = {0};
```

在C++11中，无法通过编译。正确地做法是，定义自定义常量构造函数（constant-expression constructor）。如下：

```c++
struct MyType {
    constexpr MyType(int x) : i(x) {}
    int i;
};

constexpr MyType mt = {0};  // 如果上面自定义构造函数不加constexpr，则编译错误：error: the type 'const MyType' of 'constexpr' variable 'mt' is not literal。或者不定义构造函数，由编译器默认生成无参构造函数，也可以通过编译
```

上述代码，对MyType的构造函数进行了定义。不过在定义前，加上了constexpr关键字。通过这样的定义，MyType类型的constexpr的变量mt的定义就可以通过编译了。

常量表达式的构造函数也有使用上的约束，主要有以下两点：

* 函数体必须为空。
* 初始化列表只能由常量表达式来赋值。

关于第一点，本地试验如果构造函数体不为空，也可以通过编译：

```c++
struct MyType {
    constexpr MyType(int x) : i(x) {
        i = 10;
    }

    int i;
};

constexpr MyType mt = {0};
```

通常第二点跟常量表达式函数一样，形如下面的常量表达式构造函数都是无法通过编译的：

```c++
int f();  // 编译失败
// constexpr int f();  // 编译失败
// constexpr int f() {  // 编译成功
//     return 10;
// }

struct MyType {
    constexpr MyType(int x) : i(f()) {
    }

    int i;
};

constexpr MyType mt = {0};
```

这里还需要注意的是，我们声明的是常量表达式构造函数，但是其编译时的“常量性”则体现在类型上，如下：

```c++
#include <iostream>

using namespace std;

struct Date {
    constexpr Date(int year, int month, int day) : year(year), month(month), day(day) {}

    constexpr int getYear() const { return year; }

    constexpr int getMonth() const { return month; }

    constexpr int getDay() const { return day; }

private:
    int year;
    int month;
    int day;
};

constexpr Date PRCfound{1949, 10, 1};
constexpr int foundmonth = PRCfound.getMonth();  // 把三个getter函数改为constexpr，这里也要去掉constexpr，则可以正常编译运行

int main() {
    cout << foundmonth << endl;
    return 0;
}
```

上述代码，为Date类型声明了常量表达式构造函数，随便定义了constexpr的变量PRCfound。此外，还为Date定义常量表达式的成员函数，可以看到，从PRCfound中拿出成员month，赋给一个常量表达式值foundmonth。如果PRCfound的成员变量在这里不具有编译时的常量性，显然是不可能做到的。

这里还需要注意一下常量表达式的成员函数。在C++11中，不允许常量表达式作用于virtual的成员函数。这个原因也是显而易见的，virtual表示的是运行时行为，与“可以在编译时进行值计算”的constexpr的意义是冲突的。

跟常量表达式函数一样，常量表达式构造函数也可以用于非常量表达式中的类型构造，重写了编译器也会报错的。程序员不必为类型再重写一个非常量表达式版本。

#### 6.1.4 常量表达式的其它应用 P199

常量表达式是可以用于模板函数的。不过由于模板中类型的不确定性，所以模板函数是否会被实例化为一个能够满足编译时常量性的版本通常也是未知的。针对这种情况，C++11标准规定，当声明为常量表达式的模板函数后，而某个该模板函数的实例化结果不满足常量表达式的需求的话，constexpr会被自动忽略。该实例化后的函数将成为一个普通函数，如下：

```c++
#include <iostream>

using namespace std;

struct NotLiteral {
    NotLiteral() { i = 5; }

    int i;
};

template<typename T>
constexpr T ConstExp(T t) {
    return t;
}

int main() {
    NotLiteral nl;
    NotLiteral nl1 = ConstExp(nl);
    constexpr NotLiteral nl2 = ConstExp(nl);  // 无法通过编译  error: the type 'const NotLiteral' of 'constexpr' variable 'nl2' is not literal
    constexpr int a = ConstExp(1);

    return 0;
}
```

上述代码，结构体NotLiteral不是一个定义了常量表达式构造函数的类型，因此是不能够声明为常量表达式值的。而模板函数ConstExp一旦以NotLiteral为参数，那么其constexpr关键字将被忽略，如nl1变量所示。实例化为ConstExp\<NotLiteral\>的函数将不是一个常量表达式函数，因此，也看到nl2是无法通过编译的（当然，该例中constexpr NotLiteral本来也是不正确的声明）。而在可以实例化为常量表达式函数的时候，ConstExp则可以用于常量表达值的初始化。如本例中的a，就是由实例化为ConstExp\<int\>的常量表达式函数所初始化的。

本地试验，如果把NotLiteral改成constexpr的构造，则可以用constexpr的NotLiteral对象去实例化ConstExp\<NotLiteral\>为返回常量的。如下：

```c++
#include <iostream>

using namespace std;

struct NotLiteral {
    constexpr NotLiteral(): i(5) { i = 5; }

    int i;
};

template<typename T>
constexpr T ConstExp(T t) {
    return t;
}

int main() {
    NotLiteral nl;
    NotLiteral nl1 = ConstExp(nl);
    constexpr NotLiteral nl2 = ConstExp(nl);  // 无法通过编译  error: the value of 'nl' is not usable in a constant expression

    constexpr NotLiteral cnl3;
    constexpr NotLiteral cnl4 = ConstExp(cnl3);

    return 0;
}
```

对于常量表达式的应用，还有一个有趣的问题是函数递归问题。如果一个函数是递归的，而且它是一个常量表达式函数，那么会发生什么情况？事实上，在常量表达式这个特性提出的时候，提出者是不太赞成让常量表达式支持递归的，不过C++11标准中并没有反对常量表达式的递归函数，而且在标准中说明，符合C++11标准的编译器对常量表达式函数应该至少支持512层的递归。

有时，编译器被我们稍微改造一下，或者就能成为程序员的“计算器”。如下：

```c++
#include <iostream>

using namespace std;

constexpr int Fibonacci(int n) {
    return n == 1 || n == 2 ? 1 : Fibonacci(n - 1) + Fibonacci(n - 2);
}

int main() {
    int fib[] = {
        Fibonacci(11), Fibonacci(12), Fibonacci(13), Fibonacci(14), Fibonacci(15), Fibonacci(16)
    };
    for (int i : fib) {
        cout << i << endl;
    }
    return 0;
}
输出：
89
144
233
377
610
987
```

这里程序员知道斐波那契数的算法，却懒得自行算出一个斐波那契数组（第11~16个），因此利用了常量表达式构造了一个这样的数组。在实验机上，用clang++编译器使用默认优化级别编译了这个程序，然后反汇编发现该数组的值已经被计算好了，实际运行的代码没有运行调用Fibonacci这个函数。这跟直接调用基于范围的for循环打印数组中的值是代码一致。

事实上，基于编译时期的运算的编程方式在C++中并不是第一次出现。早在C++模板刚出现的时候，就出现了基于模板的编译时期运算的编程方式，这种编程通常被称为模板元编程（template meta-programming）。模板元编程同样是有意思的话题，如要实现上述代码中的例子的效果，使用模板元编程同样可以，如下：

```c++
#include <iostream>

using namespace std;

template<long num>
struct Fibonacci {
    static const long val = Fibonacci<num - 1>::val + Fibonacci<num - 2>::val;
};

template<>
struct Fibonacci<2> { static const long val = 1; };
template<>
struct Fibonacci<1> { static const long val = 1; };
template<>
struct Fibonacci<0> { static const long val = 0; };

int main() {
    int fib[] = {
        Fibonacci<11>::val, Fibonacci<12>::val,
        Fibonacci<13>::val, Fibonacci<14>::val,
        Fibonacci<15>::val, Fibonacci<16>::val
    };
    for (int i : fib) {
        cout << i << endl;
    }
    return 0;
}
```

上述代码定义了一个非类型参数的模板Fibonacci。该模板类定义了一个静态变量val，而val的定义方式是递归的。因此模板将会递归的进行推导。此外，还通过编特化定义了模板推导的边界条件，即斐波那契的初始值。那么模板在推导到边界条件的时候就会终止推导。通过这样的方法，同样可以在编译时进行值计算，从而生成数组的值。

通过constexpr进行的运行时计算，跟模板元编程非常类似。因此有的程序员自然地称利用constexpr进行编译时期运算的编程方式为constexpr元编程（constexpr meta-programming）。学术地讲，constexpr元编程与template元编程一样，都是图灵完备的，即任何程序中需要表达的计算，都可以通过constexpr元编程的方式来表达。由于constexpr支持浮点数运算（模板元编程只支持整型），支持三元表达式、逗号表达式，所以很多人认为constexpr元编程将会比模板元编程更加强大。从这个角度讲，constexpr元编程将非常让人期待。

但是从实践中发现，并不是使用了constexpr，编译器就一定会在编译时期对常量表达式函数进行值计算。事实上，对于constexpr int Fibonacci(int n)函数的例子，如果用g++的默认优化级别来编译，实验机上会产生调用Fibonacci函数的代码（clang++在O0级别也会有这样的效果）。在C++11标准中，也没有看到要求编译器一定要对常量表达式进行编译时期的值计算。标准只是定义了可以用于编译时进行值运算的常量表达式的定义，却没有强制要求编译器一定在编译时进行值计算。所以编译器通过一些手段绕过代码的语法，仍然做运行时的调用，这样的方法也是符合C++11标准的（通过情况下，这样做也是编译器实现constexpr的第一步，因为这样最简单也最不容易出错，后期如果实现了编译时值计算，该方法还可以用作验证手段）。推迟到运行时的唯一的缺点就是性能上会有一定问题。可以想象，为了提高编译器的竞争力，各种编译器都会渐渐将常量表达式的运算放到编译时，到那个时候，constexpr元编程或许才能大行其道。

### 6.2 变长模板 P202

#### 6.2.1 变长函数和变长的模板参数



## 第7章 为改变思考方式而改变 P239

### 7.1 指针空值——nullptr

#### 7.1.1 指针空值：从0到NULL，再到nullptr








































