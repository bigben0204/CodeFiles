# 深入理解C++11：C++11新特性解析与应用

## 2.1 保持与C99兼容

### 2.1.1 预定义宏

使用预定义宏，可以查验机器环境对C标准和C库的支持情况：

```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "Standand Clib: " << __STDC_HOSTED__ << endl; // Standand Clib: 1
    //cout << "Standand C: " << __STDC__ << endl;
    //cout << "Standand C: " << __STDC_VERSION__ << endl;
    //cout << "Standand C: " << __STDC_ISO_10646__ << endl;
    return 0;
}
```

### 2.1.2 \_\_func\_\_预定义标识符

\_\_func\_\_预定义标识符功能，其基本功能就是返回所在函数的名字。

```c++
#include <iostream>
using namespace std;

const char* hello() {
    return __func__;
}

const char* world() {
    return __func__;
}

int main()
{
    cout << hello() << ", " << world() << endl; // hello, world
    return 0;
}
```

按标准定义，编译器会隐匿地在函数定义之后定义\_\_func\_\_标识符。

其实际定义等同于：

```c++
const char* hello() {
 	static const char* __func__ = "hello";
    return __func__;
}
```

\_\_func\_\_预定义标识符允许其使用在类或者结构体中，如下：

```c++
#include <iostream>
using namespace std;

struct TestStruct {
    TestStruct(): name(__func__) {}

    std::string show() {
        return __func__;
    }

    const std::string name;
};

int main()
{
    TestStruct ts;
    cout << ts.name << endl;  // TestStruct
    cout << ts.show() << endl;  // show

    return 0;
}
```

不过将\_\_func\_\_作为函数参数的默认值是不允许的，如下：

```c++
void FuncFail { string func_name = __func__ } {}; // 无法通过编译
```

这是由于参数声明时，\_\_func\_\_还未被定义。

## 2.5.2 静态断言与static_assert

断言assert宏只在程序运行时才能起作用。有的时候，希望在编译时能做一些断言，如下程序，编译时不会报错：

又如：

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}
```

对于上例，可以利用“除0”会导致编译器报错这个特性来实现静态断言：

```c++
#include <iostream>
#include <cassert>
using namespace std;

#define assert_static(e) \
    do { \
        enum {assert_static__ = 1 / (e) }; \
    } while (0)

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    assert_static(sizeof(b) == sizeof(a));
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译失败，报错：
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,1): warning C4804:  “/”: 在操作中使用类型“bool”不安全
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(20): message :         ]
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(12,5): message :  未定义的算术运算导致失败
```

C++11标准中，引入了static_assert断言来解决这个问题，接收两个参数，一个断言表达式，通常需要返回一个bool值；一个则是警告信息，通常也就是一段字符串。上例替换为static_assert：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
void bit_copy(T& a, U& b) {
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
    memcpy(&a, &b, sizeof(b));
}

int main()
{
    int a = 0x2468;
    double b;
    bit_copy(a, b);
    return 0;
}

// 编译报错
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :  查看对正在编译的函数 模板 实例化“void bit_copy<int,double>(T &,U &)”的引用
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         with
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         [
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             T=int,
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :             U=double
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(14): message :         ]
1>已完成在项目“TestProject.vcxproj”中生成目标“ClCompile”的操作 - 失败。
1>
1>已完成生成项目“TestProject.vcxproj”的操作 - 失败。
1>
1>生成失败。
1>
1>D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,29): error C2338:  the parameters of bit_copy must have same width.
1>    0 个警告
1>    1 个错误
```

static_assert是编译期的断言，其使用范围不像assert一样受到限制。通过情况下，**static_assert可以用于任何名字空间**，如下：

```c++
#include <iostream>
using namespace std;

static_assert(sizeof(int) == 8, "This 64-bit machine should follow this!"); // 应该为4

int main() {
    return 0;
}
```

必须注意的是，static_assert的断言表达式的结果必须是编译时期可以计算的表达式，即必须是常量表达式。如果使用了变量，则会导致错误，如下：

```c++
#include <iostream>
using namespace std;

int positive(const int n) {
    static_assert(n > 0, "value must > 0");
    return n;
}

int main() {
    positive(-1);
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,21): error C2131:  表达式的计算结果不是常数
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  因读取超过生命周期的变量而失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(5,19): message :  请参见“n”的用法
```

上例使用了参数变量n（虽然是个const参数），因而static_assert无法通过编译。如果需要的只是运行时的检查，还是应该使用assert宏。

## 2.6 noexcept修饰符和noexcept操作符 P51

`void excpt_func() throw(int, double) { //... }`

动态异常声明throw(int, double)，声明指出了expt_func可能抛出的异常的类型。该特性很少被使用，因此在C++11中被弃用了，而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。

noexcept形如其名，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行。

语法上讲，noexcept修饰符有两种形式：

`void excpt_func() noexcept;`

另一种可以接受一个常量表达式作为参数，如下：

`void excpt_func() noexcept (常量表达式);`

不带常量表达式的noexcept相当于声明了noexcept(true)，即不会抛出异常。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    try {
        Throw();
    }
    catch (...) {
        cout << "Found throw." << endl;
    }

    try {
        NoBlockThrow();
    }
    catch (...) {
        cout << "Throw is not blocked." << endl;
    }

    try {
        BlockThrow();
    }
    catch (...) {
        cout << "Found throw 1." << endl;
    }
    return 0;
}

// 输出：
Found throw.
Throw is not blocked.
// 出现中止提示框
```

noexcept作为一个操作符时，通常可以用于模板，如：

```c++
template<class T>
void fun() noexcept(nocept(T())) {}
```

这里fun函数是否是一个noexcept的函数，将由T()表达式是否会抛出异常所决定。这里的第二个noexcept就是一个noexcept操作符。当其参数是一个有可能抛出异常的表达式时，其返回值为false，反之为true。

```c++
#include <iostream>
using namespace std;

void Throw() {
    throw 1;
}

void NoBlockThrow() throw(int) {
    Throw();
}

void BlockThrow() noexcept {
    Throw();
}

int main() {
    cout << noexcept(Throw()) << endl; // 0
    cout << noexcept(NoBlockThrow()) << endl; // 0
    cout << noexcept(BlockThrow()) << endl; // 1
    return 0;
}
```

同样出于安全考虑，C++11标准中让类的析构函数默认也是noexcept(true)的，当然，如果程序员显式地为析构函数指定了noexcept，或者类的基类或成员有noexcept(false)的析构函数，析构函数就不会再保持为默认值。如下：

```c++
#include <iostream>
using namespace std;

struct A {
    ~A() {
        throw 1;
    }
};

struct B {
    ~B() noexcept(false) {
        throw 2;
    }
};

struct C {
    B b;
};

void funA() {
    A a;
}

void funB() {
    B b;
}

void funC() {
    C c;
}

int main() {
    try {
        funB();
    }
    catch (...) {
        cout << "caught funB." << endl; // caught funB.
    }

    try {
        funC();
    }
    catch (...) {
        cout << "caught funC." << endl; // caught funC.
    }

    try {
        funA();
    }
    catch (...) {
        cout << "caught funA." << endl; // terminate called after throwing an instance of 'int'
    }
    return 0;
}

// 编译失败
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): warning C4297:  “A::~A”: 假定函数不引发异常，但确实发生了
1>  D:\Program Files\Microsoft Visual Studio\VSProjects\TestProject\TestProject\main.cpp(6,1): message :  析构函数或释放器具有一个(可能是隐含的)非引发异常规范
```

无论是析构函数声明为noexcept(false)的类B，还是包含了B类型成员的类C，其析构函数都是可以抛出异常的。只有什么都没有声明的类A，其析构函数被默认为noexcept(true)，从而阻止了异常的扩散。

## 2.7 快速初始化成员变量

C++11中，标准允许非静态成员变量的初始化有多种形式。具体而言，除了初始化列表外，在C++11中，标准还允许使用等号=或花括号{}进行就地的非静态成员变量初始化。如：

```c++
#include <iostream>
using namespace std;

struct Init {
    int a = 1;
    double b = 1.2;
    double c{1.2};
};

int main() {
    Init init;
    return 0;
}
```

C++对于初始化表达式的改动发现，花括号式的集合（列表）初始化已经成为C++11中初始化声明的一种通用形式，而其效果类似于C++98中使用圆括号()对自定义变量的表达式列表初始化。不过在C++11中，对于非静态成员进行就地初始化，两者却并非等价的，如下：

```c++
struct C {
    C(int i): c(i) {}
    int c;
};

struct Init {
    int a = 1;
    string b{"abc"}; // string b("abc") 无法通过编译
    C c{1}; // C c(1) 无法通过编译
};
```

程序员可以为同一成员变量既声明就地的列表初始化，又在初始化列表中进行初始化，只不过初始化列表问题看起来“后作用于”非静态成员。也就是说，初始化列表的效果总是优先于就地初始化的。

## 2.8 非静态成员的sizeof

```c++
#include <iostream>
using namespace std;

struct People {
    int hand;
    static People* all;
};


int main() {
    People p;
    cout << sizeof(p.hand) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::all) << endl; // C++98中通过，C++11中通过
    cout << sizeof(People::hand) << endl; // C++98中错误，C++11中通过
    return 0;
}
```

在C++11中，对非静态成员变量使用sizeof操作是合法的。而在C++98中，只有静态成员，或者对象的实例才能对其成员进行sizeof操作。因此，如果只有一个支持C++98标准的编译器，在没有定义类实例的时候，要获得类成员大小，通常会采用以下的代码：

`sizeof(((People*)0) -> hand);`

强制转换0为一个People类的指针，继而通过指针的解引用获得其成员变量，并用sizeof求得该成员变量的大小。在C++11中，无需这样的技巧，因为sizeof可以作用的表达式包括了类成员表达式：

`sizeof(People::hand)`

## 2.9 扩展的friend语法

C++11对friend关键字进行了一些改进：

```c++
class Poly;
typedef Poly P;

class LiLei {
    friend class Poly; // C++98通过，C++11通过
};

class Jim {
    friend Poly; // C++98失败，C++11通过
};

class HanMeiMei {
    friend P; // C++98失败，C++11通过
};
```

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。甚至还使用了Poly的别名P，这同样可行。

可以为类模板声明友元了。这在C++98中无法做到，如下：

```c++
#include <iostream>
using namespace std;

class P;

template<typename T>
class People {
    friend T;
};


int main() {
    People<P> pp; // 类型P在这里是People类型的友元
    People<int> pi; // 对于int类型模板参数，友元声明被忽略
    return 0;
}
```

有个使用friend友元来访问私有成员进行测试的使用样例，在P63。

## 2.10 final/override控制 P63

## 2.11 模板函数的默认模板参数 P67

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，如下：

```c++
void DefParm(int m = 3) {} // C++98编译通过，C++11编译通过

template<typename T = int>
class DefClass {};  // C++98编译通过，C++11编译通过

template<typename T = int>
void DefTempParm() {} // C++98编译失败，C++11编译通过
```

不过在语法上，类模板在为多个默认模板参数声明指定默认值的时候，必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说不是必须的，如下：

```c++
template<typename T1, typename T2 = int>
class DefClass1 {};

template<typename T1 = int, typename T2>
class DefClass2 {};  // 无法编译通过

template<typename T, int i = 0>
class DefClass3 {};

template<int i = 0, typename T>
class DefClass4 {};  // 无法编译通过

template<typename T1 = int, typename T2>
void DefFunc1(T1 a, T2 b);  // 可以编译通过

template<int i = 0, typename T>
void DefFunc2(T a);  // 可以编译通过
```

函数模板的参数推导规则也不复杂。如果能够从函数实参中推导出类型的话，那么默认模板参数就不会被使用，反之，默认模板参数则可能会被使用。如下：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = 0) {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')
    f(1); // f<int, double>(1, 0)，使用了默认模板参数double
    //f(); // 错误：T无法被推导出来
    f<int>(); // f<int, double>(0, 0)，使用了默认模板参数double
    f<int, char>(); // f<int, char>(0, 0)
    return 0;
}

// 输出：
t type: int, u type: char
t value: 1, u value: c
t type: int, u type: double
t value: 1, u value: 0
t type: int, u type: double
t value: 0, u value: 0
t type: int, u type: char
t value: 0, u value:
```

这个例子可以看到，默认模板参数通常是需要跟默认函数参数一起使用的。

还有一点，模板函数的默认形参不是模板参数推导的依据。函数模板参数的选择，总是由函数的实参推导而来的，这点在使用中应当注意。

另外，将u = 0改成u = "abc"，有点问题没明白：

```c++
#include <iostream>
using namespace std;


template<class T, class U = double>
void f(T t = 0, U u = "abc") {
    cout << "t type: " << typeid(t).name() << ", u type: " << typeid(u).name() << endl;
    cout << "t value: " << t << ", u value: " << u << endl;
}

int main() {
    f(1, 'c'); // f<int, char>(1, 'c')，output: t type: int, u type: char<Enter>t value: 1, u value: c
    f(1); // f<int, double>(1, 0)，将"abc"转成double，output: output: t type: int, u type: double<Enter>t value: 1, u value: 1.16581e-307
    f<int>(); // 这里编译错误，“f”: 函数不接受 0 个参数，f<int>(1)可以编译通过
    cout << static_cast<double>("abc") << endl; //编译错误，说“static_cast”: 无法从“const char [4]”转换为“double”，所以不知道f(1)里"abc"是如何转成double
    return 0;
}
```

## 2.12 外部模板

### 2.12.2 显式的实例化与外部模板的声明 P71

```c++
// test.h
template<typename T> void fun(T) {}

// test1.cpp
#include "test.h"
template void fun<int>(int); // 显示地实例化
void test1() { fun(3); }

// test2.cpp
#include "test.h"
extern template void fun<int>(int); // 外部模板的声明
void test1() { fun(3); }
```

这样一来，在test2.o中不会再生成fun\<int\>(int)的实例代码。因此链接器的工作很轻松，基本跟外部变量的做法是一样的，即只需要保证让test1.cpp和test2.cpp共享一份代码位置即可。而同时，编译器也不用每次都产生一份fun\<int\>(int)的代码，所以可以减少编译时间。这里也可以把外部模板声明放在test.h头文件中，这样所有包含test.h的头文件就可以共享这个外部模板声明了。这一点跟使用外部变量声明是完全一致的。

在使用外部模板的时候，还需要注意：**如果外部模板声明出现在某个编译单元中，那么与之对应的显示实例化必须出现在另一个编译单元中或者同一个编译单元的后续代码中**；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。

实际上，C++11中“模板的显式实例化定义、外部模板声明和使用”好比“全局变量的定义、外部声明和使用”方式的再次应用。不过相比于外部变量声明，不使用外部模板声明并不会导致任何问题。

只有在项目比较大的情况下，我们才建议用户进行这样的优化。总的来说，就是在既不忽视模板实例产生的编译及链接开销的同时，也不要过分担心模板展开的开销。

## 2.13 局部和匿名类型作模板实参 P73

C++98中，标准对模板实参的类型还有一些限制。具体讲，局部的类型和匿名的类型在C++98中都不能做模板类的实参。如下：

```c++
template<typename T>
class X {};

template<typename T>
void TempFun(T t) {};

struct A {} a;

struct {
    int i;
} b; // b是匿名类型变量

typedef struct {
    int i;
} B; // B是匿名类型

void Fun() {
    struct C {} c; // C是局部类型，c是局部变量
    X<A> x1; // C++98通过，C++11通过
    X<B> x2; // C++98错误，C++11通过
    X<C> x3; // C++98错误，C++11通过
    TempFun(a); // C++98通过，C++11通过
    TempFun(b); // C++98错误，C++11通过
    TempFun(c); // C++98错误，C++11通过
}
```

值得指出的是，虽然匿名类型可以被模板参数所接受了，但并不意味着以下写法可以被接受，如下：

```c++
template<typename T> struct MyTemplate {};

int main() {
    MyTemplate<struct { int a; }> t; // 无法通过编译，匿名类型的声明不能在模板实参位置
    return 0;
}
```

即使是匿名类型的声明，也需要独立的表达式语句。要使用匿名结构作为模板参数，则需要对匿名结构体作别名。此外在第4章还会看到使用C++11独有的类型推导decltype，也可以完成相应的功能。

## 3.1 继承构造函数

基类的非虚函数无法再被派生类使用了， 这条规则对于构造函数也不例外，如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。如下：

```c++
struct A { A(int i) {} };
struct B: A { B(int i): A(i) {} };
```

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成，如下：

```c++
#include <iostream>

using namespace std;

struct Base {
    void f(double i) {
        cout << "Base: " << i << endl;
    }
};

struct Derived : Base {
    using Base::f;

    void f(int i) {
        cout << "Derived: " << i << endl;
    }
};

int main() {
    Base b;
    b.f(4.5);  // Base: 4.5

    Derived d;
    d.f(4.5);  // Base: 4.5
    d.f(10);  // Derived: 10
    return 0;
}
```

这里使用了using声明，声明派生类Derived也使用基类版本的函数f。这样，派生类中实际就拥有了两个f函数的版本。

在C++中，这个想法被扩展到了构造函数中。子类可以通过使用using声明来声明继承基类的构造函数。如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A::A;
    B(const string& s): A(10) {}  // B类如果有自己的构造函数，则还是需要调用基类A构造函数
    virtual void ExtraInterface() {}
};


int main() {
    B b(10);  // 如果没有using A::A;，则编译报错
    return 0;
}
```

通过using A::A的声明，把基类中的构造函数悉数继承到派生类B中。更为精巧的是，C++11标准继承构造函数被设计为跟派生类中的各种默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。

不过继承构造函数只会被化基类成员变量，对于派生类中的成员变量，则无能为力。不过配置2.7节中的类成员的初始化表达式，为派生类成员变量设定一个默认值还是没有问题的。

如下代码同时使用了继承构造函数和成员变量初始化两个C++11的特性。这样就可以解决一些继承构造函数无法初始化的派生类成员问题。如果这样仍然无法满足需求的话，程序员只能自动来实现一个构造函数，以达到基类和成员变量都能够初始化的目的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char *c) {}
};

struct B : A {
    using A::A;
    int d{0};
};


int main() {
    B b(356);  // b.d被初始化为0
    return 0;
}
```

有时候，基类构造函数的参数会有默认值。对于继承构造函数来讲，**参数的默认值是不会被继承**的。

```c++
#include <iostream>

using namespace std;

struct A {
    A(int a = 3, double b = 2.4) : a_(a), b_(b) {}

    int a_;
    double b_;
};

struct B : A {
    using A::A;
};


int main() {
    B b1;
    cout << "b1.a_: " << b1.a_ << endl;
    cout << "b1.b_: " << b1.b_ << endl;

    B b2(10);
    cout << "b2.a_: " << b2.a_ << endl;
    cout << "b2.b_: " << b2.b_ << endl;

    return 0;
}
//输出：
b1.a_: 3
b1.b_: 2.4
b2.a_: 10
b2.b_: 2.4
```

参数默认值会导致多个构造函数版本的产生，因此程序员在使用有参数默认值的构造函数的基类时，必须小心。

有时，有继承构造函数“冲突”的情况。通常发生在派生类拥有多个基类的时候。多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数（有时，也称其为函数签名）都相同，那么继承类中的冲突的继承构造函数将导致不合法的派生类代码。

A和B的构造函数会导致C中重复定义相同类型的继承构造函数。这种，情况下，可以通过显式定义继承类的冲突的构造函数，阻止隐匿生成相应的继承构造函数来解决冲突，如下：

```c++
#include <iostream>

using namespace std;

struct A {
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct B {
    B(int i) {
        cout << "B.i: " << i << endl;
    }
};

struct C : A, B {
    using A::A;
    using B::B;

    C(int i): A(i), B(i){  // 书中写为C(int) {}，感觉不对，因为A和B都没有无参数的构造函数
        cout << "C.i: " << i << endl;
    }
};


int main() {
    C c(10);
    return 0;
}
```

如果基类的构造函数被声明为私有成员函数（本地试验保护成员函数也不行），或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。此外，如果使用了继承构造函数，编译器就不会再为派生类生成默认构造函数了。

```c++
#include <iostream>

using namespace std;

struct A {
protected:
    A(int i) {
        cout << "A.i: " << i << endl;
    }
};

struct C : A {
    using A::A;
    //C(int i) : A(10) {}  // 这里如果注释掉则编译报错
};


int main() {
    C c(10);
    return 0;
}
```

## 3.2 委派构造函数 P81

在C++11中，可以使用委派构造函数来达到期望的效果。委派构造函数是在构造函数的初始化列表位置进行构造、委派的。如下：

```c++
#include <iostream>

using namespace std;

class Info {
public:
    // 目标构造函数（target constructor）
    Info() {
        cout << "Info() type: " << type << endl;
        InitRest();
    }

    // 委派构造函数（delegating constructor）
    Info(int i) : Info() {  // 这里type是1
        type = i;  //这里经过赋值后，type是i，所以type还是多赋值了一次
    }

    // 委派构造函数（delegating constructor）
    Info(char c) : Info() {
        name = c;
    }

private:
    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type{1};
    char name{'a'};
};

int main() {
    Info info(10);
    return 0;
}
// 输出
Info() type: 1
Info::InitRest()
```

在C++11中，所谓委派构造，就是指委派函数将构造的任务委派给了目标构造函数来完成这样一种类构造的方式。

委派构造函数只能在函数体中为type、name等成员赋初值。这是由于委派构造函数不能有初始化列表造成的。在C++中，构造函数不能同时“委派”和使用初始化列表，所以**如果委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。

这样，上述代码的初始化就不那么令人满意了，因为初始化列表的初始化方式总是等于构造函数完成的（实际在编译完成时就已经决定了），这会可能使程序员犯错（见下分析）。可以稍微改造下目标构造函数，使得委派构造函数依然可以在初始化列表中初始化所有成员，如下：

```c++
class Info {
public:
    Info() : Info(1, 'a') {}

    Info(int i) : Info(i, 'a') {}

    Info(char c) : Info(1, c) {}

private:
    Info(int i, char c) : type(i), name(c) {
        InitRest();
    }

    void InitRest() {
        cout << "Info::InitRest()" << endl;
    }

    int type;
    char name;
};
```

如上定义了一个私有的目标构造函数Info(int, char)，接受两个参数，并将参数在初始化列表中初始化。

在使用委派构造函数的时候，建议程序员抽象出最为“通用”的行为做目标构造函数。这样做一来代码清晰，二来行为也更加正确。如在InitReset()函数中做了：

`type += 1;`

则第1份代码中Info f(3)构造出来的对象其f.type=3，第2份代码中Info f(3)构造出来的对象其f.type=4，从代码编写角度看，第2份代码中Info的行为会更加正确。这是由于在C++11中，目标构造函数的执行总是等于委派构造函数而造成的。因此避免目标构造函数和委托构造函数体中初始化同样的成员通常是必要的，否则可能发生第1份代码的错误。

构造函数比较多时，可能会拥有不止一个委派构造函数，而一些目标构造函数很可能也是委派构造函数，这样，就可能在委派构造函数中形成链状的委派构造关系。有一点必须程序，就是不能形成委托环（delegation cycle），如：

```c++
struct Rule2 {
    int i, c;
    Rule(): Rule2(2) {}
    Rule(int i): Rule2('c') {}
    Rule(char c): Rule2(2) {}
};
```

Rule2定义中，Rule2()、Rule2(int)和Rule2(char)都依赖于别的构造函数，形成环委托构造关系。这样的代码通常会导致编译错误。

委派构造的一个很实际的应用就是使用构造模板函数产生目标构造函数，如代码清单：

```c++
#include <iostream>
#include <list>
#include <vector>
#include <deque>

using namespace std;

class TDConstructed {
public:
    TDConstructed(vector<short>& v) : TDConstructed(v.begin(), v.end()) {}

    TDConstructed(deque<int>& d) : TDConstructed(d.begin(), d.end()) {}

private:
    template<class T>
    TDConstructed(T first, T last): l(first, last) {}

private:
    list<int> l;
};

int main() {
    vector<short> v = {4, 5, 6};
    TDConstructed tdConstructed1(v);

    deque<int> d = {1, 2, 3};
    TDConstructed tdConstructed2(d);
    return 0;
}
```

如上代码定义了一个构造函数模板。通过两个委派构造函数的委托，构造函数模板会被实例化。T会被推导为vector\<short\>::iterator和deque\<int\>::iterator两种类型。这比罗列不同类型的构造函数方便了很多。可以心，委托构造使得构造函数的泛型编程也成为了一种可能。

如果在委派构造函数中使用try，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。如下：

```c++
#include <iostream>

using namespace std;

class DCExcept {
public:
    DCExcept(double d)
    try : DCExcept(1, d) {
        cout << "Run the body." << endl;
    }
    catch (...) {
        cout << "caught exception." << endl;
    }

private:
    DCExcept(int i, double d) {
        cout << "going to throw!" << endl;
        throw 0;
    }

private:
    int type;
    double data;

};

int main() {
    DCExcept a(1.2);
    return 0;
}
// 输出：
going to throw!
terminate called after throwing an instance of 'int'
caught exception.
```

## 3.3 右值引用：移动语义和完美转发

### 3.3.2 移动语义

在C++11中，“偷走”临时变量中资源的构造函数，就被称为“移动构造函数”。而这样的“偷”的行为，则称之为“移动语义”（move semantics）。可以理解为“移为已用”。我们可以看看如下代码是如何实现这种移动语义的：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

    HasPtrMem(HasPtrMem&& h) : d(h.d) {
        h.d = nullptr;
        cout << "Move construct: " << ++n_mvtr << endl;
    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1  // HasPtrMem h;
Resource from GetTemp: 0x6a1480
Move construct: 1  // move(h);
Destruct: 1  // h析构
Move construct: 2  // move(GetTemp());
Destruct: 2  // GetTemp返回的HasPtrMem临时变量析构
Resource from main: 0x6a1480
Destruct: 3  // a析构
```

本地试验，如果不加两个move，则只有一个构造函数调用一个析构函数调用，应该是编译器优化，直接将h赋给a，如下：

```c++
HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return h;
}

int main() {
    HasPtrMem a = GetTemp();
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出：
Construct: 1
Resource from GetTemp: 0xe81480
Resource from main: 0xe81480
Destruct: 1
```

另外，本地试验，如果不提供移动构造函数，只提供拷贝构造函数，在使用move时，会调用拷贝构造函数，如下：

```c++
#include <iostream>

using namespace std;

class HasPtrMem {
public:
    HasPtrMem() : d(new int(3)) {
        cout << "Construct: " << ++n_cstr << endl;
    }

    HasPtrMem(const HasPtrMem& h) : d(new int(*h.d)) {
        cout << "Copy construct: " << ++n_cptr << endl;
    }

//    HasPtrMem(HasPtrMem&& h) : d(h.d) {
//        h.d = nullptr;
//        cout << "Move construct: " << ++n_mvtr << endl;
//    }

    ~HasPtrMem() {
        delete d;
        cout << "Destruct: " << ++n_dstr << endl;
    }

    int* d;

private:
    static int n_cstr;
    static int n_dstr;
    static int n_cptr;
    static int n_mvtr;

};

int HasPtrMem::n_cstr = 0;
int HasPtrMem::n_dstr = 0;
int HasPtrMem::n_cptr = 0;
int HasPtrMem::n_mvtr = 0;

HasPtrMem GetTemp() {
    HasPtrMem h;
    cout << "Resource from " << __func__ << ": " << hex << h.d << endl;
    return move(h);
}

int main() {
    HasPtrMem a = move(GetTemp());
    cout << "Resource from " << __func__ << ": " << hex << a.d << endl;
    return 0;
}
// 输出:
Construct: 1
Resource from GetTemp: 0xf01480
Copy construct: 1
Destruct: 1
Copy construct: 2
Destruct: 2
Resource from main: 0xf01480
Destruct: 3
```





为什么费力地添加移动构造函数，完全可以选择改变GetTemp的接口，比如直接传一个引用或者指针到GetTemp的参数中去，效果应该也不差。其实从性能上来讲，这样的做法确实毫无问题，甚至只好不差。不过从使用的方便性来讲效果不好。如果函数返回临时值的话，可以在单条语句里完成很多计算，比如可以很自动地写出如下语句：

`Calculate(GetTemp(), SomeOther(Maybe(), Useful(Values, 2)));`

------

本地验证使用move来移动构造map：

```c++
int main() {
    map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
    map<string, int> nameValueMap2 = move(nameValueMap1);  // move之后，map1内已经没有对象了

    cout << "map1: \n";
    for_each(nameValueMap1.begin(), nameValueMap1.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });

    cout << "map2: \n";
    for_each(nameValueMap2.begin(), nameValueMap2.end(), [](const pair<string, int>& p) {
        cout << p.first << ", " << p.second << "\n";
    });
    return 0;
}
// 输出：
map1:
map2:
a, 10
b, 20
```

如果不使用move，则调用的map的拷贝构造函数，如下：

```c++
map<string, int> nameValueMap2 = nameValueMap1;
// 输出：
map1:
a, 10
b, 20
map2:
a, 10
b, 20
```

### 3.3.3 左值、右值与右值引用

在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。如：

`a = b + c`
这个赋值表达式中，a就是一个左值，而b+c则是一个右值。这种识别左值、右值的方法在C++中依然有效。不过C++中还有一个被广泛认同的说法，就是可以取地址的、有名字的就是左值。反之，不能取地址的、没有名字的就是右值。

这些差别方法通常都非常有效。在C++11中，右值是由两个概念构成的，一个是将亡值（xvalue, eXpiring Value），另一个则是纯右值（prvalue, Pure Rvalue）。

其中纯右值就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。

而将亡值则是C++11新增的跟右值引用相关的表达式，这样的表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

在C++11程序中，所有的值必属于左值、将亡值、纯右值三者之一。

在C++11中，右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。通常情况下，我们只能是从右值表达式获得其引用。比如：

`T&& a = ReturnRvalue();`

这个表达式，假设ReturnRvalue返回一个右值，我们就声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

为了区别于C++98中的引用类型，我们称C++98中的引用为“左值引用”（lvalue reference）。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

在上面的例子，ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了（通常我们也称其具有表达式生命期），而通过右值引用的声明，该右值又“重获新生”，其生命期将与右值引用类型变量a的生命期一样。只要a还“活着”，该右值临时量将会一直“存活下去”。

所以相比于以下语句的声明方式：

`T b = ReturnRvalue()`

刚才的右值引用变量声明，就会少一次对象的析构及一次对象的构造。因为a是右值引用，直接绑定了ReturnRvalue()返回的临时量，而b只是由临时值构造而成的，而临时量在表达式结束会析构因而就会多一次析构和构造的开销。

不过能够声明**右值引用a的前提是ReturnRvalue返回的是一个右值**。通常情况下，右值引用是不能够绑定到任何的左值的。

右值引用&&只能绑定在右值上，所以如下在左值nameValueMap1进行&&右值引用绑定编译失败：

```c++
map<string, int> nameValueMap1 = {make_pair("a", 10), make_pair("b", 20)};
map<string, int>&& nameValueMap2 = nameValueMap1;
```

相对地，在C++98标准中就已经出现的左值引用是否可以绑定到右值（由右值进行初始化）呢？如：

```c++
T& e = ReturnRvalue();
const T& f = ReturnRvalue();
```

答案是：e的初始化会导致编译时错误，而f则不会。

原因是，常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。而在使用右值对其初始化的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。不过**相比于右值引用所引用的右值，常量左值所引用的右值在它的“余生”中只能是只读的**。相对的，非常量左值只能接受非常量左值对其进行初始化。

在C++98通过左值引用来绑定一个右值的情况并不少见，比如：

`const bool& judgement = true;`

就是一个使用常量左值引用来绑定右值的例子。不过与如下声明相比看起来似乎差别不大：

`const bool judgement = true;`

从语法上讲，前者直接使用了右值并为其“续命”，而后者的右值在表达式结束后就销毁了。

事实上，即使在C++98中，也常可以使用常量左值引用来减少临时对象的开销，如：

```c++
void show(const string& s) {} // 使用常量左值引用来接临时变量

show("abc");
```

而在C++11中，同样的，也可以右值引用为参数声明如下函数：

`void AcceptRvalueRef(Copyable&& ) {}`

也同样可以减少临时变量拷贝的开销。进一步地，还可以在AcceptRvalueRef中修改该临时值（这时临时值由于被右值引用参数所引用，已经获得了函数时间的生命期）。不过修改一个临时值的意义通常不大，除非像3.3.2节一样使用移动语义。

就本例而言，如果这样实现函数：

```c++
void AcceptRvalueRef(Copyable&& s) {
    Copyable news = std::move(s);
}
```

这里std::move的作用是强制一个左值（s）成为右值（s）。该函数就是使用右值来初始化Copyable变量news。使用移动语义的前提是Copyable还需要添加一个以右值引用为参数的移动构造函数，如：

`Copyable(Copyable&& o) { /*实现移动语义*/ }`

这样，如果Copyable类的临时变量（即ReturnRvalue返回的临时值）中包含一些大块内存的指针，news就可以如同代码清单3-19一样将临时值中的内存“窃”为已用，从而从这个以右值引用参数的AccepRvalueRef函数中获得最大的收益。事实上，**右值引用的由来从来就跟移动语义紧紧相关。这是右值存在的一个最大的价值（另外一个价值是用于转发）**。

如果不声明移动构造函数，而只声明一个常量左值的构造函数会生成什么？如同刚才提到的，常量左值是个“万能”的引用类型，无论左值还是右值，常量还是非常量，一概能够绑定。那么如果Copyable没有移动构造函数，下列一语句：

`Copyable news = std::move(s);`

将调用以常量左值为参数的拷贝构造函数。这是一种非常安全的设计——**移动不成，至少还可以执行拷贝**。因此，通常情况下，程序员会为声明了移动构造函数的类声明一个常量左值为参数的拷贝构造函数，以保证在移动构造不成时，可以使用拷贝构造。

为了语义的完整，C++11中还存在着常量右值引用，如通过如下代码声明一个常量右值引用：

`const T&& crvalueref = ReturnRvalue();`

但是，一来右值引用主要就是为了移动语义，而移动语义需要右值是可以被修改的，那么常量右值引用在移动语义中就没有用武之处；二来如果要引用右值且让右值不可以更改，常量左值引用往往就足够了。因此在现在的情况下，我们还没有看到常量右值引用有何用处。表3-1：

![](pictures\C++11中引用类型及其可以引用的值类型.png)

有时候，可能不知道一个类型是否是引用类型，以及是左值引用还是右值引用（这在模板中比较常见）。标准库在\<type_traits\>头文件中提供了3个模板类：is_rvalue_reference、is_lvalue_reference、is_reference，可供我们进行判断，如：

```c++
HasPtrMem&& a = GetTemp();
cout << is_rvalue_reference<decltype(a)>::value << "\n";  // 1
cout << is_rvalue_reference<string&&>::value << "\n";  // 1
cout << is_rvalue_reference<map<int, int>&&>::value << "\n";  // 1
```

通过模板类的成员value就可以打印出string&&是否是一个右值引用了。配置第4章中的类型推导操作符decltype，甚至还可以对变量的类型进行判断。

说明：右值引用对象已经是一个左值了，可以使用&获取地址：

```c++
HasPtrMem&& a = GetTemp();
HasPtrMem* p = &a;
```

### 3.3.4 std::move：强制转化为右值 P99

std::move并不能移动任何东西，唯一的功能是将一个左值强制转化为右值引用，继承可以通过右值引用使用该值，用于移动语义。从实现上讲，std::move基本等同于一个类型转换：

`static_cast<&&>(lvalue);`

被转化的左值，其生命期并没有随着左值值的转化而改变，所以被std::move转化的左值变量lvalue不会被立即析构。

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

class Moveable {
public:
    Moveable() : i(new int(3)) {}

    ~Moveable() { delete i; }

    Moveable(Moveable&& m) : i(m.i) {
        m.i = nullptr;
    }

    int* i;
};

int main() {
    Moveable a;
    Moveable c(move(a));  // 会调用移动构造函数，这里move(a)将左值a变成一个右值引用，所以才会调用移动构造函数Moveable(Moveable&& m)
    cout << *a.i << endl;  // 运行时错误
    return 0;
}
```

这 里的a本来是一个左值变量，通过std::move将其转换为右值。这样一来，a.i就被c的移动构造函数设置为指针空值。由于a的生命期实际要到main函数结束才结束，所以对表达式*a.i进行计算就会运行错误。

这里如果不使用move(a)，则使用c(a)，则编译报错：

```c++
Moveable a;
Moveable c(a);  // 编译报错，因为显示声明了移动构造函数，所以拷贝构造函数如果不显示声明，则编译器不会生成拷贝构造函数
Moveable d;  // 编译报错，显示声明了移动构造函数，则编译器不会生成拷贝赋值函数
d = a;
```

事实上，为了保证移动语义的传递，程序员在编写移动构造函数的时候，应该总是记得使用std::move转换拥有形如堆内存、文件句柄等资源的成员为右值，这样，如果成员支持移动构造的话，就可以实现其移动语义。而即使成员没有移动构造函数，那么接受常量左值的拷贝构造函数版本也会轻松地实现拷贝构造，因此也不会引用大的问题。

### 3.3.5 移动语义的一些其他问题

移动语义一定是要修改临时变量的值，那么这样声明移动构造函数：

`Moveable(const Moveable&&)`

或者这样声明：

`const Moveable ReturnVal();`

都会使得临时变量常量化，成为一个常量右值，那么临时变量的引用也就无法修改，从而导致无法实现移动语义。因此在实现移动语义一定要注意排除不必要的const关键字。

默认情况下，编译器会为程序隐式地生成一个（隐式表示如果不使用则不生成）移动构造函数。

不过如果程序员声明了自定义的拷贝构造函数、拷贝赋值函数、移动赋值函数、析构函数（本地试验声明了析构函数不会影响默认构造函数的生成）中的一个或者多个，编译器都不会再为程序员生成默认版本。**默认的移动构造函数实际上跟默认的拷贝构造函数一样，只能做一些按位拷贝的工作**。这对实现移动语义来说是不够的。通常情况下，**如果需要移动语义，程序员必须自定义移动构造函数**。对一些简单的、不包含任何资源的类型来说，实现移动语义与否都无关紧要，因为对这样的类型而言，移动就是拷贝，拷贝就是移动。

同样的，声明了移动构造函数、拷贝赋值函数、移动赋值函数和构造函数中的一个或者多个，编译器也不再会再为程序员生成默认的拷贝构造函数。所以在C++11中，拷贝构造/拷贝赋值和移动构造/移动赋值函数必须同时提供，或者同时不提供，程序员才能保证类同时具有拷贝和移动语义。只声明其中一种的话，类都仅能实现一种语义。

```c++
String(const String &other);  // 拷贝构造函数 
String& operator=(const String& other);  // 拷贝赋值函数

//C++ 11的新函数 
String(String &&other);  // 移动构造函数
String& operator=(String&& other);  // 移动赋值函数
```

其实，只现实一种语义在类的编写中也是非常常见的。如只有拷贝语义的类型——在C++11之前我们见过大多数的类型的构造都是只使用拷贝语义的。而只有移动语义的类型则非常有趣，因为只有移动语义表明该类型的变量所拥有的资源只能被移动，而不能被拷贝。那么这样的资源必须是唯一的，因此，只有移动语义构造的类型往往都是“资源型”的类型，比如说智能指针、文件流等，都可以视为“资源型”的类型。如标准库中的仅可移动的模板类：unique_ptr。一些编译器，如2011，现在也把ifstream这样的类型实现为仅可移动的。

```c++
unique_ptr<int> p1 = make_unique<int>(3);
unique_ptr<int> p2 = move(p1);  // unique_ptr<int> p2 = p1编译报错，无拷贝构造
```

在标准库的头文件\<type_traits\>里，可以通过一些辅助的模板类来判断一个类型是否可以移动的。如is_move_constructible、is_trivially_move_constructible、is_nothrow_move_constructible，使用方法仍然是使用其成员value。如：

```c++
cout << is_move_constructible<unique_ptr<int>>::value << "\n";  // 1
cout << is_copy_constructible<unique_ptr<int>>::value << "\n";  // 0
```

而有了移动语义，还有一个比较典型的应用是可以实现高性能的转换（swap）函数。看下面这段swap模板函数代码：

```c++
#include <iostream>
#include <memory>

using namespace std;

template<class T>
void mySwap(T& a, T& b) {
    T tmp(move(a));
    a = move(b);
    b = move(tmp);
}

int main() {
    unique_ptr<int> p1 = make_unique<int>(3);
    unique_ptr<int> p2 = make_unique<int>(5);
    cout << "Before swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    mySwap(p1, p2);
    cout << "After swap, p1: " << *p1 << ", p2: " << *p2 << endl;
    return 0;
}
// 输出：
Before swap, p1: 3, p2: 5
After swap, p1: 5, p2: 3
```

如果T移动，那么移动构造和移动赋值将会被用于这个转换。整个过程，代码都只会按照移动语义进行指针交换，不会有资源的释放与申请。而如果T不可移动却是可拷贝的，那么拷贝语义会被用来进行转换。这就跟普通的转换语句是相同的。在移动语义的支持下，仅仅通过一个通用的模板，就可能更高效地完成转换，这对于泛型编程来说，无疑是具有积极意义的。

另外一个关于移动构造的话题是异常。对于移动构造函数来说，抛出异常是件危险的事。因为可能移动语义还没完成，一个异常抛出来，这就会导致一些指针成为悬挂指针。因此应该尽量编写不抛出异常的移动构造函数，通过为其添加一个noexcept关键字，可以保证移动构造函数中抛出来的异常会直接调用ternimate程序终止运行。而标准库中，还可以用一个std::move_if_noexcept的模板函数替代move函数。该函数在类的移动构造函数没有noexcept关键字修饰时返回一个左值引用从而使变量可以使用拷贝语义，而在类的移动构造函数有noexcept关键字时，返回一个右值引用，从而使变量可以使用移动语义。如下：

```c++
#include <iostream>

using namespace std;

struct MayThrow {
    MayThrow() {}

    MayThrow(const MayThrow&) {
        cout << "Maythrow copy constructor." << endl;
    }

    MayThrow(const MayThrow&&) {
        cout << "Maythrow move constructor." << endl;
    }
};

struct NoThrow {
    NoThrow() {}

    NoThrow(const NoThrow&) noexcept {
        cout << "NoThrow copy constructor." << endl;
    }

    NoThrow(const NoThrow&&) noexcept {
        cout << "NoThrow move constructor." << endl;
    }
};

int main() {
    MayThrow m;
    NoThrow n;

    MayThrow mt = move_if_noexcept(m);  // Maythrow copy constructor.
    NoThrow nt = move_if_noexcept(n);  // NoThrow move constructor.

    return 0;
}
```

move_if_noexcept是以牺牲性能保证安全的一种做法，而且要求类的开发者对移动构造函数使用noexcept进行描述，否则就会损失更多的性能。

编译器中被称为RVO/NRVO的优化（RVO，Return Value Optimization，返回值优化，或者NRVO，Named Return Value Optimization）。在本节中大量的代码都使用了-fno-elide-constructors选项在g++/clang++中关闭这个优化，这样可以在代码中较为容易地利用函数返回的临时量右值。

但若在编译的时候不使用该选项的话，会发现很多构造和移动都被省略。对于下面这样的代码，一旦打开g++/clang++的RVO/NRVO，从ReturnValue函数中a变量拷贝/移动构造临时变量，以及从临时变量拷贝/移动构造b的二重奏就通通没有了：

```c++
A ReturnRvalue() {
    A a();
    return a;
}

A b = ReturnRvalue();
```

b变量实际就使用了ReturnRvalue函数中a 的地址，任何的拷贝和移动都没有了。通俗地说，就是b变量“霸占”了a变量。这是编译器中一个效果非常好的优化。不过RVO/RNVO并不是对任何情况都有效。有些情况下，一些构造是无法省略的。还有一些情况，即使RVO/NRVO完成了，也不能达到最好的效果。但结论是明显的，移动语义可以解决编译器无法解决的优化问题，因而总是有用的。

关于RVO/RNVO可以参见如下博客：

<https://blog.csdn.net/songchuwang1868/article/details/83622039>

### 3.3.6 完美转发 P104

C++是通过引用一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。

在C++11以前，形如下列语句：

```c++
typedef const int T;
typedef T& TR;
TR& v = 1;  // 该声明在C++98中会导致编译错误
```

其中`TR& v = 1`这样的表达式会被编译器认为是不合法的表达式，而在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式，如下表3-2所示：

![](\pictures\C++11中的引用折叠规则.png)

这个规则不难记忆，因为一旦定义中出现了左值引用，引用折叠问题优先将其折叠为左值引用。而模板对类型的推导规则就比较简单，当转发函数的实参是类型X的一个左值引用，那么模板参数被推导为X&类型，而转发函数的实参是类型X的一个右值引用的话，那么模板的参数被推导为X&&类型。结合以上的引用折叠规则，就能确定出参数的实际类型。进一步，可以把转发函数写成如下形式：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(static_cast<T&&>(t));
}
```

注意一下，不仅在参数部分使用了T&&这样的标识，在目标函数传参的强制类型转换中也使用了这样的形式。如我们调用转发函数时传入了一个X类型的左值引用，可以想象，转发函数将被实例化为如下形式：

```c++
void IamForwarding(X& && t) {
    IrunCodeActually(static_cast<X& &&>(t));
}
```

引用折叠规则，就是：

```c++
void IamForwarding(X& t) {
    IrunCodeActually(static_cast<X&>(t));
}
```

这样，左值传递就毫无问题了。实际使用的时候，IrunCodeActually如果接受左值引用的话，就可以直接调用转发函数。这里调用前的static_cast没有什么作用。事实上，这里的static_cast是留给传递右值用的。

如果调用转发函数时传入了一个X类型的右值引用的话，转发函数将被实例化为：

```c++
void IamForwording(X&& && t) {
    IrunCodeActually(static_cast<X&& &&>(t));
}
```

应用上引用折叠规则，就是：

```c++
void IamForwarding(X&& t) {
    IrunCodeActually(static_cast<X&&>(t));
}
```

这里看到了static_cast的重要性。对于一个右值而言，当它使用右值引用表达式引用的时候，该右值引用却是个左值，那么想在函数调用中继续传递右值，就需要使用std::move来进行左右值的转换。而std::move通常就是一个static_cast。不过在C++11中，用于完美转发的函数却不再叫作move，而是另外一个名字：forward。所以可以把转发函数写成这样：

```c++
template<typename T>
void IamForwording(T&& t) {
    IrunCodeActually(forward(t));
}
```

move和forward在实际实现上差别并不大。不过标准库这么设计，也许是为了让每个名字对应于不同的用途，以应对未来可能的扩展（虽然现在使用move可能也能通过完美转发函数的编译，但这并不是推荐的做法）。

来看个完美转发的例子，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(int&& m) { cout << "rvalue ref" << endl; }

void RunCode(int& m) { cout << "lvalue ref" << endl; }

void RunCode(const int&& m) { cout << "const rvalue ref" << endl; }

void RunCode(const int& m) { cout << "const lvalue ref" << endl; }

template<typename T>
void PerfectForward(T&& t) {
    RunCode(forward<T>(t));
}

int main() {
    int a;
    int b;
    const int c = 1;
    const int d = 0;

    PerfectForward(a);  // lvalue ref 。a是一个左值，而左值无法转为int&&，所以这里类型左值引用int& &&， PerfectForward<int&>(a);
    PerfectForward(move(b));  // rvalue ref
    PerfectForward(c);  // const lvalue ref
    PerfectForward(move(d));  // const rvalue ref
    return 0;
}
```

完美转发的一个作用就是做包装函数，这是一个很方便的功能。对上述代码清单的转发函数稍作修改，就可以用很少的代码记录单参数函数的参数传递况，如下：

```c++
#include <iostream>

using namespace std;

void RunCode(double&& m) {}

void RunHome(double&& h) {}

void RunComp(double&& c) {}


template<typename T, typename U>
void PerfectForward(T&& t, U& func) {
    cout << t << "\tforwarded..." << endl;
    func(forward<T>(t));
}

int main() {
    PerfectForward(1.5, RunComp);  // 1.5	forwarded...
    PerfectForward(8, RunCode);  // 8	forwarded...
    PerfectForward(1.0, RunHome);  // 1	forwarded...
    return 0;
}
```

在C++11标准库中可以看到大量完美转发的实际应用，一些很小巧好用的函数，如make_pair、make_unique等在C++都通过完美转发实现了。这样减少了一些函数版本的重复（const和非const版本的重复），并能够充分利用移动语义。无论从运行性能的提高还是从代码编写的简化上，完美转发都堪称完美。

博客：C++11完美转发介绍 <http://ju.outofmemory.cn/entry/330864>

## 3.4 显式转换操作符

C++中，隐式类型转换的“自动性”可以让程序员免于层层构造类型。但是也会有不易发现的错误：

```c++
#include <iostream>

using namespace std;

struct Rational1 {
    Rational1(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

struct Rational2 {
    explicit Rational2(int n = 0, int d = 1) : num(n), den(d) {
        cout << __func__ << "(" << num << "/" << den << ")" << endl;
    }

    int num;  // Numerator(被除数)
    int den;  // Denominator(除数)
};

void Display1(Rational1 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

void Display2(Rational2 ra) {
    cout << "Numerator: " << ra.num << " Denominator: " << ra.den << endl;
}

int main() {
    Rational1 r1_1 = 11;  // Rational1(11/1)
    Rational1 r1_2(12);  // Rational1(21/1)

//    Rational2 r2_1 = 21;  // 无法通过编译
    Rational2 r2_2(22);  // Rational2(22/1)

    Display1(1);  // Rational1(1/1) Numerator: 1 Denominator: 1
//    Display2(2);  // 无法通过编译
    Display2(Rational2(2)); // Rational2(2/1) Numerator: 2 Denominator: 1
    return 0;
}
```

使用了explicit这个关键字保证对象的显式构造在一些情况下都是必须的。

不过同样的机制并没有出现在自定义的类型转换符上。这就允许了一个逆向的过程，从自定义类型转向一个已知类型。这样虽然出现问题的几率远小于从已知类型构造自定义类型，不过有的时候，确实应该阻止会产生歧义的隐式转换。如下：

```c++
#include <iostream>

using namespace std;

template<typename T>
class Ptr {
public:
    Ptr(T* p) : p_(p) {}

    operator bool() const {
        return p_ != 0;
    }

private:
    T* p_;
};

int main() {
    int a;
    Ptr<int> p(&a);

    if (p) {  // 自动转换为bool型，没有问题
        cout << "valid pointer." << endl;  // valid pointer
    } else {
        cout << "invalid pointer." << endl;
    }

    Ptr<double> pd(0);
    cout << p + pd << endl;  // 调用bool类型转换函数后得到1+0=1

    double d;
    Ptr<double> pd1(&d);
    cout << p + pd1 << endl;  // 调用bool类型转换函数后得到1+1=2
    return 0;
}
```

定义了指针模型类型Ptr。为方便判断指针是否有效，为指针编写了自定义类型转换到bool类型的函数，可以通过if(p)这样的表达式来判断指针是否有效。不过这样的转换使得Ptr\<int\>和Ptr\<double\>两个指针加法运算获得了语法上的允许。不过明显地，我们无法看出其语义上的意义。

在C++11中，标准将explicit的使用范围扩展到了自定义的类型转换操作符上，以支持所谓的“显式类型转换”。explicit关键字作用于类型转换操作符上，意味着只有在**直接构造目标类型**或**显式类型转换**的时候可以使用该类型。如下：

```c++
class ConvertTo {};

class Convertable {
public:
    // 自定义类型转换，转换为ConvertTo类型
    explicit operator ConvertTo() const { return ConvertTo(); }
};

void Func(ConvertTo ct) {}

void test() {
    Convertable c;
    ConvertTo ct(c);  // 直接初始化，通过，表明把c显示转换为ConvertTo类型
//    ConvertTo ct2 = c;  // 拷贝构造初始化，编译失败，如果去掉explicit则可以编译通过
    ConvertTo ct3 = static_cast<ConvertTo>(c);  // 强制转化，通过
//    Func(c);  // 拷贝构造初始化，编译失败
}
```

上述代码中，定义了两个类型ConvertTo和Convertable，Convertable定义了一个显式转换到ConvertTo类型的类型转换符。那么对于test函数中ConvertTo类型的ct变量而言，由于其直接初始化构造于Convertable变量c，所以可以编译通过。而做强制类型转换的ct3同样通过了编译。而ct2由于从c中拷贝构造，因而不能通过编译。使用函数Func的时候，传入Convertable的变量c也会导致参数的拷贝构造，也不能通过编译。

如果把explicit加到Ptr::operator bool() const方法上，则if(p)可以通过编译，因为可以通过p直接构造出bool类型的变量。而p+pd这样的语句就无法通过编译，这是由于全局的operator+并不接受bool类型变量为参数，而Ptr类也不能直接构造出适用于operator+的int类型的变量造成的（不过可以尝试一下使用p&&pd这样的表达式，是能够通过编译的）。这样一来，程序的行为将更加良好。

```c++
int a;
Ptr<int> p(&a);

Ptr<double> pd(0);
cout << (p && pd) << endl;  // 0, true && false

double d;
Ptr<double> pd1(&d);
cout << (p && pd1) << endl;  // 1, true && true
```

可以看到，所谓显式类型转换并没完全禁止从源类型到目标类型的转换，不过由于此时拷贝构造和非显式类型转换不被允许，那么通常就不能通过赋值表达式或者函数参数的方式来产生这样一个目标类型。通常通过赋值表达式和函数参数进行的转换有可能是程序员的一时疏忽，而并非本意。那么使用了显式类型转换，这样的问题就会暴露出来，也是需要显式转换操作符的一个重要原因。

## 3.5 列表初始化 P111

### 3.5.1 初始化列表

 有一种初始化形式就是使用花括号的集合（列表）初始化。事实上，在C++11中，集合（列表）的初始化已经成为C++语言的一个基本功能，在C++11中，这种初始化的方法被称为“初始化列表”（initializer list）。如下：

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main() {
    int a[] = {1, 3, 5};  // C++98通过，C++11通过
    int b[]{1, 3, 5};  // C++98失败，C++11通过
    vector<int> c{1, 3, 5};  // C++98失败，C++11通过
    map<int, float> d = {{1, 1.0f}, {2, 2.0f}, {5, 3.2f}};  // C++98失败，C++11通过
    return 0;
}
```

变量b、c、d在C++98中均无法通过编译，在C++11中，由于列表初始化的存在而可以通过编译。这里，列表初始化可以在“{}”花括号之前使用等号，其效果与不带使用等号的初始化相同。

这样，自动变量和全局变量的初始化在C++11中被丰富了。可以使用以下几种形式完成初始化的工作：

- 等号“=”加上赋值表达式（assignment-expression），比如int a = 3 + 4。
- 等号“=”加上花括号式的初始化列表，比如int a = {3 + 4}。
- 圆括号式的表达式列表（expression-list），比如int a(3 + 4)。
- 花括号式的初始化列表，比如int a{3 + 4}。

而后两种形式也可以用于获取堆内存new操作符中，如：

```c++
int* i = new int(3);
double* d = new double{1.2f};
```

这在C++11中也是合法的表达式。

初始化列表不是专属于内置类型、数组，以及标准模板库中容器的功能。

在C++11中，标准总是倾向于使用更通用的方式来支持新的特性。标准模板库中窗口对初始化列表的支持源自\<initializer_list\>这个头文件中initialize_list类模板的支持。程序员只要`#include<initializer_list>`头文件，并且声明一个以initializer_list\<T\>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。如下：

```c++
#include <iostream>
#include <vector>

using namespace std;

enum Gender { boy, girl };

class People {
public:
    People(initializer_list<pair<string, Gender>> l) : data_(l) {}  // initializer_list的构造函数

private:
    vector<pair<string, Gender>> data_;
};


int main() {
    People ship2012 = {{"Garfield", boy}, {"HelloKitty", girl}};
    return 0;
}
```

同样，函数的参数列表也可以使用初始化列表，如下：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void Fun(initializer_list<int> iv) {
    for_each(iv.begin(), iv.end(), [](const auto& e) { cout << e << ", "; });
}

int main() {
    Fun({1, 2});  // 1, 2,
    Fun({});
    return 0;
}
```

上述代码定义了一个可以接受初始化列表的函数Fun。同理，类和结构体的成员函数也可以使用初始化列表，包括一些操作符的重载函数。在如下代码示例，利用了初始化列表重载了operator[]，并且重载了operator=以及使用辅助的数组。虽然例子比较复杂，但重载的效果还是能够让人感觉眼前一亮的：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>

using namespace std;

class Mydata {
public:
    Mydata& operator[](const initializer_list<int>& l) {  // 书中这里类型为initializer_list<int>
        for (auto i = l.begin(); i != l.end(); ++i) {  // auto类型为initializer_list<int>::iterator
            idx_.push_back(*i);
        }
        return *this;
    }

    Mydata& operator=(int v) {
        if (!idx_.empty()) {  // 如果调用过operator[]，则idx_中存入了修改的index列表
            for (auto i = idx_.begin(); i != idx_.end(); ++i) {
                d_.resize(max<int>(*i, d_.size()));
                d_[*i - 1] = v;
            }
            idx_.clear();
        } else {  // 如果没有调用过operator[]，则给d全部赋值
            d_.assign(d_.size(), v);
        }
        return *this;
    }

    void Print() {
        copy(d_.begin(), d_.end(), ostream_iterator<int>(cout, " "));
    }

private:
    vector<int> idx_;  // 辅助数据，用于记录index
    vector<int> d_;
};

int main() {
    Mydata d;
    d[{2, 3, 5}] = 7;  // 先调用operator[]，再调用operator=
    d[{1, 4, 5, 8}] = 4;
    d.Print();  // 4 7 7 4 4 0 0 4
    d = 10;  // 只调用operator=
    d.Print();  // 10 10 10 10 10 10 10 10
    return 0;
}
```

上述代码中，看到自定义类型Mydata拥有一个以前所有C++代码都不具备的功能，即可以在[]符号中使用列表，将设置数组中的部分为一个指定值。先把数组的第2、3、5位设为数值7，而后又将其1、4、5、8位设为数值4。最终得到数组的内容为“4 7 7 4 4 0 0 4”。当然，由于内置的数组不能重载operator[]，也就无法为其实现相应的功能。

初始化列表还可以用于函数返回的情况。返回一个初始化列表，通常会导致构造一个临时变量，如：

`vector<int> Func() { return {1, 3}; }`

当然，跟声明时采用列表初始化一样，列表初始化构造成什么类型是依据返回类型的，如：

`deque<int> Func2() { return {3, 5}; }`

上面的返回值就是deque\<int\>列表初始化构造函数而构造的。面跟普通的字面量相同，如果返回值是一个引用类型的话，则会返回一个临时变量的引用。如：

`const vector<int>& Func1() { return {3, 5}; }`

这里注意，必须要加const限制符。该规则与返回一个字面常量是一样的。

而本地试验，上述Func1函数可以编译过，但是有编译告警，运行错误，如下：

```c++
//const Mydata& getMydata1() {
//    Mydata d;
//    d[{2, 3, 5}] = 7;
//    return d;  // 编译告警，返回局部变量引用
//}
//
//const Mydata& getMydata2() {
//    return Mydata();  // 无论返回const Mydata&还是Mydata&&，都有编译告警，返回局部变量引用
//}

//const vector<int>& Func1() {  // 如果返回值是vector<int>&，编译错误：不能把非常量左值引用绑定在右值类型std::vector<int>
//    return {3, 5};  // 同样编译告警，返回局部变量引用，这样理解的话，应该是先用{3, 5}构造出来一个同样是局部变量的vector<int>，然后再return
//}

void test1(const vector<int>& ints) {
//    ints.push_back(10);  // 编译错误，常量左值引用无法修改
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

void test2(vector<int>&& ints) {
    ints.push_back(10);
    copy(ints.begin(), ints.end(), ostream_iterator<int>(cout, " "));
}

int main() {
//    const Mydata& d1 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d1.Print();
//    const Mydata& d2 = getMydata1();  // 运行错误，出函数后临时变量析构掉
//    d2.Print();
//    const vector<int>& ints = Func1();  // 运行错误，常量左值引用的是函数返回对象，而函数返回对象又是引用函数局部变量，该局部变量已经构造
//    cout << ints.size() << endl;
    test1({1, 2, 3});  // 1 2 3
    test2({1, 2, 3});  // 1 2 3 10
    return 0;
}
```

### 3.5.2 防止类型收窄

使用列表初始化还有一个最大优势是可以防止类型收窄（narrowing）。类型收窄一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。

如果变量a从类型A转化为类型B，其值在B中也是可以被表示的，且再转化回类型A能获得原有值的话，那么这种类型转换也不能叫作类型收窄。所以类型收窄也可以简单地理解为新类型无法表示原有类型数据的值的情况。

在C++11中，使用初始化列表进行初始化的数据编译器是会松本其是否发生类型收窄。如下：

```c++
const int x = 1024;
const int y = 10;

char a = x;  // 收窄，但可以通过编译
char* b = new char(1024);  // 收窄，但可以通过编译

char c = {x};  // 收窄，无法通过编译
char d = {y};  // 可以通过编译
unsigned char e{-1};  // 收窄，无法通过编译

float f{7};  // 可以通过编译
int g{2.0f};  // 收窄，无法通过编译
float* h = new float{1e48};  // 收窄，无法通过编译
float i = 1.2l;  // 可以通过编译，l是什么意思？
```

对于变量a和*b而言，由于其采用的是赋值表达符及圆括号的表达式初始化，所以虽然它们的数据类型明显收窄（char通常取值范围为-128到127），却不会引发编译失败（事实上，在我们的实验机上会得到编译器的警告）。而使用初始化列表的情况则不一样，对于变量c，由于其类型收窄，则会导致编译器报错。而对于变量d来说，其初始化使用了常量值10，而10是可以由char类型表示的，因此这里不会发生收窄，编译可以通过。

在C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。这也是列表初始化区别于其他初始化方式的地方。事实上，现在编译器大多数会在发生类型收窄的时候提示用户，因为类型收窄通常是代码可能出现问题的征兆。C++将列表初始化设定为可以防范类型收窄，也是为了加强类型使用的安全性。

总的来说，列表初始化改变了C++中对类型初始化的一些基本模式，将标准程序库跟语言拉得更近了。这样的做法有效地统一了内置类型和自定义类型的行为。也是C++11设计所遵循的一个思想，即通用为本，专用为末。

## 3.6 POD类型 P117

C++11将POD划分为两个基本概念的合集，即：平凡的（trivial）和标准布局的（standard layout）。

通常情况下，一个平凡的类或结构体应该符合以下定义：

1. 拥有的默认构造函数（trivial constructor）和析构函数（trivial destructor）
2. 拥有的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）
3. 拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）
4. 不能包含虚函数以及虚基类。

以上4点虽然看似复杂，不过在C++11中，可以通过一些辅助的类模板来帮我们进行以上属性的判断。

类模板is_trivial的成员value可以用于判断T的类型是否是一个平凡的类型。除了类和结构体外，is_trivial还可以对内置的标题类型数据（比如int、float都属性平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

```c++
#include <iostream>

using namespace std;

struct Trivial1 {};
struct Trivial2 {
public:
    int a;
private:
    int b;
};

struct Trivial3 {
    Trivial1 a;
    Trivial2 b;
};

struct Trivial4 {
    Trivial2 a[23];
};

struct Trivial5 {
    int x;
    static int y;
};

struct NonTrivial1 {
    NonTrivial1() : z(42) {}

    int z;
};

struct NonTrivial2 {
    NonTrivial2();

    int w;
};

NonTrivial2::NonTrivial2() = default;

struct NonTrivial3 {
    Trivial5 c;

    virtual void f();
};

int main() {
    cout << is_trivial<Trivial1>::value << endl;  // 1
    cout << is_trivial<Trivial2>::value << endl;  // 1
    cout << is_trivial<Trivial3>::value << endl;  // 1
    cout << is_trivial<Trivial4>::value << endl;  // 1
    cout << is_trivial<Trivial5>::value << endl;  // 1
    cout << is_trivial<NonTrivial1>::value << endl;  // 0
    cout << is_trivial<NonTrivial2>::value << endl;  // 0
    cout << is_trivial<NonTrivial3>::value << endl;  // 0
    return 0;
}
```

POD包含的另外一个概念是标准布局。标准布局的类或结构体应该符合以下定义：

1. 所有非静态成员有相同的访问权限（public, private, protected）。

   如下匿名结构体不是标准布局的：

   ```c++
   struct {
   public:
       int a;
   private:
       int b;
   };
   ```

   如果去掉private关键字的话，该匿名结构体就符合标准布局的定义了。

2. 在类或者结构体继承时，满足以下两种情况之一：

   - 派生类中有非静态成员，且只有一个仅包含静态成员的基类。

   - 基类有非静态成员，而派生类没有非静态成员。
   
   这样的类或者结构体，也是标准布局的。
   
3. 类中的第一个非静态成员的类型与其基类不同。

   这条规则非常特别，用于形如：

   ```c++
   struct A : B {
       B b;
   }
   ```

   这样的情况。这里的A类型不是一个标准布局的类型，因为第一个非静态成员变量b的类型跟A所继承的类型B相同。而形如：

   ```c++
   struct C : B {
       int a;
       B b;
   }
   ```

   则是一个标准布局的类型。
   
4. 没有虚函数和虚基类。

5. 没有非静态数据成员均符合标准布局类型，其基类也符合标准布局。这是一个递归的定义，没什么好特别解释的。

以上5点构成了标准布局的定义，最为重要的应该是前两条。

同样，在C++11中，可以使用模板类来帮忙判断类型是否是一个标准布局的类型。

通过is_standard_layout模板类的成员value(`is_standard_layout<T>::value`)，可以在代码中打印出类型的标准布局属性。如下：

```c++
#include <iostream>

using namespace std;

struct SLayout1 {};
struct SLayout2 {
private:
    int x;
    int y;
};

struct SLayout3 : SLayout1 {
    int x;
    int y;

    void f();
};

struct SLayout4 : SLayout1 {
    int x;
    SLayout1 y;
};

struct SLayout5 : SLayout1, SLayout3 {};  // warning: direct base 'SLayout1' inaccessible in 'SLayout5' due to ambiguity

struct SLayout6 { static int y; };

struct SLayout7 : SLayout6 { int x; };

// 违反3，第一个非静态成员类型与基类相同
struct NonSLayout1 : SLayout1 {
    SLayout1 x;
    int i;
};

// 违反2，基类和派生类同时有非静态成员
struct NonSLayout2 : SLayout2 { int z; };

// 违反5，基类不符合标准布局
struct NonSLayout3 : NonSLayout2 {};

// 违反1，非静态成员访问权限不同
struct NonSLayout4 {
public:
    int x;
private:
    int y;
};

int main() {
    cout << is_standard_layout<SLayout1>::value << endl;  // 1
    cout << is_standard_layout<SLayout2>::value << endl;  // 1
    cout << is_standard_layout<SLayout3>::value << endl;  // 1
    cout << is_standard_layout<SLayout4>::value << endl;  // 1
    cout << is_standard_layout<SLayout5>::value << endl;  // 1
    cout << is_standard_layout<SLayout6>::value << endl;  // 1
    cout << is_standard_layout<SLayout7>::value << endl;  // 1

    cout << is_standard_layout<NonSLayout1>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout2>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout3>::value << endl;   // 0
    cout << is_standard_layout<NonSLayout4>::value << endl;   // 0
    return 0;
}
```

对于POD而言，在C++11中的定义就是平凡的和标准布局的两个方面。标准库中的\<type_traits\>头文件也为程序员提供了模板类。

可以使用std::is_pod\<T\>::value来判定一个类型是否是POD，如下：

```c++
#include <iostream>
#include <type_traits>

using namespace std;

union U {};

union U1 { U1() {}};

enum E {};
typedef double* DA;

typedef void (* PF)(int, double);

int main() {
    cout << is_pod<U>::value << endl;  // 1
    cout << is_pod<U1>::value << endl;  // 0
    cout << is_pod<E>::value << endl;  // 1
    cout << is_pod<int>::value << endl;  // 1
    cout << is_pod<DA>::value << endl;  // 1
    cout << is_pod<PF>::value << endl;  // 1
    return 0;
}
```

如上代码，很多内置类型默认都是POD的。POD最为复杂的地方还是在类或者结构体的判断。使用的POD的好处，大概有如下3点：

1. 字节赋值，代码中可以安全地使用memset和memcpy对POD类型进行初始化和拷贝等操作。

2. 提供对C内存布局兼容。C++程序可以与C函数进行相互操作，因为POD类型的数据在C与C++间的操作总是安全的。

3. 保证了静态初始化的安全有效。静态初始化在很多时间能够提高程序的性能，而POD类型的对象初始化往往更加简单（比如放入目标文件的.bss段，在初始化中直接被赋0）。

## 3.7 非受限联合体 P125

