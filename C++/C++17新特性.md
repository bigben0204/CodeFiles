# [C++17中那些值得关注的特性](https://www.iteye.com/news/32574)

C++17标准在2017上半年已经讨论确定，正在形成ISO标准文档，今年晚些时候会正式发布。本文将介绍最新标准中值得开发者关注的新特新和基本用法。

总的来说C++17相比C++11的新特性来说新特性不算多，做了一些小幅改进。C++17增加了数十项新特性，值得关注的特性大概有下面这些：

- constexpr if
- constexpr lambda
- fold expression
- void_t
- structured binding
- std::apply, std::invoke
- string_view
- parallel STL
- inline variable

剩下的有一些来自于boost库，比如variant,any、optional和filesystem等特性，string_view其实在boost里也有。还有一些是语法糖，比如if init、deduction guide、guaranteed copy Elision、template、nested namespace、single param static_assert等特性。我接下来会介绍C++17主要的一些特性，介绍它们的基本用法和作用，让读者对C++17的新特性有一个基本的了解。

## **fold expression**

C++11增加了一个新特性可变模版参数（variadic template）,它可以接受任意个模版参数在参数包中，参数包是三个点…，它不能直接展开，需要通过一些特殊的方法才能展开，导致在使用的时候有点难度。现在C++17解决了这个问题，让参数包的展开变得容易了，Fold expression就是方便展开参数包的。

**fold expression的语义**
fold expression有4种语义：

- unary right fold (pack op …)
- unary left fold (… op pack)
- binary right fold (pack op … op init)
- binary left fold (init op … op pack)

其中pack代表变参，比如args，op代表操作符，fold expression支持32种操作符：

引用

`+ - * / % ^ & | = < > << >> += -= *= /= %= ^= &= |= <<= >>= == != <= >= && || , .* ->*`

### **unary right fold的含义**

fold (E op …) 意味着 E1 op (… op (EN-1 op EN)).

顾名思义，从右边开始fold，看它是left fold还是right fold我们可以根据参数包…所在的位置来判断，当参数包…在操作符右边的时候就是right fold，在左边的时候就是left fold。我们来看一个具体的例子：

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto add_val(Args&& ... args) {
    return (args + ...);
}

int main() {
    auto t = add_val(1, 2, 3, 4);  // 10
    cout << t << endl;
    return 0;
}
```

right fold的过程是这样的：(1+(2+(3+4)))，从右边开始fold。

### **unary left fold的含义**

fold (… op E) 意味着 ((E1 op E2) op …) op EN。

对于+这种满足交换律的操作符来说left fold和right fold是一样的，比如上面的例子你也可以写成left fold。

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto add_val(Args&& ... args) {
    return (... + args);
}

int main() {
    auto t = add_val(1, 2, 3, 4);
    cout << t << endl;
    return 0;
}
```

对于不满足交换律的操作符来说就要注意了，比如减法。

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto sub_val_right(Args&& ... args) {
    return (args - ...);
}

template<typename... Args>
auto sub_val_left(Args&& ... args) {
    return (... - args);
}

int main() {
    auto t = sub_val_right(2, 3, 4);  // (2-(3-4)) = 3
    auto t1 = sub_val_left(2, 3, 4);  // ((2-3)-4) = -5
    cout << t << endl;
    cout << t1 << endl;
    return 0;
}
```

这次right fold和left fold的结果就不一样。

### **binary fold的含义**

Binary right fold (E op … op I) 意味着 E1 op (… op (EN-1 op (EN op I)))。

Binary left fold (I op … op E) 意味着 (((I op E1) op E2) op …) op E2。

其中E代表变参，比如args，op代表操作符，**I代表一个初始变量**。

二元fold的语义和一元fold的语义是相同的，看一个二元操作符的例子：

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto sub_one_left(Args&& ... args) {
    return (1 - ... - args);
}

template<typename... Args>
auto sub_one_right(Args&& ... args) {
    return (args - ... - 1);
}

int main() {
    auto t = sub_one_left(2, 3, 4);  // (((1-2)-3)-4) = -8
    auto t1 = sub_one_right(2, 3, 4);  // (2-(3-(4-1))) = 2
    cout << t << endl;
    cout << t1 << endl;
    return 0;
}
```

相信通过这个例子大家应该对C++17的fold expression有了基本的了解。

## **comma fold**

在C++17之前，我们经常使用逗号表达式和std::initializer_list来将变参一个个传入一个函数。比如像下面这个例子：

```c++
#include <iostream>

using namespace std;

template<typename T>
void print_arg(T t) {
    cout << t << endl;
}

template<typename... Args>
void print2(Args&& ... args) {
    initializer_list<int>{(print_arg(args), 0)...};
}

int main() {
    print2(1, 2, 3, 4);
    return 0;
}
// 输出：
1
2
3
4
```

这种写法比较繁琐，用fold expression就会变得很简单了。

```c++
#include <iostream>

using namespace std;

template<typename T>
void print_arg(T t) {
    cout << t << endl;
}

template<typename... Args>
void print3(Args... args) {
    (print_arg(args), ...);
}

int main() {
    print3(1, 2, 3, 4);
    return 0;
}
// 输出：
1
2
3
4
```

这是right fold，你也可以写成left fold，对于comma来说两种写法是一样的，参数都是从左至右传入print_arg函数。

```c++
template<typename... Args>
void print3(Args... args) {
    (..., print_arg(args));
}
// 输出：
1
2
3
4
```

你也可以通过binary fold这样写：

```c++
template<typename... Args>
void printer(Args&& ... args) {
    (std::cout << ... << args) << '\n';
}

int main() {
    printer(1, 2, 3, 4);
    return 0;
}
// 输出：
1234
    
```

也许你会觉得能写成这样：

```c++
template<typename... Args>
void printer(Args&& ... args) {
    (std::cout << args << ...) << '\n';
}

```

但这样写是不合法的，根据binary fold的语法，参数包…必须在操作符中间，因此上面的这种写法不符合语法要求。

借助comma fold我们可以简化代码，假如我们希望实现tuple的for_each算法，像这样：

```c++
for_each(make_tuple(2.5, 10, 'a'), [](auto e) { cout << e << "\n"; });
```

这个for_each将会遍历tuple的元素并打印出来。在C++17之前我们如果要实现这个算法的话，需要借助逗号表达式和std::initializer_list来实现，类似于这样：

```c++
#include <iostream>
#include <tuple>
#include <algorithm>

using namespace std;

template<typename... Args, typename Func, std::size_t... Idx>
void for_each(const std::tuple<Args...>& t, Func&& f, std::index_sequence<Idx...>) {
    (void) std::initializer_list<int>{(f(std::get<Idx>(t)), void(), 0)...};
}

int main() {
    for_each(make_tuple(2.5, 10, 'a'), [](auto e) { cout << e << "\n"; }, make_index_sequence<3>());
    return 0;
}
// 输出：
2.5
10
a
```

这样写比较繁琐不直观，现在借助fold expression我们可以简化代码了。

```c++
template<typename... Args, typename Func, std::size_t... Idx>
void for_each(const std::tuple<Args...>& t, Func&& f, std::index_sequence<Idx...>) {
    (f(std::get<Idx>(t)), ...);
}
```

借助coma fold我们可以写很简洁的代码了。

## **constexpr if**

constexpr标记一个表达式或一个函数的返回结果是编译期常量，它保证函数会在编译期执行。相比模版来说，实现编译期循环或递归，C++17中的constexpr if会让代码变得更简洁易懂。比如实现一个编译期整数加法：

```c++
#include <iostream>

using namespace std;

template<int N>
constexpr int sum() {
    return N;
}

template<int N, int N2, int... Ns>
constexpr int sum() {
    return N + sum<N2, Ns...>();
}

int main() {
    cout << sum<1, 2, 3>() << endl;  // 6
    return 0;
}
```

C++17之前你可能需要像上面这样写，但是现在你可以写更简洁的代码了。

```c++
template<int N, int... Ns>
constexpr auto sum17() {
    if constexpr (sizeof...(Ns) == 0) {
        return N;
    } else {
        return N + sum17<Ns...>();
    }
}

int main() {
    cout << sum17<1, 2, 3>() << endl;  // 6
    return 0;
}
```

当然，你也可以用C++17的fold expression：

```c++
#include <iostream>

using namespace std;

template<typename ... Args>
constexpr int sum(Args... args) {
    return (0 + ... + args);
}

int main() {
    cout << sum(1, 2, 3) << endl;  // 6
    return 0;
}
```

constexpr还可以用来消除enable_if了，对于讨厌写一长串enable_if的人来说会非常开心。比如我需要根据类型来选择函数的时候：

```c++
#include <iostream>

using namespace std;

template<typename T>
std::enable_if_t<std::is_integral<T>::value, std::string> to_str(T t) {  // 如果入参类型是数字，则调用to_string，返回std::string
    return std::to_string(t);
}

template<typename T>
std::enable_if_t<!std::is_integral<T>::value, std::string> to_str(T t) {  // 如果入参类型不是数字，则直接返回入参
    return t;
}

struct Test {};

int main() {
    string&& s1 = to_str(100);
    string&& s2 = to_str("hello");
    // string&& s3 = to_str(Test());  // 编译错误：error: could not convert 't' from 'Test' to 'std::enable_if_t<true, std::basic_string<char> >' {aka 'std::basic_string<char>'}
    cout << s1 << endl;
    cout << s2 << endl;
    return 0;
}
```

经常不得不分开几个函数来写，还需要写长长的enable_if，比较繁琐，通过if constexpr可以消除enable_if了。

```c++
template<typename T>
auto to_str17(T t) {
    if constexpr (std::is_integral<T>::value) {
        return std::to_string(t);
    } else {
        return t;
    }
}

int main() {
    string&& s1 = to_str17(100);  // 100
    string&& s2 = to_str17("hello");  // hello
    cout << s1 << endl;
    cout << s2 << endl;
    return 0;
}
```

constexpr if让C++的模版具备if-else if-else功能了，是不是很酷，C++程序员的好日子来了。

不过需要注意的是下面这种写法是有问题的。

```c++
template<typename T>
auto to_str17(T t) {
    if constexpr (std::is_integral<T>::value) {
        return std::to_string(t);
    }
    return t;
}
```

这个代码把else去掉了，当输入如果是非数字类型时代码可以编译过，以为if constexpr在模版实例化的时候会丢弃不满足条件的部分，因此函数体中的前两行代码将失效，只有最后一句有效。当输入的为数字的时候就会产生编译错误了，因为if constexpr满足条件了，这时候就会有两个return了，就会导致编译错误。

constexpr if还可以用来替换#ifdef宏，看下面的例子：

```c++
using namespace std;

enum class OS { Linux, Mac, Windows };

//Translate the macros to C++ at a single point in the application
#ifdef __linux__
constexpr OS the_os = OS::Linux;
#elif __APPLE__
constexpr OS the_os = OS::Mac;
#elif __WIN32
constexpr OS the_os = OS::Windows;
#endif

void do_something() {
    //do something general

    if constexpr (the_os == OS::Linux) {
        //do something Linuxy
    } else if constexpr (the_os == OS::Mac) {
        //do something Appley
    } else if constexpr (the_os == OS::Windows) {
        //do something Windowsy
    }

    //do something general
}
//备注：这个例子摘自https://blog.tartanllama.xyz/c++/2016/12/12/if-constexpr/  
```

代码变得更清爽了，再也不需要像以前一样写#ifdef那样难看的代码块了。

## **constexpr lambda**

constexpr lambda其实很简单，它的意思就是可以在constexpr 函数中用lambda表达式了，这在C++17之前是不允许的。这样使用constexpr函数和普通函数没多大区别了，使用起来非常舒服。下面是constexpr lambda的例子：

```c++
#include <iostream>

using namespace std;

template<typename I>
constexpr auto func(I i) {
    // use a lambda in constexpr context，看起来和python的闭包有点像
    return [i](auto j) { return i + j; };
}

int main() {
    auto f = func(1);
    cout << f(2) << endl;  // 3
    return 0;
}
```

constexpr if和constexpr lambda是C++17提供的非常棒的特性，enjoy it.

## **string_view**

### **string_view的基本用法**

C++17中的string_view是一个char数据的视图或者说引用，它并不拥有该数据，是为了避免拷贝，因此使用string_view可以用来做性能优化。你应该用string_view来代替const char和const string了。string_view的方法和string类似，用法很简单：

```c++
#include <iostream>

using namespace std;

int main() {
    const char* data = "test";
    string_view str1(data, 4);
    cout << str1.length() << "\n";
    if (data == str1) {
        cout << "ok" << "\n";
    }

    const std::string str2 = "test";
    string_view str3(str2.c_str(), str2.size());
    cout << str3 << endl;
    return 0;
}
// 输出：
4
ok
test
```

构造string_view的时候用char*和长度来构造，这个长度可以自由确定，它表示string_view希望引用的字符串的长度。因为它只是引用其他字符串，所以它不会分配内存，不会像string那样容易产生临时变量。我们通过一个测试程序来看看string_view如何来帮我们优化性能的。

```c++
#include <iostream>
#include <string_view>
#include <chrono>

using namespace std;
using namespace std::literals;

class Timer {
public:
    ~Timer() {
        chrono::steady_clock::time_point end = chrono::steady_clock::now();
        chrono::duration<double> timeUsed = chrono::duration_cast<chrono::duration<double >>(end - start_);
        cout << "Elapse time : " << timeUsed.count() << "s" << endl;
    }

private:
    chrono::steady_clock::time_point start_ = chrono::steady_clock::now();;
};

int main() {
    constexpr auto LEN = 1000000;

    {
        constexpr auto s = "it is a test"sv;
        Timer t1;
        for (int i = 0; i < LEN; ++i) {
            constexpr auto s1 = s.substr(3);  // 返回的也是string_view类型
        }
    }

    {
        auto str = "it is a test"s;
        Timer t2;
        for (int i = 0; i < LEN; ++i) {
            auto s2 = str.substr(3);
        }
    }
    return 0;
}
// 输出：
Elapse time : 0.0013916s
Elapse time : 0.309733s
```

我们可以通过字面量””sv来初始化string_view。string_view的substr和string的substr相比，快了50多倍，根本原因是它不会分配内存。（上述代码本地验证，快了200多倍）

### **string_view的生命周期**

由于string_vew并不拥有锁引用的字符串，所以它也不会去关注被引用字符串的生命周期，用户在使用的时候需要注意，不要将一个临时变量给一个string_view，那样会导致string_view引用的内容也失效。

```c++
#include <iostream>
#include <string_view>

using namespace std;

int main() {
    string_view str_v;
    {
        string temp = "test";
        str_v = {temp.c_str()};
        cout << str_v << endl;
    }
    cout << str_v << endl;
    return 0;
}
```

这样的代码是有问题的，因为出了作用域之后，string_view引用的内容已经失效了。

**总结**

本文介绍了C++17的fold expression、constexpr if、constexpr lambda和string_view。fold expression为了简化可变模板参数的展开，让可以模板参数的使用变得更简单直观；constexpr if让模板具备if-else功能，非常强大。它也避免了写冗长的enable_if代码，让代码变得简洁易懂了；string_view则是用来做性能优化的，应该用它来代替const char*和const string。

# [你需要了解的 C++ 17 Top 19 新特性](https://www.oschina.net/news/85129/top-19-new-features-of-c17-you-need-to-know)

### C++17 的 19 个新特性

1. 使 static_assert 的文本信息可选
2. 删除 trigraphs
3. 在模板参数中允许使用 typename（作为替代类）
4. 来自 braced-init-list 的新规则用于自动推导
5. 嵌套命名空间的定义，例如：使用 namespace X::Y { … } 代替 namespace X { namespace Y { … }}
6. 允许命名空间和枚举器的属性
7. 新的标准属性：[[fallthrough]], [[maybe_unused]] 和 [[nodiscard]]
8. UTF-8 字符文字
9. 对所有非类型模板参数进行常量评估
10. Fold 表达式，用于可变的模板
11. A compile-time static if with the form if constexpr(expression)
12. 结构化的绑定声明，现在允许 auto [a, b] = getTwoReturnValues();
13.  if 和 switch 语句中的初始化器
14. 在某些情况下，确保通过编译器进行 copy elision（Guaranteed copy elision by compilers in some cases）
15.  一些用于对齐内存分配的扩展
16. 构造函数的模板推导，允许使用 std::pair(5.0, false) 代替 std::pair<double,bool>(5.0, false)
17. 内联变量，允许在头文件中定义变量
18. __has_include，允许由预处理程序指令检查头文件的可用性
19. __cplusplus 的值更改为 201703L

# [C++17新属性详解](https://blog.csdn.net/fanyun_01/article/details/80471626)

## 非类型模板参数的 auto

模板参数分为两种，一种是类型模板参数，也是我们用得最多的一种：

```c++
template <typename T, typename U>
auto add(T t, U u) {
    return t+u;
}
```

 里面的 `T` 和 `U` 都是类型模板参数。另一种是非类型模板参数，它可以让不同的字面量成为模板的参数：

```c++
template <typename T, int BufSize>
class buffer_t {
public:
    T& alloc();
    void free(T& item);
private:
    T data[BufSize];
}
 
buffer_t<int, 100> buf; // 100 作为模板参数
```

遗憾的是我们在编写模板的时候就必须明确非类型模板参数的具体类型，C++17 打破了这一限制，让我们能够在非类型模板参数中使用 auto 关键字，从而让编译器推导具体的类型：

```c++
template <auto value> void foo() {
    return;
}
 
foo<10>();  // value 被推导为 int 类型
```

## std::variant

熟悉 boost 的人应该很早就听说过 variant<> 了。variant<> 可以用于存储和操作不同类型的对象。我们在前面（对标准库的扩充：新增容器）对于迭代 std::tuple 时，简单使用了 boost::variant<>。提供给 variant<> 的类型模板参数可以让一个 variant<> 从而容纳提供的几种类型的变量（在其他语言(例如 Python/JavaScript 等)表现为动态类型）。

C++17 正式将 variant<> 纳入标准库，摇身一变成为 std::variant<>，有了它之后，我们可以将前面的代码更改为：

```c++
#include <iostream>
#include <variant>
#include <tuple>

using namespace std;

template<size_t n, typename... Args>
std::variant<Args...> _tuple_index(size_t i, const std::tuple<Args...>& tpl) {
    if (i == n) {
        return std::get<n>(tpl);  // 这里编译错误：error: could not convert 'std::get<0, int, int, int>((* & tpl))' from 'std::__tuple_element_t<0, std::tuple<int, int, int> >' {aka 'const int'} to 'std::variant<int, int, int>'，不太知道怎么用
    } else if (n == sizeof...(Args) - 1) {
        throw std::out_of_range("越界.");
    } else {
        return _tuple_index<(n < sizeof...(Args) - 1 ? n + 1 : 0)>(i, tpl);
    }
}

template<typename... Args>
std::variant<Args...> tuple_index(size_t i, const std::tuple<Args...>& tpl) {
    return _tuple_index<0>(i, tpl);
}

int main() {
    auto ret = tuple_index(1, make_tuple(1, 2, 3));
    return 0;
}
```



## 结构化绑定(Structured bindings)

结构化绑定提供了类似其他语言中提供的多返回值的功能。到目前为止，我们可以通过 std::tuple 来构造一个元组，囊括多个返回值。但缺陷是显而易见的，我们没有一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型。

C++17 给出的结构化绑定可以让我们写出这样的代码：

```c++
#include <iostream>
#include <tuple>

using namespace std;

std::tuple<int, double, std::string> f() {  // 可以写成auto f()
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto[x, y, z] = f(); // x,y,z 分别被推导为int,double,std::string
    cout << x << "\n";  // 1
    cout << y << "\n";  // 2.3
    cout << z << "\n";  // 456
    return 0;
}
```

## 变量声明的强化

变量的声明在虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch语句中声明一个临时的变量。例如：

```c++
auto p = map_container.try_emplace(key, value);
if(!p.second) {
    //...
} else {
    //...
}
```

C++17 消除了这一限制，使得我们可以：

```c++
if (auto p = m.try_emplace(key, value); !p.second) {   
    //...  这里可以使用p
} else {
    //...  这里也可以使用p
}
// 这里无法使用p
```

# [C++17新特性个人总结](https://blog.csdn.net/qq811299838/article/details/90371604?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)



 















