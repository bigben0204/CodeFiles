# [C++17中那些值得关注的特性](https://www.iteye.com/news/32574)

C++17标准在2017上半年已经讨论确定，正在形成ISO标准文档，今年晚些时候会正式发布。本文将介绍最新标准中值得开发者关注的新特新和基本用法。

总的来说C++17相比C++11的新特性来说新特性不算多，做了一些小幅改进。C++17增加了数十项新特性，值得关注的特性大概有下面这些：

- constexpr if
- constexpr lambda
- fold expression
- void_t
- structured binding
- std::apply, std::invoke
- string_view
- parallel STL
- inline variable

剩下的有一些来自于boost库，比如variant,any、optional和filesystem等特性，string_view其实在boost里也有。还有一些是语法糖，比如if init、deduction guide、guaranteed copy Elision、template、nested namespace、single param static_assert等特性。我接下来会介绍C++17主要的一些特性，介绍它们的基本用法和作用，让读者对C++17的新特性有一个基本的了解。

## **fold expression**

C++11增加了一个新特性可变模版参数（variadic template）,它可以接受任意个模版参数在参数包中，参数包是三个点…，它不能直接展开，需要通过一些特殊的方法才能展开，导致在使用的时候有点难度。现在C++17解决了这个问题，让参数包的展开变得容易了，Fold expression就是方便展开参数包的。

**fold expression的语义**
fold expression有4种语义：

- unary right fold (pack op …)
- unary left fold (… op pack)
- binary right fold (pack op … op init)
- binary left fold (init op … op pack)

其中pack代表变参，比如args，op代表操作符，fold expression支持32种操作符：

引用

`+ - * / % ^ & | = < > << >> += -= *= /= %= ^= &= |= <<= >>= == != <= >= && || , .* ->*`

### **unary right fold的含义**

fold (E op …) 意味着 E1 op (… op (EN-1 op EN)).

顾名思义，从右边开始fold，看它是left fold还是right fold我们可以根据参数包…所在的位置来判断，当参数包…在操作符右边的时候就是right fold，在左边的时候就是left fold。我们来看一个具体的例子：

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto add_val(Args&& ... args) {
    return (args + ...);
}

int main() {
    auto t = add_val(1, 2, 3, 4);  // 10
    cout << t << endl;
    return 0;
}
```

right fold的过程是这样的：(1+(2+(3+4)))，从右边开始fold。

### **unary left fold的含义**

fold (… op E) 意味着 ((E1 op E2) op …) op EN。

对于+这种满足交换律的操作符来说left fold和right fold是一样的，比如上面的例子你也可以写成left fold。

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto add_val(Args&& ... args) {
    return (... + args);
}

int main() {
    auto t = add_val(1, 2, 3, 4);
    cout << t << endl;
    return 0;
}
```

对于不满足交换律的操作符来说就要注意了，比如减法。

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto sub_val_right(Args&& ... args) {
    return (args - ...);
}

template<typename... Args>
auto sub_val_left(Args&& ... args) {
    return (... - args);
}

int main() {
    auto t = sub_val_right(2, 3, 4);  // (2-(3-4)) = 3
    auto t1 = sub_val_left(2, 3, 4);  // ((2-3)-4) = -5
    cout << t << endl;
    cout << t1 << endl;
    return 0;
}
```

这次right fold和left fold的结果就不一样。

### **binary fold的含义**

Binary right fold (E op … op I) 意味着 E1 op (… op (EN-1 op (EN op I)))。

Binary left fold (I op … op E) 意味着 (((I op E1) op E2) op …) op E2。

其中E代表变参，比如args，op代表操作符，**I代表一个初始变量**。

二元fold的语义和一元fold的语义是相同的，看一个二元操作符的例子：

```c++
#include <iostream>

using namespace std;

template<typename... Args>
auto sub_one_left(Args&& ... args) {
    return (1 - ... - args);
}

template<typename... Args>
auto sub_one_right(Args&& ... args) {
    return (args - ... - 1);
}

int main() {
    auto t = sub_one_left(2, 3, 4);  // (((1-2)-3)-4) = -8
    auto t1 = sub_one_right(2, 3, 4);  // (2-(3-(4-1))) = 2
    cout << t << endl;
    cout << t1 << endl;
    return 0;
}
```

相信通过这个例子大家应该对C++17的fold expression有了基本的了解。

## **comma fold**

在C++17之前，我们经常使用逗号表达式和std::initializer_list来将变参一个个传入一个函数。比如像下面这个例子：

```c++
#include <iostream>

using namespace std;

template<typename T>
void print_arg(T t) {
    cout << t << endl;
}

template<typename... Args>
void print2(Args&& ... args) {
    initializer_list<int>{(print_arg(args), 0)...};
}

int main() {
    print2(1, 2, 3, 4);
    return 0;
}
// 输出：
1
2
3
4
```

这种写法比较繁琐，用fold expression就会变得很简单了。

```c++
#include <iostream>

using namespace std;

template<typename T>
void print_arg(T t) {
    cout << t << endl;
}

template<typename... Args>
void print3(Args... args) {
    (print_arg(args), ...);
}

int main() {
    print3(1, 2, 3, 4);
    return 0;
}
// 输出：
1
2
3
4
```

这是right fold，你也可以写成left fold，对于comma来说两种写法是一样的，参数都是从左至右传入print_arg函数。

```c++
template<typename... Args>
void print3(Args... args) {
    (..., print_arg(args));
}
// 输出：
1
2
3
4
```

你也可以通过binary fold这样写：

```c++
template<typename... Args>
void printer(Args&& ... args) {
    (std::cout << ... << args) << '\n';
}

int main() {
    printer(1, 2, 3, 4);
    return 0;
}
// 输出：
1234
    
```

也许你会觉得能写成这样：

```c++
template<typename... Args>
void printer(Args&& ... args) {
    (std::cout << args << ...) << '\n';
}

```

但这样写是不合法的，根据binary fold的语法，参数包…必须在操作符中间，因此上面的这种写法不符合语法要求。

借助comma fold我们可以简化代码，假如我们希望实现tuple的for_each算法，像这样：

```c++
for_each(make_tuple(2.5, 10, 'a'), [](auto e) { cout << e << "\n"; });
```

这个for_each将会遍历tuple的元素并打印出来。在C++17之前我们如果要实现这个算法的话，需要借助逗号表达式和std::initializer_list来实现，类似于这样：

```c++
#include <iostream>
#include <tuple>
#include <algorithm>

using namespace std;

template<typename... Args, typename Func, std::size_t... Idx>
void for_each(const std::tuple<Args...>& t, Func&& f, std::index_sequence<Idx...>) {
    (void) std::initializer_list<int>{(f(std::get<Idx>(t)), void(), 0)...};
}

int main() {
    for_each(make_tuple(2.5, 10, 'a'), [](auto e) { cout << e << "\n"; }, make_index_sequence<3>());
    return 0;
}
// 输出：
2.5
10
a
```

这样写比较繁琐不直观，现在借助fold expression我们可以简化代码了。

```c++
template<typename... Args, typename Func, std::size_t... Idx>
void for_each(const std::tuple<Args...>& t, Func&& f, std::index_sequence<Idx...>) {
    (f(std::get<Idx>(t)), ...);
}
```

借助coma fold我们可以写很简洁的代码了。

## **constexpr if**

constexpr标记一个表达式或一个函数的返回结果是编译期常量，它保证函数会在编译期执行。相比模版来说，实现编译期循环或递归，C++17中的constexpr if会让代码变得更简洁易懂。比如实现一个编译期整数加法：

```c++
#include <iostream>

using namespace std;

template<int N>
constexpr int sum() {
    return N;
}

template<int N, int N2, int... Ns>
constexpr int sum() {
    return N + sum<N2, Ns...>();
}

int main() {
    cout << sum<1, 2, 3>() << endl;  // 6
    return 0;
}
```

C++17之前你可能需要像上面这样写，但是现在你可以写更简洁的代码了。

```c++
template<int N, int... Ns>
constexpr auto sum17() {
    if constexpr (sizeof...(Ns) == 0) {
        return N;
    } else {
        return N + sum17<Ns...>();
    }
}

int main() {
    cout << sum17<1, 2, 3>() << endl;  // 6
    return 0;
}
```

当然，你也可以用C++17的fold expression：

```c++
#include <iostream>

using namespace std;

template<typename ... Args>
constexpr int sum(Args... args) {
    return (0 + ... + args);
}

int main() {
    cout << sum(1, 2, 3) << endl;  // 6
    return 0;
}
```

constexpr还可以用来消除enable_if了，对于讨厌写一长串enable_if的人来说会非常开心。比如我需要根据类型来选择函数的时候：

```c++
#include <iostream>

using namespace std;

template<typename T>
std::enable_if_t<std::is_integral<T>::value, std::string> to_str(T t) {  // 如果入参类型是数字，则调用to_string，返回std::string
    return std::to_string(t);
}

template<typename T>
std::enable_if_t<!std::is_integral<T>::value, std::string> to_str(T t) {  // 如果入参类型不是数字，则直接返回入参
    return t;
}

struct Test {};

int main() {
    string&& s1 = to_str(100);
    string&& s2 = to_str("hello");
    // string&& s3 = to_str(Test());  // 编译错误：error: could not convert 't' from 'Test' to 'std::enable_if_t<true, std::basic_string<char> >' {aka 'std::basic_string<char>'}
    cout << s1 << endl;
    cout << s2 << endl;
    return 0;
}
```

经常不得不分开几个函数来写，还需要写长长的enable_if，比较繁琐，通过if constexpr可以消除enable_if了。

```c++
template<typename T>
auto to_str17(T t) {
    if constexpr (std::is_integral<T>::value) {
        return std::to_string(t);
    } else {
        return t;
    }
}

int main() {
    string&& s1 = to_str17(100);  // 100
    string&& s2 = to_str17("hello");  // hello
    cout << s1 << endl;
    cout << s2 << endl;
    return 0;
}
```

constexpr if让C++的模版具备if-else if-else功能了，是不是很酷，C++程序员的好日子来了。

不过需要注意的是下面这种写法是有问题的。

```c++
template<typename T>
auto to_str17(T t) {
    if constexpr (std::is_integral<T>::value) {
        return std::to_string(t);
    }
    return t;
}
```

这个代码把else去掉了，当输入如果是非数字类型时代码可以编译过，以为if constexpr在模版实例化的时候会丢弃不满足条件的部分，因此函数体中的前两行代码将失效，只有最后一句有效。当输入的为数字的时候就会产生编译错误了，因为if constexpr满足条件了，这时候就会有两个return了，就会导致编译错误。

constexpr if还可以用来替换#ifdef宏，看下面的例子：

```c++
using namespace std;

enum class OS { Linux, Mac, Windows };

//Translate the macros to C++ at a single point in the application
#ifdef __linux__
constexpr OS the_os = OS::Linux;
#elif __APPLE__
constexpr OS the_os = OS::Mac;
#elif __WIN32
constexpr OS the_os = OS::Windows;
#endif

void do_something() {
    //do something general

    if constexpr (the_os == OS::Linux) {
        //do something Linuxy
    } else if constexpr (the_os == OS::Mac) {
        //do something Appley
    } else if constexpr (the_os == OS::Windows) {
        //do something Windowsy
    }

    //do something general
}
//备注：这个例子摘自https://blog.tartanllama.xyz/c++/2016/12/12/if-constexpr/  
```

代码变得更清爽了，再也不需要像以前一样写#ifdef那样难看的代码块了。

## **constexpr lambda**

constexpr lambda其实很简单，它的意思就是可以在constexpr 函数中用lambda表达式了，这在C++17之前是不允许的。这样使用constexpr函数和普通函数没多大区别了，使用起来非常舒服。下面是constexpr lambda的例子：

```c++
#include <iostream>

using namespace std;

template<typename I>
constexpr auto func(I i) {
    // use a lambda in constexpr context，看起来和python的闭包有点像
    return [i](auto j) { return i + j; };
}

int main() {
    auto f = func(1);
    cout << f(2) << endl;  // 3
    return 0;
}
```

constexpr if和constexpr lambda是C++17提供的非常棒的特性，enjoy it.

## **string_view**

### **string_view的基本用法**

C++17中的string_view是一个char数据的视图或者说引用，它并不拥有该数据，是为了避免拷贝，因此使用string_view可以用来做性能优化。你应该用string_view来代替const char和const string了。string_view的方法和string类似，用法很简单：

```c++
#include <iostream>

using namespace std;

int main() {
    const char* data = "test";
    string_view str1(data, 4);
    cout << str1.length() << "\n";
    if (data == str1) {
        cout << "ok" << "\n";
    }

    const std::string str2 = "test";
    string_view str3(str2.c_str(), str2.size());
    cout << str3 << endl;
    return 0;
}
// 输出：
4
ok
test
```

构造string_view的时候用char*和长度来构造，这个长度可以自由确定，它表示string_view希望引用的字符串的长度。因为它只是引用其他字符串，所以它不会分配内存，不会像string那样容易产生临时变量。我们通过一个测试程序来看看string_view如何来帮我们优化性能的。

```c++
#include <iostream>
#include <string_view>
#include <chrono>

using namespace std;
using namespace std::literals;

class Timer {
public:
    ~Timer() {
        chrono::steady_clock::time_point end = chrono::steady_clock::now();
        chrono::duration<double> timeUsed = chrono::duration_cast<chrono::duration<double >>(end - start_);
        cout << "Elapse time : " << timeUsed.count() << "s" << endl;
    }

private:
    chrono::steady_clock::time_point start_ = chrono::steady_clock::now();;
};

int main() {
    constexpr auto LEN = 1000000;

    {
        constexpr auto s = "it is a test"sv;
        Timer t1;
        for (int i = 0; i < LEN; ++i) {
            constexpr auto s1 = s.substr(3);  // 返回的也是string_view类型
        }
    }

    {
        auto str = "it is a test"s;
        Timer t2;
        for (int i = 0; i < LEN; ++i) {
            auto s2 = str.substr(3);
        }
    }
    return 0;
}
// 输出：
Elapse time : 0.0013916s
Elapse time : 0.309733s
```

我们可以通过字面量””sv来初始化string_view。string_view的substr和string的substr相比，快了50多倍，根本原因是它不会分配内存。（上述代码本地验证，快了200多倍）

### **string_view的生命周期**

由于string_vew并不拥有锁引用的字符串，所以它也不会去关注被引用字符串的生命周期，用户在使用的时候需要注意，不要将一个临时变量给一个string_view，那样会导致string_view引用的内容也失效。

```c++
#include <iostream>
#include <string_view>

using namespace std;

int main() {
    string_view str_v;
    {
        string temp = "test";
        str_v = {temp.c_str()};
        cout << str_v << endl;
    }
    cout << str_v << endl;
    return 0;
}
```

这样的代码是有问题的，因为出了作用域之后，string_view引用的内容已经失效了。

**总结**

本文介绍了C++17的fold expression、constexpr if、constexpr lambda和string_view。fold expression为了简化可变模板参数的展开，让可以模板参数的使用变得更简单直观；constexpr if让模板具备if-else功能，非常强大。它也避免了写冗长的enable_if代码，让代码变得简洁易懂了；string_view则是用来做性能优化的，应该用它来代替const char*和const string。

# [你需要了解的 C++ 17 Top 19 新特性](https://www.oschina.net/news/85129/top-19-new-features-of-c17-you-need-to-know)

### C++17 的 19 个新特性

1. 使 static_assert 的文本信息可选
2. 删除 trigraphs
3. 在模板参数中允许使用 typename（作为替代类）
4. 来自 braced-init-list 的新规则用于自动推导
5. 嵌套命名空间的定义，例如：使用 namespace X::Y { … } 代替 namespace X { namespace Y { … }}
6. 允许命名空间和枚举器的属性
7. 新的标准属性：[[fallthrough]], [[maybe_unused]] 和 [[nodiscard]]
8. UTF-8 字符文字
9. 对所有非类型模板参数进行常量评估
10. Fold 表达式，用于可变的模板
11. A compile-time static if with the form if constexpr(expression)
12. 结构化的绑定声明，现在允许 auto [a, b] = getTwoReturnValues();
13.  if 和 switch 语句中的初始化器
14. 在某些情况下，确保通过编译器进行 copy elision（Guaranteed copy elision by compilers in some cases）
15.  一些用于对齐内存分配的扩展
16. 构造函数的模板推导，允许使用 std::pair(5.0, false) 代替 std::pair<double,bool>(5.0, false)
17. 内联变量，允许在头文件中定义变量
18. __has_include，允许由预处理程序指令检查头文件的可用性
19. __cplusplus 的值更改为 201703L

# [C++17新属性详解](https://blog.csdn.net/fanyun_01/article/details/80471626)

## 非类型模板参数的 auto

模板参数分为两种，一种是类型模板参数，也是我们用得最多的一种：

```c++
template <typename T, typename U>
auto add(T t, U u) {
    return t+u;
}
```

 里面的 `T` 和 `U` 都是类型模板参数。另一种是非类型模板参数，它可以让不同的字面量成为模板的参数：

```c++
template <typename T, int BufSize>
class buffer_t {
public:
    T& alloc();
    void free(T& item);
private:
    T data[BufSize];
}
 
buffer_t<int, 100> buf; // 100 作为模板参数
```

遗憾的是我们在编写模板的时候就必须明确非类型模板参数的具体类型，C++17 打破了这一限制，让我们能够在非类型模板参数中使用 auto 关键字，从而让编译器推导具体的类型：

```c++
template <auto value> void foo() {
    return;
}
 
foo<10>();  // value 被推导为 int 类型
```

## std::variant

熟悉 boost 的人应该很早就听说过 variant<> 了。variant<> 可以用于存储和操作不同类型的对象。我们在前面（对标准库的扩充：新增容器）对于迭代 std::tuple 时，简单使用了 boost::variant<>。提供给 variant<> 的类型模板参数可以让一个 variant<> 从而容纳提供的几种类型的变量（在其他语言(例如 Python/JavaScript 等)表现为动态类型）。

C++17 正式将 variant<> 纳入标准库，摇身一变成为 std::variant<>，有了它之后，我们可以将前面的代码更改为：

```c++
#include <iostream>
#include <variant>
#include <tuple>

using namespace std;

template<size_t n, typename... Args>
std::variant<Args...> _tuple_index(size_t i, const std::tuple<Args...>& tpl) {
    if (i == n) {
        return std::get<n>(tpl);  // 这里编译错误：error: could not convert 'std::get<0, int, int, int>((* & tpl))' from 'std::__tuple_element_t<0, std::tuple<int, int, int> >' {aka 'const int'} to 'std::variant<int, int, int>'，不太知道怎么用
    } else if (n == sizeof...(Args) - 1) {
        throw std::out_of_range("越界.");
    } else {
        return _tuple_index<(n < sizeof...(Args) - 1 ? n + 1 : 0)>(i, tpl);
    }
}

template<typename... Args>
std::variant<Args...> tuple_index(size_t i, const std::tuple<Args...>& tpl) {
    return _tuple_index<0>(i, tpl);
}

int main() {
    auto ret = tuple_index(1, make_tuple(1, 2, 3));
    return 0;
}
```



## 结构化绑定(Structured bindings)

结构化绑定提供了类似其他语言中提供的多返回值的功能。到目前为止，我们可以通过 std::tuple 来构造一个元组，囊括多个返回值。但缺陷是显而易见的，我们没有一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型。

C++17 给出的结构化绑定可以让我们写出这样的代码：

```c++
#include <iostream>
#include <tuple>

using namespace std;

std::tuple<int, double, std::string> f() {  // 可以写成auto f()
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto[x, y, z] = f(); // x,y,z 分别被推导为int,double,std::string
    cout << x << "\n";  // 1
    cout << y << "\n";  // 2.3
    cout << z << "\n";  // 456
    return 0;
}
```

## 变量声明的强化

变量的声明在虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch语句中声明一个临时的变量。例如：

```c++
auto p = map_container.try_emplace(key, value);
if(!p.second) {
    //...
} else {
    //...
}
```

C++17 消除了这一限制，使得我们可以：

```c++
if (auto p = m.try_emplace(key, value); !p.second) {   
    //...  这里可以使用p
} else {
    //...  这里也可以使用p
}
// 这里无法使用p
```

# [C++17新特性个人总结](https://blog.csdn.net/qq811299838/article/details/90371604?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)

## 1 关键字

### 1.1 constexpr

 扩展constexpr使用范围，可用于if语句中，也可用于lambda表达式中。

例子1：

```c++
#include<iostream>

template<bool ok>
constexpr void foo() {
    //在编译期进行判断，if和else语句不生成代码
    if constexpr (ok == true) {
        //当ok为true时，下面的else块不生成汇编代码
        std::cout << "ok" << std::endl;
    } else {
        //当ok为false时，上面的if块不生成汇编代码
        std::cout << "not ok" << std::endl;
    }
}

int main() {
    foo<true>();//输出ok，并且汇编代码中只有std::cout << "ok" << std::endl;这一句
    foo<false>();//输出not ok，并且汇编代码中只有std::cout << "not ok" << std::endl;这一句
    return 0;
}
```

例子2：

```c++
int main() {
    constexpr auto add1 = [](int n, int m) {
        auto func1 = [=] { return n; }; //func1  lambda表达式
        auto func2 = [=] { return m; }; //func2  lambda表达式
        return [=] { return func1() + func2(); };
    };
    constexpr auto add2 = [](int n, int m) {
        return n + m;
    };
    auto add3 = [](int n, int m) {
        return n + m;
    };
    int sum1 = add1(30, 40)(); //传入常量值，add1在编译期计算，立即返回70
    int sum2 = add2(sum1, 4); //由于传入非constexpr变量，add2的constexpr失效，变成运行期lambda
    constexpr int sum3 = add3(1, 2); //sum3为constexpr变量，传入常量值，add3变成编译期lambda，立即返回3
    int sum4 = add2(10, 2);//传入常量值，add2在编译期计算，立即返回12
    return 0;
}
```

### 1.2 static_assert

扩展static_assert用法，静态断言的显示文本可选。如：

```c++
static_assert(true, "");
static_assert(true);//c++17支持
```

### 1.3 auto

扩展auto的推断范围，如：

```c++
int main() {
    auto x1 = {1, 2}; //推断出std::initializer_list<int>类型
    auto x2 = {1, 2.0}; //错误：类型不统一，无法推断
    auto x3{1, 2}; //错误：auto的聚合初始化只能一个元素
    auto x4 = {3}; //推断出std::initializer_list<int>类型
    auto x5{3}; //推断出int类型
    return 0;
}
```

### 1.4 typename

扩展用法，允许出现在模板的模板的参数中。

首先回顾一下typename的用法，①用于模板中，表示模板参数为类型；②用于声明某名字是变量名

如例1：

```c++
struct A {
    typedef int Example;
};
//第一种用法：声明模板参数为类型
template<typename T>
struct B {};

struct C {
    typedef typename A::Example E;//第二种用法：声明某名字为一种类型
};

int main() {
    typename A::Example e;//第二种用法：声明某名字为一种类型
    return 0;
}
```

新特性下的typename用法，

如例2：

```cpp
#include<iostream>
#include<typeinfo>

template<typename T>
struct A {
    int num;

    A() {
        std::cout << "A Construct" << std::endl;
        std::cout << "template typename is: " << typeid(T).name() << std::endl;
    }
};

//此处的T可省略，X代表模板类型，T和X前的typename可替换成class
template<template<typename T> typename X>
struct B {
    X<double> e;

    B() { std::cout << "B Construct" << std::endl; }
};

int main() {
    A<B<A>> a;
    std::cout << "***************************" << std::endl;
    B<A> b;
    return 0;
}
// 输出：
A Construct
template typename is: 1BI1AE
***************************
A Construct
template typename is: d
B Construct
```

### 1.5 inline

扩展用法，可用于定义内联变量，功能与内联函数相似。inline可避免函数或变量多重定义的问题，如果已定义相同的函数或变量（且该函数或变量声明为inline），编译器会自动链接到该函数或变量。

如（不发生错误）：

```c++
// test.h
#ifndef TESTPROJECT_TEST_H
#define TESTPROJECT_TEST_H

#include <iostream>

inline void print() {
    std::cout << "hello world" << std::endl;
}

inline int num = 0;

#endif //TESTPROJECT_TEST_H

// func.h
#ifndef TESTPROJECT_FUNC_H
#define TESTPROJECT_FUNC_H

#include "test.h"

inline void add(int arg) {
    num += arg;
    print();
}

#endif //TESTPROJECT_FUNC_H

//main.cpp
#include "func.h"

int main() {
    num = 0;
    print();
    add(10);
    return 0;
}
```

## 2 语法

### 2.1 折叠表达式

用于变长参数模板的解包，只支持各种运算符（和操作符），分左、右折叠

如：

```c++
#include<string>

template<typename ... T>
auto sum(T ... arg) {
    return (arg + ...);//右折叠
}

template<typename ... T>
double sum_strong(T ... arg) {
    return (arg + ... + 0);//右折叠
}

template<typename ... T>
double sub1(T ... arg) {
    return (arg - ...);//右折叠
}

template<typename ... T>
double sub2(T ... arg) {
    return (... - arg);//左折叠
}

int main() {
    int s1 = sum(1, 2, 2, 4, 5);//解包：((((1+)2+)3+)4+)5 = 15
    double s2 = sum(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
    double s3 = sum(1, 2.2, 3, 4.4, 5);

    double s4 = sub1(5, 2, 1, 1);//解包：((((5-)2-)1-)1) = 1
    double s5 = sub2(5, 2, 1, 1);//解包：(5-(2-(1-(1)))) = 3

    double s6 = sum_strong();//s6 = 0

    std::string str1("he");
    std::string str2("ll");
    std::string str3("o ");
    std::string str4("world");
    std::string str5 = sum(str1, str2, str3, str4);//str5 = "hello world"
    return 0;
}
```

### 2.2 结构化绑定

用一对包含一个或多个变量的中括号，表示结构化绑定，但是使用结构化绑定时，须用auto关键字，即绑定时声明变量

例子1：

```c++
#include<string>

/*
 * 例子：多值返回
 */
struct S {
    double num1;
    long num2;
};

S foo(int arg1, double arg2) {
    double result1 = arg1 * arg2;
    long result2 = arg2 / arg1;
    return {result1, result2};//返回结构体S对象
};

int main() {
    auto[num1, num2] = foo(10, 20.2);//自动推导num1为double，num2为long
    return 0;
}
```

例子2：

```c++
#include<list>
#include<map>

/*
 * 例子：循环遍历
 */
template<typename T, typename U>
struct MyStruct {
    T key;
    U value;
};

int main() {
    std::list<MyStruct<int, double>> Container1;
    std::map<int, MyStruct<long long, char>> Container2;
    for (auto[key, value] : Container1) {
        //key为int类型，value为double类型
    }
    for (auto[key, value] : Container2) {
        //key为int类型，value为MyStruct<long long, char>类型
        //value1为long long类型，value2为char类型
        auto[value1, value2] = value;
    }
    return 0;
}
```

### 2.3 允许非类型模板参数进行常量计算

非类型模板参数可传入类的静态成员

如：

```c++
class MyClass {
public:
    static int a;
};

template<int* arg>
void foo() {}

int main() {
    foo<&MyClass::a>();
    return 0;
}
```

### 2.4 条件分支语句初始化

在if和switch中可进行初始化

如：

```c++
template<long value>
void foo(int& ok) {
    if constexpr (ok = 10; value > 0) {
    }
}

int main() {
    int num = 0;
    if (int i = 0; i == 0) {
    }
    foo<10>(num);
    switch (int k = 10; k) {
        case 0:
            break;
        case 1:
            break;
        default:
            break;
    }
    return 0;
}
```

### 2.5 聚合初始化

在初始化对象时，可用花括号进行对其成员进行赋值

如：

```c++
struct MyStruct1 {
    int a;
    int b;
};

struct MyStruct2 {
    int a;
    MyStruct1 ms;
};

int main() {
    MyStruct1 a{10};
    MyStruct2 b{10, 20};
    MyStruct2 c{1, {}};
    MyStruct2 d{{}, {}};
    MyStruct2 e{{}, {1, 2}};
    return 0;
}
```

### 2.6 嵌套命名空间

简化多层命名空间的写法

如：

```c++
//传统写法
namespace A { namespace B { namespace C {
}}}
//新写法
namespace A::B::C {
}
```

### 2.7 lambda表达式捕获*this的值

lambda表达式可捕获*this的值，但this及其成员为只读

如：

```c++
struct MyStruct {
    double ohseven = 100.7;

    auto f() {
        return [this] {
            return [*this] {
                this->ohseven = 200.2;//错误，只读变量不可赋值
                return ohseven;//正确
            };
        }();
    }

    auto g() {
        return [] {
            return [*this] {};//错误，外层lambda表达式没有捕获this
        }();
    }
};
```

### 2.8 枚举[类]对象的构造

可以给枚举[类]对象赋值

如：

```c++
enum MyEnum { value };
MyEnum me{10};//错误：不能用int右值初始化MyEnum类型对象

enum byte : unsigned char {};
byte b{42}; //正确
byte c = {42}; //错误：不能用int右值初始化byte类型对象
byte d = byte{42}; //正确，其值与b相等
byte e{-1}; //错误：常量表达式-1不能缩小范围为byte类型

struct A { byte b; };
A a1 = {{42}}; //错误：不能用int右值初始化byte类型对象
A a2 = {byte{42}}; //正确

void f(byte);
f({42}); //错误：无类型说明符

enum class Handle : unsigned int { value = 0 };
Handle h{42}; //正确
return 0;
```

### 2.9 十六进制单精度浮点数字面值

以0x前缀开头的十六进制数，以f后缀的单精度浮点数，合并，就有了十六进制的单精度浮点数

如：

```c++
int main() {
    float value = 0x1111f;
    return 0;
}
```

### 2.10 基于对齐内存的动态内存分配

谈到动态内存分配，少不了new和delete运算符，新标准中的new和delete运算符新增了按照对齐内存值来分配、释放内存空间的功能（即一个新的带对齐内存值的new、delete运算符重载）

函数原型：

```cpp
void* operator new(std::size_t size, std::align_val_t alignment);
void* operator new[](std::size_t size, std::align_val_t alignment);
    
void operator delete(void*, std::size_t size, std::align_val_t alignment);
void operator delete[](void*, std::size_t size, std::align_val_t alignment);
```

参数说明：

size —— 分配的字节数。必须为alignment的整数倍。

alignment —— 指定的对齐内存值。必须是实现支持的合法对齐。

 new的返回值：

成功，返回指向新分配内存起始地址的指针。

 用法例子：

```c++
#include<new>

struct alignas(8) A {};

int main() {
    A* a = static_cast<A*>(::operator new(sizeof(A), static_cast<std::align_val_t>(alignof(A))));
    ::operator delete(a, sizeof(A), static_cast<std::align_val_t>(alignof(A)));
    return 0;
}
```

### 2.11 细化表达式的计算顺序

为了支持泛型编程和重载运算符的广泛使用，新特性将计算顺序进行的细化

如以下争议代码段：

```c++
#include<map>

int main() {
    std::map<int, int> tmp;
    //对于std::map的[]运算符重载函数，在使用[]新增key时，std::map就已经插入了一个新的键值对
    tmp[0] = tmp.size();//此处不知道插入的是{0, 0}还是{0, 1}
    for (const auto&[key, value] : tmp) {
        std::cout << "key=" << key << ", value=" << value << std::endl;
    }
    return 0;
}
```

为了解决该情况，新计算顺序规则为：

①后缀表达式从左到右求值。这包括函数调用和成员选择表达式。

②赋值表达式从右向左求值。这包括复合赋值。

③从左到右计算移位操作符的操作数。

按上述规则2，先计算tmp.size()为0，所以输出为0，0。

### 2.12 模板类的模板参数自动推导

定义模板类的对象时，可以不指定模板参数，但必须要在构造函数中能推导出模板参数

如：（这个例子没太看懂）

```c++
template<class T>
struct A {
    explicit A(const T&, ...) noexcept {} // #1
    A(T&&, ...) {} // #2，这里不是万能引用
};

int i;

A a1 = {i, i}; //错误，不能根据#1推导为右值引用，也不能通过#1实现复制初始化。=方式不能使用explict赋值，只能使用非explict。error: cannot bind rvalue reference of type 'int&&' to lvalue of type 'int'
A a2{i, i}; //正确，调用#1初始化成功，a2推导为A<int>类型
A a3{0, i}; //正确，调用#2初始化成功，a2推导为A<int>类型
A a4 = {0, i}; //正确，调用#2初始化成功，a2推导为A<int>类型

template<class T> A(const T&, const T&) -> A<T&>; // #3
template<class T> explicit A(T&&, T&&) -> A<T>; // #4

A a5 = {0, 1}; //错误，#1和#2构造函数结果相同（即冲突）。根据#3推导为A<int&>类型
A a6{0, 1}; //正确，通过#2推断为A<int>类型
A a7 = {0, i}; //错误，不能将非静态左值引用绑定到右值。根据#3推导为A<int&>类型
A a8{0, i}; //错误，不能将非静态左值引用绑定到右值。根据#3推导为A<int&>类型

template<class T>
struct B {

    template<class U>
    using TA = T;//定义别名

    template<class U>
    B(U, TA<U>);//构造函数
};

B b{(int*) 0, (char*) 0}; //正确，推导为B<char *>类型
```

### 2.13 简化重复命名空间的属性列表

如：

```c++
[[ using CC: opt(1), debug ]] void f() {}
//作用相同于 [[ CC::opt(1), CC::debug ]] void f() {}
```

### 2.14 不支持、非标准的属性

在添加属性列表时，编译器会忽略不支持的非标准的属性，不会发出警告和错误。

### 2.15 改写与继承构造函数

在类的继承体系中，构造函数的自动调用是一个令人头疼的问题。新特性引入继承与改写构造函数的用法。

例子1：

```c++
#include<iostream>

struct B1 {
    B1(int) { std::cout << "B1" << std::endl; }
};

struct D1 : B1 {
    using B1::B1;//表示继承B1的构造函数
};

D1 d1(0);    //正确，委托基类构造函数进行初始化，调用B1::B1(int)
```

例子2：

```c++
#include<iostream>

struct B1 {
    B1(int) { std::cout << "B1" << std::endl; }
};

struct B2 {
    B2(int) { std::cout << "B2" << std::endl; }
};

struct D1 : B1, B2 {
    using B1::B1;//表示继承B1的构造函数
    using B2::B2;//表示继承B2的构造函数
};
D1 d1(0);    //错误：函数冲突，error: call of overloaded 'D1(int)' is ambiguous

struct D2 : B1, B2 {
    using B1::B1;
    using B2::B2;

    //正确，D2::D2(int)隐藏了B1::B1(int)和B2::B2(int)。另外由于B1和B2没有默认的构造函数，因此必须显式调用B1和B2的构造函数
    D2(int) : B1(1), B2(0) { std::cout << "D2" << std::endl; }
};

struct D3 : B1 {
    using B1::B1;
};
D3 d3(0);//正确，继承B1的构造函数，即利用B1的构造函数来初始化，输出B1

// 程序入口
int main() {
    D2 d(100);//编译通过，输出B1   B2   D2
    return 0;
}
```

例子3：

```c++
#include<iostream>

struct B1 {
    B1() { std::cout << "B1 default" << std::endl; }

    B1(int) { std::cout << "B1" << std::endl; }
};

struct B2 {
    B2() { std::cout << "B2 default" << std::endl; }

    B2(int) { std::cout << "B2" << std::endl; }
};

struct D1 : B1, B2 {
    using B1::B1;
    using B2::B2;

    //正确，D2::D2(int)隐藏了B1::B1(int)和B2::B2(int)，但必须要显示调用B1和B2的构造函数
    D1(int) : B1(1), B2(0) { std::cout << "D2" << std::endl; }

    //有默认构造函数，在不显示调用基类的构造函数时自动调用基类的默认构造函数
    D1() { std::cout << "D2 default" << std::endl; }
};

// 程序入口
int main() {
    D1 d(100);//编译通过，输出B1   B2   D2
    D1 dd;
    //输出
    //B1 default
    //B2 default
    //D2 default
    return 0;
}
```

### 2.16 内联变量

见1.5

### 2.17 用auto作为非类型模板参数

当模板参数为非类型时，可用auto自动推导类型

如：

```c++
#include<iostream>

template<auto T>
void foo() {
    std::cout << T << std::endl;
}

int main() {
    foo<100>();//输出100
    foo<int>();//no matching function for call to "foo<int>()"
    return 0;
}
```

## 3 宏

### 3.1 __has_include

判断有没有包含某文件

如：

```c++
int main() {
#if __has_include(<cstdio>)
    printf("hehe");
#endif
#if __has_include("iostream")
    std::cout << "hehe" << std::endl;
#endif
    return 0;
}
```

## 4 属性

### 4.1 fallthrough

用于switch语句块内，表示会执行下一个case或default

如：

```c++
#include<iostream>

int main() {
    int ok1, ok2;
    switch (0) {
        case 0:
            ok1 = 0;
            [[fallthrough]];  // 没看懂这个有什么用，如果没有这句话，，因为没有break;也会正常执行case1
        case 1:
            ok2 = 1;
            [[fallthrough]];
    }
    return 0;
}
```

### 4.2 nodiscard

可用于类声明、函数声明、枚举声明中，表示函数的返回值没有被接收，在编译时会出现警告。

如：

```c++
[[nodiscard]] class A {}; //该属性在这其实没用
[[nodiscard]] enum class B {}; //该属性在这其实没用
class C {};

[[nodiscard]] int foo() { return 10; }

[[nodiscard]] A func1() { return A(); }

[[nodiscard]] B func2() { return B(); }

[[nodiscard]] C func3() { return C(); }

int main() {
    foo();//warning: ignoring return value
    func1();//warning: ignoring return value
    func2();//warning: ignoring return value
    func3();//warning: ignoring return value
    return 0;
}
```

### 4.3 maybe_unused

可用于类、typedef、变量、非静态数据成员、函数、枚举或枚举值中。用于抑制编译器对没用实体的警告。即加上该属性后，对某一实体不会发出“没有用”的警告。

用法例子：

```c++
[[maybe_unused]] class A {};  // warning: attribute ignored in declaration of 'class A' [-Wattributes]
[[maybe_unused]] enum B {};

int main() {
    [[maybe_unused]] int C;
    [[maybe_unused]] void fun();
    return 0;
}
```

# [C++17新特性optional](https://blog.csdn.net/janeqi1987/article/details/100567933)

## 1.1 使用std::optional<>

std::optional<>为任意类型的可空实例建模。实例可以是成员、参数或返回值。还可以认为std::optional<>是一个包含0或1个元素的容器。

### 1.1.1 std::optional<>返回值

下面的程序演示了std::optional<>作为返回值的处理:

```cpp
#include <iostream>
#include <optional>
#include <string>

// convert string to int if possible:
std::optional<int> asInt(const std::string& s) {
    try {
        return std::stoi(s);
    }
    catch (...) {
        return std::nullopt;
    }
}

int main() {
    for (auto s : {"42", " 077", "hello", "0x33"}) {
        // convert s to int and use the result if possible:
        std::optional<int> oi = asInt(s);
        if (oi) {
            std::cout << "convert '" << s << "' to int: " << *oi << "\n";
        } else {
            std::cout << "can't convert '" << s << "' to int\n";
        }
    }
}
// 输出：
convert '42' to int: 42
convert ' 077' to int: 77
can't convert 'hello' to int
convert '0x33' to int: 0
```

我们可以实现相同的行为如下:

```c++
std::optional<int> asInt(const std::string& s) {
    std::optional<int> ret; // initially no value
    try {
        ret = std::stoi(s);
    }
    catch (...) {
    }
    return ret;
}
```

还可以通过如下方法来处理返回值，例如:

```c++
std::optional<int> oi = asInt(s);
if (oi.has_value()) {
    std::cout << "convert '" << s << "' to int: " << oi.value() << "\n";
}
```

在这里has_value()用来检查是否有返回值，如果有通过value()来获取。**value()比操作符\*更安全，因为没有值而调用该接口的话会抛出异常。操作符*只有你确认有值的情况下才能使用，否则程序会出现未定义行为。**

### 1.1.2 std::optional<>参数和数据成员

使用std::optional<>的另一个例子是参数的std::optional传递和做为数据成员:

```c++
#include <iostream>
#include <string>
#include <optional>

class Name {
public:
    Name(std::string f,
         std::optional<std::string> m,
         std::string l)
        : first{std::move(f)}, middle{std::move(m)}, last{std::move(l)} {
    }

    friend std::ostream& operator<<(std::ostream& strm, const Name& n) {
        strm << n.first << ' ';
        // strm << n.middle.value_or("") << ' ';

        if (n.middle) {
            strm << n.middle.value() << ' ';
        }
        return strm << n.last;
    }

private:
    std::string first;
    std::optional<std::string> middle;
    std::string last;
};

int main() {
    Name n{"Jim", std::nullopt, "Knopf"};
    std::cout << n << '\n';
    Name m{"Donald", "Ervin", "Knuth"};
    std::cout << m << '\n';

    return 0;
}
```

类Name表示由一个名字，可选的中间名，姓氏组成。成员中间被定义为std::optional<>，当没有中间名字时构造函数允许传递std::nullopt参数，这与中间名称为空字符串的状态不同。

  注意，对于具有值语义的类型，定义初始化相应成员的构造函数的最佳方法是按值获取参数并将参数移动到成员。

  还要注意，std::optional<>改变了对成员中间值的访问。使用middle作为布尔表达式可以判断是否有中间名，如果有的话可以使用value()方法来获取值。

  另外一种访问optional值的方法是用一个成员函数value_or()，该方法如果不存在值，则允许指定的值。例如，在类名内部我们也可以实现:

```cpp
std::cout << middle.value_or(""); // print middle name or nothing
```

## 1.2 std::optional<>类型和操作

本节详细描述std::optional<>的类型和操作。

1.2.1 std::optional<>类型

  在标准库的头文件\<optional\>中定义了std::optional<>如下；

```cpp
namespace std 
{
template<typename T> class optional;
}
```

此外，定义了类型和对象如下：

- std::nullopt_t类型的nullopt是一种没有值的对象；
- 异常类std::bad_optional_access，派生自std:: Exception，用于std::optional<>对象没有值的情况下访问是抛出的异常。

可选对象还使用\<utility\>中定义的对象std::in_place(类型为std::in_place_t)来初始化带有多个参数的可选对象的值(参见下面)。

### 1.2.2 std::optional<>操作

下面std::optional操作列出了为std::optional<>提供的所有操作：

| 成员定义              | 说明                                             |
| --------------------- | ------------------------------------------------ |
| constructors          | 创建一个optional对象(可能调用包含类型的构造函数) |
| make_optional<>()     | 创建一个optional对象(传递值来初始化它)           |
| destructor            | 销毁一个optional对象                             |
| =                     | 分配一个新值                                     |
| emplace()             | 为所包含的类型分配一个新值                       |
| reset()               | 销毁任何值(使对象为空)                           |
| has_value()           | 返回对象是否具有值                               |
| conversion to bool    | 返回对象是否具有值                               |
| *                     | 访问值(如果没有值，则未定义行为)                 |
| ->                    | 访问值的成员(如果没有值，则为未定义的行为)       |
| value()               | 访问值(如果没有值，则抛出异常)                   |
| value_or()            | 访问值(如果没有值，则使用提供的值)               |
| swap()                | 交换两个对象的值                                 |
| ==, !=, < , <=, >, >= | 比较两个optional对象                             |
| hash<>                | 函数对象类型来计算哈希值                         |

1. **构造函数**

  特殊构造函数允许将参数直接传递给所包含的类型。

- 可以创建一个没有值的可选对象。在这种情况下，必须指定包含的类型:

```cpp
std::optional<int> o1;
// std::optional o1; //编译错误：class template argument deduction failed:
std::optional<int> o2(std::nullopt);
```

这里不会为所包含的类型调用任何构造函数。

- 可以传递一个值来初始化所包含的类型。根据推导指南，不必指定所包含的类型，如下:

```cpp
std::optional o3{42}; // deduces optional<int>
std::optional<std::string> o4{"hello"};
std::optional o5{"hello"}; // deduces optional<const char*>
```

要初始化一个具有多个参数的可选对象，必须创建该对象或将std::in_place添加为第一个参数(所包含的类型无法推断):

```cpp
std::optional o6{std::complex{3.0, 4.0}};
std::optional<std::complex<double>> o7{std::in_place, 3.0, 4.0};  // 使用in_place，表明要使用多个参数来构造对象
// std::optional<std::complex<double>> o7{3.0, 4.0};  // 如果不加in_place，则编译报错：error: no matching function for call to 'std::optional<std::complex<double> >::optional(<brace-enclosed initializer list>)'
```

注意，第二种形式避免创建临时对象。通过使用这种形式，甚至可以传递初始化器列表和附加参数:

```cpp
#include <iostream>
#include <string>
#include <optional>
#include <set>

using namespace std;

int main() {
    // initialize set with lambda as sorting criterion:
    auto sc = [](int x, int y) {
        return std::abs(x) < std::abs(y);
    };

    std::optional<std::set<int, decltype(sc)>> o8{std::in_place, {4, 8, -7, -2, 0, 5}, sc};  // auto o8 = std::make_optional<std::set<int, decltype(sc)>>({4, 8, -7, -2, 0, 5}, sc);
    return 0;
}
// 如果不使用decltype，则需要像C++ 98一样，使用函数对象声明比较器的类型或函数指针：
#include <iostream>
#include <set>

using namespace std;

bool fncomp(int lhs, int rhs) { return lhs < rhs; }

struct classcomp {
    bool operator()(const int& lhs, const int& rhs) const { return lhs < rhs; }
};

int main() {
    set<int, classcomp> fifth;                 // class as Compare
    
    bool (* fn_pt)(int, int) = fncomp;
    set<int, bool (*)(int, int)> sixth(fn_pt);  // function pointer as Compare
    return 0;
}
```

- 可以复制可选对象(包括类型转换)：

```cpp
std::optional o5{"hello"}; // deduces optional<const char*>
std::optional<std::string> o9{o5}; // OK，这里如果使用move(o5)，则o5仍有const char*值hello，如果std::optional<std::string> o5{"hello"}，则move(o5)，o5值为""
```

注意，还有一个方便的函数make_optional<>()，它允许使用单个或多个参数初始化(不需要in_place参数)。像往常一样make……函数推导:

```cpp
auto o10 = std::make_optional(3.0); // optional<double>
auto o11 = std::make_optional("hello"); // optional<const char*>
auto o12 = std::make_optional<std::complex<double>>(3.0, 4.0);
```

然而，注意，没有构造函数接受一个值并根据它的值来决定是使用值初始化一个可选值还是使用nullopt。可以使用操作符?:，例如:

```cpp
#include <iostream>
#include <string>
#include <optional>
#include <set>
#include <map>

using namespace std;

int main() {
    std::multimap<std::string, std::string> englishToGerman = {{"wisdom", "aaa"}};
    auto pos = englishToGerman.find("wisdom");
    auto o13 = pos != englishToGerman.end() ? std::optional{pos->second} : std::nullopt;
    
    auto test1 = std::optional<string>{"hello"};  // 这里的test1是由临时对象std::optional<string>{"hello"}移动构造而来，成本很低
    auto test2 = std::nullopt;  // 这里的test2类型为nullopt_t，类似nullptr类型为nullptr_t一样
    return 0;
}
```

  在这里，o13初始化为std::optional<std::string>，这是由于类模板参数的推导std::optionalf(pos->second)。对于std::nullopt类模板参数推导不起作用，但是运算符?:在推导表达式的结果类型时也将其转换为这种类型。

## 1.3 特定情况

  特定的可选值类型可能导致特殊或意外的行为。

### 1.3.1 bool或者原始指针的optional

注意，使用比较操作符与使用optional对象作为布尔值具有不同的语义。如果包含的类型是bool或指针类型，这就会变得很混乱:例如:

```cpp
std::optional<bool> ob{false}; // has value, which is false
if (!ob) ... // yields false
if (ob == false) ... // yields true
std::optional<int*> op{nullptr};
if (!op) ... // yields false
if (op == nullptr) ... // yields true
```

### 1.3.2 Optional的Optional

原则上，你也可以定义一个optional的optional值:

```cpp
std::optional<std::optional<std::string>> oos1;
std::optional<std::optional<std::string>> oos2 = "hello";
std::optional<std::optional<std::string>> oos3{std::in_place, std::in_place, "hello"};
std::optional<std::optional<std::complex<double>>> ooc{std::in_place, std::in_place, 4.2, 5.3};
```

你也可以分配新的值，即使隐式转换:

```cpp
oos1 = "hello"; // OK: assign new value
ooc.emplace(std::in_place, 7.2, 8.3);
```

由于optional的无值有两个层次，optional的optional使“无值”出现在外部或内部，可以有不同的语义含义:

```cpp
*oos1 = std::nullopt; // inner optional has no value
oos1 = std::nullopt; // outer optional has no value
```

但必须特别注意处理optional值:

```cpp
if (!oos1) std::cout << "no value\n";
if (oos1 && !*oos1) std::cout << "no inner value\n";
if (oos1 && *oos1) std::cout << "value: " << **oos1 << '\n';
```

## 2. 访问值

  检查optional对象是否有值，可以将对象当做一个布尔表达式使用它，或者调用has_value():

```cpp
std::optional o{42};
if (o) ... // true
if (!o) ... // false
if (o.has_value()) ... // true
```

为了访问该值，提供了指针语法。操作符*可以直接访问它所包含类型对象的值，而操作符->允许访问它所包含类型对象的成员：

```cpp
std::optional o{std::pair{42, "hello"}};
auto p = *o; // initializes p as pair<int,string>
std::cout << o->first; // prints 42

int main() {
    std::optional o{std::pair{42, "hello"}};
    auto& p = *o; // 可以使用引用获取值，并修改
    std::cout << o->first; // prints 42
    p.first = 50;
    std::cout << o->first; // prints 50
    return 0;
}
```

注意，这些操作符要求optional包含一个值。在没有值的情况下使用它们是未定义的行为:

```cpp
std::optional<std::string> o{"hello"};
std::cout << *o; // OK: prints ”hello”
o = std::nullopt;
std::cout << *o; // undefined behavior
```

注意，实际上第二个输出仍然会编译并执行一些输出，比如再次打印“hello”，因为用于optional对象值的底层内存没有被修改。
然而，你不能也不应该依赖它。如果你不知道一个可选对象是否有值，你只能调用以下函数:

```cpp
if (o) std::cout << *o; // OK (might output nothing)
```

或者，您可以使用value()，如果没有包含值，它会抛出一个std::bad_optional_access异常:

```cpp
std::cout << o.value(); // OK (throws if no value)
```

bad_optional_access直接派生自std::exception。

最后，如果optional对象没有值，您可以请求该值并传递回退值，回退值将被使用:

```cpp
std::cout << o.value_or("fallback"); // OK (outputs fallback if no value)

#include <iostream>
#include <string>
#include <optional>

using namespace std;

int main() {
    auto o = make_pair<int, string>(42, "hello");
    std::optional<std::pair<int, string>> o2 = std::nullopt;
    cout << o.first << ", " << o.second << endl;
    auto&& o3 = o2.value_or(o);  // value_or返回的是临时变量，这里不能使用auto&来引用

    auto&& o5 = std::make_optional<std::pair<int, string>>(11, "good").value_or(o);
    return 0;
}
```

回退参数作为**通用引用**传递，因此，如果不使用回退，则不需要花费任何代价，如果使用回退，则支持move语义。

## 3 比较操作

  可以使用通常的比较操作符。操作数可以是optional对象、包含类型的对象和std::nullopt。

- 如果两个操作数都是具有值的对象，则使用所包含类型的对应操作符。
- 如果两个操作数都是没有值的对象，则认为它们是相等的(==产生true，所有其他比较产生false)。
- 如果只有一个操作数是有值的对象，则没有值的操作数被认为小于另一个操作数。

例如：

```c++
std::optional<int> o0;
std::optional<int> o1{42};
o0 == std::nullopt // yields true
o0 == 42 // yields false
o0 < 42 // yields true
o0 > 42 // yields false
o1 == 42 // yields true
o0 < o1 // yields true
    
#include <iostream>
#include <string>
#include <optional>

using namespace std;

int main() {
    auto o1 = std::nullopt;
    auto o2 = std::nullopt;
    auto o3 = std::make_optional<std::string>();
    auto o4 = std::make_optional<std::string>();
//    cout << (o1 == o2) << endl;  // error: no match for 'operator==' (operand types are 'std::nullopt_t' and 'std::nullopt_t')
    cout << (o2 == o3) << endl;  // false
    cout << (o3 == o4) << endl;  // true
    return 0;
}

#include <iostream>
#include <string>
#include <optional>

using namespace std;

int main() {
    auto o3 = std::make_optional<std::string>("hello");
    cout << boolalpha << (o3 == "hello") << "\n";  // true

    auto o4 = std::make_optional<std::string>();
    auto o5 = std::make_optional<std::string>();
    cout << boolalpha << (o4 == o5) << "\n";  // true
    cout << boolalpha << (o4 < o5) << "\n";  // false
    cout << boolalpha << (o4 > o5) << "\n";  // false
    cout << boolalpha << (o4 <= o5) << "\n";  // true
    cout << boolalpha << (o4 >= o5) << "\n";  // true

    cout << boolalpha << (o3 == o4) << "\n";  // false
    cout << boolalpha << (o3 > o4) << "\n";  // true，有值比没值大
    cout << boolalpha << (o3 <= o4) << "\n";  // false

    return 0;
}
```

这意味着对于无符号整型的optional对象有一个小于0的值，对于bool的optional对象有一个小于0的值:

```cpp
std::optional<unsigned> uo;
uo < 0 // yields true

std::optional<bool> bo;
bo < false // yields true
```

同样，支持底层类型的隐式类型转换:

```cpp
std::optional<int> o1{42};
std::optional<double> o2{42.0};
o2 == 42 // yields true
o1 == o2 // yields true
```

注意，optional的bool值或原始指针值可能会导致一些意外。

## **4 修改值**

通过赋值和emplace来修改值：

```cpp
#include <iostream>
#include <string>
#include <optional>
#include <complex>

using namespace std;

int main() {
    std::optional<std::complex<double>> o; // has no value
    std::optional ox{77}; // optional<int> with value 77
    o = 42; // value becomes complex(42.0, 0.0)
    o = {9.9, 4.4}; // value becomes complex(9.9, 4.4)
    o = ox; // OK, because int converts to complex<double>
    o = std::nullopt; // o no longer has a value
    o.emplace(5.5, 7.7); // value becomes complex(5.5, 7.7)

    std::optional<string> optStr{"hello"};
    optStr.emplace("good");
    return 0;
}
```

赋值std::nullopt将删除该值，如果之前有值，该值将调用所包含类型的析构函数。也可以通过调用reset()获得相同的效果:

```cpp
o.reset(); // o no longer has a value
```

或赋值为空花括号:

```cpp
o = {}; // o no longer has a value
```

最后，我们还可以使用操作符*修改值，因为它通过引用生成值。但是，请注意，这需要修改一个有存在的值:

```cpp
std::optional<std::complex<double>> o;
*o = 42; // undefined behavior
...
if (o) {
    *o = 88; // OK: value becomes complex(88.0, 0.0)
    *o = {1.2, 3.4}; // OK: value becomes complex(1.2, 3.4)
}
```

## 5 移动语义

  std::optional<>也支持移动语义。如果将对象作为一个整体移动，则会复制状态并移动所包含的对象(如果有的话)。因此，一个从对象中移出的对象仍然具有相同的状态，但是移动后的值会变成是未指定的。但是也可以将一个值移动到或移出所包含的对象。例如:

```c++
#include <iostream>
#include <string>
#include <optional>
#include <complex>

using namespace std;

int main() {
    std::optional<std::string> os;
    std::string s = "a very very very long string";
    os = std::move(s); // OK, moves
    std::string s2 = *os; // OK copies
    std::string s3 = std::move(*os); // OK, moves
    return 0;
}
```

注意，在最后一次调用之后os仍然有一个字符串值，但是对于os对象这个值未指定的。因此，不能对移动后的对象的值做任何假设就去使用它。当然，可以给移动后的对象分配一个新的值。

