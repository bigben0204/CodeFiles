//------------------------------------------------------------------------------------------------
//Windows Sockets网络编程
3.3.3 传输协议的选择：UDP与TCP的对比 P47
经验法则：采用TCP吧，除非你的确有不用的理由。

P56 socket()
SOCKET PASCAL FAR socket(int af, int type, int protocal);
af：“地址族”， 否则视为socket域
type：socket类型。
protocol：所采用的协议。
af参数（地址族）指明所使用的协议簇。WinSock规范1.1 版本定义了唯一的有效值为PF_INET，代表因特网地址族或者协议系列(TCP/IP)。
type参数常常隐式地指示地址中的protocol。例如，在TCP/IP地址族中，SOCK_DGRAM类型的socket所用协议总是UDP，SOCK_STREAM类型的socket所用协议总是TCP。在这种情况下，socket()函数总是忽略protocol参数的值，但是，把它的值设为0是一个良好的习惯。

还有第三种socket类型，即SOCK_RAW。对于TCP和UDP以外的协议可以使用SOCK_RAW类型的socket，例如，通过它可以访问因特网控制消息协议（ICMP）。与SOCK_STREAM和SOCK_DGRAM类型不同，当你选用SOCK_RAW类型时，不再有默认值，必须自己指定协议各字段的值（如第16章所述）。
socket()函数调用成功时，返回一个socket描述符；调用失败时，返回一个INVALID_SOCKET值。调用失败后，需要调用WSAGetLastError()检索对应的错误值，提示用户失败原因。如果socket()函数调用成功，则不用调用WSAGetLastError()函数，因为任何函数的成功调用都不会重置错误值（它保持程序使用的任何一个socket最近一次发生的错误值）。

4.4 socket的命名 P58
客户端必须能够定位和识别服务器socket。构成socket名称的有3个属性：协议、端口号和地址。服务器必须为socket分配这3个属性，客户端必须引用这3个属性，客户端和服务器之间才能通信。

4.4.1 sockaddr结构

4.4.2 sockaddr_in结构
对于TCP/IP地址族（PF_INET），总是引用sockaddr_in结构中的域，而不会引用通用的sockaddr结构，下面是因特网协议地址族结构的定义：
struct sockaddr_in
{
	short sin_family;//address family (PF_INET)
	u_short sin_port;//port (service) number
	struct in_addr sin_addr;//IP address 32-bit
	char sin_zero[8];//unused filler
};

sin_family：地址族
sin_port：按网络顺序的16位的端口号。
sin_addr：按网络顺序的32位的因特网地址。

4.4.3 端口号
sin_port域的值就是端口号，无符号的16位的值用于标识服务器所采用的应用层协议。
0~1023： 为知名服务保留（例如FTP）。
1024： INAN保留。
1025~5000： 用户自定义服务的典型范围。
可以用服务数据库中获取端口号的方法来代替将端口号硬编码到应用程序中。函数getservbyname()和WSAsyncGetServByName()提供了从服务数据库中检索给定了服务名称的端口号的功能。例如，如果服务器支持标准TCP/IP的FTP协议，那么就可以调用函数getservbyname()请求FTP服务的端口，调用的返回值通常是21(0x15)，可以将该值赋给sin_port域。

4.4.4 本地IP地址
sockaddr_in结构中的域sin_addr的取值是为IP地址所设。根据具体函数的不同，可以是本地IP地址，也可以是远程IP地址。调用bind()函数时，sin_addr总是指向本地IP地址，换言之，你用调用bind()函数的这台主机的接口地址来初始化sin_addr。
在大多数系统中，可以简单地使用地址INADDR_ANY要求协议栈自动指派本地IP地址。

4.4.5 什么是socket名称
socket名称包含3个属性：
--协议
--端口号
--IP地址
当调用函数socket()打开socket时确定所用的协议，这时可以在初始化sockaddr_in结构时定义端口号和IP地址，并调用bind()函数。
bind()
bind()函数用sockaddr_in结构中的值命名本地socket。下面是bind()函数的原型：
int PASCAL FAR bind(SOCKET s,//an unbound socket
	struct sockaddr FAR *addr,//local port and IP addr
	int namelen//addr structure length
);
s：socket句柄。
addr：指向socket地址结构的指针（对于TCP/IP，总是指向sockaddr_in数据结构）
namelen：addr所指向的socket结构的长度（size of(struct sockaddr)）
指向bind()函数原型的指针引用的总是通用地址结构sockaddr。在调用函数bind()的过程中，将TCP/IP类型的socketaddr_in结构的指针指向通用的地址结构sockaddr，这是一个标准的操作过程。
bind()函数调用成功时返回0值，不成功时返回SOCKET_ERROR。当bind()函数调用失败后，WSAGetLastError()函数所返回的最常见的错误是WSAEADDRINUSE（100048）。错误原因：这个应用程序和其他应用程序都绑定了同名的socket（同一端口号和同一本地IP地址的组合）。可以通过设置函数setsockopt()中的选项SO_REUSEADDR来避免此错误。但是该选项的使用可能会带来一些问题，不建议使用。最好的办法是保证每个socket名称都是独一无二的。

4.4.6 客户端的socket名称是可选的 P60
服务器必须对其socket命名，以使客户能够在网络中发现它．而客户端的socket则不要求命名，但是也不限制其命名。
每个socket都需要一个完整有效的名称。当用户没有使用bind()函数显式地为客户socket命名时，协议栈将隐式地为其命名。协议栈将本地IP地址指派给它，并从用户定义的服务端口号范围中任取一个分给它。这种隐含式的命名方法的好处是：协议栈总是分配独有的端口号以避免与其他socket冲突。对于TCP socket，协议栈在调用connect()函数时隐式地为其命名，对于UDP socket，则通过connect()函数或者sendto()函数隐式地为其命名。
调用bind()函数时，端口号也可以设为0值。实际上，这将请求网络系统将下一个可用的端口号码分配给它。bind()调用返回后，可以通过调用getsockname()函数获取系统刚分配的这个端口号。
只能对本地端口命名一次，所以，如果调用了bind()，然后再调用connect()或者sendto()，那么后两个函数就不会再隐式地为socket命名。相反地，如果已经调用了connect()或者sendto()，再调用bind()函数就会失败，并返回WSAEINVAL（10022）错误，意为“socket已经与某个地址绑定”（即已经对socket命名了）。

4.5 与另一个socket建立关联
一个socket关联包含5个元素：
--协议（客户端与服务器socket采用相同协议）。
--客户端IP地址。
--客户端口号。
--服务器IP地址。
--服务器端口号。
构成一个关联需要结合两端的socket名称，需要3个步骤：
--服务顺为建立关联做准备。
--客户端初始化这个关联。
--服务器完成关联。

在任何网络（内部）中，每一个关联都是唯一的。特定的关联决定了网络数据包的唯一性。它引导每个数据包在网络中的传输。关联两端的协议栈维持相关信息，并把此信息插入在客户端与服务器之间所传输的每个网络层（IP）和传输层（TCP或UDP）数据单元的首部。接收端的协议栈利用其中的关系元素来识别其所属的socket。

4.5.1 服务器如何准备建立关联 P62
一个数据报（UDP）服务器无须为它同客户端的关联做任何准备工作，因为这个关联是在接收数据时建立起来的，所以，在基于UDP的服务器应用程序中，只要调用函数WSAAsyncSelect()、rev()、recvfrom()或者select()中的任何一个，即可为接收数据做好准备。流（TCP）服务器，为了使其已命名的socket能够为客户端所用，还需要额外的步骤，见下面listen()函数。
服务器必须为接纳来自TCP客户端的连接请求做好准备，可通过调用listen()函数实现。
int PASCAL FAR listen(SOCKET s,//a named, unconnected socket
	int backlog//pending connect queue length
);
s：已命名的socket句柄（已调用bind()函数），但尚未连接
backlog：等待连接的队列长度（不等于已接纳并建立连接的数目）。
listen()函数调用成功时返回0值，失败时返回SOCKET_ERROR。函数listen()调用一般不会失败。如果失败，最可能的错误是由函数WSAGetLastError()返回WSAEMFILE(10024)，表明无可用的socket描述符。
当在一个TCP socket上调用了listen()后，需要调用另一个函数以检测来自客户端的连接请求，有3种方法可以实现这个功能：可以调用accept()、select()或WSAAsyncSelect()。使用accept()函数是最容易的，但并非最有效率的，在比较复杂的服务器应用程序中（需处理多个socket），通常使用select()。WSAAsyncSelect()则是任何Windows Socket应用程序都可选用的函数。
如果采用select()，那么应当检查可读性；如果采用WSAAsyncSelect()，那么需要为WSAsyncSelect()请求FD_ACCEPT事件，以便为检测到来的连接请求做好准备。

4.5.2 客户端如何发起一个关联 P63
对于数据报（UDP）客户端，有两种不同的方法来发起关联。第一种方法：在运行时需从同一个socket向不同的远程主机发送数据。这个方法采用sendto()函数，住厕所是可以改造所发送的每个数据报的目标。
第二种发起关联的方法需要采取若干步骤，先初始化socket结构，接着调用connect()函数建立远程目标，然后调用send()。通常在下列情况下采用这种方法，即UDP socket在其生存期中向同一个远程地址发送数据。这种方法还隐式地设置了一个针对该socket的数据报过滤器。于是，你的recv()就只接收来自给定目的地址的数据报。如果需要向另一台主机发送，可以再次调用connect()来“动态地”改变接收目标，不过要先从前者断开（通过连接到INADDR_ANY）。
connect()
由于流（TCP）客户端是面向连接的，为了创建必须发起一个连接，可以通过调用函数connect()实现。该函数在一个TCP socket上发起创建虚电路，或者为UDP socket设置一个默认的socket名称。
int PASCAL FAR connect (SOCKET s//an unconnected socket
	struct sockaddr FAR *addr,//remote port and IP addr
	int namelen//addr structure length
);
s：socket句柄
addr：socket地址结构指针（对于TCP/IP，总是采用sockaddr_in结构）。
namelen：addr所指向的socket结构的长度（size of(struct sockaddr)）。

connect()的参数与bind()参数相同。调用connect()函数之前，必须初始化socket地址结构。这点也与bind()相似，不同之处在于：对于connect()，使用远程socket名称来初始化sin_port和sin_addr的值，而不是像bind()那样用本地socket名称。connect()函数要求提供客户端打算与之建立关联的服务器端的socket名称。
connect()函数调用成功返回0值，失败返回SOCKET_ERROR，对于TCP socket，connect()调用失败后，WSAGetLastError()函数返回的最常见错误信息是WSAECONNREFUSED(10061)。错误几种情况：服务器没有运行、你在客户端（或服务器端）对sin_port的初始化不正确或者IP地址不正确。在UDP socket上调用connect()并不对网络进行访问，对于UDP socket，最常见的错误是WSAEADDRINUSE(10048)，如果在同一个地址socket上，调用一次以上connect()函数，并且引用同一个远程socket名称时，就会产生这个错误。
如果没有事先调用bind()函数（显式地为本地socket命名），那么connect()函数会隐式地对本地socket()命名。如果还没有为socket命名，connect()将自动地在用户定义的服务范围内选择一个没有使用的端口号，并且指派一个合适的本地接口地址。由于存在这种隐式的端口号分配功能，大多数客户端程序没有必要调用bind()函数。

4.5.3 服务器如何完成一个关联 P65

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------
