//------------------------------------------------------------------------------------------------
//extern作用
//https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html
也就是说extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

例如：
//Define.h
#ifndef __DEFINE_HPP__
#define __DEFINE_HPP__

int number = 100;

#endif

//main.cpp
#include <iostream>
#include <string> 
using namespace std;

extern int number;//当用extern指定了此参数后，就可以不用包含头文件Define.h，可以正常编译过，链接时会找到对应变量

int main(int argc, char* argv[])
{
    cout << number << endl;
    return 0;
}

如果写成extern int number2;，则会链接错误：
1>main.obj : error LNK2001: 无法解析的外部符号 "int number2" (?number2@@3HA)
1>     1>
1>e:\Program Files\VS Projects\TestProject\Debug\TestProject.exe : fatal error LNK1120: 1 个无法解析的外部命令

问题：当单方面修改extern 函数原型
当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？
答案与分析：
目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。
宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。
//------------------------------------------------------------------------------------------------
//windows环境下用c++实现socket编程
http://blog.csdn.net/xiaoquantouer/article/details/58001960

（1）服务端
1、加载套接字库，创建套接字（WSAStartup()/socket()）;
2、绑定套接字到一个IP地址和一个端口上（bind()）;
3、将套接字设置为监听模式等待连接请求（listen()）；
4、请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）；
5、用返回的套接字和客户端进行通信（send()/recv()）；
6、返回，等待另一个连接请求；
7、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；

#include <stdio.h>    
#include <winsock2.h>    

#pragma comment(lib,"ws2_32.lib")    

int main(int argc, char* argv[])
{
    //初始化WSA    
    WORD sockVersion = MAKEWORD(2, 2);
    WSADATA wsaData;
    if (WSAStartup(sockVersion, &wsaData) != 0)
    {
        return 0;
    }

    //创建套接字    
    SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (slisten == INVALID_SOCKET)
    {
        printf("socket error !");//如果没有//初始化WSA，则报错
        return 0;
    }

    //绑定IP和端口    
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_port = htons(8888);//本地监听端口：8888
    sin.sin_addr.S_un.S_addr = INADDR_ANY;
    if (bind(slisten, (LPSOCKADDR) &sin, sizeof(sin)) == SOCKET_ERROR)
    {
        printf("bind error !");
    }

    //绑定成功后就开始监听 
    if (listen(slisten, 5) == SOCKET_ERROR)//5为等待连接数目
    {
        printf("listen error !");
        return 0;
    }

    //循环接收数据    
    SOCKET sClient;
    sockaddr_in remoteAddr;
    int nAddrlen = sizeof(remoteAddr);
    char revData[255];
    while (true)
    {
        printf("等待连接...\n");
        sClient = accept(slisten, (SOCKADDR *) &remoteAddr, &nAddrlen);
        if (sClient == INVALID_SOCKET)
        {
            printf("accept error !");
            continue;
        }
        printf("接受到一个连接：%s \r\n", inet_ntoa(remoteAddr.sin_addr));

        //接收数据    
        int ret = recv(sClient, revData, 255, 0);
        if (ret > 0)
        {
            revData[ret] = 0x00;
            printf(revData);
        }

        //发送数据    
        const char * sendData = "你好，TCP客户端！\n";
        send(sClient, sendData, strlen(sendData), 0);
        closesocket(sClient);
    }

    closesocket(slisten);
    WSACleanup();
    return 0;
}


（2）客户端
1、加载套接字库，创建套接字（WSAStartup()/socket()）；
2、向服务器发出连接请求（connect()）；
3、和服务器进行通信（send()/recv()）；
4、关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()）；
#include<WINSOCK2.H>  
#include<STDIO.H>  
#include<iostream>  
#include<cstring>  
#include<string>  
using namespace std;
#pragma comment(lib, "ws2_32.lib")  

int main()
{
    WORD sockVersion = MAKEWORD(2, 2);
    WSADATA data;
    if (WSAStartup(sockVersion, &data) != 0)
    {
        return 0;
    }
    while (true) {
        SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (sclient == INVALID_SOCKET)
        {
            printf("invalid socket!");
            return 0;
        }

        sockaddr_in serAddr;
        serAddr.sin_family = AF_INET;
        serAddr.sin_port = htons(8888);
        serAddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
        if (connect(sclient, (sockaddr *) &serAddr, sizeof(serAddr)) == SOCKET_ERROR)
        {  //连接失败   
            printf("connect error !");
            closesocket(sclient);
            return 0;
        }

        string data;
        cin >> data;
        const char * sendData;
        sendData = data.c_str();   //string转const char*   
                                   //char * sendData = "你好，TCP服务端，我是客户端\n";  
        send(sclient, sendData, strlen(sendData), 0);
        //send()用来将数据由指定的socket传给对方主机  
        //int send(int s, const void * msg, int len, unsigned int flags)  
        //s为已建立好连接的socket，msg指向数据内容，len则为数据长度，参数flags一般设0  
        //成功则返回实际传送出去的字符数，失败返回-1，错误原因存于error   

        char recData[255];
        int ret = recv(sclient, recData, 255, 0);
        if (ret>0) {
            recData[ret] = 0x00;
            printf(recData);
        }
        closesocket(sclient);
    }


    WSACleanup();
    return 0;
}


（二）UDP协议
服务端代码：
#include <stdio.h>   
#include <winsock2.h>   

#pragma comment(lib,"ws2_32.lib")    

int main(int argc, char* argv[])
{
    WSADATA wsaData;
    WORD sockVersion = MAKEWORD(2, 2);
    if (WSAStartup(sockVersion, &wsaData) != 0)
    {
        return 0;
    }

    SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (serSocket == INVALID_SOCKET)
    {
        printf("socket error !");
        return 0;
    }

    sockaddr_in serAddr;
    serAddr.sin_family = AF_INET;
    serAddr.sin_port = htons(8888);
    serAddr.sin_addr.S_un.S_addr = INADDR_ANY;
    if (bind(serSocket, (sockaddr *) &serAddr, sizeof(serAddr)) == SOCKET_ERROR)
    {
        printf("bind error !");
        closesocket(serSocket);
        return 0;
    }

    sockaddr_in remoteAddr;
    int nAddrLen = sizeof(remoteAddr);
    while (true)
    {
        char recvData[255];
        int ret = recvfrom(serSocket, recvData, 255, 0, (sockaddr*) &remoteAddr, &nAddrLen);
        if (ret > 0)
        {
            recvData[ret] = 0x00;
            printf("接受到一个连接：%s \r\n", inet_ntoa(remoteAddr.sin_addr));
            printf(recvData);
        }

        const char * sendData = "一个来自服务端的UDP数据包\n";
        sendto(serSocket, sendData, strlen(sendData), 0, (sockaddr *) &remoteAddr, nAddrLen);

    }
    closesocket(serSocket);
    WSACleanup();
    return 0;
}

客户端代码：
#include <stdio.h>   
#include <winsock2.h>   
   
#pragma comment(lib,"ws2_32.lib")    
   
int main(int argc, char* argv[])   
{   
   WORD socketVersion = MAKEWORD(2,2);   
   WSADATA wsaData;    
   if(WSAStartup(socketVersion, &wsaData) != 0)   
   {   
       return 0;   
   }   
   SOCKET sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);   
       
   sockaddr_in sin;   
   sin.sin_family = AF_INET;   
   sin.sin_port = htons(8888);   
   sin.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");   
   int len = sizeof(sin);   
       
   const char * sendData = "来自客户端的数据包.\n";   
   sendto(sclient, sendData, strlen(sendData), 0, (sockaddr *)&sin,len);   
   
   char recvData[255];        
   int ret = recvfrom(sclient, recvData, 255, 0, (sockaddr *)&sin,&len);   
   if(ret > 0)   
   {   
       recvData[ret] = 0x00;   
       printf(recvData);   
   }   
   
   closesocket(sclient);   
   WSACleanup();   
   return 0;   
}   
//------------------------------------------------------------------------------------------------
//使用pack预处理指令来禁止对齐调整
#pragma pack(1)
struct XXX
{
    
};
#pragma pack()
//------------------------------------------------------------------------------------------------
int f(int x, int y)
{
    return (x & y) + ((x ^ y) >> 1);
}

int main()
{
    cout << f(2, 6);

    return 0;
}
输出：4
//------------------------------------------------------------------------------------------------
//基类可以作为模板类来编写
//TemplateBase.h
#ifndef __TEMPLATEBASE_H__
#define __TEMPLATEBASE_H__

template<typename T, typename BaseT>
class TypeRef: public BaseT
{
public:
	TypeRef(const T& t)
		: t_(t)
	{

	}

	const T& d() const
	{
		return t_;
	}

private:
	const T& t_;
};

#endif

//Base.h
#ifndef __BASE_H__
#define __BASE_H__

#include <iostream>

class BaseA
{
public:
	virtual ~BaseA() {}

	virtual void show() = 0;
};

class DerivedA: public BaseA
{
public:
	virtual ~DerivedA() 
	{
	
	}

	virtual void show()
	{
		std::cout << "DerivedA: BaseA" << std::endl;
	}
};

#endif

//main.cpp
#include <iostream>

#include "Base.h"
#include "TemplateBase.h"

using namespace std;

int main()
{
	int i = 3;
	TypeRef<int, DerivedA> t(i);//可以让基类作为模板参数来使用
	std::cout << t.d() << std::endl;
	t.show();
	return 0;
}
输出如下：
3
DerivedA: BaseA

//------------------------------------------------------------------------------------------------
//类函数里的静态对象，对于所有的类实例来说，都是共用的，并不是针对单个实例独有的。
//这种情况下，是否多线程可能会有问题？多个线程同时写同一个对象
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

class StaticObjectTest
{
public:
    void printStaticVector() const
    {
        static vector<string> strVector;

        cout << strVector.size() << endl;

        if (strVector.empty())
        {
            strVector = {"hello", "world", "nice", "day"};
        }

        for_each(strVector.begin(), strVector.end(), [] (const string& s) {cout << s << "\n"; });
    }
};

int main()
{
    StaticObjectTest s1;
    s1.printStaticVector();
    s1.printStaticVector();
    StaticObjectTest s2;
    s2.printStaticVector();

    return 0;
}
输出：
0
hello
world
nice
day
4
hello
world
nice
day
4
hello
world
nice
day
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//C++的派生类重载函数的返回类型可以与基类函数不一致，但也要有继承关系，即可以返回基类返回对象的子类（同Java一样）
//没有继承关系的不同返回类型编译报错
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class Base
{
public:
	virtual Base* get() = 0;//virtual int get() = 0;
};

class DerivedString: public Base
{
public:
	/*virtual string get() override //string与int无法继承返回
	{
		return "hello, world";
	}*/
	virtual DerivedString* get() override
	{
		return new DerivedString();
	}
};

class DerivedDouble: public Base
{
public:
	/*virtual double get() override
	{
		return 3.0;
	}*/
	virtual DerivedDouble* get() override
	{
		return new DerivedDouble();
	}
};

int main()
{
	/*unique_ptr<Base> pBase1(new DerivedString());
	cout << pBase1->get() << endl;

	unique_ptr<Base> pBase2(new DerivedDouble());
	cout << pBase2->get() << endl;*/

	return 0;
}
//------------------------------------------------------------------------------------------------
//gtest学习
http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html

//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之二 - 断言
可以在断言后加输出流语句，则断言失败时，则会打出该语句，方便定位。如果测试用例通过，则不会打出该语句。
//一、前言
这篇文章主要总结gtest中的所有断言相关的宏。 gtest中，断言的宏可以理解为分为两类，一类是ASSERT系列，一类是EXPECT系列。一个直观的解释就是：
1. ASSERT_* 系列的断言，当检查点失败时，退出当前函数（注意：并非退出当前案例）。 
2. EXPECT_* 系列的断言，当检查点失败时，继续往下执行。

//二、示例
EXPECT_EQ(6, Foo(30, 18)) << "the eq failed when i = " << i;

//三、布尔值检查
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_TRUE(condition);	EXPECT_TRUE(condition);	condition is true
ASSERT_FALSE(condition);	EXPECT_FALSE(condition);	condition is false

//四、数值型数据检查
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_EQ(expected, actual);	EXPECT_EQ(expected, actual);	expected == actual
ASSERT_NE(val1, val2);	EXPECT_NE(val1, val2);	val1 != val2
ASSERT_LT(val1, val2);	EXPECT_LT(val1, val2);	val1 < val2
ASSERT_LE(val1, val2);	EXPECT_LE(val1, val2);	val1 <= val2
ASSERT_GT(val1, val2);	EXPECT_GT(val1, val2);	val1 > val2
ASSERT_GE(val1, val2);	EXPECT_GE(val1, val2);	val1 >= val2

//五、字符串检查 
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_STREQ(expected_str, actual_str);	EXPECT_STREQ(expected_str, actual_str);	 the two C strings have the same content
ASSERT_STRNE(str1, str2);	EXPECT_STRNE(str1, str2);	 the two C strings have different content
ASSERT_STRCASEEQ(expected_str, actual_str);	EXPECT_STRCASEEQ(expected_str, actual_str);	 the two C strings have the same content, ignoring case
ASSERT_STRCASENE(str1, str2);	EXPECT_STRCASENE(str1, str2);	 the two C strings have different content, ignoring case


*STREQ*和*STRNE*同时支持char*和wchar_t*类型的，*STRCASEEQ*和*STRCASENE*却只接收char*，估计是不常用吧。下面是几个例子：
TEST(StringCmpTest, Demo)
{
	char* pszCoderZh = "CoderZh";
	wchar_t* wszCoderZh = L"CoderZh";
	std::string strCoderZh = "CoderZh";
	std::wstring wstrCoderZh = L"CoderZh";

	EXPECT_STREQ("CoderZh", pszCoderZh);
	EXPECT_STREQ(L"CoderZh", wszCoderZh);

	EXPECT_STRNE("CnBlogs", pszCoderZh);
	EXPECT_STRNE(L"CnBlogs", wszCoderZh);

	EXPECT_STRCASEEQ("coderzh", pszCoderZh);
	//EXPECT_STRCASEEQ(L"coderzh", wszCoderZh);    不支持

	EXPECT_STREQ("CoderZh", strCoderZh.c_str());
	EXPECT_STREQ(L"CoderZh", wstrCoderZh.c_str());
}

//六、显示返回成功或失败
直接返回成功：SUCCEED();

返回失败： 
Fatal assertion	Nonfatal assertion
FAIL();	ADD_FAILURE();

TEST(ExplicitTest, Demo)
{
	SUCCEED();//直接返回成功，没看到有什么用？
	ADD_FAILURE() << "Sorry"; // None Fatal Asserton，继续往下执行。
	//FAIL(); // Fatal Assertion，不往下执行该案例。
	EXPECT_EQ(3, 4);
}

//七、异常检查
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_THROW(statement, exception_type);	EXPECT_THROW(statement, exception_type);	statement throws an exception of the given type
ASSERT_ANY_THROW(statement);	EXPECT_ANY_THROW(statement);	statement throws an exception of any type
ASSERT_NO_THROW(statement);	EXPECT_NO_THROW(statement);	statement doesn't throw any exception

int Foo(int a, int b)
{
	if (a == 0 || b == 0)
	{
		throw "don't do that";
	}
	int c = a % b;
	if (c == 0)
		return b;
	return Foo(b, c);
}

TEST(FooTest, HandleZeroInput)
{
	EXPECT_ANY_THROW(Foo(10, 0));
	EXPECT_THROW(Foo(0, 5), char*);
	EXPECT_NO_THROW(Foo(0, 5));//断言失败
}

//八、Predicate Assertions
在使用EXPECT_TRUE或ASSERT_TRUE时，有时希望能够输出更加详细的信息，比如检查一个函数的返回值TRUE还是FALSE时，希望能够输出传入的参数是什么，以便失败后好跟踪。因此提供了如下的断言：
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_PRED1(pred1, val1);	EXPECT_PRED1(pred1, val1);	pred1(val1) returns true
ASSERT_PRED2(pred2, val1, val2);	EXPECT_PRED2(pred2, val1, val2);	pred2(val1, val2) returns true
...	 ...	 ...

Google人说了，他们只提供<=5 个参数的，如果需要测试更多的参数，直接告诉他们。下面看看这个东西怎么用。
 
bool MutuallyPrime(int m, int n)
{
	return Foo(m, n) > 1;
}

TEST(PredicateAssertionTest, Demo)
{
	int m = 5, n = 6;
	EXPECT_PRED2(MutuallyPrime, m, n);
}
当失败时，返回错误信息：
error: MutuallyPrime(m, n) evaluates to false, where
m evaluates to 5
n evaluates to 6

如果对这样的输出不满意的话，还可以自定义输出格式，通过如下：
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_PRED_FORMAT1(pred_format1, val1);`	EXPECT_PRED_FORMAT1(pred_format1, val1);	pred_format1(val1) is successful
ASSERT_PRED_FORMAT2(pred_format2, val1, val2);	EXPECT_PRED_FORMAT2(pred_format2, val1, val2);	pred_format2(val1, val2) is successful

用法示例：
testing::AssertionResult AssertFoo(const char* m_expr, const char* n_expr, const char* k_expr, int m, int n, int k) 
{
	if (Foo(m, n) == k)
		return testing::AssertionSuccess();
	testing::Message msg;
	msg << m_expr << " 和 " << n_expr << " 的最大公约数应该是：" << Foo(m, n) << " 而不是：" << k_expr;
	return testing::AssertionFailure(msg);
}

TEST(AssertFooTest, HandleFail)
{
	EXPECT_PRED_FORMAT3(AssertFoo, 3, 6, 2);
}

失败时，输出信息：
error: 3 和 6 的最大公约数应该是：3 而不是：2

//九、浮点型检查
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_FLOAT_EQ(expected, actual);	EXPECT_FLOAT_EQ(expected, actual);	 the two float values are almost equal
ASSERT_DOUBLE_EQ(expected, actual);	EXPECT_DOUBLE_EQ(expected, actual);	 the two double values are almost equal

对相近的两个数比较：
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_NEAR(val1, val2, abs_error);	EXPECT_NEAR(val1, val2, abs_error);	 the difference between val1 and val2 doesn't exceed the given absolute error

TEST(AssertFloatTest, FloatTest)
{
	EXPECT_FLOAT_EQ(1.21, 1.22);
	EXPECT_NEAR(1.21, 1.22, 0.01);
}
d:\program files\vc2013 projects\learningtest\learningtest\gtest_examples.cpp(16): error:
Value of: 1.22
Expected: 1.21
d:\program files\vc2013 projects\learningtest\learningtest\gtest_examples.cpp(17): error:
The difference between 1.21 and 1.22 is 0.010000000000000009, which exceeds 0.01, where
1.21 evaluates to 1.21,
1.22 evaluates to 1.22, and
0.01 evaluates to 0.01.

同时，还可以使用：
EXPECT_PRED_FORMAT2(testing::FloatLE, val1, val2);
EXPECT_PRED_FORMAT2(testing::DoubleLE, val1, val2);

//十、Windows HRESULT assertions
Fatal assertion	Nonfatal assertion	Verifies
ASSERT_HRESULT_SUCCEEDED(expression);	EXPECT_HRESULT_SUCCEEDED(expression);	expression is a success HRESULT
ASSERT_HRESULT_FAILED(expression);	EXPECT_HRESULT_FAILED(expression);	expression is a failure HRESULT
 
例如：
CComPtr shell;
ASSERT_HRESULT_SUCCEEDED(shell.CoCreateInstance(L"Shell.Application"));
CComVariant empty;
ASSERT_HRESULT_SUCCEEDED(shell->ShellExecute(CComBSTR(url), empty, empty, empty, empty));

//十一、类型检查
类型检查失败时，直接导致代码编不过，难得用处就在这？看下面的例子：
template <typename T> 
class FooType 
{
public:
    void Bar() { testing::StaticAssertTypeEq<int, T>(); }
};

TEST(TypeAssertionTest, Demo)
{
    FooType<bool> fooType;
    fooType.Bar();
}
代码直接编译不过，有点类似C++ 11 的新特性：静态断言

//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之三 - 事件机制
一、前言
gtest提供了多种事件机制，非常方便我们在案例之前或之后做一些操作。总结一下gtest的事件一共有3种：
1. 全局的，所有案例执行前后。
2. TestSuite级别的，在某一批案例中第一个案例前，最后一个案例执行后。
3. TestCase级别的，每个TestCase前后。

二、全局事件
要实现全局事件，必须写一个类，继承testing::Environment类，实现里面的SetUp和TearDown方法。
1. SetUp()方法在所有案例执行前执行
2. TearDown()方法在所有案例执行后执行
当然，这样还不够，我们还需要告诉gtest添加这个全局事件，我们需要在main函数中通过testing::AddGlobalTestEnvironment方法将事件挂进来，也就是说，我们可以写很多个这样的类，然后将他们的事件都挂上去。

#include "gtest/gtest.h"

class FooEnvironment: public testing::Environment
{
public:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown" << std::endl;
	}
};

class FooEnvironment2: public testing::Environment
{
public:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP2" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown2" << std::endl;
	}
};

int main(int argc, char* argv[])
{
	testing::AddGlobalTestEnvironment(new FooEnvironment);
	testing::AddGlobalTestEnvironment(new FooEnvironment2);
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
输出如下：
[==========] Running 3 tests from 2 test cases.
[----------] Global test environment set-up.
Foo FooEnvironment SetUP
Foo FooEnvironment SetUP2
[----------] 1 test from FooTest
[ RUN      ] FooTest.HandleNoneZeroInput
[       OK ] FooTest.HandleNoneZeroInput (0 ms)
[----------] 1 test from FooTest (1 ms total)

[----------] 2 tests from TypeAssertionTest
[ RUN      ] TypeAssertionTest.Demo
[       OK ] TypeAssertionTest.Demo (0 ms)
[ RUN      ] TypeAssertionTest.Demo2
[       OK ] TypeAssertionTest.Demo2 (0 ms)
[----------] 2 tests from TypeAssertionTest (2 ms total)

[----------] Global test environment tear-down
Foo FooEnvironment TearDown2
Foo FooEnvironment TearDown
[==========] 3 tests from 2 test cases ran. (25 ms total)
[  PASSED  ] 3 tests.
请按任意键继续. . .

几个要点：
--public继承 testing::Environment
--实现两个虚函数SetUp和TearDown，访问控制符号可以用public、protected或者private
--可以声明静态成员变量，并在全局使用，访问控制符必须public，protected和private将无法在case中使用。但是其实也没什么用，完全可以定义一个类对象，全局使用即可

见如下测试代码：
//gtest_main.hpp
#ifndef __GTESTMAIN_H__
#define __GTESTMAIN_H__

class FooEnvironment: public testing::Environment
{
public:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown" << std::endl;
	}

	static int i_;
};

class FooEnvironment2: public testing::Environment
{
public:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP2" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown2" << std::endl;
	}
};

#endif

//gtest_main.cpp
#include "gtest/gtest.h"
#include "gtest_main.hpp"

int FooEnvironment::i_ = 30;

int main(int argc, char* argv[])
{
	testing::AddGlobalTestEnvironment(new FooEnvironment);
	testing::AddGlobalTestEnvironment(new FooEnvironment2);
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}

//gest_TestCase.cpp
#include "gtest/gtest.h"
#include "main.h"
#include "gtest_main.hpp"

class FooTest: public testing::Test
{
protected:
	static void SetUpTestCase() {
		sharedResource_ = new int(3);
	}
	static void TearDownTestCase() {
		delete sharedResource_;
		sharedResource_ = nullptr;
	}

protected:
	// Some expensive resource shared by all tests.
	static int* sharedResource_;
};

int* FooTest::sharedResource_ = nullptr;

TEST_F(FooTest, Test1)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(3, *sharedResource_);
	*sharedResource_ = 2;

	EXPECT_EQ(30, FooEnvironment::i_);
	FooEnvironment::i_ = 20;//这里修改全局变量静态成员值
}

TEST_F(FooTest, Test2)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(2, *sharedResource_);
	EXPECT_EQ(20, FooEnvironment::i_);//这里进行全局变量静态成员值测试
}

//----
还可以对全局变量进行声明，并进行测试，不过没什么用，见如下实现：
//gtest_main.hpp
#ifndef __GTESTMAIN_H__
#define __GTESTMAIN_H__

class FooEnvironment: public testing::Environment
{
public:
	FooEnvironment(): i_(10) { }
private:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown" << std::endl;
	}
public:
	int i_;
};

class FooEnvironment2: public testing::Environment
{
public:
	virtual void SetUp()
	{
		std::cout << "Foo FooEnvironment SetUP2" << std::endl;
	}
	virtual void TearDown()
	{
		std::cout << "Foo FooEnvironment TearDown2" << std::endl;
	}
};

#endif

//gtest_main.cpp
#include "gtest/gtest.h"
#include "gtest_main.hpp"

int main(int argc, char* argv[])
{
	testing::AddGlobalTestEnvironment(new FooEnvironment);
	testing::AddGlobalTestEnvironment(new FooEnvironment2);
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}

//gtest_TestCases.cpp
#include "gtest/gtest.h"
#include "main.h"
#include "gtest_main.hpp"

class FooTest: public testing::Test
{
protected:
	static void SetUpTestCase() {
		sharedResource_ = new int(3);
	}
	static void TearDownTestCase() {
		delete sharedResource_;
		sharedResource_ = nullptr;
	}

protected:
	// Some expensive resource shared by all tests.
	static int* sharedResource_;
};

int* FooTest::sharedResource_ = nullptr;

TEST_F(FooTest, Test1)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(3, *sharedResource_);
	*sharedResource_ = 2;

	FooEnvironment fooEnvironment;

	EXPECT_EQ(3, fooEnvironment.i_);
}

TEST_F(FooTest, Test2)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(2, *sharedResource_);
}


三、TestSuite事件
我们需要写一个类，继承testing::Test，然后实现两个静态方法
1. SetUpTestCase() 方法在第一个TestCase之前执行
2. TearDownTestCase() 方法在最后一个TestCase之后执行
在编写测试案例时，我们需要使用TEST_F这个宏，第一个参数必须是我们上面类的名字，代表一个TestSuite。

//所有Suite用例共享一份资源
class FooTest: public testing::Test
{
protected:
	static void SetUpTestCase() {
		sharedResource_ = new int(3);
	}
	static void TearDownTestCase() {
		delete sharedResource_;
		sharedResource_ = nullptr;
	}
	// Some expensive resource shared by all tests.
	static int* sharedResource_;
};

int* FooTest::sharedResource_ = nullptr;//静态成员变量需要在类外声明

TEST_F(FooTest, Test1)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(3, *sharedResource_);
	*sharedResource_ = 2;//这里修改了sharedResource_值后，在下一个Suite中的用例值即改变了
}

TEST_F(FooTest, Test2)
{
	// you can refer to shared_resource here 
	EXPECT_EQ(2, *sharedResource_);
}

几个要点：
--public继承 testing::test
--实现两个静态成员函数SetUpTestCase和TearDownTestCase，函数访问控制可以设置为protected或public，不能用private
--声明并定义静态成员变量，访问控制符可以设置为protected或public，不能用private

四、TestCase事件 
TestCase事件是挂在每个案例执行前后的，实现方式和上面的几乎一样，不过需要实现的是SetUp方法和TearDown方法：
1. SetUp()方法在每个TestCase之前执行
2. TearDown()方法在每个TestCase之后执行

class FooTest: public testing::Test
{
protected:
	virtual void SetUp() 
	{
		sharedResource_ = new int(3);
	}
	virtual void TearDown() 
	{
		delete sharedResource_;
		sharedResource_ = nullptr;
	}
	//这里的static没什么用，虽然是static变量，但仍不会TestCases共享
	static int* sharedResource_;//改成非静态int* sharedResource_;
};

int* FooTest::sharedResource_ = nullptr;//改成非静态后，此行可以删除

TEST_F(FooTest, Test1)
{
	EXPECT_EQ(3, *sharedResource_);//这里尽管sharedResource_是所有类共享的static变量，但是在各个TestCases中，仍不会共享
	*sharedResource_ = 2;
}

TEST_F(FooTest, Test2)
{
	EXPECT_EQ(2, *sharedResource_);
}
输出如下：
[==========] Running 2 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 2 tests from FooTest
[ RUN      ] FooTest.Test1
[       OK ] FooTest.Test1 (0 ms)
[ RUN      ] FooTest.Test2
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(31): error:
 Value of: *sharedResource_
  Actual: 3
Expected: 2
[  FAILED  ] FooTest.Test2 (1 ms)
[----------] 2 tests from FooTest (4 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test case ran. (7 ms total)
[  PASSED  ] 1 test.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] FooTest.Test2

 1 FAILED TEST
请按任意键继续. . .

几个要点：
--public继承 testing::test
--实现两个虚成员函数SetUp和TearDown，函数访问控制可以设置为protected，public和private
--声明并定义成员变量（无论是否静态），访问控制符可以设置为protected或public，不能用private

五、总结
gtest提供的这三种事件机制还是非常的简单和灵活的。同时，通过继承Test类，使用TEST_F宏，我们可以在案例之间共享一些通用方法，共享资源。使得我们的案例更加的简洁，清晰。

//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之四 - 参数化
一、前言
在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况。我们之前的做法通常是写一个通用方法，然后编写在测试案例调用它。即使使用了通用方法，这样的工作也是有很多重复性的，程序员都懒，都希望能够少写代码，多复用代码。Google的程序员也一样，他们考虑到了这个问题，并且提供了一个灵活的参数化测试的方案。

二、旧的方案
为了对比，我还是把旧的方案提一下。首先我先把被测函数IsPrime帖过来(在gtest的example1.cc中)，这个函数是用来判断传入的数值是否为质数的。
// Returns true if n is a prime number.
bool IsPrime(int n)
{
	// Trivial case 1: small numbers
	if (n <= 1) return false;

	// Trivial case 2: even numbers
	if (n % 2 == 0) return n == 2;

	// Now, we have that n is odd and n >= 3.

	// Try to divide n by every odd number i, starting from 3
	for (int i = 3;; i += 2) 
	{
		// We only have to try i up to the squre root of n
		if (i > n / i) break;

		// Now, we have i <= n/i < n.
		// If n is divisible by i, n is not prime.
		if (n % i == 0) return false;
	}
	// n has no integer factor in the range (1, n), and thus is prime.
	return true;
}

//假如我要编写判断结果为True的测试案例，我需要传入一系列数值让函数IsPrime去判断是否为True（当然，即使传入再多值也无法确保函数正确，呵呵），因此我需要这样编写如下的测试案例：
TEST(FooTest, Test1)
{
	EXPECT_TRUE(IsPrime(3));
	EXPECT_TRUE(IsPrime(5));
	EXPECT_TRUE(IsPrime(11));
	EXPECT_TRUE(IsPrime(23));
	EXPECT_TRUE(IsPrime(17));
}
我们注意到，在这个测试案例中，我至少复制粘贴了4次，假如参数有50个，100个，怎么办？同时，上面的写法产生的是1个测试案例，里面有5个检查点，假如我要把5个检查变成5个单独的案例，将会更加累人。

接下来，就来看看gtest是如何为我们解决这些问题的。 

三、使用参数化后的方案
1. 告诉gtest你的参数类型是什么
你必须添加一个类，继承testing::TestWithParam<T>，其中T就是你需要参数化的参数类型，比如上面的例子，我需要参数化一个int型的参数
class IsPrimeParamTest: public::testing::TestWithParam < int >
{

};

2. 告诉gtest你拿到参数的值后，具体做些什么样的测试
这里，我们要使用一个新的宏（嗯，挺兴奋的）：TEST_P，关于这个"P"的含义，Google给出的答案非常幽默，就是说你可以理解为”parameterized" 或者 "pattern"。我更倾向于 ”parameterized"的解释，呵呵。在TEST_P宏里，使用GetParam()获取当前的参数的具体值。
TEST_P(IsPrimeParamTest, HandleTrueReturn)
{
    int n =  GetParam();
    EXPECT_TRUE(IsPrime(n));
}
嗯，非常的简洁！

3. 告诉gtest你想要测试的参数范围是什么
使用INSTANTIATE_TEST_CASE_P这宏来告诉gtest你要测试的参数范围：
INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::Values(3, 5, 11, 23, 17));

第一个参数是测试案例的前缀，可以任意取。 
第二个参数是测试案例的名称，需要和之前定义的参数化的类的名称相同，如：IsPrimeParamTest 
第三个参数是可以理解为参数生成器，上面的例子使用test::Values表示使用括号内的参数。Google提供了一系列的参数生成的函数：
Range(begin, end[, step])	 范围在begin~end之间，步长为step，不包括end
Values(v1, v2, ..., vN)	 v1,v2到vN的值
ValuesIn(container) and ValuesIn(begin, end)	 从一个C类型的数组或是STL容器，或是迭代器中取值
Bool()	 取false 和 true 两个值
Combine(g1, g2, ..., gN)	
这个比较强悍，它将g1,g2,...gN进行排列组合，g1,g2,...gN本身是一个参数生成器，每次分别从g1,g2,..gN中各取出一个值，组合成一个元组(Tuple)作为一个参数。
说明：这个功能只在提供了<tr1/tuple>头的系统中有效。gtest会自动去判断是否支持tr/tuple，如果你的系统确实支持，而gtest判断错误的话，你可以重新定义宏GTEST_HAS_TR1_TUPLE=1。

//完整代码如下：
// Returns true if n is a prime number.
bool IsPrime(int n)
{
	// Trivial case 1: small numbers
	if (n <= 1) return false;

	// Trivial case 2: even numbers
	if (n % 2 == 0) return n == 2;

	// Now, we have that n is odd and n >= 3.

	// Try to divide n by every odd number i, starting from 3
	for (int i = 3;; i += 2) 
	{
		// We only have to try i up to the squre root of n
		if (i > n / i) break;

		// Now, we have i <= n/i < n.
		// If n is divisible by i, n is not prime.
		if (n % i == 0) return false;
	}
	// n has no integer factor in the range (1, n), and thus is prime.
	return true;
}

class IsPrimeParamTest: public testing::TestWithParam<int>
{

};

TEST_P(IsPrimeParamTest, HandleTrueReturn)
{
	int n = GetParam();
	EXPECT_TRUE(IsPrime(n));
}

INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::Values(3, 5, 11, 23, 17));//testing::Values<int>(3, 5, 11, 23, 17)，可以指定模板函数参数

输出如下：
[==========] Running 5 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 5 tests from TrueReturn/IsPrimeParamTest
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/0
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/0 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/1
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/1 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/2
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/2 (1 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/3
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/3 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/4
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/4 (0 ms)
[----------] 5 tests from TrueReturn/IsPrimeParamTest (8 ms total)

[----------] Global test environment tear-down
[==========] 5 tests from 1 test case ran. (11 ms total)
[  PASSED  ] 5 tests.
请按任意键继续. . .

//IsPrimeParamTest和TEST_P里的内容还可以如下定义：
class IsPrimeParamTest: public testing::TestWithParam<int>
{
public:
	IsPrimeParamTest(): n_(GetParam()) { }
protected:
	int n_;
};

TEST_P(IsPrimeParamTest, HandleTrueReturn)
{
	EXPECT_TRUE(IsPrime(n_));//这里的n_即IsPrimeParamTest类中的保护成员变量
}

另几种参数生成器的使用样例：
//Range(begin, end[, step])
TEST_P(IsPrimeParamTest, HandleTrueReturn)
{
	EXPECT_TRUE(IsPrime(n_));// << n_ << " is not prime";//这里无需增加输出语句，该测试框架会打出什么数据测试失败
}

INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::Range(1, 11, 2));
输出如下：
[==========] Running 5 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 5 tests from TrueReturn/IsPrimeParamTest
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/0
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(39): error:
 Value of: IsPrime(n_)
  Actual: false
Expected: true
[  FAILED  ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/0, where GetParam() = 1 (1 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/1
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/1 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/2
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/2 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/3
[       OK ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/3 (0 ms)
[ RUN      ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/4
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(39): error:
 Value of: IsPrime(n_)
  Actual: false
Expected: true
[  FAILED  ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/4, where GetParam() = 9 (1 ms)
[----------] 5 tests from TrueReturn/IsPrimeParamTest (18 ms total)

[----------] Global test environment tear-down
[==========] 5 tests from 1 test case ran. (23 ms total)
[  PASSED  ] 3 tests.
[  FAILED  ] 2 tests, listed below:
[  FAILED  ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/0, where GetParam() = 1
[  FAILED  ] TrueReturn/IsPrimeParamTest.HandleTrueReturn/4, where GetParam() = 9

 2 FAILED TESTS
请按任意键继续. . .

//ValuesIn(container) and ValuesIn(begin, end)
int intArray[] = {1, 2, 3};
std::vector<int> intVec = {1, 2, 3};

INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest, testing::ValuesIn(intArray));//testing::ValuesIn(intVec)
INSTANTIATE_TEST_CASE_P(TrueReturn2, IsPrimeParamTest, testing::ValuesIn(intArray, intArray + 3));//testing::ValuesIn(intVec.begin(), intVec.end())

//Combine(g1, g2, ..., gN)
#include "gtest/gtest.h"
#include <tuple>

typedef std::tuple<int, int> IntIntTuple;

bool isSame(IntIntTuple intIntTuple)
{
	return std::get<0>(intIntTuple) == std::get<1>(intIntTuple);
}

class IsSameTest: public testing::TestWithParam<IntIntTuple>
{
public:
	IsSameTest(): intIntTuple_(GetParam()) { }
protected:
	const IntIntTuple& intIntTuple_;//这里可以使用&引用来避免对象构造，但是必须使用const引用
};

TEST_P(IsSameTest, HandleTrueReturn)
{
	EXPECT_TRUE(isSame(intIntTuple_));
}

INSTANTIATE_TEST_CASE_P(TrueReturn, IsSameTest, testing::Combine(testing::Values(1, 3), testing::Values(3, 4)));

输出如下：
[==========] Running 4 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 4 tests from TrueReturn/IsSameTest
[ RUN      ] TrueReturn/IsSameTest.HandleTrueReturn/0
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(21): error:
 Value of: isSame(intIntTuple_)
  Actual: false
Expected: true
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/0, where GetParam() = (1, 3) (1 ms)
[ RUN      ] TrueReturn/IsSameTest.HandleTrueReturn/1
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(21): error:
 Value of: isSame(intIntTuple_)
  Actual: false
Expected: true
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/1, where GetParam() = (1, 4) (1 ms)
[ RUN      ] TrueReturn/IsSameTest.HandleTrueReturn/2
[       OK ] TrueReturn/IsSameTest.HandleTrueReturn/2 (0 ms)
[ RUN      ] TrueReturn/IsSameTest.HandleTrueReturn/3
d:\program files\vc2013 projects\learningtest\learningtest\gtest_testcases.cpp(21): error:
 Value of: isSame(intIntTuple_)
  Actual: false
Expected: true
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/3, where GetParam() = (3, 4) (1 ms)
[----------] 4 tests from TrueReturn/IsSameTest (10 ms total)

[----------] Global test environment tear-down
[==========] 4 tests from 1 test case ran. (13 ms total)
[  PASSED  ] 1 test.
[  FAILED  ] 3 tests, listed below:
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/0, where GetParam() = (1, 3)
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/1, where GetParam() = (1, 4)
[  FAILED  ] TrueReturn/IsSameTest.HandleTrueReturn/3, where GetParam() = (3, 4)

 3 FAILED TESTS
请按任意键继续. . .

四、参数化后的测试案例名
因为使用了参数化的方式执行案例，我非常想知道运行案例时，每个案例名称是如何命名的。我执行了上面的代码，输出如下：
从上面的框框中的案例名称大概能够看出案例的命名规则，对于需要了解每个案例的名称的我来说，这非常重要。 命名规则大概为：
prefix/test_case_name.test.name/index

五、类型参数化 
没看明白，这里不列了。

//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之五 - 死亡测试
没看

//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之六 - 运行参数
一、前言
使用gtest编写的测试案例通常本身就是一个可执行文件，因此运行起来非常方便。同时，gtest也为我们提供了一系列的运行参数（环境变量、命令行参数或代码里指定），使得我们可以对案例的执行进行一些有效的控制。
二、基本介绍
前面提到，对于运行参数，gtest提供了三种设置的途径：
1. 系统环境变量
2. 命令行参数
3. 代码中指定FLAG

因为提供了三种途径，就会有优先级的问题， 有一个原则是，最后设置的那个会生效。不过总结一下，通常情况下，比较理想的优先级为：
命令行参数 > 代码中指定FLAG > 系统环境变量

为什么我们编写的测试案例能够处理这些命令行参数呢？是因为我们在main函数中，将命令行参数交给了gtest，由gtest来搞定命令行参数的问题。
int _tmain(int argc, _TCHAR* argv[])
{
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
 
这样，我们就拥有了接收和响应gtest命令行参数的能力。如果需要在代码中指定FLAG，可以使用testing::GTEST_FLAG这个宏来设置。比如相对于命令行参数--gtest_output，可以使用testing::GTEST_FLAG(output) = "xml:";来设置。注意到了，不需要加--gtest前缀了。同时，推荐将这句放置InitGoogleTest之前，这样就可以使得对于同样的参数，命令行参数优先级高于代码中指定。
int _tmain(int argc, _TCHAR* argv[])
{
    testing::GTEST_FLAG(output) = "xml:";
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
 
最后再来说下第一种设置方式-系统环境变量。如果需要gtest的设置系统环境变量，必须注意的是：
1. 系统环境变量全大写，比如对于--gtest_output，响应的系统环境变量为：GTEST_OUTPUT
2.  有一个命令行参数例外，那就是--gtest_list_tests，它是不接受系统环境变量的。（只是用来罗列测试案例名称）

三、参数列表
了解了上面的内容，我这里就直接将所有命令行参数总结和罗列一下。如果想要获得详细的命令行说明，直接运行你的案例，输入命令行参数：/? 或 --help 或 -help
1. 测试案例集合
testing::GTEST_FLAG(list_tests) = true;//输出所有案例，但不运行
testing::GTEST_FLAG(filter) = "*.*Test*";//案例过滤，名称是大小写敏感的，支持通配符 ?单个字符；*任意字符；-排除，如，-a 表示除了a；:取或，如，a:b 表示a或b
testing::GTEST_FLAG(also_run_disabled_tests) = true;//运行所有用例，即便该用例被标识为无效的（在用例前增加 DISABLED_ 前缀）
testing::GTEST_FLAG(repeat) = 2;//运行用例次数,-1无限次运行

2. 测试案例输出
testing::GTEST_FLAG(color) = "no";//输出无颜色，yes或者是auto是有颜色的，默认是auto
testing::GTEST_FLAG(print_time) = false;//打印测试用例的执行时间，默认就是打印的
testing::GTEST_FLAG(output) = "xml:";
1.--gtest_output=xml:    不指定输出路径时，默认为案例当前路径。
2.--gtest_output=xml:d:\ 指定输出到某个目录 
3.--gtest_output=xml:d:\foo.xml 指定输出到d:\foo.xml
如果不是指定了特定的文件路径，gtest每次输出的报告不会覆盖，而会以数字后缀的方式创建。

3. 对案例的异常处理
testing::GTEST_FLAG(break_on_failure) = true;//遇到错误的用例就停了。调试模式下，当案例失败时停止，方便调试
testing::GTEST_FLAG(throw_on_failure) = true;//当案例失败时以C++异常的方式抛出，没看到效果
testing::GTEST_FLAG(catch_exceptions) = false;//是否捕捉异常（我这里测试默认是捕捉的）。gtest默认是不捕捉异常的，因此假如你的测试案例抛了一个异常，很可能会弹出一个对话框，这非常的不友好，同时也阻碍了测试案例的运行。如果想不弹这个框，可以通过设置这个参数来实现。如将--gtest_catch_exceptions设置为一个非零的数。

注意：这个参数只在Windows下有效。

四、XML报告输出格式
从报告里可以看出，我们之前在TEST等宏中定义的测试案例名称(testcase_name)在xml测试报告中其实是一个testsuite name，而宏中的测试名称(test_name)在xml测试报告中是一个testcase name，概念上似乎有点混淆，就看你怎么看吧。

当检查点通过时，不会输出任何检查点的信息。当检查点失败时，会有详细的失败信息输出来failure节点。

在我使用过程中发现一个问题，当我同时设置了--gtest_filter参数时，输出的xml报告中还是会包含所有测试案例的信息，只不过那些不被执行的测试案例的status值为“notrun”。而我之前认为的输出的xml报告应该只包含我需要运行的测试案例的信息。不知是否可提供一个只输出需要执行的测试案例的xml报告。因为当我需要在1000个案例中执行其中1个案例时，在报告中很难找到我运行的那个案例，虽然可以查找，但还是很麻烦。

五、总结
本篇主要介绍了gtest案例执行时提供的一些参数的使用方法，这些参数都非常有用。在实际编写gtest测试案例时肯定会需要用到的时候。至少我现在比较常用的就是：
1. --gtest_filter
2. --gtest_output=xml[:DIRECTORY_PATH\|:FILE_PATH]
3. --gtest_catch_exceptions

最后再总结一下我使用过程中遇到的几个问题:
1. 同时使用--gtest_filter和--gtest_output=xml:时，在xml测试报告中能否只包含过滤后的测试案例的信息。
2. 有时，我在代码中设置 testing::GTEST_FLAG(catch_exceptions) = 1和我在命令行中使用--gtest_catch_exceptions结果稍有不同，在代码中设置FLAG方式有时候捕捉不了某些异常，但是通过命令行参数的方式一般都不会有问题。这是我曾经遇到过的一个问题，最后我的处理办法是既在代码中设置FLAG，又在命令行参数中传入--gtest_catch_exceptions。不知道是gtest在catch_exceptions方面不够稳定，还是我自己测试案例的问题。


//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之七 - 深入解析gtest

四、总结
本文通过分析TEST宏和RUN_ALL_TEST宏，了解到了整个gtest运作过程，可以说整个过程简洁而优美。之前读《代码之美》，感触颇深，现在读过gtest代码，再次让我感触深刻。记得很早前，我对设计的理解是“功能越强大越好，设计越复杂越好，那样才显得牛”，渐渐得，我才发现，简单才是最好。我曾总结过自己写代码的设计原则：功能明确，设计简单。了解了gtest代码后，猛然发现gtest不就是这样吗，同时gtest也给了我很多惊喜，因此，我对gtest的评价是：功能强大，设计简单，使用方便。

总结一下gtest里的几个关键的对象：
1. UnitTest 单例，总管整个测试，包括测试环境信息，当前执行状态等等。
2. UnitTestImpl UnitTest内部具体功能的实现者。
3. Test    我们自己编写的，或通过TEST，TEST_F等宏展开后的Test对象，管理着测试案例的前后事件，具体的执行代码TestBody。
4. TestCase 测试案例对象，管理着基于TestCase的前后事件，管理内部多个TestInfo。
5. TestInfo  管理着测试案例的基本信息，包括Test对象的创建方法。 
6. TestInfoImpl TestInfo内部具体功能的实现者 。
本文还有很多gtest的细节没有分析到，比如运行参数，死亡测试，跨平台处理，断言的宏等等，希望读者自己把源码下载下来慢慢研究。如本文有错误之处，也请大家指出，谢谢！
//------------------------------------------
//玩转Google开源C++单元测试框架Google Test系列(gtest)之八 - 打造自己的单元测试框架
一、前言
上一篇我们分析了gtest的一些内部实现，总的来说整体的流程并不复杂。本篇我们就尝试编写一个精简版本的C++单元测试框架：nancytest ，通过编写这个简单的测试框架，将有助于我们理解gtest。

二、整体设计
使用最精简的设计，我们就用两个类，够简单吧：

1. TestCase类
包含单个测试案例的信息。 

2. UnitTest类

负责所有测试案例的执行，管理。

三、TestCase类
TestCase类包含一个测试案例的基本信息，包括：测试案例名称，测试案例执行结果，同时还提供了测试案例执行的方法。我们编写的测试案例都继承自TestCase类。

四、UnitTest类
我们的UnitTest类和gtest的一样，是一个单件。我们的UnitTest类的逻辑非常简单：
1. 整个进程空间保存一个UnitTest 的单例。
2. 通过RegisterTestCase()将测试案例添加到测试案例集合testcases_中。
3. 执行测试案例时，调用UnitTest::Run()，遍历测试案例集合testcases_，调用案例的Run()方法

五、NTEST宏
接下来定一个宏NTEST，方便我们写我们的测试案例的类。

六、RUN_ALL_TEST宏
然后是执行所有测试案例的一个宏：

七、断言的宏EXPECT_EQ 
这里，我只写一个简单的EXPECT_EQ ：

八、案例Demo
够简单吧，再来看看案例怎么写：

//样例代码
//ConsoleColor.h
#ifndef __CONSOLECOLOR_H__
#define __CONSOLECOLOR_H__

#include <iostream>  
#include <windows.h> 

inline std::ostream& blue(std::ostream &s)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout, FOREGROUND_BLUE
		| FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	return s;
}

inline std::ostream& red(std::ostream &s)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout,
		FOREGROUND_RED | FOREGROUND_INTENSITY);
	return s;
}

inline std::ostream& green(std::ostream &s)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout,
		FOREGROUND_GREEN | FOREGROUND_INTENSITY);
	return s;
}

inline std::ostream& yellow(std::ostream &s)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout,
		FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
	return s;
}

inline std::ostream& white(std::ostream &s)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout,
		FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
	return s;
}

struct color
{
	color(WORD attribute):m_color(attribute)
	{
	};

	WORD m_color;
};

template <class _Elem, class _Traits>
std::basic_ostream<_Elem, _Traits>& operator<<(std::basic_ostream<_Elem, _Traits>& i, const color& c)
{
	HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hStdout, c.m_color);
	return i;
}

#endif


//NancyTest.h
#ifndef __NANCYTEST_H__
#define __NANCYTEST_H__

#include <vector>
#include "ConsoleColor.h"

class TestCase
{
public:
	TestCase(const char* case_name): testcase_name(case_name)
	{
	}

	// 执行测试案例的方法
	virtual void Run() = 0;

	int nTestResult; // 测试案例的执行结果 
	const char* testcase_name; // 测试案例名称
};

class UnitTest
{
public:
	// 获取单例
	static UnitTest* GetInstance();

	// 注册测试案例
	TestCase* RegisterTestCase(TestCase* testcase);

	// 执行单元测试
	int Run();

	TestCase* CurrentTestCase; // 记录当前执行的测试案例
	int nTestResult; // 总的执行结果
	int nPassed; // 通过案例数
	int nFailed; // 失败案例数
protected:
	std::vector<TestCase*> testcases_; // 案例集合
};


#define TESTCASE_NAME(testcase_name) \
    testcase_name##_TEST


#define NANCY_TEST_(testcase_name) \
class TESTCASE_NAME(testcase_name) : public TestCase \
{ \
public: \
    TESTCASE_NAME(testcase_name)(const char* case_name) : TestCase(case_name){}; \
    virtual void Run(); \
private: \
    static TestCase* const testcase_; \
}; \
\
TestCase* const TESTCASE_NAME(testcase_name) \
    ::testcase_ = UnitTest::GetInstance()->RegisterTestCase( \
        new TESTCASE_NAME(testcase_name)(#testcase_name)); \
void TESTCASE_NAME(testcase_name)::Run()


#define NTEST(testcase_name) \
    NANCY_TEST_(testcase_name)


#define RUN_ALL_TESTS() \
    UnitTest::GetInstance()->Run();


#define EXPECT_EQ(m, n) \
    if (m != n) \
    { \
        UnitTest::GetInstance()->CurrentTestCase->nTestResult = 0; \
        std::cout << red << "Failed" << std::endl; \
        std::cout << red << "Expect:" << m << std::endl; \
        std::cout << red << "Actual:" << n << std::endl; \
    } \
	else \
	{ \
		++UnitTest::GetInstance()->CurrentTestCase->nTestResult; \
	} //原代码没有这里的else，有问题，没有记录case成功的个数

#endif


//NancyTest.cpp
#include <iostream>
#include "NancyTest.h"

UnitTest* UnitTest::GetInstance()
{
	static UnitTest instance;
	return &instance;
}

TestCase* UnitTest::RegisterTestCase(TestCase* testcase)
{
	testcases_.push_back(testcase);
	return testcase;
}

int UnitTest::Run()
{
	nTestResult = 1;
	for (std::vector<TestCase*>::iterator it = testcases_.begin();
		it != testcases_.end(); ++it)
	{
		TestCase* testcase = *it;
		CurrentTestCase = testcase;
		std::cout << green << "======================================" << std::endl;
		std::cout << green << "Run TestCase:" << testcase->testcase_name << std::endl;
		testcase->Run();
		std::cout << green << "End TestCase:" << testcase->testcase_name << std::endl;
		if (testcase->nTestResult)
		{
			nPassed++;
		}
		else
		{
			nFailed++;
			nTestResult = 0;
		}
	}

	std::cout << green << "======================================" << std::endl;
	std::cout << green << "Total TestCase : " << nPassed + nFailed << std::endl;
	std::cout << green << "Passed : " << nPassed << std::endl;
	std::cout << red << "Failed : " << nFailed << std::endl;
	return nTestResult;
}


//main.cpp
#include <iostream>
#include "NancyTest.h"

int Foo(int a, int b)
{
	return a + b;
}

NTEST(FooTest_PassDemo)//这里最终被展开为TestCase::Run()的实现体，即这行void TESTCASE_NAME(testcase_name)::Run()
{
	EXPECT_EQ(3, Foo(1, 2));
	EXPECT_EQ(2, Foo(1, 1));
}

NTEST(FooTest_FailDemo)
{
	EXPECT_EQ(4, Foo(1, 2));
	EXPECT_EQ(2, Foo(1, 2));
}


//编译时，以上内容全都被宏替换掉，并生成了每一个TestCase的注册代码，以及Run()函数体的定义代码
int main()
{
	RUN_ALL_TESTS();
	return 0;
}
输出如下：
======================================
Run TestCase:FooTest_PassDemo
End TestCase:FooTest_PassDemo
======================================
Run TestCase:FooTest_FailDemo
Failed
Expect:4
Actual:3
Failed
Expect:2
Actual:3
End TestCase:FooTest_FailDemo
======================================
Total TestCase : 2
Passed : 1
Failed : 1
请按任意键继续. . .


//对main.cpp预编译查看代码如下：
#line 84 "d:\\program files\\vc2013 projects\\testcaseproject\\testcaseproject\\nancytest.h"
#line 3 "d:\\program files\\vc2013 projects\\testcaseproject\\testcaseproject\\main.cpp"

int Foo(int a, int b)
{
	return a + b;
}

class FooTest_PassDemo_TEST : public TestCase 
{ 
public: 
	FooTest_PassDemo_TEST(const char* case_name) : TestCase(case_name){}; 
	virtual void Run(); 
private: 
	static TestCase* const testcase_; 
}; 

TestCase* const FooTest_PassDemo_TEST ::testcase_ = UnitTest::GetInstance()->RegisterTestCase( new FooTest_PassDemo_TEST("FooTest_PassDemo")); 

void FooTest_PassDemo_TEST::Run()
{
	if (3 != Foo(1, 2)) 
	{ 
		UnitTest::GetInstance()->CurrentTestCase->nTestResult = 0; 
		std::cout << red << "Failed" << std::endl; 
		std::cout << red << "Expect:" << 3 << std::endl; 
		std::cout << red << "Actual:" << Foo(1, 2) << std::endl; 
	} 
	else 
	{ 
		++UnitTest::GetInstance()->CurrentTestCase->nTestResult; 
	};
	if (2 != Foo(1, 1)) 
	{ 
		UnitTest::GetInstance()->CurrentTestCase->nTestResult = 0; 
		std::cout << red << "Failed" << std::endl; 
		std::cout << red << "Expect:" << 2 << std::endl; 
		std::cout << red << "Actual:" << Foo(1, 1) << std::endl; 
	} 
	else 
	{ 
		++UnitTest::GetInstance()->CurrentTestCase->nTestResult; 
	};
}

class FooTest_FailDemo_TEST : public TestCase { public: FooTest_FailDemo_TEST(const char* case_name) : TestCase(case_name){}; virtual void Run(); private: static TestCase* const testcase_; }; TestCase* const FooTest_FailDemo_TEST ::testcase_ = UnitTest::GetInstance()->RegisterTestCase( new FooTest_FailDemo_TEST("FooTest_FailDemo")); void FooTest_FailDemo_TEST::Run()
{
	if (3 != Foo(1, 2)) { UnitTest::GetInstance()->CurrentTestCase->nTestResult = 0; std::cout << red << "Failed" << std::endl; std::cout << red << "Expect:" << 3 << std::endl; std::cout << red << "Actual:" << Foo(1, 2) << std::endl; } else { ++UnitTest::GetInstance()->CurrentTestCase->nTestResult; };
	if (2 != Foo(1, 2)) { UnitTest::GetInstance()->CurrentTestCase->nTestResult = 0; std::cout << red << "Failed" << std::endl; std::cout << red << "Expect:" << 2 << std::endl; std::cout << red << "Actual:" << Foo(1, 2) << std::endl; } else { ++UnitTest::GetInstance()->CurrentTestCase->nTestResult; };
}


int main()
{
	UnitTest::GetInstance()->Run();;
	return 0;
}

九、总结 
本篇介绍性的文字比较少，主要是我们在上一篇深入解析gtest时已经将整个流程弄清楚了，而现在编写的nancytest又是其非常的精简版本，所有直接看代码就可以完全理解。希望通过这个Demo，能够让大家对gtest有更加直观的了解。回到开篇时所说的，我们没有必要每个人都造一个轮子，因为gtest已经非常出色的为我们做好了这一切。如果我们每个人都写一个自己的框架的话，一方面我们要付出大量的维护成本，一方面，这个框架也许只能对你有用，无法让大家从中受益。
gtest正是这么一个优秀C++单元测试框架，它完全开源，允许我们一起为其贡献力量，并能让更多人从中受益。如果你在使用gtest过程中发现gtest不能满足你的需求时（或发现BUG），gtest的开发人员非常急切的想知道他们哪来没做好，或者是gtest其实有这个功能，但是很多用户都不知道。所以你可以直接联系gtest的开发人员，或者你直接在这里回帖，我会将您的意见转告给gtest的主要开发人员。
如果你是gtest的超级粉丝，原意为gtest贡献代码的话，加入他们吧。　　　

本Demo代码下载：/Files/coderzh/Code/nancytest.rar 
本篇是该系列最后一篇，其实gtest还有更多东西值得我们去探索，本系列也不可能将gtest介绍完全，还是那句话，想了解更多gtest相关的内容的话：
访问官方主页：http://code.google.com/p/googletest/
下载gtest源码： http://code.google.com/p/googletest/downloads/list
//------------------------------------------------------------------------------------------------
//gmock学习
http://blog.chinaunix.net/uid-25711527-id-3225605.html

Google Mock 入门概述什么是Mock?
Mock，更确切地说应该是Mock Object。它究竟是什么？它有什么作用？在这里，我也只能先说说我的理解。 比如当我们在单元测试、模块的接口测试时，当这个模块需要依赖另外一个/几个类，而这时这些个类还没有开发好（那名开发同学比较懒，呵呵），这时我们就可以定义了Mock对象来模拟那些类的行为。

说得更直白一些，就是自己实现一个假的依赖类，对这个类的方法你想要什么行为就可以有什么行为，你想让这个方法返回什么结果就可以返回怎么样的结果。
但这时很多同学往往会提出一个问题："那既然是我自己实现一个假的依赖类"，那和那些市面上的Mock框架有什么关系啊？
这个其实是这样的，这些个Mock框架可以帮助你比较方便、比较轻松地实现这些个假的依赖类。毕竟，如果你实现这么一个假的依赖类的时间花费过场的话，那我还不如等待那位懒惰的同学吧。

Google Mock概述
Google Mock（简称gmock）是Google在2008年推出的一套针对C++的Mock框架，它灵感取自于jMock、EasyMock、harcreat。它提供了以下这些特性：
--轻松地创建mock类
--支持丰富的匹配器（Matcher）和行为（Action）
--支持有序、无序、部分有序的期望行为的定义
--多平台的支持


//FooInterface.h
#ifndef __FOOINTERFACE_H__
#define __FOOINTERFACE_H__

#include <string>

namespace seamless {
	class FooInterface
	{
	public:
		virtual ~FooInterface()
		{
		}

		virtual std::string getArbitraryString() = 0;
		virtual void setValue(std::string value) = 0;

		static std::string create()
		{
			return "";
		};
	};
}  // namespace seamless

#endif


//MockFoo.h
#ifndef __MOCKFOO_H__
#define __MOCKFOO_H__

#include "gmock/gmock.h"
#include "FooInterface.h"

namespace seamless {
	class MockFoo: public FooInterface
	{
	public:
		MOCK_METHOD0(getArbitraryString, std::string());
		MOCK_METHOD1(setValue, void(std::string));//必须MOCK所有虚函数，否则无法实例化该对象，但是可以不调用
	};
}

#endif


//gtest_TestCases.cpp
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include "MockFoo.h"

using namespace seamless;
using testing::Return;

TEST(MockTest, Test1)
{
	std::string value = "Hello, world!";
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, getArbitraryString()).Times(1).WillOnce(Return(value));
	std::string returnValue = mockFoo.getArbitraryString();
	EXPECT_EQ(value, returnValue);

	//std::string returnValue2 = mockFoo.getArbitraryString();//前面定义了times(1)，所以只能调用一次
	
	//至少要调用5次，调用次数不到将测试失败。第1次value，第2次abc，后面全都是def
	//EXPECT_CALL(mockFoo, getArbitraryString()).Times(testing::AtLeast(5)).WillOnce(Return(value)).WillOnce(Return("abc")).WillRepeatedly(Return("def"));
}

//gtest_main.cpp
#include "gtest/gtest.h"
#include "gmock/gmock.h"

int main(int argc, char* argv[])
{
	testing::InitGoogleTest(&argc, argv);
	testing::InitGoogleMock(&argc, argv);
	return RUN_ALL_TESTS();
}

典型的流程
通过上述的例子，已经可以看出使用Mock类的一般流程如下：
--引入你要用到的Google Mock名称. 除宏或其它特别提到的之外所有Google Mock名称都位于*testing*命名空间之下.
--建立模拟对象(Mock Objects).
--可选的,设置模拟对象的默认动作.
--在模拟对象上设置你的预期(它们怎样被调用,应该怎样回应?).

自定义方法/成员函数的期望行为
从上述的例子中可以看出，当我们针对懒同学的接口定义好了Mock类后，在单元测试/主程序中使用这个Mock类中的方法时最关键的就是对期望行为的定义。
对方法期望行为的定义的语法格式如下：

EXPECT_CALL(mock_object, method(matcher1, matcher2, ...))
.With(multi_argument_matcher)
.Times(cardinality)
.InSequence(sequences)
.After(expectations)
.WillOnce(action)
.WillRepeatedly(action)
.RetiresOnSaturation();

解释一下这些参数（虽然很多我也没弄明白）：
--第1行的mock_object就是你的Mock类的对象
--第1行的method(matcher1, matcher2, …)中的method就是你Mock类中的某个方法名，比如上述的getArbitraryString;而matcher（匹配器）的意思是定义方法参数的类型，我们待会详细介绍。
--第3行的Times(cardinality)的意思是之前定义的method运行几次。至于cardinality的定义，我也会在后面详细介绍。
--第4行的InSequence(sequences)的意思是定义这个方法被执行顺序（优先级），我会再后面举例说明。
--第6行WillOnce(action)是定义一次调用时所产生的行为，比如定义该方法返回怎么样的值等等。
--第7行WillRepeatedly(action)的意思是缺省/重复行为。

我稍微先举个例子来说明一下，后面有针对更为详细的说明：
EXPECT_CALL(mockTurtle, getX()).Times(testing::AtLeast(5)).
	WillOnce(testing::Return(100)).WillOnce(testing::Return(150)).
	WillRepeatedly(testing::Return(200))

这个期望行为的定义的意思是：
--调用mockTurtle的getX()方法
--这个方法会至少调用5次
--第一次被调用时返回100
--第2次被调用时返回150
--从第3次被调用开始每次都返回200


Matcher（匹配器）
Matcher用于定义Mock类中的方法的形参的值（当然，如果你的方法不需要形参时，可以保持match为空。），它有以下几种类型：（更详细的介绍可以参见Google Mock Wiki上的Matcher介绍）
通配符
_	可以代表任意类型
A() or An()	可以是type类型的任意值
这里的_和*A*包括下面的那个匹配符都在Google Mock的*::testing*这个命名空间下，大家要用时需要先引入那个命名空间

一般比较
Eq(value) 或者 value	argument == value，method中的形参必须是value
Ge(value)	argument >= value，method中的形参必须大于等于value
Gt(value)	argument > value
Le(value)	argument <= value
Lt(value)	argument < value
Ne(value)	argument != value
IsNull()	method的形参必须是NULL指针
NotNull()	argument is a non-null pointer
Ref(variable)	形参是variable的引用
TypedEq(value)	形参的类型必须是type类型，而且值必须是value

浮点数的比较
DoubleEq(a_double)	形参是一个double类型，比如值近似于a_double，两个NaN是不相等的
FloatEq(a_float)	同上，只不过类型是float
NanSensitiveDoubleEq(a_double)	形参是一个double类型，比如值近似于a_double，两个NaN是相等的，这个是用户所希望的方式
NanSensitiveFloatEq(a_float)	同上，只不过形参是float

字符串匹配
这里的字符串即可以是C风格的字符串，也可以是C++风格的。
ContainsRegex(string)	形参匹配给定的正则表达式
EndsWith(suffix)	形参以suffix截尾
HasSubstr(string)	形参有string这个子串
MatchesRegex(string)	从第一个字符到最后一个字符都完全匹配给定的正则表达式.
StartsWith(prefix)	形参以prefix开始
StrCaseEq(string)	参数等于string，并且忽略大小写
StrCaseNe(string)	参数不是string，并且忽略大小写
StrEq(string)	参数等于string
StrNe(string)	参数不等于string

容器的匹配
很多STL的容器的比较都支持==这样的操作，对于这样的容器可以使用上述的Eq(container)来比较。但如果你想写得更为灵活，可以使用下面的这些容器匹配方法：
Contains(e)	在method的形参中，只要有其中一个元素等于e
Each(e)	参数各个元素都等于e
ElementsAre(e0, e1, …, en)	形参有n+1的元素，并且挨个匹配
ElementsAreArray(array) 或者ElementsAreArray(array, count)	和ElementsAre()类似，除了预期值/匹配器来源于一个C风格数组
ContainerEq(container)	类型Eq(container)，就是输出结果有点不一样，这里输出结果会带上哪些个元素不被包含在另一个容器中
Pointwise(m, container)	 

//例
//FooInterface.h
#ifndef __FOOINTERFACE_H__
#define __FOOINTERFACE_H__

#include <string>

namespace seamless{
	class FooInterface
	{
	public:
		virtual ~FooInterface()
		{
		}

		virtual std::string getArbitraryString() = 0;
		virtual void setValue(std::string& value) = 0;
		virtual void setDoubleValue(int x, int y) = 0;

		static std::string create()
		{
			return "";
		};
	};
}  // namespace seamless

#endif

//MockFoo.h
#ifndef __MOCKFOO_H__
#define __MOCKFOO_H__

#include "gmock/gmock.h"
#include "FooInterface.h"

namespace seamless {
	class MockFoo: public FooInterface
	{
	public:
		MOCK_METHOD0(getArbitraryString, std::string());
		MOCK_METHOD1(setValue, void(std::string& value));
		MOCK_METHOD2(setDoubleValue, void(int x, int y));
	};
}

#endif

//gtest_TestCases.cpp
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include "MockFoo.h"

using namespace seamless;
using testing::Return;
//using testing::Assign;
using testing::Eq;
using testing::Ge;


TEST(MockTest, Test1)
{
	std::string value = "Hello, world!";
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, setValue(testing::_));//_任意值
	mockFoo.setValue(value);

	EXPECT_CALL(mockFoo, setDoubleValue(Eq(1), Ge(1)));//出错，第二个参数期望>=1，结果输入的是0
	mockFoo.setDoubleValue(1, 0);
}


上述的那些匹配器都比较简单，下面我们来看看那些比较复杂的匹配吧。
成员匹配器
Field(&class::field, m)	argument.field (或 argument->field, 当argument是一个指针时)与匹配器m匹配, 这里的argument是一个class类的实例.
Key(e)	形参（argument）比较是一个类似map这样的容器，然后argument.first的值等于e
Pair(m1, m2)	形参（argument）必须是一个pair，并且argument.first等于m1，argument.second等于m2.
Property(&class::property, m)	argument.property()(或argument->property(),当argument是一个指针时)与匹配器m匹配, 这里的argument是一个class类的实例.

还是举例说明一下：
//FooInterface.h
#ifndef __FOOINTERFACE_H__
#define __FOOINTERFACE_H__

#include <string>

namespace seamless{
	class Bar
	{
	public:
		Bar(): num_(1) {}
	
	public:
		int num_;
	};

	class FooInterface
	{
	public:
		virtual ~FooInterface()
		{
		}

		virtual std::string getArbitraryString() const = 0;
		virtual void setValue(const std::string& value) = 0;
		virtual void setDoubleValue(int x, int y) = 0;

		//virtual int get(const Bar& bar) = 0;
		virtual int get(Bar* pBar) = 0;

		virtual int getParameter(std::string* name, std::string* value) = 0;

		static std::string create()
		{
			return "";
		};
	};
}  // namespace seamless

#endif


//MockFoo.h
#ifndef __MOCKFOO_H__
#define __MOCKFOO_H__

#include "gmock/gmock.h"
#include "FooInterface.h"

namespace seamless {
	class MockFoo: public FooInterface
	{
	public:
		MOCK_CONST_METHOD0(getArbitraryString, std::string());
		MOCK_METHOD1(setValue, void(const std::string& value));
		MOCK_METHOD2(setDoubleValue, void(int x, int y));
		//MOCK_METHOD1(get, int(const Bar& bar));
		MOCK_METHOD1(get, int(Bar* bar));

		MOCK_METHOD2(getParameter, int(std::string*, std::string*));
	};
}

#endif


//gtest_TestCases.cpp
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include "MockFoo.h"

using namespace seamless;
using testing::Return;
using testing::Field;
using testing::Eq;
using testing::Ge;
using testing::AllOf;
using testing::Le;


TEST(MockTest, Test1)
{
	MockFoo mockFoo;
	//这里有个问题，如果get有两个重载函数，如上所示，一个为Bar&，一个为Bar*，则如下Field函数不知道访问哪个函数，编译出错。但是&Bar::num_这个写法却是对Bar&和Bar*的入参都是通用的
	EXPECT_CALL(mockFoo, get(Field(&Bar::num_, Ge(0))));//这里要求成员变量num_必须是public，否则访问不到

	Bar bar;
	bar.num_ = -1;
	mockFoo.get(&bar);//测试出错
	
	EXPECT_CALL(mockFoo, setDoubleValue(AllOf(Ge(5), Le(10)), AllOf(Ge(1), Le(4))));//两个参数的范围
	mockFoo.setDoubleValue(1, 2);
}

//后改成如下
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include "MockFoo.h"

using namespace seamless;
using namespace testing;

class GMockLearningTest: public testing::Test
{
protected:
	virtual void SetUp()
	{}

	virtual void TearDown()
	{}

	MockFoo mockFoo_;
};

TEST_F(GMockLearningTest, Test1)
{
	//这里有个问题，如果get有两个重载函数，如上所示，一个为Bar&，一个为Bar*，则如下Field函数不知道访问哪个函数，编译出错。但是&Bar::num_这个写法却是对Bar&和Bar*的入参都是通用的
	EXPECT_CALL(mockFoo_, get(Field(&Bar::num_, Ge(0))));//这里要求成员变量num_必须是public，否则访问不到
	Bar bar;
	bar.num_ = 31;
	mockFoo_.get(&bar);//测试出错
}

TEST_F(GMockLearningTest, Test2)
{
	EXPECT_CALL(mockFoo_, setDoubleValue(AllOf(Ge(5), Le(10)), AllOf(Ge(1), Le(4))));//两个参数的范围
	mockFoo_.setDoubleValue(6, 3);

	EXPECT_CALL(mockFoo_, setValue(Not(HasSubstr("abc"))));
	mockFoo_.setValue("abdef");
}

TEST_F(GMockLearningTest, Test3)
{
	std::string helloStr("hello");
	std::string worldStr("world");

	std::string* a = &helloStr;
	std::string* b = &worldStr;

	EXPECT_CALL(mockFoo_, getParameter(_, _)).Times(1).WillOnce(DoAll(Assign(&a, b), Return(1)));//DoAll做所有动作

	EXPECT_NE(*a, *b);
	EXPECT_NE(a, b);
	
	EXPECT_EQ(1, mockFoo_.getParameter(&helloStr, &worldStr));
	
	EXPECT_EQ(*a, *b);
	EXPECT_EQ(a, b);
}

TEST_F(GMockLearningTest, TestInSequence)
{
	EXPECT_CALL(mockFoo_, getArbitraryString()).WillOnce(Return("hello"));
	EXPECT_CALL(mockFoo_, setValue("world"));
	mockFoo_.setValue("world");
	mockFoo_.getArbitraryString();
	
	Sequence s1, s2;
	EXPECT_CALL(mockFoo_, getArbitraryString()).InSequence(s1, s2).WillOnce(Return("hello"));
	EXPECT_CALL(mockFoo_, setValue("world")).InSequence(s1);
	mockFoo_.getArbitraryString();//先调用.setValue()将报错
	mockFoo_.setValue("world");
}

TEST_F(GMockLearningTest, TestInSequence2)
{
	InSequence dummy;//必须按照定义的顺序来调用
	EXPECT_CALL(mockFoo_, getArbitraryString()).WillOnce(Return("hello"));
	EXPECT_CALL(mockFoo_, setValue("world"));
	mockFoo_.getArbitraryString();
	mockFoo_.setValue("world");
}


匹配函数或函数对象的返回值
ResultOf(f, m)	f(argument) 与匹配器m匹配, 这里的f是一个函数或函数对象.

指针匹配器
Pointee(m)	argument (不论是智能指针还是原始指针) 指向的值与匹配器m匹配.

复合匹配器
AllOf(m1, m2, …, mn)	argument 匹配所有的匹配器m1到mn
AnyOf(m1, m2, …, mn)	argument 至少匹配m1到mn中的一个
Not(m)	argument 不与匹配器m匹配


基数（Cardinalities）
基数用于Times()中来指定模拟函数将被调用多少次。或者：
AnyNumber()	函数可以被调用任意次.
AtLeast(n)	预计至少调用n次.
AtMost(n)	预计至多调用n次.
Between(m, n)	预计调用次数在m和n(包括n)之间.
Exactly(n) 或 n	预计精确调用n次. 特别是, 当n为0时,函数应该永远不被调用.


行为（Actions）
Actions（行为）用于指定Mock类的方法所期望模拟的行为：比如返回什么样的值、对引用、指针赋上怎么样个值，等等。 值的返回
Return()	让Mock方法返回一个void结果
Return(value)	返回值value
ReturnNull()	返回一个NULL指针
ReturnRef(variable)	返回variable的引用.
ReturnPointee(ptr)	返回一个指向ptr的指针


另一面的作用（Side Effects）
Assign(&variable, value)	将value分配给variable


使用函数或者函数对象（Functor）作为行为
Invoke(f)	使用模拟函数的参数调用f, 这里的f可以是全局/静态函数或函数对象.
Invoke(object_pointer, &class::method)	使用模拟函数的参数调用object_pointer对象的method方法.


复合动作
DoAll(a1, a2, …, an)	每次发动时执行a1到an的所有动作.
IgnoreResult(a)	执行动作a并忽略它的返回值. a不能返回void.
这里我举个例子来解释一下DoAll()的作用，我个人认为这个DoAll()还是挺实用的。例如有一个Mock方法：
virtual int getParamter(std::string* name,  std::string* value) = 0
对于这个方法，我这回需要操作的结果是将name指向value的地址，并且得到方法的返回值。
类似这样的需求，我们就可以这样定义期望过程：
TEST(SimpleTest, F1) {
    std::string* a = new std::string("yes");
    std::string* b = new std::string("hello");
    MockIParameter mockIParameter;
    EXPECT_CALL(mockIParameter, getParamter(testing::_, testing::_)).Times(1).\
        WillOnce(testing::DoAll(testing::Assign(&a, b), testing::Return(1)));
    mockIParameter.getParamter(a, b);
}
这时就用上了我们的DoAll()了，它将Assign()和Return()结合起来了。
//参考上例

序列（Sequences）
默认时，对于定义要的期望行为是无序（Unordered）的，即当我定义好了如下的期望行为：
MockFoo mockFoo;
EXPECT_CALL(mockFoo, getSize()).WillOnce(Return(1));
EXPECT_CALL(mockFoo, getValue()).WillOnce(Return(string("Hello World")));
对于这样的期望行为的定义，我何时调用mockFoo.getValue()或者何时mockFoo.getSize()都可以的。
但有时候我们需要定义有序的（Ordered）的调用方式，即序列 (Sequences) 指定预期的顺序. 在同一序列里的所有预期调用必须按它们指定的顺序发生; 反之则可以是任意顺序.

using ::testing::Return;
using ::testing::Sequence;

int main(int argc, char **argv) {
	::testing::InitGoogleMock(&argc, argv);

	Sequence s1, s2;
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, getSize()).InSequence(s1, s2).WillOnce(Return(1));
	EXPECT_CALL(mockFoo, getValue()).InSequence(s1).WillOnce(Return(
			string("Hello World!")));
	cout << "First:\t" << mockFoo.getSize() << endl;
	cout << "Second:\t" << mockFoo.getValue() << endl;

	return EXIT_SUCCESS;
}
首先在第8行建立两个序列：s1、s2。
然后在第11行中，EXPECT_CALL(mockFoo, getSize()).InSequence(s1, s2)说明getSize()的行为优先于s1、s2.
而第12行时，EXPECT_CALL(mockFoo, getValue()).InSequence(s1)说明getValue()的行为在序列s1中。


另外，我们还有一个偷懒的方法，就是不要这么傻乎乎地定义这些个Sequence s1, s2的序列，而根据我定义期望行为（EXPECT_CALL）的顺序而自动地识别调用顺序，这种方式可能更为地通用。
using ::testing::InSequence;
using ::testing::Return;

int main(int argc, char **argv) {
	::testing::InitGoogleMock(&argc, argv);

	InSequence dummy;
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, getSize()).WillOnce(Return(1));
	EXPECT_CALL(mockFoo, getValue()).WillOnce(Return(string("Hello World")));

	cout << "First:\t" << mockFoo.getSize() << endl;
	cout << "Second:\t" << mockFoo.getValue() << endl;

	return EXIT_SUCCESS;
}


Mock实践
下面我从我在工作中参与的项目中选取了一个实际的例子来实践Mock。
这个例子的背景是用于搜索引擎的：
引擎接收一个查询的Query，比如http://127.0.0.1/search?q=mp3&retailwholesale=0&isuse_alipay=1
引擎接收到这个Query后，将解析这个Query，将Query的Segment（如q=mp3、retail_wholesale=0放到一个数据结构中）
引擎会调用另外内部模块具体根据这些Segment来处理相应的业务逻辑。
由于Google Mock不能Mock模版方法，因此我稍微更改了一下原本的接口，以便演示：
我们先来看看引擎定义好的接口们：

//VariantField.h 一个联合体，用于保存Query中的Segment的值
#ifndef __VARIANTFIELD_H__
#define __VARIANTFIELD_H__

#include <cstdint>

namespace seamless {
	union VariantField
	{
		const char* strVal;
		int32_t intVal;
	};
}

#endif

//IParameterInterface.h 提供一个接口，用于得到Query中的各个Segment的值
#ifndef __IPARAMETERINTERFACE_H__
#define __IPARAMETERINTERFACE_H__

#include "VariantField.h"

namespace seamless {
	class IParameterInterface
	{
	public:
		virtual ~IParameterInterface() {};
	
	public:
		virtual int32_t getParameter(const char* name, VariantField*& value) = 0;
	};
}

#endif

//IAPIProviderInterface.h 一个统一的外部接口
#ifndef __IAPIPROVIDERINTERFACE_H__
#define __IAPIPROVIDERINTERFACE_H__

#include <cstdint>
#include "IParameterInterface.h"
#include "VariantField.h"

namespace seamless {
	class IAPIProviderInterface
	{
	public:
		IAPIProviderInterface() {}
		virtual ~IAPIProviderInterface() {}

	public:
		virtual IParameterInterface* getParameterInterface() = 0;
	};
}

#endif

//引擎定义好的接口就以上三个，下面是引擎中的一个模块用于根据Query中的Segment接合业务处理的。
//Rank.h 头文件
#ifndef _RANK_H__
#define _RANK_H__

#include "IAPIProviderInterface.h"

namespace seamless {
	class Rank
	{
	public:
		virtual ~Rank() {};

	public:
		void processQuery(IAPIProviderInterface* iAPIProvider);
	};
}

#endif

//Rank.cpp 实现
#include <iostream>

#include "Rank.h"
#include "IAPIProviderInterface.h"
#include "IParameterInterface.h"
#include "VariantField.h"

using namespace seamless;
using namespace std;

namespace seamless {

	void Rank::processQuery(IAPIProviderInterface* iAPIProvider)
    {
		IParameterInterface* iParameter = iAPIProvider->getParameterInterface();
		if (!iParameter)
		{
			cerr << "iParameter is NULL" << endl;
		}

		int32_t isRetailWholesale = 0;
		int32_t isUseAlipay = 0;

		VariantField* value = new VariantField;
		iParameter->getParameter("retail_wholesale", value);
		isRetailWholesale = (strcmp(value->strVal, "0")) ? 1 : 0;

		iParameter->getParameter("is_use_alipay", value);
		isUseAlipay = (strcmp(value->strVal, "0")) ? 1 : 0;

		cout << "isRetailWholesale:\t" << isRetailWholesale << endl;
		cout << "isUseAlipay:\t" << isUseAlipay << endl;

		delete value;//这里也不应该操作原始指针
		delete iParameter;//这个设计不好，不应该让new出来的对象在函数外delete掉
	}
}
//从上面的例子中可以看出，引擎会传入一个IAPIProviderInterface对象，这个对象调用getParameterInterface()方法来得到Query中的Segment。
//因此，我们需要Mock的对象也比较清楚了，就是要模拟引擎将Query的Segment传给这个模块。其实就是让=模拟iParameter->getParameter方法：我想让它返回什么样的值就返回什么样的值.

//下面我们开始Mock了：
//MockIParameterInterface.h 模拟模拟IParameterInterface类
#ifndef __MOCKIPARAMETERINTERFACE_H__
#define __MOCKIPARAMETERINTERFACE_H__

#include <cstdint>
#include "IParameterInterface.h"
#include "VariantField.h"

namespace seamless {
	class MockIParameterInterface: public IParameterInterface
	{
	public:
		MOCK_METHOD2(getParameter, int32_t(const char* name, VariantField*& value));
	};
}

#endif


//MockIAPIProviderInterface.h 模拟IAPIProviderInterface类
#ifndef __MOCKIAPIPROVIDER_H__
#define __MOCKIAPIPROVIDER_H__

#include "IAPIProviderInterface.h"
#include "IParameterInterface.h"

namespace seamless {
	class MockIAPIParameterInterface: public IAPIProviderInterface
	{
	public:
		MOCK_METHOD0(getParameterInterface, IParameterInterface*());
	};
}

#endif

//gtest_main.cpp
#include "gtest/gtest.h"
#include "gmock/gmock.h"

int main(int argc, char* argv[])
{
	testing::InitGoogleTest(&argc, argv);
	testing::InitGoogleMock(&argc, argv);
	return RUN_ALL_TESTS();
}

//gtest_TestCases.cpp 一个测试程序，试试我们的Mock成果
#include <memory>

#include "gtest/gtest.h"
#include "gmock/gmock.h"

#include "MockIAPIProviderInterface.h"
#include "MockIParameterInterface.h"
#include "Rank.h"

using namespace std;
using namespace seamless;
using namespace testing;

TEST(TestInterface, Test1)
{
	MockIAPIParameterInterface* iAPIProvider = new MockIAPIParameterInterface;
	MockIParameterInterface* iParameter = new MockIParameterInterface;

	EXPECT_CALL(*iAPIProvider, getParameterInterface()).Times(AtLeast(1)).
		WillRepeatedly(Return(iParameter));
	
	shared_ptr<VariantField> retailWholesaleValue(new VariantField);
	retailWholesaleValue->strVal = "0";

	shared_ptr<VariantField> defaultValue(new VariantField);
	defaultValue->strVal = "9";//这里改为0，则最终输出两个0

	EXPECT_CALL(*iParameter, getParameter(_, _)).Times(AtLeast(1)).
		WillOnce(DoAll(SetArgumentPointee<1>(*retailWholesaleValue), Return(1))).//这里将形参value指向了retailWholesaleValue，不会出现内存泄露吗？？？
		WillRepeatedly(DoAll(SetArgumentPointee<1>(*defaultValue), Return(1)));//SetArgumentPointee版本不赞同使用，建议使用SetArgPointee

	Rank rank;
	rank.processQuery(iAPIProvider);

	delete iAPIProvider;
	//delete iParameter;这里如果加了这句话，则测试体抛异常，因为此对象已经在processQuery中删除掉了，这种实现有些奇怪
}

第26行，定义一个执行顺序，因此在之前的Rank.cc中，是先调用iAPIProvider>getParameterInterface，然后再调用iParameter>getParameter，因此我们在下面会先定义MockIAPIProviderInterface.getParameterInterface的期望行为，然后再是其他的。
第27~28 行，定义MockIAPIProviderInterface.getParameterInterface的的行为：程序至少被调用一次（Times(AtLeast(1))），每次调用都返回一个iParameter（即MockIParameterInterface*的对象）。
第30~34 行，我自己假设了一些Query的Segment的值。即我想达到的效果是Query类似http://127.0.0.1/search?retailwholesale=0&isuse_alipay=9。
第36~38 行，我们定义MockIParameterInterface.getParameter的期望行为：这个方法至少被调用一次;第一次被调用时返回1并将第一个形参指向retailWholesaleValue;后续几次被调用时返回1，并指向defaultValue。
第51行，运行Rank类下的processQuery方法。


Mock protected、private方法
Google Mock也可以模拟protected和private方法，比较神奇啊（其实从这点上也可以看出，Mock类不是简单地继承原本的接口，然后自己把它提供的方法实现;Mock类其实就等于原本的接口）。
对protected和private方法的Mock和public基本类似，只不过在Mock类中需要将这些方法设置成public。
//例如下例：
class Foo
{
private:
	virtual void setValue(int value)
	{
	}

public:
	int value;
};

class MockFoo: public Foo
{
public:
	MOCK_METHOD1(setValue, void(int value));//MOCK保护或私有函数时需要将方法设置为public
};

TEST(PrivateToPublicTest, Test1)
{
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, setValue(10)).Times(1).WillOnce(Assign(&mockFoo.value, 10));

	mockFoo.setValue(10);
	EXPECT_EQ(10, mockFoo.value);
}

Mock 模版类（Template Class）
Google Mock可以Mock模版类，只要在宏MOCK*的后面加上T。
//参考下例：
template<typename T>
class Foo
{
private:
	virtual void setValue(T value)
	{
	}

public:
	T value;
};

template<typename T>
class MockFoo: public Foo<T>
{
public:
	MOCK_METHOD1_T(setValue, void(T value));//这里Mock函数后加T
};

TEST(PrivateToPublicTest, Test1)
{
	MockFoo<int> mockFoo;
	EXPECT_CALL(mockFoo, setValue(10)).Times(1).WillOnce(Assign(&mockFoo.value, 10));

	mockFoo.setValue(10);
	EXPECT_EQ(10, mockFoo.value);
}

Nice Mocks 和 Strict Mocks
当在调用Mock类的方法时，如果之前没有使用EXPECT_CALL来定义该方法的期望行为时，Google Mock在运行时会给你一些警告信息：

GMOCK WARNING:
Uninteresting mock function call C returning default value.
Function call: setValue(1)
Returns: 0
Stack trace
对于这种情况，可以使用NiceMock来避免，即可以使用默认值来进行调用和比较:
//仍是上例：
TEST(PrivateToPublicTest, Test1)
{
	NiceMock<MockFoo<int> > mockFoo;//将原来的MockFoo<int> mockFoo;改为前面代码
	//EXPECT_CALL(mockFoo, setValue(10)).Times(1).WillOnce(Assign(&mockFoo.value, 10));

	mockFoo.setValue(10);
	EXPECT_EQ(10, mockFoo.value);
}

当然，另外还有一种办法，就是使用StrictMock来将这些调用都标为失败：

StrictMock<MockFoo> mockFoo;
这时得到的结果：

unknown file: Failure
Uninteresting mock function call C returning default value.
Function call: setValue(1)
Returns: 0
//如下例：
TEST(PrivateToPublicTest, Test1)
{
	StrictMock<MockFoo<int> > mockFoo;//没有声明EXPECT_CALL的MOCK函数调用都标为失败
	//EXPECT_CALL(mockFoo, setValue(10)).Times(1).WillOnce(Assign(&mockFoo.value, 10));

	mockFoo.setValue(10);
	EXPECT_EQ(0, mockFoo.value);
}

//--------------------
http://blog.csdn.net/guang11cheng/article/details/7169957
示例5：设置参数（引用、指针类型的出参，数组类型的出参），指的是出参，相当于返回值的角色
设置引用类型的参数是通过SetArgReferee<N>(value)实现的，N是参数的索引，从0开始。这个东西称为Action，类似的Action还有SetArgPointee<N>(value)，设置指针参数, SetArrayArgument<N>(first, last)，设置数组参数，数组范围[first,last)，前闭后开。
有时候，可能需要设置参数和返回值，也就是同时设置多个行为，那么可以使用DoAll函数帮我们实现，DoAll相当于一个action的集合，使用示例如下：
EXPECT_CALL(oMock,  QueryXXX(_, _)).WillOnce(DoAll(SetArgReferee<1>(oRsp), Return(someObj))));

// SetArrayArgument<N>(first, last)示例：
SetArrayArgument<N>(first, last)    
 Copies the elements in source range [first, last) to the array pointed to by the N-th (0-based) argument, which can be either a pointer or an iterator. The action does not take ownership of the elements in the source range.

示例：
using ::testing::NotNull;
using ::testing::SetArrayArgument;

 class MockArrayMutator : public ArrayMutator {
  public:
   MOCK_METHOD2(Mutate, void(int* values, int num_values));
   ...
 };
 ...

MockArrayMutator mutator;
int values[5] = { 1, 2, 3, 4, 5 };
EXPECT_CALL(mutator, Mutate(NotNull(), 5))
   .WillOnce(SetArrayArgument<0>(values, values + 5)); // 将数组元素[values[0], values[5])拷贝到函数Mutate的第0个参数中，作为出参。
注意：
1， mock函数必须为虚函数，因为要被mock对象重载。（不一定非要是纯虚函数）
2， 可以只mock感兴趣的接口，不感兴趣的会继承父类中的实现

//SetArgReferee，SetArgPointee，SetArrayArgument使用样例
#include <iostream>
#include "gtest/gtest.h"
#include "gmock/gmock.h"
using namespace std;
using namespace testing;

class ActionLearning
{
public:
	virtual ~ActionLearning() {}
	virtual void getIntRef(int& i) = 0;
	virtual void getIntPointer(int*& pInt) = 0;
	//virtual void getIntArray(int* intArray, int number) = 0;
};

class MockActionLearning: public ActionLearning
{
public:
	MOCK_METHOD1(getIntRef, void(int& i));
	MOCK_METHOD1(getIntPointer, void(int*& pInt));
	//MOCK_METHOD2(getIntArray, void(int* intArray, int number));
};

void myFunc(ActionLearning& al)
{
	int i = 0;
	al.getIntRef(i);
	cout << i << endl;

	int* b = &i;
	al.getIntPointer(b);//这里不能为空指针，空指针没有地址，无法赋值
	cout << i << endl;

	// int intArray[5] = {5, 4, 3, 2, 1};
	// al.getIntArray(intArray, 5);
	// for (int i : intArray)
	// {
		// cout << i << " ";
	// }
	// cout << endl;
}

TEST(ActionLearningTest, Test1)
{
	MockActionLearning mockActionLearning;
	int a = 100;
	int* b = &a;
	int newIntArray[5] = {10, 20, 30, 40, 50};
	EXPECT_CALL(mockActionLearning, getIntRef(_)).WillOnce(SetArgReferee<0>(a));//可以用SetArgReferee<0>(100)
	EXPECT_CALL(mockActionLearning, getIntPointer(_)).WillOnce(SetArgPointee<0>(a));//这里可以用SetArgPointee<0>(*b)，也可以用SetArgPointee<0>(100)，但必须是指针参数所指向的对象类型。即这里虽然函数入参是个int指针，但是这里必须入参int。
	//EXPECT_CALL(mockActionLearning, getIntPointer(NotNull())).WillOnce(SetArgPointee<0>(1000));//可以设置入参数指针非Null
	
	//EXPECT_CALL(mockActionLearning, getIntArray(NotNull(), 5)).WillOnce(SetArrayArgument<0>(newIntArray, newIntArray + 5));//数组入参的设置没有编译过？？？

	myFunc(mockActionLearning);
}

//--------------------
如果只关心mock方法的返回值。
这里用到一个宏ON_CALL。看例子：
ON_CALL(subObj, readBuf(1000)).WillByDefault(Return(blen));  
ON_CALL(#1, #2(#3)).WillByDefault(Return(#4));
#1表示mock对象。就像我上面所说，对CSubscriber我定义了一个Mock类，那么就必须生成相应的mock对象，例如：
MockCSubscriber subObj(5);  
#2表示想定义的那个方法名称。上例中我想定义readBuf这个方法的返回值。
#3表示readBuf方法的参数。这里的1000表示，只有调用CSubscriber::readBuf同时传递参数为1000时，才会用到ON_CALL的定义。
#4表示调用CSubscriber::readBuf同时传递参数为1000时，返回blen这个变量的值。




//------------------------------------------------------------------------------------------------
//给定n个人，计算至少有两个人生日在同一天的概率
#include <iostream>
using namespace std;

class CalcSameBirthday
{
public:
	static double getProbability(int n)
	{
		double peopleNumber = static_cast<double>(n);
		double allDifferentProbability = 1;
		for (int peopleNumber = 0; peopleNumber < n; ++peopleNumber)
		{
			allDifferentProbability *= (yearDays - peopleNumber) / yearDays;//计算所有人的生日都不相同的概率
		}
		return 1 - allDifferentProbability;//1-所有人生日都不相同的概率=至少有两个人生日概率相同
	}
private:
	static const double yearDays;
};

const double CalcSameBirthday::yearDays = 365;

int main()
{
	cout << CalcSameBirthday::getProbability(25) << endl;
	return 0;
}
输出如下：
0.5687
请按任意键继续. . .

算法导论 P62 生日悖论一节中根据数学推导到得至少有23人时，才会使两个生日相同的概率达到50%，经此算法计算，也是符合的
//------------------------------------------------------------------------------------------------
http://blog.csdn.net/augusdi/article/details/11773163

//C++ 11新特性 右值引用
http://www.cnblogs.com/hujian/archive/2012/02/13/2348621.html

非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值。如果允许绑定到常量左值和常量右值，则非常量左值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义。如果允许绑定到非常量右值，则会导致非常危险的情况出现，因为非常量右值是一个临时对象，非常量左值引用可能会使用一个已经被销毁了的临时对象。
常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。
#include <iostream>
using namespace std;

int func()
{
	return 10;
}

const int func2()
{
	return 10;
}

int main()
{
	//非常量左值引用只能绑定到非常量左值，不能绑定到常量左值、非常量右值和常量右值
	
	//非常量左值引用只能绑定到非常量左值
	int i = 1;
	int &a = i;

	//非常量左值不能绑定到常量左值
 	//const int i = 1;
 	//int &a = i;
	
	//非常量左值不能绑定到非常量右值
	//int &a = func();//此处函数的返回值就是典型的非常量右值
	//int &a = 1;
	//int &a = func2();//这是常量右值吗？貌似是非常量右值
	
	//非常量左值不能绑定到常量右值
	//这里没有找到什么常量右值的例子？

	//常量左值引用可以绑定到所有类型的值，包括非常量左值、常量左值、非常量右值和常量右值。
	return 0;
}

如果我们能确定某个值是一个非常量右值（或者是一个以后不会再使用的左值），则我们在进行临时对象的拷贝时，可以不用拷贝实际的数据，而只是“窃取”指向实际数据的指针（类似于STL中的auto_ptr，会转移所有权）。C++ 11 中引入的右值引用正好可用于标识一个非常量右值。C++ 11中用&表示左值引用，用&&表示右值引用
右值引用根据其修饰符的不同，也可以分为非常量右值引用和常量右值引用。
非常量右值引用只能绑定到非常量右值，不能绑定到非常量左值、常量左值和常量右值（VS2010 beta版中可以绑定到非常量左值和常量左值，但正式版中为了安全起见，已不允许）。如果允许绑定到非常量左值，则可能会错误地窃取一个持久对象的数据，而这是非常危险的；如果允许绑定到常量左值和常量右值，则非常量右值引用可以用于修改常量左值和常量右值，这明显违反了其常量的含义。
常量右值引用可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值（理由同上）。
#include <iostream>
using namespace std;

int func()
{
	return 10;
}

const int func2()
{
	return 12;
}

int main()
{
	//右值引用，使用的前提是知道右值是临时对象，不会再被使用

	//非常量右值引用只能绑定到非常量右值
	int &&a = 1;//实际a就是拿到了值1，这里其实是个常量右值？博客里写的可能不准确
	a = 3;//OK
	int &&b = func();//此处函数的返回值就是典型的非常量右值
	int &&c = func2();//这里可以编过，也是个非常量右值？那什么是常量右值

	//&&a = 5;编译错误，引用只能在变量初始化时使用，右值引用也一样


	//非常量右值不能绑定到非常量左值
	//int i = 1;
	//int &&a = i;

	//非常量右值不能绑定到常量左值
	//const int i = 1;
	//int &&a = i;

	//非常量右值不能绑定到常量右值
	//这里没有找到什么常量右值的例子？
	
	
	//常量右值引用可以绑定到非常量右值和常量右值，不能绑定到非常量左值和常量左值（理由同上）。
	
	//常量右值引用可以绑定到非常量右值
	const int &&d = func();
	
	//常量右值引用可以绑定到常量右值
	//这里没有找到什么常量右值的例子？

	//常量右值不能绑定到非常量左值和常量左值
	//const int i = 1;//这里加不加const，下句的常量右值引用都编不过
	//const int &&a = i;

	return 0;
}


#include <iostream>
#include <cstring>
using namespace std;

class CMyString
{
public:
	// 构造函数
	CMyString(const char *pszSrc = NULL)
	{
		cout << "CMyString(const char *pszSrc = NULL)" << endl;
		if (pszSrc == NULL)
		{
			m_pData = new char[1];
			*m_pData = '\0';
		}
		else
		{
			m_pData = new char[strlen(pszSrc) + 1];
			strcpy(m_pData, pszSrc);
		}
	}

	// 拷贝构造函数
	CMyString(const CMyString &s)
	{
		cout << "CMyString(const CMyString &s)" << endl;
		m_pData = new char[strlen(s.m_pData) + 1];
		strcpy(m_pData, s.m_pData);
	}

	// move构造函数
	CMyString(CMyString &&s)
	{
		cout << "CMyString(CMyString &&s)" << endl;
		m_pData = s.m_pData;
		s.m_pData = NULL;
	}

	// 析构函数
	~CMyString()
	{
		cout << "~CMyString() " << (m_pData == nullptr ? "NULL" : m_pData) << endl;
		delete[] m_pData;
		m_pData = NULL;
	}

	// 拷贝赋值函数
	CMyString& operator =(const CMyString &s)
	{
		cout << "CMyString& operator =(const CMyString &s)" << endl;
		if (this != &s)
		{
			delete[] m_pData;
			m_pData = new char[strlen(s.m_pData) + 1];
			strcpy(m_pData, s.m_pData);
		}
		return *this;
	}

	// move赋值函数
	CMyString& operator =(CMyString &&s)
	{
		cout << "CMyString& operator =(CMyString &&s)" << endl;
		if (this != &s)
		{
			delete[] m_pData;
			m_pData = s.m_pData;
			s.m_pData = NULL;
		}
		return *this;
	}

private:
	char *m_pData;
};

CMyString getCMyString()
{
	//这里直接用返回构造的临时对象，则调用处构造s2时，优化器会优化掉函数里的一次构造函数和返回值的一次拷贝构造函数，实际只调用了一次构造函数
	return CMyString();

	//如果这里显示调用move，则优化器无法做优化，首先对CMyString()调用构造函数生成，再调用一次move构造函数"CMyString(CMyString &&s)"生成返回值对象，
	//return move(CMyString());
}

int main()
{
	CMyString s1("abc");//构造函数

	CMyString s2 = getCMyString();//只有一次构造函数

	//想要获取一个右值,应该使用模板函数std::move<T>()，将返回一个右值对象
	s2 = move(s1);//s1对象并没有析构掉，只是内部数据指针置NULL。s2对象调用move赋值函数"CMyString& operator =(CMyString &&s)"

	return 0;
}
可以看到，上面我们添加了move版本的构造函数和赋值函数。那么，添加了move版本后，对类的自动生成规则有什么影响呢？唯一的影响就是，如果提供了move版本的构造函数，则不会生成默认的构造函数。另外，编译器永远不会自动生成move版本的构造函数和赋值函数，它们需要你手动显式地添加。
当添加了move版本的构造函数和赋值函数的重载形式后，某一个函数调用应当使用哪一个重载版本呢？下面是按照判决的优先级列出的3条规则：
	 1、 常量值只能绑定到常量引用上，不能绑定到非常量引用上。
	 2、 左值优先绑定到左值引用上，右值优先绑定到右值引用上。
	 3、 非常量值优先绑定到非常量引用上。
当给构造函数或赋值函数传入一个非常量右值时，依据上面给出的判决规则，可以得出会调用move版本的构造函数或赋值函数。而在move版本的构造函数或赋值函数内部，都是直接“移动”了其内部数据的指针（因为它是非常量右值，是一个临时对象，移动了其内部数据的指针不会导致任何问题，它马上就要被销毁了，我们只是重复利用了其内存），这样就省去了拷贝数据的大量开销。
一个需要注意的地方是，拷贝构造函数可以通过直接调用*this = s来实现，但move构造函数却不能。这是因为在move构造函数中，s虽然是一个非常量右值引用，但其本身却是一个左值（是持久对象，可以对其取地址），因此调用*this = s时，会使用拷贝赋值函数而不是move赋值函数，而这已与move构造函数的语义不相符。要使语义正确，我们需要将左值绑定到非常量右值引用上，C++ 11提供了move函数来实现这种转换，因此我们可以修改为*this = move(s)，这样move构造函数就会调用move赋值函数。

//---------------------
//C++ 11新特性 constexpr VS2013还未支持
#include <iostream>
using namespace std;

constexpr int get_five() 
{
	return 5;
}

int main()
{
	int some_value[get_five() + 7]; // 创建一个包含12个整数的数组. 这种形式在C++中是非法的.

	constexpr int a = 3;

	return 0;
}

//---------------------
//C++ 11新特性 std::shared_ptr
#include <iostream>
#include <memory>
using namespace std;

int main()
{
	shared_ptr<int> pInt1 = make_shared<int>(3);//生成shared_ptr
	shared_ptr<int> pInt2(new int(3));

	return 0;
}

//---------------------
//C++ 11新特性 std::unique_ptr
1 动态资源的异常安全保证(利用其RAII特性)：
void foo()  
{//不安全的代码  
    X *px = new X;  
    // do something, exception may occurs  
    delete px; // may not go here  
}  

void foo()  
{//异常安全的代码。无论是否异常发生，只要px指针成功创建，其析构函数都会被调用，确保动态资源被释放  
    unique_ptr<X> px(new X);  
    // do something,  
}  

2 返回函数内创建的动态资源 
unique_ptr<X> foo()  
{  
    unique_ptr<X> px(new X);  
    // do something  
    return px; //移动语义  
}  

3 可放在容器中(弥补了auto_ptr不能作为容器元素的缺点) 
方式一：
vector<unique_ptr<string>> vs { new string{“Doug”}, new string{“Adams”} };  
方式二： 
vector<unique_ptr<string>>v;  
unique_ptr<string> p1(new string("abc"));  
v.push_back(std::move(p1));//这里需要显式的移动语义，因为unique_ptr并无copy语义  

4 管理动态数组，因为unique_ptr有unique_ptr<X[]>重载版本，销毁动态对象时调用delete[]
unique_ptr<int[]> p (new int[3]{1,2,3});  
p[0] = 0;// 重载了operator[]  

5. 自定义资源删除操作(Deleter):
unique_ptr默认的资源删除操作是delete/delete[]，若需要，可以进行自定义：
void end_connection(connection *p) { disconnect(*p); } //资源清理函数  
unique_ptr<connection, decltype(end_connection)*> //资源清理器的“类型”  
p(&c, end_connection);// 传入函数名，会自动转换为函数指针  

6 auto_ptr与unique_ptr
在C++ 11 环境下，auto_ptr被看做“遗留的”，他们有如下区别：
auto_ptr有拷贝语义，拷贝后源对象变得无效；unique_ptr则无拷贝语义，但提供了移动语义
auto_ptr不可作为容器元素，unique_ptr可以作为容器元素
auto_ptr不可指向动态数组(尽管不会报错，但不会表现出正确行为)，unique_ptr可以指向动态数组

#include <iostream>
#include <memory>
#include <vector>
using namespace std;

unique_ptr<int> getUp(int i)
{
	return make_unique<int>(i);
}

int main()
{
	unique_ptr<int> pInt1(new int(3)); //unique_ptr<int> pInt = make_unique<int>(3);
	
	//1.无法进行拷贝构造和赋值操作
	//unique_ptr<int> pInt2(pInt1);//这种不安全的转移控制权方式编译错误
	//unique_ptr<int> pInt2 = pInt1;//错误

	//2.可以进行移动构造和移动赋值操作
	//如果想转移控制权，必须显示调用move函数
	unique_ptr<int> pInt2(move(pInt1));
	
	//move语意可以用在任何你需要创建一个“右值引用”的地方
	//也可以在函数返回值中使用
	unique_ptr<int> pInt3 = getUp(5);//函数中作为返回值却可以用

	//3.可做为容器元素
	vector<unique_ptr<int> > pIntVec;
	pIntVec.push_back(move(pInt1));
	//pIntVec.push_back(pInt1);报错
	//cout << *pInt1 << endl;但这个也同样出错,说明sp添加到容器中之后,它自身报废了
	
	//目前理解是：虽然unique_ptr可以放置在容器中，但是不能做各种拷贝操作，如排序，遍历之类的操作都不支持
// 	//抛异常了
// 	for (unique_ptr<int>& pInt : pIntVec)
// 	{
// 		cout << *pInt << endl;
// 	}
	//同样抛异常了
// 	for (vector<unique_ptr<int> >::iterator iter = pIntVec.begin(); iter != pIntVec.end(); ++iter)
// 	{
// 		cout << **iter << endl;
// 	}

	return 0;
}

//http://www.tuicool.com/articles/6zUBfen

#include <iostream>
#include <memory>
#include <vector>
using namespace std;

struct my_deleter
{
    void operator()(int *p)
	{
		cout << "delete point, value = " << *p << endl;
		delete p;
	}
};

int main()
{
	vector<unique_ptr<int, my_deleter> > vup;
	{
		cout << "scope begin######################" << endl;
		unique_ptr<int, my_deleter> up(new int(12), my_deleter());
		vup.push_back(move(up));//使用move就表示放弃对该对象的所有权，但并不对raw指针进行释放。这里up就不再有raw指针的所有权了，容器vup持有所有权
		if (up.get() == NULL)
		{
			cout << "up points NULL" << endl;
		}
		cout << "scope end######################" << endl;
	}
	cout << "outer######################" << endl;

	return 0;
}
输出如下：
scope begin######################
up points NULL
scope end######################
outer######################
delete point, value = 12

//---------------------
//C++ 11新特性 初始化列表
#include <iostream>
#include <memory>
#include <vector>
#include <string>
using namespace std;

struct Object 
{
	float first;
	int second;
};

int main()
{
	//报错，目前对于unique_ptr在容器中使用还是不是很懂，如果需要在容器中使用，还是用share_ptr
	//vector<unique_ptr<int> > vup {move(make_unique<int>(3)), move(make_unique<int>(4))};
	
	vector<string> stringVec = { "abc", "def" };
	for (const string& s : stringVec)
	{
		cout << s << endl;
	}

	Object scalar = { 0.43f, 10 }; //One Object, with first=0.43f and second=10  
	Object anArray[] = { { 13.4f, 3 }, { 43.28f, 29 }, { 5.934f, 17 } }; //An array of three Objects  

	return 0;
}

#include <iostream>
#include <initializer_list>
#include <algorithm>
using namespace std;

class SequenceClass {
public:
	SequenceClass(std::initializer_list<int> list)//SequenceClass(const std::initializer_list<int>& list)这样会更好
	{
		//initializer_list，可以像容器一样遍历
		for_each(list.begin(), list.end(), [](int i) {cout << i << " "; });
	}
};

int main()
{
	SequenceClass some_var = { 1, 4, 5, 6 };

	std::initializer_list<int> list = { 1, 4, 5, 6 };
	std::initializer_list<int> list2 = list;
	cout << *list2.begin() << endl;
	
	return 0;
}
这个构造函数是一种特殊的构造函数,叫做初始化列表构造函数(initializer-list-constructor).有这种构造函数的类在统一初始化中会被特殊对待(详见5.2)
类型std::initializer_list<>是个第一级的C++11 标准程序库类型. 但是,它们只能由C++11 通过{}语法来静态构造!这个列表一经构造便可复制，虽然这只是copy-by-reference.初始化列表是常数；一旦被创建，其成员均不能被改变，成员中的数据也不能够被改变.

因为初始化列表是真实类型，除了构造函数之外还能够被用在其他地方。常规的函数能够使用初始化列表作为参数。例如：
void FunctionName(std::initializer_list list);  
FunctionName({1.0f, -3.45f, -0.4f});  

标准容器也能够以这种方式初始化：  
std::vector v = { "xyzzy", "plugh", "abracadabra" };  
std::vector v({ "xyzzy", "plugh", "abracadabra" });  
std::vector v{ "xyzzy", "plugh", "abracadabra" }; // 参见下面 "统一的初始化"<span style='font-family: verdana, "ms song", Arial, Helvetica, sans-serif;'> </span>  


C++03 在初始化类型方面有着许多问题.初始化类型有数种方法，而且交换使用时不会都产生相同结果。传统的建构式语法，看起来像是函数声明，而且必须采取一些步骤保证不破坏编译器那些最让人恼火的解析规则.只有聚合体和POD类型能够用集合式初始化(通过SomeType var = {}; 形式的语法)
 　  C++11 提供了一个完全统一的可以用在任何类型的对象的初始化语法. 它扩展了初始化列表语法:
#include <iostream>
using namespace std;

struct BasicStruct 
{
	int x;
	double y;
};

struct AltStruct 
{
	AltStruct(int x, double y) : x_{ x }, y_{ y } {}
	
private:
	int x_;
	double y_;

};

struct IdString   
{  
	std::string name;  
	int identifier;  
};  

IdString get_string()   
{  
	return {"foo", 42}; //注意,这里没有指定具体类型.  
}  

int main()
{
	BasicStruct var1{ 5, 3.2 };
	AltStruct var2{ 2, 4.3 };

	return 0;
}

统一初始化不会取代构造函数语法,还是有一些时候是需要构造函数语法的.如果一个类有初始化列表构造函数(TypeName(initializer_list);),假定它有资格成为构造函数之一(我们知道,一个类可以有多个构造函数),那么它的优先级会高于其它形式的构造函数.C++11 版本的std::vector就有一个初始化列表构造函数.这意味着  std::vector the_vec{4};会调用初始化列表构造函数,而不是调用以vector大小为唯一参数的构造函数. 要访问后一个构造函数, 用户必须直接使用标准构造函数语法.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> intVec{4};//intVec(4)将构造4个大小，默认值都为0的vector对象
	for (int i : intVec)
	{
		cout << i << " ";
	}

	return 0;
}

//---------------------
//C++ 11新特性 类型推导 auto与decltype

#include <iostream>
#include <vector>
using namespace std;

int main()
{
	auto i = 3;//int
	decltype(i) j = 5;//int

	const std::vector<int> v(1);
	auto a = v[0];        // a 是 int 类型  
	decltype(v[0]) b = 1; // b 是 const int& 类型, 是std::vector::operator[](size_type) const 的返回类型  
	
	auto c = 0;           // c 是 int 类型  
	auto d = c;           // d 是 int 类型  
	decltype(c) e;        // e 是 int 类型, c变量的类型  
	decltype((c)) f = c;  // f 是int&类型, 因为(c)是一个左值  
	decltype(0) g;        // g 是 int 类型, 因为0是一个右值  

	decltype((e)) h = c;//decltype((e)) h因为是int&类型，所以必须初始化
	h = 4;
	cout << c;//变为了4
	return 0;
}

//---------------------
//C++ 11新特性 for
这种形式的for语句叫作"基于范围的for语句",它会遍历列表中的每一个元素.可以用在C风格数组,初始化列表和那些带有能返回迭代器的begin()和end()函数的类型上.所有提供了begin/end的标准容器都可以使用基于范围的for语句.
#include <iostream>
#include <string>
using namespace std;

int main()
{
	string s("abc");
	for each (char c in s)//这里不能用char&
	{
		cout << c << endl;
	}

	for (char& c : s)//这里可以用char、char&、const char或const char&
	{
		cout << c << endl;
	}
	return 0;
}

//---------------------
//C++ 11新特性 lambda函数与表达式

//---------------------
//C++ 11新特性 一种新的函数语法 
C++11 引入了一种新的函数声明语法,叫做后置返回类型(trailing-return-type)。关键字auto的这种用法与在自动类型推导中有所不同，这里的auto是返回值占位//（搜索【C++11】新特性――auto的使用）
template  
auto adding_func(const Lhs &lhs, const Rhs &rhs) -> decltype(lhs+rhs) {return lhs + rhs;}  

这种语法可以用到更普通的函数声明和定义上:
#include <iostream>
using namespace std;

struct SomeStruct  
{
	auto func_name(int x, int y) -> int;
};

auto SomeStruct::func_name(int x, int y) -> int
{
	return x + y;
}

int main()
{
	SomeStruct s;
	cout << s.func_name(1, 3);
	return 0;
}

//---------------------
//C++ 11新特性 对象构造的改进
C++03 中类的构造函数不允许调用该类的其它构造函数;每个构造函数都必须自己或者调用一个公共的成员函数来构造类的全部成员。而且,基类的构造函数不能直接暴露给派生类;每个派生类必须实现自己的构造函数哪怕基类的构造函数已经够用了.非静态数据成员不能在声明的地方初始化.它们只能在构造函数中初始化.
C++11 为这些问题提供了解决方案.C++11 允许构造函数调用另一个构造函数(叫做委托构造).这允许构造函数利用其它构造函数的行为而只需增加少量的代码.C#,java和D语言都提供了这种功能. C++的语法如下:
class SomeType  {  
    int number;  
   
public:  
    SomeType(int new_number) : number(new_number) {}  
    SomeType() : SomeType(42) {}  
};

注意:这个例子可以通过给new_number设定一个默认参数来达到相同的效果.但是,这种新语法可以让这个默认值在实现中来设置而不是在接口中设置.这带来的一个好处就是,对库代码的维护者而言,在接口中(头文件中)声明默认值,这个默认值被嵌入到了调用端;要改变这个默认值的话,调用端的代码都需要重新编译.但委托构造可以在实现中(CPP文件中)来改变这个默认值, 这样调用端的代码就不需要重新编译,只用重新编译这个库就可以了.
还有一个附加说明: C++03认为,构造函数执行完了一个对象就被构造好了. 而C++11则认为,只要任何一个构造函数执行完了,对象就算构造完成了. 由于可能有多构造函数会被执行,C++11的这种做法就意味着,所有的委托构造函数都将在一个已经用它自己类型完全构造好的对象上执行.这句话什么意思呢?举个例子, B 继承自 A, B的构造函数里调用了A的构造函数;当A的构造函数执行完以后,就已经有一个A类的对象构造完成了.而这时B的构造函数不会再构造一个新对象,而是把那个A对象改造成B类的对象(这是我的推测).再举一个例子,类C有两个构造函数C1和C2, C2调用了C1. 当C1执行完后,已构造好了一个C类对象.而这时C2的代码会直接作用在这个对象上,不会再构造一个新对象.C++03就会构造2个对象,其中一个是临时对象.
对于基类的构造函数,C++11 允许一个类指定要不要继承基类的构造函数.注意,这是一个"全部"或"全不"的特性,要么继承基类的全部构造函数,要么一个都不继承.

每一个构造函数都将把value初始化为5, 如果它们没用其它值来覆盖这个初始化的话.上面那个空的构造函数会把value初始化为类定义时的状态5.而那带有参数的构造函数会用指定的值来初始化value.成员的初始化也可以使用前面提到的统一初始化.
#include <iostream>
using namespace std;

class SomeClass 
{
public:
	SomeClass() {}
	explicit SomeClass(int new_value) : value(new_value) {}
	
	void show()
	{
		cout << value << endl;
	}

private :
	int value = 5;
};

int main()
{
	SomeClass s;
	s.show();
	return 0;
}

//C++ 11新特性 显式重写(覆盖,override)和final
override 这个特殊的标识符意味编译器将去检查基类中有没有一个具有相同签名的虚函数,如果没有,编译器就会报错!
#include <iostream>
using namespace std;

struct Base 
{
	virtual void some_func(float);
};

struct Derived : public Base
{
	virtual void some_func(int) override; //override会去检查是否有基类的重载函数，如果没有就会报错，以防手误新声明一个虚函数。Java中也有相同参数@Override
};

int main()
{
	Derived d;
	return 0;
}
C++ 11还增加了防止基类被继承和防止子类重写函数的能力.这是由特殊的标识符final来完成的,例如:
#include <iostream>
using namespace std;

struct Base1 final { };

struct Derived1 : Base1{}; // 病态的, 因为类Base1被标记为final了  

struct Base2
{
	virtual void f() final;
};

struct Derived2 : Base2
{
	void f(); // 病态的, 因为虚函数Base2::f 被标记为final了.  
};

int main()
{
	return 0;
}
在这个例子中, virtual void f() final;语句声明了一个虚函数却也阻止了子类重写这个函数.它还有一个作用,就是防止了子类将那个特殊的函数名与新的参数组合在一起.
　　需要注意的是,override和final都不是C++语言的关键字.他们是技术上的标识符,只有在它们被用在上面这些特定的上下文在才有特殊意义.用在其它地方他们仍然是有效标识符.（怎么理解？）
int final = 10;
cout << final << end;//将编译报错

//C++ 11新特性 空常量指针

#include <iostream>
using namespace std;

void foo(char *)
{
	cout << "foo(char *)" << endl;
}

void foo(int)
{
	cout << "foo(int)" << endl;
}

int main()
{
	foo(NULL);
	foo(nullptr);

	nullptr_t p = nullptr;//可以这么用么？
	foo(p);

	char *pc = nullptr;     // OK  
	int *pi = nullptr;     // OK  
	bool b = nullptr;     // OK. b is false.  
	//int i = nullptr;     // error 

	return 0;
}

输出如下：
foo(int)
foo(char *)
foo(char *)

如果NULL定义为0,那么foo(NULL);语句将会调用foo(int).这几乎必定不是程序员想要的,也不是代码直观上要表达的意图.
C++11 通过引入一个新的关键字nullptr充当单独的空指针常量来纠正这个问题.它的类型是nullptr_t,是一个可以隐式转换任意类型的指针或指向成员的指针的类型,并且可以和这些类型进行比较.它不能隐式转换为整型,也不能与整型做比较,bool类型除外.尽管最初的提议中一个nullptr类型的右值不应该能转换为bool类型,但是为了保持与常规指针类型的一致性,核心语言工作组还是认定这种转换是合理的. 为了向下兼容,0仍然是一个有效的空指针常量!

//C++ 11新特性 强枚举类型
在C++03 中,枚举不是类型安全的.他们实际上是整数,尽管他们是不同的枚举类型.这使得我们可以比较两种不同类型的枚举值.C++03提供的唯一安全性就是,一个整数或一个枚举类型的值不能隐式地转换成另一个枚举类型.此外,底层的具体的整数类型(short,long,int,...)是由实现(编译器)定义的,标准并无明确规定.因此,那些枚举变量的大小的代码将是不可移植的.最后,枚举值是暴露在外层作用域(直接包含枚举定义的作用域)中的.所以,两个不同枚举类型的成员不可能有相同的名字.
C++11 引入了一个没上述问题的特殊"枚举类".使用 enum class(也可以用同义词enum struct)来声明:

这种枚举是类型安全的;枚举值不能隐式地转换成整数,所以也不可以和整数做比较.表达式 Enumeration::Val4 == 101 会报一个编译错误.

枚举类的底层类型总是已知的.默认是int型,这可以用其它整数类型来覆盖它.就像下面这个例子:

老式的枚举被放在直接包含该定义的作用域中.新式的枚举被放在枚举类的作用中.所以,上例中Val1是未定义的,而Enum2::Val1是已定义的.

C++11 还提供了一个过渡语法让老式的枚举类型可以提供显式的作用域和定义底层整数类型.语法如下:
这个例子中枚举名字被定义在枚举类型的作用域内(Enum3::Val1),但是为了向下兼容它们也会被放在直接包含在Enum3所在的作用域中.

#include <iostream>
using namespace std;

enum MyEnum
{
	typeA = 0,
	typeB = 1
};

enum class Enumeration 
{
	Val1,
	Val2,
	Val3 = 100,
	Val4 // = 101  
};

enum class Enum2 : unsigned short { Val1, Val2 };//可以修改枚举值的底层类型，默认是int

enum Enum3 : unsigned long { Val1 = 1, Val2 };//过渡语法，让老式的枚举类型可以提供显式的作用域和定义底层整数类型

int main()
{
	MyEnum a = typeA;
	cout << a << endl;
	bool flag = (a == 0);
	if (flag)
	{
		cout << "a == 0" << endl;
	}
	else
	{
		cout << "a != 0" << endl;
	}
	
	Enumeration newEnum = Enumeration::Val1;//一定要加作用域，否则Val1无法识别
	//cout << newEnum << endl;编译错误，无法转换
	//flag = (newEnum == 0);编译错误，无法比较
	flag = (newEnum == Enumeration::Val1);
	if (flag)
	{
		cout << "newEnum == Enumeration::Val1" << endl;
	}
	else
	{
		cout << "newEnum != Enumeration::Val1" << endl;
	}

	Enum3 enum3 = Enum3::Val2;//枚举名字被定义在枚举类型的作用域内(Enum3::Val1),但是为了向下兼容它们也会被放在直接包含在Enum3所在的作用域中.
	cout << enum3 << endl;

	return 0;
}
输出如下：
0
a == 0
newEnum == Enumeration::Val1
2

//C++ 11新特性 右尖括号
C++03 的解析器都把">>"定义为右移运算符.但是,在嵌套的模板声明中,程序员往往倾向于忽略两个右尖括号之间的空格.这会导致编译器报一个语法错误.
C++11 改进了编译器的解析规则,尽可能地将多个右尖括号(>)解析成模板参数结束符.可以用圆括号来改变这个规则,圆号的优先级比它高.例如:
#include <iostream>
#include <vector>
using namespace std;

template<bool Test> class SomeType {};

//std::vector < SomeType < 1>2 >> x1;  // 被解析成 std::vector of SomeType<true> 2>,  
// 这是错误的语法, 1 被当成 true 了.  
std::vector<SomeType < (1>2) >> x1;  // 被解析成 std::vector of SomeType<false>,  
// 在C++11中是合法的. (1>2) 这个表达式的结果为false.  

int main()
{

	return 0;
}

//---------------------
//C++ 11新特性 显式类型转换操作符

//---------------------
//C++ 11新特性 模板的别名
在进入这个主题前,先弄清楚"模板"和"类型"的区别.类型,是具体的数据类型,可以直接用来定义变量. 模板,是类型的模板,根据这个模板可以产生具体的类型;模板是不能直接定义变量的;当指定了所有的模板参数后,就产生了一个具体的类型,就可以用来定义变量了.
在C++03中,只能为类型(包括完全特化的模板,也是一种类型)定义别名, 而不能为模板定义别名:　　
template <typename First, typename Second, int Third>  
class SomeType;  

template <typename Second>  
typedef SomeType<OtherType, Second, 5> TypedefName; // 在C++03中, 这是非法的。C++ 11中这样定义也是非法的
用如下语句 using：
这种using语法也可以用来定义类型的别名:
#include <iostream>
using namespace std;

template <typename First, typename Second, int Third>
class SomeType {};

template <typename Second>
using TypedefName = SomeType<double, Second, 5>;

void func(double d)
{
	cout << d << endl;
}

int main()
{
	//typedef void(*FunctionType)(double); // 老式语法  
	using FunctionType = void(*)(double); // 新式语法

	FunctionType f = func;
	f(5.0);

	return 0;
}

//---------------------
//C++ 11新特性 无限制的unions VS2013还未支持
C++03中,对哪些类型的对象能够作为联合的成员是有限制的.例如,联合不能包含定义了非平凡构造函数的对象.C++11 废除了其中的一些限制:
现在,联合可以包含定义了非平凡构造函数的对象;如果包含了,那么联合就必须要显式定义一个构造函数.

#include <iostream>
#include <new> // Required for placement 'new'.  
using namespace std;

struct Point{
	Point() {}
	Point(int x, int y): x_(x), y_(y) {}
	int x_, y_;
};

union U
{
	int z;
	double w;
	Point p; // 非法的C++03; 合法的C++11.
	U() { new(&p) Point(); } // 由于Point的原因, 必须定义构造函数。定位new操作符
};

int main()
{
	return 0;
}

//---------------------
//C++ 11新特性 可变参数模板
不太会用？？？再找些相关文档看一下
template<typename... Values>
class TupleParasClass
{

};

//编不过
// template<>
// struct CountClass<T>
// {
	// static const int value = 1;
// };

// template<typename T, typename... Args>
// struct CountClass 
// {
	// static const int value = 1 + CountClass<Args...>::value;
// };


//编不过
// void printf(const char *s)
// {
	// while (*s)
	// {
		// if (*s == '%' && *(++s) != '%')
			// throw std::runtime_error("invalid format string: missing arguments");
		// std::cout << *s++;
	// }
// }

// template<typename T, typename... Args>
// void printf(const char* s, T value, Args... args)
// {
	// while (*s)
	// {
		// if (*s == '%' && *(++s) != '%')
		// {
			// std::cout << value;
			// printf(*s ? ++s : s, args...); // 即便当 *s == 0 也会产生调用，以检测更多的类型参数。
			// return;
		// }
		// std::cout << *s++;
	// }
	// throw std::logic_error("extra arguments provided to printf");
// }

int main()
{
	TupleParasClass<int, std::vector<int>, std::map<std::string, std::vector<int>>> someInstanceName;

	// int count = CountClass<int, double>::value;
	// cout << count << endl;

	
	// printf("abc", 3, 5.0);

	return 0;
}


template<typename ...Args> 
struct SomeStruct
{
	static const int size = sizeof...(Args);
};

int main()
{
	cout << SomeStruct<int, double>::size << endl;//2，cout << SomeStruct<>::size << endl;输出为0

	return 0;
}
(sizeof...(Args) 的结果是编译期常数。)

//---------------------
//C++ 11新特性 新的字符串字面值
C++03 提供两种字符串字面值.第一种,包含在一对双引号内,产生一个以空字符结尾的const char数组.第二种,由L""定义,产生以空字符结尾的const wchar_t类型的数组.wchar_t是一个大小和定义都未明确定义的宽字符.字符串字面值既不支持UTF-8,UTF-16 也不支持其它任何类型的unicode编码.
char类型的定义被修改了,明确表述为:char的大小至少能存储UTF-8的8位编码,并且要足够大到能够存储编译器实际使用的字符集的任何成员.这以前只在C++标准的后半部分中有定义,依靠C标准来保证char的大小至少为8位.
C++11 支持3种UNICODE编码: UTF-8, UTF-16, 和 UTF-32. 除了前面提到的char类型定义的修改,C++11 还增加了两种字符类型:char16_t 和 char32_t.这两种类型是分别用来存储UTF-16 和UTF-32 的.
下面的例子展示了如何创建各种编码类型的字符串字面值:
//没有编过
#include <iostream>
using namespace std;

int main()
{
	char * s1 = u8"I'm a UTF-8 string.";
	char16_t* s2 = u"This is a UTF-16 string.";
	char32_t* s3 = U"This is a UTF-32 string.";

	return 0;
}

//---------------------
//C++ 11新特性 用户自定义的字面值

//---------------------
//C++ 11新特性 多线程内存模型

//---------------------
//C++ 11新特性 线程局部存储

//---------------------
//C++ 11新特性 明确默认和明确删除的特殊成员函数 
C++03中,如果类没有定义构造函数,拷贝构造函数,赋值函数和析构函数的话,编译器会为类提供这些函数.程序员可以自己定义这些函数来覆盖编译生成的默认版本.C++还定义了几个可以作用在所有类上的操作符(比如,赋值操作符=,new操作符等),程序员也可以覆盖它们.
然而, 对这些默认函数的创建只有很少的控制.例如, 要生成一个不可拷贝的类必须要声明私有的拷贝构造函数和私有的赋值操作符并且不定义它们的实现.试图调用这些函数就会违反"一个定义原则"(ODR,一个函数可以被调用,那么这个函数必须且只能有一个函数体定义).尽管诊断信息不是必须的,但是这类违规行为可能会导致链接错误.
就构造函数而言, 只要一个类定义了任意一个构造函数,编译器就不会自动为它生成构造函数了.这在很多情况下是很有用的,但有些情况下用户定义了这些函数,编译器还生成这些函数也是很有用的.
C++11 允许显式指明要不要使用这些特殊的成员函数.例如,下面的声明显式指出要使用默认构造函数:
另一方面,一些特性可以被显式地禁用.例如,下面的类是不可拷贝的:
#include <iostream>
using namespace std;

class SomeType 
{
public:
	//虽然没有对无参数的构造函数定义，但是做了声明，并加了default，表明要使用默认构造函数，如果不加这一行，则编译不过，提示没有合适的默认构造函数
	SomeType() = default; //The default constructor is explicitly stated.
	SomeType(int value): value_(value) {}

	void show() // = delete 这里也可以加上= delete
	{
		cout << value_ << endl;
	}
private:
	int value_ = 5;
};

int main()
{
	SomeType st1(10);
	st1.show();

	SomeType st2;
	st2.show();

	return 0;
}

指示符 = delete 可以用来阻止任何函数被调用,可以用来禁止调用带特定参数的成员函数.例如:
struct NoInt {
    void f(double i);
    void f(int) = delete;    // 不能调用这个函数
};

编译器会拒绝试图对带int参数的函数f()的调用, 而不是默默地转换为对带有double参数的f()的调用.这可以泛化到禁止除了带double参数外其他任何参数类型的f()的调用.例如:
struct OnlyDouble {
    void f(double d);
    template<class T> void f(T) = delete;    //不能调用这个函数
};

//---------------------
//C++ 11新特性 long long int类型
C++03中,最大的整数类型是long int.它保证使用的位数至少与int一样. 这导致long int在一些实现是64位的, 而在另一些实现上却是32位的.C++11增加了一个新的整数类型long long int来弥补这个缺陷.它保证至少与long int一样大,并且不少于64位.这个类型早在C99就引入到了标准C中, 而且大多数C++编译器都以扩展的形式支持这种类型了.
//---------------------
//C++ 11新特性 静态断言
C++03 提供两种方法来测试断言:宏assert和#error预处理指令.然而,这不适合用在模板中:宏在运行期间测试断言,而预处理指令在编译预处理阶段测试断言,这些都发生在模板实例化之前;也不适合用于依赖于模板参数的属性.
C++11 引入了一个新的关键字static_assert在编译期测试断言.声明呈现下面这样的形式:

#include <iostream>
using namespace std;

//static_assert (constant - expression, error - message);

//下面几个例子展示怎样使用static_assert:
template<int GREEKPI>//这里用double，会报类型非法， 换成int就可以，非类型模板参数不能使用double？
struct MyStruct
{
	static_assert((GREEKPI > 3.14) && (GREEKPI < 3.15), "GREEKPI is inaccurate!");
};

template<class T>
struct Check  
{
	static_assert(sizeof(int) <= sizeof(T), "T is not big enough!");
};

template<class Integral>
Integral foo(Integral x, Integral y) 
{
	static_assert(std::is_integral<Integral>::value, "foo() parameter must be an integral type.");
	return x + y;
}

int main()
{
	//如下三条语句均会在编译时报错
	MyStruct<2> ms;
	Check<short> c;
	foo(5.0, 3.0);

	return 0;
}
当常量表达的结果为false时,编译器就会产生一个错误消息.第一个例子类似于预处理指令#error,但是预处理指令只支持整数类型.相比之下,第二例子中的断言在模板类Check每一次被实例化的时候都被检查一次.
除了模板之外,静态断言也是很有用的.例如:一个算法的某个实现依赖于long long类型必须大于int,这类型事情标准并没有做出保证.这种假设在大多数系统和编译器上是有效的,但绝不是全部!
//---------------------
//C++ 11新特性 允许sizeof运算符作用在类型的数据成员上，无须明确的对象
C++03中,sizeof可以作用在类和对象上.但却不能像下面这样做:

//编不过
#include <iostream>
using namespace std;

struct SomeType 
{ 
	double member; 
};

int main()
{
	cout << sizeof(SomeType::member); // C++03 不行. C++11 可以.
	//这会返回OtherType的大小.C++03不允许这样做,会报一个编译错误.C++11允许这样做.

	return 0;
}
//---------------------
//C++ 11新特性 控制和查询对象的对齐方式
C++11 可以用alignof和alingas来查询和控制变量的对齐方式.
alignof是一个操作符,他以一个类型为参数,并且返回这个类型的实例必须分配的字节边界值,这个值一定是2的整数次幂.如果参数是引用类型,那么返回的是被引用的类型的对齐信息.对于数组,返回的是元素类型的对齐信息.
alignas指示符变量的内存控制方式.这个指示符的参数是一个常量或一个类型, alignas(T)是alignas(alignof(T))的简写形式.例如:下面的例子声明一个char数组,它的对齐方式与float型数据一样.
//编不过，不认识alignof和alignas
#include <iostream>
using namespace std;

int main()
{
	cout << alignof(int);
	alignas(float) unsigned char c[sizeof(float)];

	return 0;
}
//---------------------
//C++ 11新特性 允许实现垃圾回收
之前版本的C++标准通过set_new_handler提供了程序员驱动的垃圾回收机制,但却没有为自动化垃圾回收机制给出对象可到达性的定义. C++11 定义了指针完全地从其他地方获得值的条件.编译器实现可以指定在严格的指针安全下进行操作,在这种情况下不按这个规则获得值的指针就会变成无效的.
//---------------------
//C++ 11新特性 属性
C++11 为编译器和其他工具提供了标准的语言扩展语法.这些扩展历来都是用#pragma指令或生产商指定的关键字(如GNU的__attributes__和微软的 __declspec).C++11有了新的语法, 以双重方括号的形式为属性指定额外的信息.属性可以被用于各种代码元素:
int [[attr1]] i [[attr2, attr3]];

[[attr4(arg1, arg2)]] if (cond)
{
    [[vendor::attr5]] return i;
}

在上面的例子中,属性attr1作用在变量i的类型int上,而attr2和attr3则作用于变量i本身.attr4作用于if语句,vendor::attr5作用于return语句.一般地(但有一些例外),为一个命名实体指定的属性放在实体名字之后,其他部分之前.多个属性可以放在一个双重方括号对中,像上面的例子那样. 属性可能会有附加的参数,属性也可能被放在生产商指定的属性命名空间中.
建议属性不要有任何语言上的意义,也不要改变程序的观感. 属性可以提供一些很有用的信息,例如帮助编译器生成更好的诊断信息或优化生成的代码.
C++11 本身提供两种标准的属性:noreturn属性指出函数没有返回值, carries_dependency属性通过指出函数的参数或返回值有依赖关系来帮助优化多线程代码.
//---------------------
//C++ 11新特性 标准库组件的升级
C++11 提供了很多现存标准库组件能从中获益的新特性.例如,大多数标准容器都可以从基于移动构造右值引用中获益,不管是快速移动重型容器还是把容器的内容移动到新的内存位置.标准库组件已经用适当的C++11 新特性升级过了.包括但不限于以下特性:
右值引用及其关联的移动支持
支持utf-16 和utf-32 编码的unicode字符类型
可变模板(加上右值引用可以实现完美转发)
编译期常量表达式
decltype
显式类型转换操作符
default/deleted成员函数

#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> intVec = {1, 2, 3, 4};
	vector<int> intVec2 = move(intVec);//右值引用的使用，可以不用构造对象，获取原对象的指针，传递参数时提高效率。如果直接vector<int> intVec2 = intVec;则是用intVec拷贝构造了intVec2

	cout << "intVec:" << endl;
	for (int i : intVec)
	{
		cout << i << endl;
	}

	cout << "intVec2:" << endl;
	for (int i : intVec2)
	{
		cout << i << endl;
	}

	return 0;
}
输出如下：
intVec:
intVec2:
1
2
3
4
请按任意键继续. . .
//---------------------
//C++ 11新特性 线程支持
C++11 虽然从语言上提供了支持线程的内存模型,但主要的支持还是来自标准库.
新的标准库提供了一个线程类(std::thread)来运行一个新线程,它带有一个函数对象参数和一系列可选的传递给函数对象的参数.通过std::thread::join()支持的线程连接操作可以让一个线程直到另一个线程执行完毕才停止.std:thread::native_handle()成员函数提供了对底层本地线程对象的可能且合理的平台相关的操作.
为支持线程同步,标准库增加了互斥体(std::mutex, std::recursive_mutex等)和条件变量(std::condition_variable 和std::condition_variable_any).这些都是通过RAII锁和加锁算法就可以简单使用的.
有时为了高性能或底层工作,要求线程间的通信没有开销巨大的互斥锁.原子操作可以达到这个目的,这可以随意地为一个操作指定最小的内存可见度.显式的内存屏障也可以用于这个目的.
C++11 线程库还包含了futures和promises,用于在线程间传递异步结果.并且提供了std::packaged_task来封装可以产生这种异步结果的函数调用.
　　更高级的线程支持，如线程池，已经决定留待在未来的 Technical Report 加入此类支持。更高级的线程支持不会是 C++11 的一部份，但是其最终实现将建立在目前已有的线程支持之上。std::async 提供了一个简便方法来运行线程，并将线程绑定在 std::future上。用户可以选择一个工作是要在多个线程上异步的运行，还是在一个线程上运行并等待其所需要的数据。默认的情况，实现可以根据底层硬件选择前面两个选项的其中之一。另外在较简单的使用场景下，实现也可以利用线程池提供支持。
//---------------------
//C++ 11新特性 元组类型
元组(tuple)由预先确定数量的多种对象组成.元组可以看作是struct数据成员的泛化.
#include <iostream>
#include <tuple>
using namespace std;

// template <class ...Types> 
// class tuple
// {};

//下面是定义和使用元组的一个例子:
typedef std::tuple <int, double, long&, const char*> test_tuple;

int main()
{
	long lengthy = 12;
	test_tuple proof(18, 6.5, lengthy, "Ciao!");
	lengthy = std::get<0>(proof);  // 把'lengthy' 赋值为18.
	std::get<3>(proof) = "Beautiful!";  // 修改元组的第四个元素
	cout << lengthy << endl;
	cout << std::get<3>(proof) << endl;
}

输出如下：
18
Beautiful
请按任意键继续. . .

可以在定义一个元组时不定义他的内容,不过只有当它的每个元素类型都有默认构造函数时才可以这样做.而且,可以将一个元组赋值给另一个元组:如果两个元组的类型相同,且每种元素类型都有拷贝构造函数;否则,需要右边的元组的元素可以隐式转换成左边元组的对应元素类型或者左边元组的元素类型有合适的构造函数.
#include <iostream>
#include <tuple>
#include <typeinfo>
using namespace std;

typedef std::tuple <int, double, string> tuple_1;
typedef std::tuple <char, short, const char*> tuple_2;

int main()
{
	tuple_1 t1;
	tuple_2 t2('X', 2, "Hola!");
	t1 = t2; // Ok, 前两个元素都是可以转换的.// 第三个可以用'const char *'来构造一个string对象.

	//可以对元组类型对象的进行比较运算(当它们拥有同样数量的元素)。此外，C++11 提供两个表达式用来检索元组类型的属性(仅在编译期做此检查)。
	cout << std::tuple_size<tuple_1>::value << endl; //返回元组 T 内的元素个数，
	cout << typeid(std::tuple_element<0, tuple_1>::type).name() << endl; //返回元组 T 内的第 I 个元素的类型
}
//---------------------
//C++ 11新特性 散列表
在过去，不断有要求想将散列表(无序关系式容器)引进标准库。只因为时间上的限制，散列表才没有被标准库所采纳。虽然，散列表在最糟情况下(如果出现许多冲突 (collision) 的话)在性能上比不过平衡树。但实际运用中，散列表的表现则较好。
因为标准委员会还看不到有任何机会能将开放寻址法标准化，所以目前冲突仅能通过线性链(linear chaining) 的方式来处理。为避免与第三方库发展的散列表发生名称上的冲突，前缀将采用 unordered 而非 hash。
标准库将引进四种散列表，其中差别在于以下两个特性: 是否接受具相同键值的项(Equivalent keys)，以及是否会将键值映射到相对应的数据(Associated values).新的标准库增加了以下散列表类型:
#include <iostream>
#include <string>
#include <unordered_set>
#include <unordered_map>
using namespace std;

int main()
{
	cout << "unordered_set test:\n";
	unordered_set<int> intSet = {3, 4, 1, 3};
	for (const int i : intSet)
	{
		cout << i << " ";
	}
	cout << "\n\n";

	cout << "unordered_multiset test:\n";
	unordered_multiset<int> intMultiset = {20, 10, 30, 10};//无序的
	for (const int i : intMultiset)
	{
		cout << i << " ";
	}
	cout << "\n\n";

	cout << "unordered_map test:\n";
	unordered_map<int, string> intStringMap = {{2, "b"}, {1, "a"}, make_pair<int, string>(3, "c"), {2, "b"}, {2, "c"}};
	for (const pair<int, string>& intStringPair : intStringMap)
	{
		cout << "first: " << intStringPair.first << ", second: " << intStringPair.second << "\n";
	}
	cout << "\n\n";

	cout << "unordered_map test:\n";
	unordered_multimap<int, string> intStringMultiMap = {{20, "bb"}, {10, "aa"}, make_pair<int, string>(30, "cc"), {20, "bb"}, {20, "bc"}};
	for (const pair<int, string>& intStringPair : intStringMultiMap)
	{
		cout << "first: " << intStringPair.first << ", second: " << intStringPair.second << "\n";
	}
}
输出如下：
unordered_set test:
3 4 1

unordered_multiset test:
20 10 10 30

unordered_map test:
first: 2, second: b
first: 1, second: a
first: 3, second: c


unordered_map test:
first: 20, second: bb
first: 20, second: bb
first: 20, second: bc
first: 10, second: aa
first: 30, second: cc
请按任意键继续. . .

这些类完全具备容器类需的条件，同时也提供访问其中元素的成员函数: insert, erase, begin, end。
散列表不需要对现有核心语言做扩展(虽然散列表的实现会利用到 C++11 新的语言特性)，只会对头文件 <functional> 做些许扩展，并引入 <unordered_set> 和 <unordered_map> 两个头文件。对于其它现有的类型不会有任何修改。同时，散列表也不会依赖标准库的其它扩展功能。
//---------------------
//C++ 11新特性 正则表达式
新的标准库定义了一个新的头文件<regex>,由一些新的类组成:

正则表达式由模板类std::regex的实例来表示;
模式匹配由的结果模板类std::match_results的实例来表示;
函数 regex_search 是用来搜索模式的; 若要搜索并替换，则要使用函数 regex_replace，该函数会返回一个新的字符串。算法regex_search 和 regex_replace 接受一个正则表达式(模式)和一个字符串，并将该模式匹配的结果情况存储在 struct match_results对象中。
下面的例子展示了 match_results 的用法:
//没有输出结果？？？
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main()
{
	const char *reg_esp = "[ ,.\\t\\n;:]";  // 列出分隔符.
	
	// 这也可以通过字符串字面值来完成:
	// const char *reg_esp = R"([ ,.\t\n;:])";

	std::regex rgx(reg_esp); // 'regex' 是模板类'basic_regex'以'char'为类型参数特化的类.
	std::cmatch match; // 'cmatch'是模板类'match_results'以'const char *'特化的类. smatch是以string特化的类。 差别就是在regex_match中的入参是const char*还是string
	const char *target = "Unseen University - Ankh-Morpork";

	// 找出'target'中所有以'reg_esp'中的字符分隔的单词. 这个是做不到的！
	if (std::regex_search(target, match, rgx)) 
	{
		// 如果找到了指定的单词 
		const size_t n = match.size();
		for (size_t a = 0; a < n; a++) 
		{
			std::string str(match[a].first, match[a].second);
			std::cout << str << "\n";
			//如上两句实际就相当于下句
			//std::cout << match[0].str();
		}
	}
}
注意双反斜杠的使用，因为 C++ 将反斜杠作为转义字符使用。但 C++11 的原始字符串(raw string)可以用来避免这一问题。库 <regex> 不需要改动到现有的头文件，同时也不需要扩展现有的语言特性。


#include <iostream>
#include <string>
#include <regex>
using namespace std;

/* 测试C++11中的正则表达式. */
int main()
{
	//定义正则表达式,匹配时间格式  
	regex testRegex("[0-9]{2}:[0-9]{2}:[0-9]{2}\\.[0-9]{3}");

	//要匹配的字符串  
	string strText("OTA LOG SFTCH/MPA Stream 2/Reservation Accept  07:23:50.580 Channel: 147, Pilot PN: 232");

	cmatch result; //结果  

	//search 是匹配子字符串, match 是匹配整个字符串  
	if (regex_search(strText.c_str(), result, testRegex, regex_constants::format_default))
	{
		cout << result.str() << endl;
	}
	else
	{
		cout << "fail." << endl;
	}
}
输出如下：
07:23:50.580

http://www.cnblogs.com/zhuyp1015/archive/2012/04/08/2438215.html
//该实例通过一个函数is_email_valid 来检查一个email地址是否是一个正确的格式。如果格式正确则返回true。
#include <iostream>
#include <string>
#include <regex>
using namespace std;

bool is_email_valid(const std::string& email)
{
	//(\\w+) 匹配任意匹配包括下划线的任何单词字符(类似于“[A-Za-z0-9_]”) 一次或者多次
	//(\\.|_)? 匹配.或者_ 零次或一次
	//(\\w*) 匹配任意匹配包括下划线的任何单词字符(类似于“[A-Za-z0-9_]”) 任意次
	//@
	//(\\w+) 同上
	//(\\.(\\w+))+ 匹配.[A-Za-z0-9_] 一次或者多次
	const std::regex pattern("(\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+");
	return std::regex_match(email, pattern);
}

int main()
{
	std::string email1 = "marius.bancila@domain.com";
	std::string email2 = "mariusbancila@domain.com";
	std::string email3 = "marius_b@domain.co.uk";
	std::string email4 = "marius@domain";

	std::cout << email1 << " : " << (is_email_valid(email1) ? "valid" : "invalid") << std::endl;
	std::cout << email2 << " : " << (is_email_valid(email2) ? "valid" : "invalid") << std::endl;
	std::cout << email3 << " : " << (is_email_valid(email3) ? "valid" : "invalid") << std::endl;
	std::cout << email4 << " : " << (is_email_valid(email4) ? "valid" : "invalid") << std::endl;

	return 0;
}
这里对is_email_valid()函数中的正则表达式做一个简短的说明，如果对于正则表示不是很清楚的同学就能很容易理解了。
const std::regex pattern("(\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+"); 首先注意‘()’表示将正则表达式分成子表达式，每个‘()’之间的内容表示一个子表达式；‘\’是一个转义字符，‘\\’表示扔掉第二个‘\’的转义特性，‘\w+’表示匹配一个或多个单词，‘+’表示重复一次或者多次，因此第一个子表达式的意思就是匹配一个或者多个单词；接着看第二个子表达式，‘|’表示选择，出现‘.’或者‘_’，后面的‘?’表示该子表示出现一次或者零次，因此第二个子表示表示‘.’或‘_’出现不出现都匹配。第三个子表达式表示出现一个单词，‘*’表示任意个字符。后面的子表示根据已经介绍的内容，已经可以容易理解，就不再赘述。通过对正则表达式匹配模式串的分析，可以容易理解运行结果。

//下面一个例子通过正则表达式识别和打印IP地址的各个部分：
#include <iostream>
#include <string>
#include <regex>
using namespace std;

void show_ip_parts(const std::string& ip)
{
	// regular expression with 4 capture groups defined with
	// parenthesis (...)
	//\d 匹配一个数字字符。等价于[0-9]
	//{1,3} 匹配指定数目的字符1次到3次
	//这里有问题，没有考虑到字符不能超255
	const std::regex pattern("(\\d{1,3}):(\\d{1,3}):(\\d{1,3}):(\\d{1,3})");
	
	// object that will contain the sequence of sub-matches
	std::match_results<std::string::const_iterator> result;//获取的匹配子项()
	// match the IP address with the regular expression
	bool valid = std::regex_match(ip, result, pattern);

	std::cout << ip << " \t: " << (valid ? "valid" : "invalid")	<< std::endl;
	// if the IP address matched the regex, then print the parts

	if (valid)
	{
		std::cout << "b1: " << result[1] << std::endl;
		std::cout << "b2: " << result[2] << std::endl;
		std::cout << "b3: " << result[3] << std::endl;
		std::cout << "b4: " << result[4] << std::endl;
	}
}

int main()
{
	show_ip_parts("1:22:33:444");
	show_ip_parts("1:22:33:4444");
	show_ip_parts("100:200");

	return 0;
}
输出如下：
1:22:33:444     : valid
b1: 1
b2: 22
b3: 33
b4: 444
1:22:33:4444    : invalid
100:200         : invalid
请按任意键继续. . .
是对正则表达式的模式串做一个说明：首先还是通过‘()’将这个串分成几个子表达式，其中\d表示匹配一个数字，{,}表示数字的个数，例如{1,3}可以理解为匹配一个小于1000的数字（1-3位数都符合匹配要求）。
程序中还使用了match_results类，用来保存匹配的每一个子序列。调用regex_match(ip,result,pattern)，表示将ip中与模式串pattern匹配的结果放在result中。
result最后可以通过下标来访问各个匹配的子表达式。

//下面来介绍和regex_match()很像的regex_search()的使用实例，regex_match()要求正则表达式必须与模式串完全匹配，regex_search()只要求存在匹配项就可以。
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main()
{
	const std::regex pattern("(\\w+day)");

	// the source text
	std::string weekend = "Saturday and Sunday";
	std::smatch result;
	bool match = std::regex_search(weekend, result, pattern);
	if (match)
	{
		for (size_t i = 1; i < result.size(); ++i)
		{
			std::cout << result[i] << std::endl;
		}
	}
	std::cout << std::endl;

	return 0;
}
输出如下：
Saturday

请按任意键继续. . .
上面这个例子只能返回第一个匹配的项，如果要返回所有匹配的子序列，可以使用下面的方式：

#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main()
{
	// regular expression
	const std::regex pattern("\\w+day");

	// the source text
	std::string weekend = "Saturday and Sunday, but some Fridays also. Everyday is a good day.";
	const std::sregex_token_iterator end;  //需要注意一下这里
	for (std::sregex_token_iterator i(weekend.begin(), weekend.end(), pattern); i != end; ++i)
	{
		std::cout << *i << std::endl;
	}
	std::cout << std::endl;

	return 0;
}
输出如下：
Saturday
Sunday
Friday
Everyday

请按任意键继续. . .


下面的例子将元音字母打头的单词前面的a替换为an：
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main()
{
	// text to transform
	std::string text = "This is a element and this is a unique ID.";

	//\b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”
	// regular expression with two capture groups
	const std::regex pattern("(\\ba (a|e|i|u|o))+");

	// the pattern for the transformation, using the second
	// capture group
	std::string replace = "an $2";
	std::string newtext = std::regex_replace(text, pattern, replace);
	std::cout << newtext << std::endl;
	std::cout << std::endl;

	return 0;
}
输出如下：
This is an element and this is an unique ID.

请按任意键继续. . .

还是来说明一下，这里主要使用了regex_replace(text, pattern, replace)，意思是将text的内容按照pattern进行匹配，匹配成功的使用replace串进行替换，并将替换后的结果作为函数值返回。需要注意的是std::string replace = "an $2"; 这里‘$2’表示模式串的第二个子表达式，也就是以a,e,i,o,u开头的单词。

下面一个例子将进行年月日格式的转换，将DD-MM-YYYY C> YYYY-MM-DD，其中‘.’或者‘/’都能正确识别。
#include <iostream>
#include <string>
#include <regex>
using namespace std;

std::string format_date(const std::string& date)
{
	// regular expression
	const std::regex pattern("(\\d{1,2})(\\.|-|/)(\\d{1,2})(\\.|-|/)(\\d{4})");
	
	// transformation pattern, reverses the position of all capture groups
	std::string replacer = "$5$4$3$2$1";
	
	// apply the tranformation
	return std::regex_replace(date, pattern, replacer);
}

int main()
{
	std::string date1 = "1/2/2008";
	std::string date2 = "12.08.2008";
	std::string date3 = "12-08/2008";

	std::cout << date1 << " -> " << format_date(date1) << std::endl;
	std::cout << date2 << " -> " << format_date(date2) << std::endl;
	std::cout << date3 << " -> " << format_date(date3) << std::endl;
	std::cout << std::endl;

	return 0;
}
输出如下：
1/2/2008 -> 2008/2/1
12.08.2008 -> 2008.08.12
12-08/2008 -> 2008/08-12

请按任意键继续. . .

相信通过以上例子，对正则表达式的运用已经有了一个不错的了解，下面再来添加一个实例，加深一下理解。
下面一个例子用来查找给定文本中new的个数和delete的个数是否相等：
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main() 
{
	// "new" and "delete" 出现的次数是否一样？
	std::regex reg("(new)|(delete)");
	
	std::smatch m;
	std::string s =	"Calls to new must be followed by delete. \
		Calling simply new results in a leak!";
	
	int new_counter = 0;
	int delete_counter = 0;
	std::string::const_iterator it = s.begin();
	std::string::const_iterator end = s.end();

	//在两个字符串迭代器之间查找匹配项，直到遍历结束
	while (std::regex_search(it, end, m, reg))
	{
		// 是 new 还是 delete?
		m[1].matched ? ++new_counter : ++delete_counter;//m[1].matched表示第一个分组是否找到匹配项，m[1].fisrt表示带上第一个匹配项的剩余字符串，m[1].second表示不带上第一个匹配项的剩余字符串，如果没有找到匹配项，则first和second都为""；m[2]及之后类推
		it = m[0].second;//m[0].matched表示是否找到了全部匹配项，m[0].first表示带上全部匹配项的剩余字符串，m[0].second表示不带上全部匹配项的剩余字符串，而这里的全部匹配项是用|连接的，所以全部匹配项要么和m[1]相等，要么和m[2]相等
	}

	if (new_counter != delete_counter)
	{
		std::cout << "Leak detected!\n";
	}
	else
	{
		std::cout << "Seems ok...\n";
	}

	std::cout << std::endl;

	return 0;
}
输出如下：
Leak detected!

请按任意键继续. . .

//将字符串里的以,分隔的数字匹配出来求和
#include <iostream>
#include <string>
#include <regex>
using namespace std;

class regex_callback 
{
	int sum_;
public:
	regex_callback(): sum_(0) {}

	template <typename T> 
	void operator()(const T& what) 
	{
		//what对象是smatch类型，what[1]就是第1个匹配项，即(\\d+)，调用.str()得到匹配项的字符串类型string，再调用c_str()得到了对应const char*
		sum_ += atoi(what[1].str().c_str());
		//同下
		//string intStr = what[1].str();
		//sum_ += atoi(intStr.c_str());
	}

	int sum() const 
	{
		return sum_;
	}
};

int main() 
{
	regex reg("(\\d+),?");
	//如果"(\\d+)(,)?"，则将有what[2]，string commaStr = what[2].str().c_str();
	//此时what[0]将是 1,     what[1]将是 1   what[2]将是 ,
	
	
	string s = "1,1,2,3,5,8,13,21";
	
	sregex_iterator it(s.begin(), s.end(), reg);
	sregex_iterator end;

	regex_callback c;
	int sum = for_each(it, end, c).sum();//for_each返回的是这个函数对象，因此可以调用sum
	cout << sum << endl;
	cout << endl;
}
输出如下：
54

//匹配用/分隔的字符串
#include <iostream>
#include <string>
#include <regex>
using namespace std;

using namespace std;

int main()
{
	regex reg("/");
	vector<std::string> vec;
	string s = "Split/Vulue/Teather/Neusoft/Write/By/Lanwei";
	
	sregex_token_iterator it(s.begin(), s.end(), reg, -1);// -1逆向匹配,就是匹配除了'/'之外的
	sregex_token_iterator end;

	while (it != end)
	{
		vec.push_back(*it++);
	}

	copy(vec.begin(), vec.end(), ostream_iterator<std::string>(cout, "\n"));
	
	return 0;
}
输出如下：
Split
Vulue
Teather
Neusoft
Write
By
Lanwei
请按任意键继续. . .
//---------------------
//C++ 11新特性 通用智能指针
这些指针是由 TR1 智能指针演变而来。注意! 智能指针是类而非一般指针。shared_ptr 是引用计数型(reference-counted) 指针类，其行为与一般 C++ 指针极为相似。在 TR1 的实现中，缺少了一些一般指针所拥有的特性，像是别名或是指针运算。C++11 增加了这些特性。以下是一个使用 shared_ptr 的例子:
#include <iostream>
#include <memory>
using namespace std;

int main()
{
	std::shared_ptr<double> p_first(new double);
	cout << *p_first << "\n";
	{
		std::shared_ptr<double> p_copy = p_first;
		*p_copy = 21.2;
		cout << *p_first << "\n";
	}  // 此r 'p_copy' 会被销毁，但动态分配的 double 不会被销毁。

	return 0;  // 此时'p_first'会被销毁，但动态分配的 double也会被销毁(因为不再有指针指向它)。
}
输出如下：
-6.27744e+066
21.2
请按任意键继续. . .

auto_ptr 将会被 C++ 标准所废弃，取而代之的是unique_ptr。 unique_ptr 提供 auto_ptr 大部份特性，但不包括 auto_ptr 的不安全性和隐性的左值转移。不像 auto_ptr，unique_ptr 可以存放在 C++11 提出的那些需要移动语义的容器之中。
//---------------------
//C++ 11新特性 可扩展的随机数生成器
C 标准库允许使用rand函数来生成伪随机数。不过其算法则取决于各程序库开发者。 C++ 直接从 C 继承了这部份，但是 C++11 将会提供产生伪乱数的新方法。C++11 的随机数功能分为两部分： 第一，一个随机数生成引擎，其中包含该生成引擎的状态，用来产生随机数。第二,一个分布，这可以用来决定产生随机数的范围，也可以决定以何种分布方式产生随机数。随机数生成对象即是由随机数生成引擎和分布所构成。
不同于 C 标准库的 rand; 针对产生随机数的机制，C++11 将会提供三种算法，每一种算法都有其强项和弱项:
样板类	整数/浮点数	品质	速度	状态数*
linear_congruential	整数	低	中等	1
subtract_with_carry	两者皆可	中等	快	25
mersenne_twister	整数	佳	快	624

C++11 将会提供一些标准分布: uniform_int_distribution (离散型均匀分布)，bernoulli_distribution (伯努利分布)，geometric_distribution (几何分布)， poisson_distribution (卜瓦松分布)，binomial_distribution (二项分布)，uniform_real_distribution (离散型均匀分布)， exponential_distribution (指数分布)，normal_distribution (正态分布) 和 gamma_distribution (伽玛分布)。下面的例子展示了一个随机数生成对象如何由生成引擎和分布构成的:
//VS2013 还未支持
std::uniform_int_distribution<int> distribution(0, 99); // 建立分布,以离散均匀分布方式在0到99之间产生随机数
std::mt19937 engine; // 建立随机数生成引擎
auto generator = std::bind(distribution, engine); // 利用 bind 随机数生成引擎和分布M合成一个随机数生成器
int random = generator();  // 产生随机数

//---------------------
//C++ 11新特性 封装引用
我们可以通过实例化模板类 reference_wrapper 得到一个封装引用 (wrapper reference)。封装引用类似于一般的引用。对于任意对象，我们可以通过模板类 ref 得到一个封装引用 (至于 constant reference 则可通过 cref 得到)。当模板函数需要形参的引用而非其拷贝时封装引用就能派上用场了:

#include <iostream>
#include <utility>
using namespace std;

// 此函数将得到r的引用,并将r的值加1.
void f(int &r)  
{ 
	r++; 
}

// 模板函数
template<class F, class P> 
void g(F f, P t)//如果这里改成P& t，则加不加形参引用都没有差异
{ 
	f(t); 
}

void h(int r)
{
	++r;
}

int main()
{
	int i = 0;
	g(f, i);  // 实例化 'g<void (int &r), int>' 
	// 'i' 不会被修改
	std::cout << i << std::endl;  // 输出 0

	g(f, std::ref(i));  // 实例化 'g<void(int &r),reference_wrapper<int>>'
	// 'i' 会被修改
	std::cout << i << std::endl;  // 输出 1

	//只对模板参数有用，对于一般参数没有效果
	h(i);
	cout << i << endl;

	h(std::ref(i));
	cout << i << endl;
}
输出如下：
0
1
1
1
请按任意键继续. . .
//---------------------
//C++ 11新特性 多态的函数对象包装器
函数对象的多态包装器(又称多态函数对象包装器)在语义和语法上和函数指针相似，但不像函数指针那么狭隘。只要能被调用，且其参数能与包装器兼容的都能以称之为多态函数对象包装器(函数指针，成员函数指针或仿函数)。
#include <iostream>
#include <functional>
using namespace std;

struct Test
{
	bool operator()(short x, short y)
	{
		return x > y;
	}
};

bool adjacent(long x, long y)
{
	return x > y;
}

int main()
{
	std::function<int(int, int)> func;  // 利用模板类 'function'建立包b器
	std::plus<int> add;  // 'plus' 被声明 'template<class T> T plus( T, T )，因此 'add' 的类型是 'int add( int x, int y )'
	//这里不能用fun = &add;
	func = add;  // 可行。'add' 的型参和回返值类型与 'func' 相符

	int a = func(1, 2);  // 注意: 若包b器 'func' ]有引用到任何函数会抛出 'std::bad_function_call' 异常
	cout << a << "\n";

	std::function<bool(short, short)> func2;
	//func2 = std::greater<short>();如果这里给func2赋值了，if (!func2)为假，fun2类似函数指针的感觉
	if (!func2) // 因为还未给'func2'赋值,此表达式为真
	{
		func2 = adjacent;  // 可行。'adjacent' 的型参和回返值类型可通过类型转换与'func2'相符
		cout << func2(1, 3) << "\n";

		Test car;
		//这里也可以不用std::ref，直接func = car;
		func = std::ref(car);  // 模板类 'std::ref' 返回一个struct 'car' 成员函数 'operator()' 的包b
		cout << func(3, 2) << "\n";
	}
 	func = func2;  // 可行。'func2'的型参和回返值类型可通过类型转换而与'func' 相符
	return 0;
}


//http://www.hankcs.com/program/cpp/c11-std-function-usage.html
#include <iostream>
#include <map>
#include <functional>
using namespace std;

// 普通函数
int add(int i, int j) { return i + j; }
// lambda表达式
auto mod = [] (int i, int j){return i % j; };
// 函数对象类
struct divide
{
	int operator() (int denominator, int divisor)
	{
		return denominator / divisor;
	}
};

///////////////////////////SubMain//////////////////////////////////
int main(int argc, char *argv[])
{
	// 受限的map
	map<char, int(*)(int, int)> binops_limit;
	binops_limit.insert({'+', add});
	binops_limit.insert({'%', mod});
	// 错误  1   error C2664: “void std::_Tree<std::_Tmap_traits<_Kty,_Ty,_Pr,_Alloc,false>>::insert(std::initializer_list<std::pair<const _Kty,_Ty>>)”: 无法将参数 1 从“initializer-list”转换为“std::pair<const _Kty,_Ty> &&”
	// binops_limit.insert({ '%', divide() });

	// 更灵活的map
	map<char, function<int(int, int)>> binops =
	{
		{'+', add},
		{'-', minus<int>()},
		{'*', [] (int i, int j){return i * j; }},
		{'/', divide()},
		{'%', mod},
	};
	cout << binops['+'](10, 5) << endl;
	cout << binops['-'](10, 5) << endl;
	cout << binops['*'](10, 5) << endl;
	cout << binops['/'](10, 5) << endl;
	cout << binops['%'](10, 5) << endl;
	//system("pause");
	return 0;
}
如上所示，function可以将普通函数，lambda表达式和函数对象类统一起来。它们并不是相同的类型，然而通过function模板类，可以转化为相同类型的对象（function对象），从而放入一个map里。

另外我实际测试的结果来看，在VS2013编译器下，上述代码可以通过，而第五版《C++ Primer》第512页第一行所言“错误：mod不是一个函数指针”并没有发生错误，有可能是对C++11 标准的不同实现吧。
//---------------------
//C++ 11新特性 用于元编程的类型特征
编写一个创建或修改其它程序(也可以是程序本身)的程序称为元编程.这种行为可以发生在编译期,也可以发生在运行期.C++标准委员会决定引入一个库,允许在编译期利用模板进行元编程.
以下是一个元编程的例子,基于当前的C++03 标准: 模板的递归实例化来计算整数的幂
#include <iostream>
using namespace std;

template<int B, int N>
struct Pow 
{
	// 递归调用和重新组合.
	enum{ value = B * Pow<B, N - 1>::value };
};

//模板的部分参数特化
template<int B>
struct Pow<B, 0> {
	// ''N == 0'' 是终止条件.
	enum{ value = 1 };
};

int main()
{
	int quartic_of_three = Pow<3, 4>::value;
	cout << quartic_of_three << endl;
	return 0;
}
输出结果：
81

很多算法都可以操作不同类型的数据;C++的模板支持泛型编程,并且使代码更加紧凑和有用.然而算法通常都需要知道它正使用的数据的类型.这些信息可以在编译期利用类型特征(type trait)获取到. 类型特征(type traits)可以标识出一个对象的类别和类或结构体的全部特征.type traits定义在一个新头文件<type_traits>中.
在下面的例子中,模板函数elaborate根据给定的数据类型实例化了一个特定的算法(algorithms.do_it)

#include <iostream>
using namespace std;

// 算法一
template< bool B > 
struct Algorithm 
{
	template<class T1, class T2> 
	static int do_it(T1 &, T2 &)  
	{ 
		cout << "Algorithm<false>" << endl;
		return 0;
	}
};

// 算法二
template<> struct 
Algorithm < true > 
{
	template<class T1, class T2> 
	static int do_it(T1, T2)  
	{
		cout << "Algorithm<true>" << endl;
		return 0;
	}
};

// 根据给定的类型,会自动实例化正确的算法.
template<class T1, class T2>
int elaborate(T1 A, T2 B)
{
	// 只有当T1是整数,T2是浮点数是实例化算法二
	// 其他情况实例化算法一
	return Algorithm<std::is_integral<T1>::value && std::is_floating_point<T2>::value>::do_it(A, B);
}

int main()
{
	elaborate(3.0, 4.0);
	elaborate(3, 4.0);

	return 0;
}
输出如下：
Algorithm<false>
Algorithm<true>
请按任意键继续. . .

通过定义在<type_transform>头文件中的类型特征,可以创建类型转换操作(static_cast和const_cast对模板来说是不够的).这种编程技术能产生优雅简洁的代码,但是除错却是这种技术的弱点:编译期的错误信息难以理解,运行期错误则更难.

//C++ 11新特性 用于计算函数对象返回类型的统一方法
要在编译期确定一个模板函数的返回值类型不是那么容易的,特别是当返回类型依赖于函数参数的时候.例如:
#include <iostream>
using namespace std;

struct Clear 
{
	// 参数类型与返回类型相同
	int operator()(int i) const
	{
		return i;
	}
	double operator()(double d) const
	{
		return d;
	}
};

template <class Obj>
class Calculus 
{
public:
	template<class Arg> 
	Arg operator()(const Arg& a) const 
	{
		return member(a);
	}
private:
	Obj member;
};

//以Clear来实例化Calculus模板类(Calculus<Clear>), Calculus类的所有对象都有与Clear类相同的返回类型.但是下面给出的Confused类:
struct Confused 
{
	// 参数类型，不同于返回类型
	double operator()(int i) const
	{
		return static_cast<double>(i);
	}
	int operator()(double d) const
	{
		return static_cast<int>(floor(d));
	}
};

//试图实例化Calculus<Confused>会导致Calculus与Confused的返回类型不同.编译会产生一条从int转换到double的警告和一条从double转换到int的警告信息.
//在TR1引入,C++11也接受了模板类std::result_of,它允许我们在所有的声明中确定和使用函数对象的返回类型.下面的类CalculusVer2用std::result_of对象来获得函数对象的返回类型:
template< class Obj >
class CalculusVer2 
{
public:
	template<class Arg>
	typename std::result_of<Obj(Arg)>::type operator()(const Arg& a) const 
	{
		return member(a);
	}
private:
	Obj member;
};

int main()
{
	Calculus<Clear> a;
	cout << a(3) << endl;
	cout << a(4.5) << endl;

// 	Calculus<Confused> b;
// 	cout << b(3) << endl;
// 	//如下会报警告：warning C4244: “return”: 从“double”转换到“int”，可能丢失数据
// 	cout << b(4.5) << endl;

	//这种实例化CalculusVer2<Confused>函数对象的方法没有类型转换,没有警告也没错误.
	CalculusVer2<Confused> c;
	cout << c(3) << endl;
	cout << c(4.5) << endl;

	return 0;
}
模板 std::result_of 在 TR1 和 C++11 的实现中有一点不同。TR1 的版本允许实现在特殊情况下，可能无法决定一个函数调用其回返值的类别。然而，因为 C++11 支持了decltype，实现被要求在所有情况下，皆能计算出回返值类型。

//---------------------
原本计划加入但没有加入C++11 的特性  

预计由 Technical Report 提供支持的:
--模块
--十进制类别
--数学专用函数
延后讨论的:
--Concepts (概念 (C++))
--更完整或必备的垃圾回收支持
--Reflection 反射
--Macro Scopes 宏作用域

被移除或被废弃的特性
--顺序点 (sequence point)，这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。
--export,用法已被去掉,但关键字还是被保留了,给将来可能的特性使用
--exception specifications
--std::auto_ptr 被 std::unique_ptr 取代。
--函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;  

int main()
{
	vector<string> stringVec;
	stringVec.push_back("abc");
	stringVec.push_back("def");
	string oldValue("abc");
	string newValue("aaa");

	//这句话将编译不过，编译器无法推演出T到底是char*类型还是string
	//replace(stringVec.begin(), stringVec.end(), "abc", newValue);
	
	//要么传入两个char*类型参数
	replace(stringVec.begin(), stringVec.end(), "abc", "aaa");

	//要么传入两个string类型参数
	replace(stringVec.begin(), stringVec.end(), oldValue, newValue);

	//如果要传入一个char*类型参数，一个string类型参数，那就需要为函数明确指定两个模板类型参数，帮助编译器获知参数类型
	replace<vector<string>::iterator, string>(stringVec.begin(), stringVec.end(), "abc", newValue);
} 

//replace的原型如下：两个模板类型参数，一个迭代器类型ForwardIterator，一个值类型T
template < class ForwardIterator, class T >
  void replace ( ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value );
//------------------------------------------------------------------------------------------------
//输入两个字符串，只有数字和字母，合并后奇偶分别排序，如果字符为0-9，a-f，A-F，则对所代表的16进制数进行位倒序，并转换成相应的大写字母
//例：dec + fab -> decfab -> abcdef -> 5D37BF
//edc + fab ->5D3B7F
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <functional>
#include <sstream>
#include <cctype>
#include <cstdlib>
using namespace std;  

void expandToFourBits(string &s)
{
	if (s.length() < 4)
	{
		s.insert(s.begin(), 4 - s.length(), '0');
	}
}

//十进制数字转换成二进制字符串
string decToBinString(int num)
{
	if (num > 0)
	{
		string s;
		stringstream ss;
		s = decToBinString(num/2);
		ss << num % 2;
		return s + ss.str();
	}
	else
	{
		return "";
	}
}

//二进制字符串转换成十进制数字
long binStringToDec(const string& binString)
{
	return strtol(binString.c_str(), (char**)NULL, 2);
}

//十六进制字符串转换成十进制数字
long hexStringToDec(const string& hexString)
{
	return strtol(hexString.c_str(), (char**)NULL, 16);
}

//十进制数字转换成十六进制字符串
string decToHexString(int d)
{
	char buffer[1000];
	itoa(d, buffer, 16);
	return buffer;//lower alpha
}

//十六进制字符串转换成二进制字符串
string hexStringToBinString(const string& hexString)
{
	return decToBinString(hexStringToDec(hexString));
}

//二进制字符串转换成十六进制字符串
string binStringToHexString(const string& binString)
{
	return decToHexString(binStringToDec(binString));
}

class StringProcessor
{
public:
	StringProcessor(const string& s1, const string& s2): fullString_(s1 + s2) {}

	string getOutputString()
	{
		string sortedString = makeSortedString();

		changeString(sortedString);

		return sortedString;
	}

private:
	string makeSortedString()
	{
		int i = 0;
		for_each(fullString_.begin(), fullString_.end(), [&] (char c) {
			if (i % 2 == 0)
			{
				s1_.append(1, c);
			}
			else
			{
				s2_.append(1, c);
			}
			++i;
		});

		sort(s1_.begin(), s1_.end());
		sort(s2_.begin(), s2_.end());

		bool addSpaceFlag = false;
		if (s1_.size() != s2_.size())
		{
			s2_.append(" ");
			addSpaceFlag = true;
		}

		string s;
		for (size_t i = 0; i < s1_.size(); ++i)
		{
			s += string(1, s1_.at(i)) + string(1, s2_.at(i));
		}

		return addSpaceFlag ? s.substr(0, s.size() - 1) : s;
	}

	void changeString(string& s)
	{
		//这里的lambda表达里要用类的成员函数，因此必须要在这里显示捕获this，才能使用类成员函数
		transform(s.begin(), s.end(), s.begin(), [this] (char c) -> char {
			if (isalpha(c))
			{
				if ((c >= 'G' && c <= 'Z') || (c >= 'g' && c <= 'z'))
				{
					return c;
				}
				else
				{
					//convertion
					return convertChar(c);
				}
			}
			else if (isdigit(c))
			{
				//convertion
				return convertChar(c);
			}
			else
			{
				return c;
			}
		});
	}

	char convertChar(char c)
	{
		string binaryStr = hexStringToBinString(string(1, c));
		expandToFourBits(binaryStr);
		reverse(binaryStr.begin(), binaryStr.end());
		string hexStr = binStringToHexString(binaryStr);
		return toupper(hexStr.at(0));
	}

	string fullString_;
	string s1_;
	string s2_;
};

void ProcessString(char* str1, char* str2, char* StrOutput)
{
	if (str1 == NULL || str2 == NULL)
	{
		return;
	}
	StringProcessor sp(str1, str2);
	string s = sp.getOutputString();
	strncpy(StrOutput, s.c_str(), s.size() + 1);
}

int main()  
{
	char strOutput[1000];
	ProcessString("3402", "98765", strOutput);
	cout << strOutput << endl;
}
//------------------------------------------------------------------------------------------------
//C++按位异或运算符的使用介绍
参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0
例如：10100001^00010001=10110000
0^0=0,0^1=1  0 异或任何数=任何数
1^0=1,1^1=0  1 异或任何数=任何数取反
任何数异或自己=把自己置0

(1)按位异或可以用来使某些特定的位翻转，如对数10100001的第2位和第3位翻转，可以将数与00000110进行按位异或运算。
10100001^00000110=10100111 //1010 0001 ^ 0x06 = 1010 0001 ^ 6
(2)通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现：
    a=10100001,b=00000110
    a=a^b； 　　//a=10100111
    b=b^a； 　　//b=10100001
    a=a^b； 　　//a=00000110
(3)异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.

//用异或实现两个整型数据的交换
#include <iostream>  
using namespace std;  

int main()  
{  
	long A, B;
	cout << "Please Input variable A:\n";
	cin >> A;
	cout << "Please Input variable B:\n";
	cin >> B;
	A = A ^ B;
	B = B ^ A;
	A = A ^ B;
	cout << "After exchange: A = " << A << "\tB = " << B;
	return 0;
} 
//------------------------------------------------------------------------------------------------
在Visual Studio中的Debug模式下，如果声明一个变量，但是没有初始化，微软会给未初
始化的内存复制为0xCC。给为初始化的内存赋0xCC是有原因的，0xCC其实是INT3中断指令
，所以如果在Debug模式下试图去执行这块未初始化的内存的话就会中断程序。

但VS中调试器默认的字符集是MBCS，而在MBCS中0xCCCC正好就是中文中的“烫”，所以显
示出来就都是烫……

如果是用分配堆的内存，会初始化成0xCD，0xCDCD在MBCS字符集中就是屯……

锟斤拷则涉及unicode的字符集转换问题，Unicode和老编码体系的转化过程中，肯定有一
些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：
U+FFFD REPLACEMENT CHARACTER。U+FFFD的UTF-8编码是0xEFBFBD，如果重复多次形成：E
FBFBDEFBFBDEFBFBD 这样

在GBK/CP936/GB2312/GB18030的环境（都是中国标准惹的祸）中显示的话，一个汉字2个字
节，最终的结果就是：锟斤拷――锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）
//------------------------------------------------------------------------------------------------
//网上找到的爬虫算法查找某个网址上的图片算法 http://blog.csdn.net/huangxy10/article/details/8120106 www.pdfshu.org/?pdf/924
//学习一下
//#include <Windows.h>  
#include <string>  
#include <iostream>  
#include <fstream>  
#include <vector>  
#include "winsock2.h"  
#include <time.h>  
#include <queue>  
#include <hash_set>  

#pragma comment(lib, "ws2_32.lib")   
using namespace std;  

#define DEFAULT_PAGE_BUF_SIZE 1048576  

queue<string> hrefUrl;  
hash_set<string> visitedUrl;  
hash_set<string> visitedImg;  
int depth=0;  
int g_ImgCnt=1;  

//解析URL，解析出主机名，资源名  
bool ParseURL( const string & url, string & host, string & resource){  
	if ( strlen(url.c_str()) > 2000 ) {  
		return false;  
	}  

	const char * pos = strstr( url.c_str(), "http://" );  
	if( pos==NULL ) pos = url.c_str();  
	else pos += strlen("http://");  
	if( strstr( pos, "/")==0 )  
		return false;  
	char pHost[100];  
	char pResource[2000];  
	sscanf( pos, "%[^/]%s", pHost, pResource );  
	host = pHost;  
	resource = pResource;  
	return true;  
}  

//使用Get请求，得到响应  
bool GetHttpResponse( const string & url, char * &response, int &bytesRead ){  
	string host, resource;  
	if(!ParseURL( url, host, resource )){  
		cout << "Can not parse the url"<<endl;  
		return false;  
	}  

	//建立socket  
	struct hostent * hp= gethostbyname( host.c_str() );  
	if( hp==NULL ){  
		cout<< "Can not find host address"<<endl;  
		return false;  
	}  

	SOCKET sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP);  
	if( sock == -1 || sock == -2 ){  
		cout << "Can not create sock."<<endl;  
		return false;  
	}  

	//建立服务器地址  
	SOCKADDR_IN sa;  
	sa.sin_family = AF_INET;  
	sa.sin_port = htons( 80 );  
	//char addr[5];  
	//memcpy( addr, hp->h_addr, 4 );  
	//sa.sin_addr.s_addr = inet_addr(hp->h_addr);  
	memcpy( &sa.sin_addr, hp->h_addr, 4 );  

	//建立连接  
	if( 0!= connect( sock, (SOCKADDR*)&sa, sizeof(sa) ) ){  
		cout << "Can not connect: "<< url <<endl;  
		closesocket(sock);  
		return false;  
	};  

	//准备发送数据  
	string request = "GET " + resource + " HTTP/1.1\r\nHost:" + host + "\r\nConnection:Close\r\n\r\n";  

	//发送数据  
	if( SOCKET_ERROR ==send( sock, request.c_str(), request.size(), 0 ) ){  
		cout << "send error" <<endl;  
		closesocket( sock );  
		return false;  
	}  

	//接收数据  
	int m_nContentLength = DEFAULT_PAGE_BUF_SIZE;  
	char *pageBuf = (char *)malloc(m_nContentLength);  
	memset(pageBuf, 0, m_nContentLength);  

	bytesRead = 0;  
	int ret = 1;  
	cout <<"Read: ";  
	while(ret > 0){  
		ret = recv(sock, pageBuf + bytesRead, m_nContentLength - bytesRead, 0);  

		if(ret > 0)  
		{  
			bytesRead += ret;  
		}  

		if( m_nContentLength - bytesRead<100){  
			cout << "\nRealloc memorry"<<endl;  
			m_nContentLength *=2;  
			pageBuf = (char*)realloc( pageBuf, m_nContentLength);       //重新分配内存  
		}  
		cout << ret <<" ";  
	}  
	cout <<endl;  

	pageBuf[bytesRead] = '\0';  
	response = pageBuf;  
	closesocket( sock );  
	return true;  
	//cout<< response <<endl;  
}  

//提取所有的URL以及图片URL  
void HTMLParse ( string & htmlResponse, vector<string> & imgurls, const string & host ){  
	//找所有连接，加入queue中  
	const char *p= htmlResponse.c_str();  
	char *tag="href=\"";  
	const char *pos = strstr( p, tag );  
	ofstream ofile("url.txt", ios::app);  
	while( pos ){  
		pos +=strlen(tag);  
		const char * nextQ = strstr( pos, "\"" );  
		if( nextQ ){  
			char * url = new char[ nextQ-pos+1 ];  
			//char url[100]; //固定大小的会发生缓冲区溢出的危险  
			sscanf( pos, "%[^\"]", url);  
			string surl = url;  // 转换成string类型，可以自动释放内存  
			if( visitedUrl.find( surl ) == visitedUrl.end() ){  
				visitedUrl.insert( surl );  
				ofile << surl<<endl;  
				hrefUrl.push( surl );  
			}  
			pos = strstr(pos, tag );  
			delete [] url;  // 释放掉申请的内存  
		}  
	}  
	ofile << endl << endl;  
	ofile.close();  

	tag ="<img ";  
	const char* att1= "src=\"";  
	const char* att2="lazy-src=\"";  
	const char *pos0 = strstr( p, tag );  
	while( pos0 ){  
		pos0 += strlen( tag );  
		const char* pos2 = strstr( pos0, att2 );  
		if( !pos2 || pos2 > strstr( pos0, ">") ) {  
			pos = strstr( pos0, att1);  
			if(!pos) {  
				pos0 = strstr(att1, tag );  
				continue;  
			} else {  
				pos = pos + strlen(att1);  
			}  
		}  
		else {  
			pos = pos2 + strlen(att2);  
		}  

		const char * nextQ = strstr( pos, "\"");  
		if( nextQ ){  
			char * url = new char[nextQ-pos+1];  
			sscanf( pos, "%[^\"]", url);  
			cout << url<<endl;  
			string imgUrl = url;  
			if( visitedImg.find( imgUrl ) == visitedImg.end() ){  
				visitedImg.insert( imgUrl );  
				imgurls.push_back( imgUrl );  
			}  
			pos0 = strstr(pos0, tag );  
			delete [] url;  
		}  
	}  
	cout << "end of Parse this html"<<endl;  
}  

//把URL转化为文件名  
string ToFileName( const string &url ){  
	string fileName;  
	fileName.resize( url.size());  
	int k=0;  
	for( int i=0; i<(int)url.size(); i++){  
		char ch = url[i];  
		if( ch!='\\'&&ch!='/'&&ch!=':'&&ch!='*'&&ch!='?'&&ch!='"'&&ch!='<'&&ch!='>'&&ch!='|')  
			fileName[k++]=ch;  
	}  
	return fileName.substr(0,k) + ".txt";  
}  

//下载图片到img文件夹  
void DownLoadImg( vector<string> & imgurls, const string &url ){  

	//生成保存该url下图片的文件夹  
	string foldname = ToFileName( url );  
	foldname = "./img/"+foldname;  
	if(!CreateDirectory( foldname.c_str(),NULL ))  
		cout << "Can not create directory:"<< foldname<<endl;  
	char *image;  
	int byteRead;  
	for( int i=0; i<imgurls.size(); i++){  
		//判断是否为图片，bmp，jgp，jpeg，gif   
		string str = imgurls[i];  
		int pos = str.find_last_of(".");  
		if( pos == string::npos )  
			continue;  
		else{  
			string ext = str.substr( pos+1, str.size()-pos-1 );  
			if( ext!="bmp"&& ext!="jpg" && ext!="jpeg"&& ext!="gif"&&ext!="png")  
				continue;  
		}  
		//下载其中的内容  
		if( GetHttpResponse(imgurls[i], image, byteRead)){  
			if ( strlen(image) ==0 ) {  
				continue;  
			}  
			const char *p=image;  
			const char * pos = strstr(p,"\r\n\r\n")+strlen("\r\n\r\n");  
			int index = imgurls[i].find_last_of("/");  
			if( index!=string::npos ){  
				string imgname = imgurls[i].substr( index , imgurls[i].size() );  
				ofstream ofile( foldname+imgname, ios::binary );  
				if( !ofile.is_open() )  
					continue;  
				cout <<g_ImgCnt++<< foldname+imgname<<endl;  
				ofile.write( pos, byteRead- (pos-p) );  
				ofile.close();  
			}  
			free(image);  
		}  
	}  
}  



//广度遍历  
void BFS( const string & url ){  
	char * response;  
	int bytes;  
	// 获取网页的相应，放入response中。  
	if( !GetHttpResponse( url, response, bytes ) ){  
		cout << "The url is wrong! ignore." << endl;  
		return;  
	}  
	string httpResponse=response;  
	free( response );  
	string filename = ToFileName( url );  
	ofstream ofile( "./html/"+filename );  
	if( ofile.is_open() ){  
		// 保存该网页的文本内容  
		ofile << httpResponse << endl;  
		ofile.close();  
	}  
	vector<string> imgurls;  
	//解析该网页的所有图片链接，放入imgurls里面  
	HTMLParse( httpResponse,  imgurls, url );  

	//下载所有的图片资源  
	DownLoadImg( imgurls, url );  
}  

void main()  
{  
	//初始化socket，用于tcp网络连接  
	WSADATA wsaData;  
	if( WSAStartup(MAKEWORD(2,2), &wsaData) != 0 ){  
		return;  
	}  

	// 创建文件夹，保存图片和网页文本文件  
	CreateDirectory( "./img",0);  
	CreateDirectory("./html",0);  
	//string urlStart = "http://hao.360.cn/meinvdaohang.html";  

	// 遍历的起始地址  
	//string urlStart = "http://www.wmpic.me/tupian";  
	string urlStart = "http://item.taobao.com/item.htm?spm=a230r.1.14.19.sBBNbz&id=36366887850&ns=1#detail";  

	// 使用广度遍历  
	// 提取网页中的超链接放入hrefUrl中，提取图片链接，下载图片。  
	BFS( urlStart );  

	// 访问过的网址保存起来  
	visitedUrl.insert( urlStart );  

	while( hrefUrl.size()!=0 ){  
		string url = hrefUrl.front();  // 从队列的最开始取出一个网址  
		cout << url << endl;  
		BFS( url );                   // 遍历提取出来的那个网页，找它里面的超链接网页放入hrefUrl，下载它里面的文本，图片  
		hrefUrl.pop();                 // 遍历完之后，删除这个网址  
	}  
	WSACleanup();  
	return;  
}
//------------------------------------------------------------------------------------------------
//检验一个IPv4字段是否合法。输入字符串两端可以有空格，字段中不可以有空格，字段中不可以有前置0，如1.02.3.4；字段全为0合法
#include <iostream>
#include <algorithm>
#include <iterator>
#include <locale>
#include <vector>
#include <functional>
#include <sstream>
using namespace std;

const int MaxIpLength = 15;

template<typename T>
void split(const string& s, const string& delimiters, T& container)
{
	size_t firstPos = 0;
	size_t secondPos = s.find(delimiters);
	size_t delimitersLength = delimiters.size();
	string temp;
	while (secondPos != string::npos)
	{
		temp = s.substr(firstPos, secondPos - firstPos);
		container.push_back(temp);
		firstPos = secondPos + delimitersLength;
		secondPos = s.find(delimiters, firstPos);
	}
	temp = s.substr(firstPos, secondPos - firstPos);
	container.push_back(temp);
}

//利用erase来实现的trim函数，进一步拆分可以得到ltrim函数和rtrim函数
void trim(::std::string& str)
{
	//left, ltrim
	str.erase(str.begin(), std::find_if(str.begin(), str.end(), std::not1(std::ptr_fun<int, int>(isspace))));
	//right, rtrim
	str.erase(std::find_if(str.rbegin(), str.rend(), std::not1(std::ptr_fun<int, int>(isspace))).base(), str.end());
}

int stringToInt(const string& s)
{
	char* offset;
	return strtol(s.c_str(), &offset, 10);
}

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

class CheckIpSegment
{
public:
	CheckIpSegment(): checkFlag_(true) { }

	void operator()(const string& ipSegment)
	{
		if (checkFlag_ == false)
		{
			return;
		}

		//has none-digit char
		if (find_if(ipSegment.begin(), ipSegment.end(), not1(ptr_fun(isdigit))) != ipSegment.end())
		{
			checkFlag_ = false;
			return;
		}

		//ipsegment not between(0, 255)
		int ipSegmentInt = stringToInt(ipSegment);
		if (ipSegmentInt > 255 || ipSegmentInt < 0)
		{
			checkFlag_ = false;
			return;
		}

		//has prefix zero or empty ""
		string ipSegmentStr = intToString(ipSegmentInt);
		if (ipSegmentStr.size() != ipSegment.size())
		{
			checkFlag_ = false;
			return;
		}
	}

	bool getCheckResult()
	{
		return checkFlag_;
	}

private:
	bool checkFlag_;
};

bool isIPAddressValid(const char* pszIPAddr)
{
	if (NULL == pszIPAddr)
	{
		return false;
	}

	string inputString(pszIPAddr);
	
	//erase head and tail space
	trim(inputString);

	if (inputString.size() > MaxIpLength)
	{
		return false;
	}

	//split the ipAddress by "."
	vector<string> ipVector;
	ipVector.reserve(4);
	split(inputString, ".", ipVector);

	if (ipVector.size() != 4)
	{
		return false;
	}

	return for_each(ipVector.begin(), ipVector.end(), CheckIpSegment()).getCheckResult();
}

int main()
{
	const char* s = "  0.0..0  ";
	cout << isIPAddressValid(s) << endl;
}
//------------------------------------------------------------------------------------------------
//小括号()匹配，给一个字符串，看其中的(和)是否个数能够完全匹配上
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
#include <sstream>
using namespace std;

const char FrontBracket = '(';
const char BackBracket = ')';

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

class BracketsChecker
{
private:
	typedef pair<char, string::size_type> BracketPositionPair;
	typedef stack<BracketPositionPair> BracketStack;
	typedef vector<pair<BracketPositionPair, BracketPositionPair> > MatchPairVector;

public:
	bool checkBrackets(const string& s)
	{
		BracketStackMaker bracketStackMaker(bracketStack_, matchPairVec_, errorMsg_);
		matchFlag_ = for_each(s.begin(), s.end(), bracketStackMaker).getCheckResult();
		return matchFlag_;
	}

	void printResult()
	{
		if (true == matchFlag_)
		{
			for_each(matchPairVec_.begin(), matchPairVec_.end(), [] (const pair<BracketPositionPair, BracketPositionPair>& matchPair)
			{
				const BracketPositionPair& frontBracketPair = matchPair.first;
				const BracketPositionPair& backBracketPair = matchPair.second;
				cout << string(1, FrontBracket) << " at position: " << frontBracketPair.second << " matches " << string(1, BackBracket) << " at position: " << backBracketPair.second << "\n";
			}
				);
		}
		else
		{
			cout << errorMsg_;
		}
	}

private:
	class BracketStackMaker
	{
	public:
		BracketStackMaker(BracketStack& bracketStack, MatchPairVector& matchPairVec, string& errorMsg)
			: bracketStack_(bracketStack), matchPairVec_(matchPairVec), errorFlag_(false), errorMsg_(errorMsg), pos_(0) 
		{

		}

		void operator()(char c)
		{
			if (hasErrorFlag())
			{
				return;
			}

			getAChar(c);
			++pos_;
		}

		bool getCheckResult()
		{
			bool bracketStackEmptyFlag = bracketStack_.empty();
			
			//make redundant ( errorMsg
			while (!bracketStack_.empty())
			{
				BracketPositionPair& bracketPositionPair = bracketStack_.top();
				errorMsg_ += string(1, FrontBracket) + " at position: " + intToString(bracketPositionPair.second) + " is redundant.\n";
				bracketStack_.pop();
			}
			
			return !hasErrorFlag() && bracketStackEmptyFlag;
		}

		string getErrorMsg()
		{
			return errorMsg_;
		}

	private:
		void getAChar(char c)
		{
			if (FrontBracket == c)
			{
				//push ( into stack
				bracketStack_.push(make_pair(FrontBracket, pos_));
			}
			else if (BackBracket == c)
			{
				//if the stack is empty
				if (bracketStack_.empty())
				{
					setErrorFlag();
					errorMsg_.assign(string(1, BackBracket) + " at position: " + intToString(pos_) + " is redundant.\n");
					return;
				}

				BracketPositionPair bracketPositionPair = bracketStack_.top();
				//if the stack is not empty, top must be (, then a match is found
				BracketPositionPair backBracketPositionPair = make_pair(BackBracket, pos_);
				matchPairVec_.push_back(make_pair(bracketPositionPair, backBracketPositionPair));
				bracketStack_.pop();
			}
		}

		bool hasErrorFlag()
		{
			return errorFlag_;
		}

		void setErrorFlag()
		{
			errorFlag_ = true;
		}
	private:
		BracketStack& bracketStack_;
		MatchPairVector& matchPairVec_;
		bool errorFlag_;
		string& errorMsg_;
		string::size_type pos_;
	};

private:
	BracketStack bracketStack_;
	MatchPairVector matchPairVec_;
	string errorMsg_;
	bool matchFlag_;
};

int main()
{
	string s("((3)()4)()");
	BracketsChecker bracketChecker;
	cout << bracketChecker.checkBrackets(s) << "\n";
	bracketChecker.printResult();
}
输出如下：
1
( at position: 1 matches ) at position: 3
( at position: 4 matches ) at position: 5
( at position: 0 matches ) at position: 7
( at position: 8 matches ) at position: 9
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//给n位不重复数字组成的所有字符串排序。给定一个字符串，得到它是第几个；给定一个数字，得到它对应的数字串是什么
//如3位数字，123，132，213，231，312，321对应分别为1，2，3，4，5，6
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <algorithm>
#include <sstream>
#include <iterator>
using namespace std;

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

//递归得到n的阶乘，这里没用到，开始想用vector::reserve的
long getFactorN(int n)
{
	if (n > 1)
	{
		return n * getFactorN(n - 1);
	}
	else if (1 == n)
	{
		return 1;
	}
	else
	{
		return -1;
	}
}

class CalcNLengthStringContainer
{
public:
	CalcNLengthStringContainer(set<string>& stringContainer): stringContainer_(stringContainer) { }
	void operator()(const string& s) const
	{
		int sLength = s.size();
		const string nNumberString = intToString(sLength + 1);
		for (int i = 0; i <= sLength; ++i)
		{
			string tempString(s);
			stringContainer_.insert(tempString.insert(i, nNumberString));
		}
	}
private:
	set<string>& stringContainer_;
};

//递归得到所有的n位字符串
set<string> getAllNBitsStringContainer(int n)
{
	if (n > 1)
	{
		//得到所有n-1位字符串
		set<string> nMinusOneLengthStringContainer(getAllNBitsStringContainer(n - 1)), nLengthStringContainer;
		
		//将每一个n-1位的字符串间隔处插入第n个数字，就得到了所有的n位字符串
		//[&] (const string& s) 这里不能加const，否则编译不过
		for_each(nMinusOneLengthStringContainer.begin(), nMinusOneLengthStringContainer.end(), [&] (const string& s)
		{
			int sLength = s.size();
			const string nNumberString = intToString(sLength + 1);
			for (int i = 0; i <= sLength; ++i)
			{
				string tempString(s);
				nLengthStringContainer.insert(tempString.insert(i, nNumberString));
			}
		}
		);//lambda表达式实现
		//for_each(nMinusOneLengthStringContainer.begin(), nMinusOneLengthStringContainer.end(), CalcNLengthStringContainer(nLengthStringContainer));//函数对象实现
		return nLengthStringContainer;
	}
	else if (1 == n)
	{
		set<string> oneLengthStringContainer;
		oneLengthStringContainer.insert("1");
		return oneLengthStringContainer;
	}
	else
	{
		return set<string>();
	}
}

void getNBitsSortContainer(int n, map<string, long>& stringLongMap, map<long, string>& longStringMap)
{
	set<string> nLengthStringContainer(getAllNBitsStringContainer(n));//得到n位排序的字符串
	//for_each(nLengthStringContainer.begin(), nLengthStringContainer.end(), [] (const string& s) {cout << s << endl;});//输出显示得到的n位排序字符串
	long posN = 1;
	for_each(nLengthStringContainer.begin(), nLengthStringContainer.end(), [&] (const string& s)
	{
		stringLongMap.insert(make_pair(s, posN));//得到字符串-顺序映射
		longStringMap.insert(make_pair(posN, s));//得到顺序-字符串映射
		posN++;
	}
	);

	//用tranform来插入，需要实现两遍，效率慢，不过可以看下在transform中使用lambda表达式与for_each的不同
	//transform(nLengthStringContainer.begin(), nLengthStringContainer.end(), inserter(stringLongMap, stringLongMap.begin()), [&] (const string& s)
	//{
	//	return make_pair(s, posN++);//tranform中需要返回一个pair，在for_each中直接操作捕获的map进行插入pair的操作
	//}
	//);
	//posN = 1;
	//transform(nLengthStringContainer.begin(), nLengthStringContainer.end(), inserter(longStringMap, longStringMap.begin()), [&] (const string& s)
	//{
	//	return make_pair(posN++, s);
	//}
	//);
}

int main()
{
	map<string, long> stringLongMap;
	map<long, string> longStringMap;
	getNBitsSortContainer(5, stringLongMap, longStringMap);//一直到6!速度还可以，再往上就比较慢了，还有什么好方法吗？
}

//From Liulongjun，不太懂，需要讲解一下
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

class Solution {
public:
	static int getSortIndex(string& str)
	{
		if(str.size() == 1)
		{
			return 1;
		}
		string tmpStr = str;
		sort(tmpStr.begin(),tmpStr.end());
		string::size_type pos = 0; 
		for(; pos < tmpStr.size(); pos++)
		{
			if(str[0] == tmpStr[pos])
			{
				break;
			}
		}
		int result = pos*getNum(str.size()-1);
		tmpStr = str.substr(1,str.size()-1);
		return result + getSortIndex(tmpStr);
	}
private:
	static int getNum(int num)
	{
		if(num == 1 || num == 0)
		{
			return 1;
		}
		return num*getNum(num-1);
	}
};

int main()
{
	string s("4231");
	cout << Solution::getSortIndex(s) << endl;
}
//------------------------------------------------------------------------------------------------
//兄弟单词维护
//任意交换两个字母顺序所组成的不同单词叫兄弟单词
//输入只由小写字母组成，字典中单词个数[0, 1000]，单词字母数[1, 50]，输入保证这两个限制
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <map>
#include <set>
using namespace std;

class BrotherWordsManager
{
private:
	typedef string BaseWord;
	typedef set<string> BrotherWordsContainer;
	typedef map<const BaseWord, BrotherWordsContainer> AllBrotherWordsMap;

public:
	int addOneWord(const string& word)
	{
		string baseWord(getBaseWord(word));
		AllBrotherWordsMap::iterator iter(allBrotherWordsMap_.find(baseWord));
		
		if (iter == allBrotherWordsMap_.end())//not find base word
		{
			BrotherWordsContainer newBrotherWordsContainer;
			newBrotherWordsContainer.insert(word);
			allBrotherWordsMap_.insert(make_pair(baseWord, newBrotherWordsContainer));
			return 0;
		}
		else//find base word
		{
			BrotherWordsContainer& brotherWordsContainer((*iter).second);
			if (brotherWordsContainer.find(word) == brotherWordsContainer.end())//not find the word
			{
				brotherWordsContainer.insert(word);
				return 0;
			}
			else//find the word
			{
				return -1;
			}
		}
	}

	int findSimilarWordNum(const string& word)
	{
		string baseWord(getBaseWord(word));
		AllBrotherWordsMap::iterator iter(allBrotherWordsMap_.find(baseWord));

		if (iter == allBrotherWordsMap_.end())
		{
			return 0;
		}
		else
		{
			BrotherWordsContainer& brotherWordsContainer((*iter).second);
			size_t allWordsNumber(brotherWordsContainer.size());
			return brotherWordsContainer.find(word) == brotherWordsContainer.end() ? allWordsNumber : allWordsNumber - 1;
		}
	}

	int findOneSimilarWord(const string& word, int seq, string& similarWord)
	{
		string baseWord(getBaseWord(word));
		AllBrotherWordsMap::iterator iter(allBrotherWordsMap_.find(baseWord));

		if (iter == allBrotherWordsMap_.end())//not find the base word
		{
			similarWord.assign("");
			return -1;
		}
		else//find the base word
		{
			BrotherWordsContainer brotherWordsContainer((*iter).second);
			brotherWordsContainer.erase(word);//the word itself does not belong to the brother words sequence
			if (seq < 1 || seq > static_cast<int>(brotherWordsContainer.size()))//seq is not valid
			{
				similarWord.assign("");
				return -1;
			}
			else//seq is valid
			{
				BrotherWordsContainer::iterator iter(brotherWordsContainer.begin());
				advance(iter, seq - 1);
				similarWord.assign(*iter);//get the brother word according to the seq
				return 0;
			}
		}
	}

	void clearAllWords()
	{
		allBrotherWordsMap_.clear();
	}

private:
	string getBaseWord(string word)
	{
		sort(word.begin(), word.end());
		return word;
	}

private:
	AllBrotherWordsMap allBrotherWordsMap_;
};

BrotherWordsManager brotherWordsManager;

int AddOneWord(char* Word)
{
	return brotherWordsManager.addOneWord(Word);
}

int FindSimilarWordNum(char* Word)
{
	return brotherWordsManager.findSimilarWordNum(Word);
}

int FindOneSimilarWord(char* Word, int Seq, char* SimilarWord)
{
	string similarWordString;
	int retValue = brotherWordsManager.findOneSimilarWord(Word, Seq, similarWordString);
	if (retValue != -1)
	{
		strncpy(SimilarWord, similarWordString.c_str(), similarWordString.size() + 1);
	}
	return retValue;
}

void ClearAllWords()
{
	brotherWordsManager.clearAllWords();
}

int main(int argc, char* argv[])
{
	char* Test_Word[7] = {"mock", "aabc", "abc", "ckom", "bcaa", "abca", "ppp"};
	for (int i = 0; i < 7; ++i)
	{
		AddOneWord(Test_Word[i]);
	}
	
	cout << FindSimilarWordNum(Test_Word[6]) << "\n";

	char SimilarWord[50] = {'\0'};
	cout << FindOneSimilarWord(Test_Word[1], 2, SimilarWord) << "\n";
	cout << SimilarWord << endl;
}
//------------------------------------------------------------------------------------------------
//不区分大小写，查找连续出现字母模块的最大数量，跳过非字母字符，如a!a识别为aa
//函数原型为 int Count(char* input);
//例：abb abbA返回3
#include <iostream>
#include <algorithm>
#include <string>
#include <cctype>
#include <functional>
#include <set>
#include <vector>
using namespace std;

class CountContinuous
{
public:
	CountContinuous(set<string>& stringVec, vector<string>& splitStringContainer): 
		continuousStringContainer_(stringVec), 
		splitStringContainer_(splitStringContainer),
		lastAlpha_(0) 
	{
	
	}

	void operator()(const char c)
	{
		char currentChar = tolower(c);
		bool currentCharIsAlpha = isalpha(c);
		if (currentCharIsAlpha && lastAlpha_ == currentChar)
		{
			continuousString_.append(1, currentChar);
		}
		else if (currentCharIsAlpha && lastAlpha_ != currentChar)
		{
			if (0 == lastAlpha_)
			{
				lastAlpha_ = currentChar;
				continuousString_.assign(1, currentChar);
			}
			else
			{
				pushBackContinuouString();
				lastAlpha_ = currentChar;
				continuousString_.assign(1, currentChar);
			}	
		}
	}

	void pushBackContinuouString()
	{
		continuousStringContainer_.insert(continuousString_);
		splitStringContainer_.push_back(continuousString_);
	}

private:
	set<string>& continuousStringContainer_;
	vector<string>& splitStringContainer_;
	char lastAlpha_;
	string continuousString_;
};

class CountMaxString
{
public:
	CountMaxString(vector<string>& splitStringContainer): splitStringContainer_(splitStringContainer) { }
	
	void operator()(const string& s)
	{
		sameStringNumberSet_.insert(count(splitStringContainer_.begin(), splitStringContainer_.end(), s));
	}
	
	operator int ()
	{
		return *sameStringNumberSet_.begin();
	}

private:
	vector<string>& splitStringContainer_;
	set<int, greater<int> > sameStringNumberSet_;
};

int Count(char* input)
{
	string inputString(input);
	set<string> continuousStringContainer;
	vector<string> splitStringContainer;
	
	//开始想的去掉非字母的操作和全部转换成小写的操作，后去掉了，在一个for_each中即可全部完成，提高处理效率
	//inputString.erase(remove_if(inputString.begin(), inputString.end(), not1(ptr_fun(isalpha))), inputString.end());
	//transform(inputString.begin(), inputString.end(), inputString.begin(), tolower);
	for_each(inputString.begin(), inputString.end(), CountContinuous(continuousStringContainer, splitStringContainer)).pushBackContinuouString();

	//for_each(continuousStringContainer.begin(), continuousStringContainer.end(), [] (const string& s) {cout << s << " ";});
	//cout << endl;
	//for_each(splitStringContainer.begin(), splitStringContainer.end(), [] (const string& s) {cout << s << " ";});
	//cout << endl;
	return for_each(continuousStringContainer.begin(), continuousStringContainer.end(), CountMaxString(splitStringContainer));
}

int main()
{
	cout << Count("abb abbA!ac   bcaaacdc") << endl;
}
//------------------------------------------------------------------------------------------------
//新auto类型使用，http://blog.csdn.net/huang_xw/article/details/8760403
#include <iostream>
#include <string>
#include <typeinfo>
using namespace std;

const int elementCount = 9;

int main() 
{
	auto a("hello");
	cout << a << endl;
	cout << typeid(a).name() << endl;
}
输出如下：
hello
char const *
请按任意键继续. . .

//【C++11】新特性――auto的使用
//C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。
1. 自动类型推断
auto自动类型推断，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推断，可以大大简化我们的编程工作。下面是一些使用auto的例子。
#include <vector>  
#include <map>  
  
using namespace std;  
  
int main(int argc, char *argv[], char *env[])  
{  
//  auto a;                 // 错误，没有初始化表达式，无法推断出a的类型  
//  auto int a = 10;        // 错误，auto临时变量的语义在C++11中已不存在, 这是旧标准的用法。  
  
    // 1. 自动帮助推导类型  
    auto a = 10;  
    auto c = 'A';  
    auto s("hello");  
  
    // 2. 类型冗长  
    map<int, map<int,int> > map_;  
    map<int, map<int,int>>::const_iterator itr1 = map_.begin();  
    const auto itr2 = map_.begin();  
    auto ptr = []()  
    {  
        std::cout << "hello world" << std::endl;  
    };  
  
    return 0;  
};  
  
// 3. 使用模板技术时，如果某个变量的类型依赖于模板参数，  
// 不使用auto将很难确定变量的类型（使用auto后，将由编译器自动进行确定）。  
template <class T, class U>  
void Multiply(T t, U u)  
{  
    auto v = t * u;  
}  

2. 返回值占位
template <typename T1, typename T2>  
auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)  
{  
   return t1+t2;  
}  
auto v = compose(2, 3.14); // v's type is double  

3.使用注意事项
①我们可以使用valatile，pointer（*），reference（&），rvalue reference（&&） 来修饰auto
auto k = 5;  
auto* pK = new auto(k);  
auto** ppK = new auto(&k);  
const auto n = 6;  

②用auto声明的变量必须初始化
auto m; // m should be intialized    

③auto不能与其他类型组合连用
auto int p; // 这是旧auto的做法。  

④函数和模板参数不能被声明为auto
void MyFunction(auto parameter){} // no auto as method argument  
  
template<auto T> // utter nonsense - not allowed  
void Fun(T t){}  

⑤定义在堆上的变量，使用了auto的表达式必须被初始化
int* p = new auto(0); //fine  
int* pp = new auto(); // should be initialized  
   
auto x = new auto(); // Hmmm ... no intializer  
     
auto* y = new auto(9); // Fine. Here y is a int*  
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)  

⑥以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid
int value = 123;  
auto x2 = (auto)value; // no casting using auto  
  
auto x3 = static_cast<auto>(value); // same as above   

⑦定义在一个auto序列的变量必须始终推导成同一类型
auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this  

⑧auto不能自动推导成CV-qualifiers（constant & volatile qualifiers），除非被声明为引用类型
const int i = 99;  
auto j = i;       // j is int, rather than const int  
j = 100           // Fine. As j is not constant  
  
// Now let us try to have reference  
auto& k = i;      // Now k is const int&  
k = 100;          // Error. k is constant  
  
// Similarly with volatile qualifer  

⑨auto会退化成指向数组的指针，除非被声明为引用
int a[9];  
auto j = a;  
cout<<typeid(j).name()<<endl; // This will print int*  
  
auto& k = a;  
cout<<typeid(k).name()<<endl; // This will print int [9]  
//------------------------------------------------------------------------------------------------
//用已经构造好的auto_ptr对象再次构造一个新的auto_ptr对象，用*取出构造对象。这种使用场景在需要部分改变对象值的时候比较有用，而不用完全新构造对象。
#include <iostream>
#include <string>
#include <memory>
using namespace std;

struct Test
{
	int i;
	string s;
};

int main()
{
	auto_ptr<Test> pToTest(new Test);
	pToTest->i = 1;
	pToTest->s = "hello";

	auto_ptr<Test> pToTest2(new Test(*pToTest));
	pToTest2->i = 2;
	pToTest2->s = "world";

	cout << pToTest->i << endl;
	cout << pToTest2->i << endl;
}
//------------------------------------------------------------------------------------------------
//const指针
const int* p;和int const* p;这两个指针是被指向的int变量不可改变，指针可以改变。
int* const p;这个指针不可改变，必须是初始化时把指针指向的地址赋值好，之后不可再改变了（跟变量引用一样int& a;，必须在初始化时赋值）。
const int* const p;这个指针是指针不可改变，指向的变量也不可改变。
//------------------------------------------------------------------------------------------------
//公司的检查BoardNo是否有重复值的部分代码
#include <iostream>
#include <string>
#include <set>
#include <map>
#include <vector>
//using namespace std; 

class BoardNoChecker
{
public:
	void preAttrNode(const std::string& mocName, const std::string& boardNo, const std::string& pos)
	{
		boardNoSet_.insert(boardNo);
		boardNoPosMap_.insert(make_pair(boardNo, pos));
	}
	
	bool valid()
	{
		bool flag = true;//boardNo is valid or not 
		std::vector<std::string> errorInfoVec;
		for(BNCIterator iter = boardNoSet_.begin(); iter != boardNoSet_.end(); ++iter)
		{
			if (checkEachBoardNo(*iter, errorInfoVec) && flag)
			{
				flag = false;
			}
		}
	}

private:
	bool checkEachBoardNo(const std::string& boardNo, std::vector<std::string>& errorInfoVec)
	{
		bool hasSameBoardNoFlag = false;
		std::pair<BNPCIterator, BNPCIterator> retPairIter = boardNoPosMap_.equal_range(boardNo);
		for (BNPCIterator sameBoardNoIter = retPairIter.first; sameBoardNoIter != retPairIter.second; ++sameBoardNoIter)
		{
			hasSameBoardNoFlag = true;
		}
	}

private:
	typedef std::set<std::string> BoardNoContainer;
	typedef BoardNoContainer::iterator BNCIterator;
	BoardNoContainer boardNoSet_;

	typedef std::multimap<std::string, std::string> BoardNoPosContainer;
	typedef BoardNoPosContainer::iterator BNPCIterator;
	BoardNoPosContainer boardNoPosMap_;
};

int main( ) 
{

}

//可以对Value值为某个容器的Map的Value进行填加对象操作，如下：
#include <iostream>
#include <string>
#include <map>
#include <list>

int main( ) 
{
	typedef std::map<std::string, std::list<std::string> > StringListMap;
	StringListMap stringlistMap;
	stringlistMap["a"] = std::list<std::string>();
	StringListMap::iterator iter = stringlistMap.find("a");
	std::list<std::string>& stringList = iter->second;//得到List
	stringList.push_back("aaaaaaaa");//为List填加值
	iter = stringlistMap.begin();
	std::cout << iter->first << std::endl;//显示"a"
	std::cout << iter->second.front() << std::endl;//显示"aaaaaaaa"
}
//------------------------------------------------------------------------------------------------
//数组赋值，只能一个一个赋值，而不能初始时给所有赋值
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;

int main() 
{
	int intArray[20] = {1};
	copy(intArray, intArray + 20, ostream_iterator<int>(cout, " "));

	//char str[20] = "abc";//字符数据可以这样赋值
	char str[20] = {'a', 'b', 'c', 0};//也可以这样赋值，同上，或{'a', 'b', 'c', '\0'}，之后不能str = "abc"这样赋值，只能一位一位赋值
	cout << str << endl;
	return 0;
}
输出如下：
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 abc
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//参考strtok写的split函数，参见模板函数的内联“//模板的内嵌”
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <list>
#include <iterator>
using namespace std;

template<typename T>
bool split(const string& s, const string& delimiters, T& container)
{
	if (s.empty())
	{
		return false;
	}
	else
	{
		try
		{
			long unsigned length = s.size() + 1;
			char* str = new char[length];
			strncpy(str, s.c_str(), length);

			length = delimiters.size() + 1;
			char* charStarDelimiters = new char[length];
			strncpy(charStarDelimiters, delimiters.c_str(), length);

			char* pch;
			pch = strtok(str, charStarDelimiters);
			while (NULL != pch)
			{
				container.push_back(pch);
				pch = strtok(NULL, charStarDelimiters);
			}

			delete [] charStarDelimiters;
			charStarDelimiters = 0;
			delete [] str;
			str = 0;
			
			return true;
		}
		catch(...)
		{
			return false;
		}
	}
}

int main() 
{
	vector<string> stringVec;
	string s("This is a sample string.\nIt is a nice day.\nHow are you?\n");
	string delimiters("\n");
	if (split(s, delimiters, stringVec))
	{
		copy(stringVec.begin(), stringVec.end(), ostream_iterator<string>(cout, "\n"));
	}	
	return 0;
}
输出如下：
This is a sample string.
It is a nice day.
How are you?
请按任意键继续. . .

//--不想自己管理new出来的对象，改用auto_ptr管理对象
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
#include <list>
#include <iterator>
#include <memory>
using namespace std;

template<typename T>
bool split(const string& s, const string& delimiters, T& container)
{
	if (s.empty())
	{
		return false;
	}
	else
	{
		try
		{
			long unsigned length = s.size() + 1;
			auto_ptr<char> pStr(new char[length]);
			char* str = pStr.get();//是否可以这样使用？
			strncpy(str, s.c_str(), length);

			length = delimiters.size() + 1;
			auto_ptr<char> pDelimiters(new char[length]);
			char* charStarDelimiters = pDelimiters.get();
			strncpy(charStarDelimiters, delimiters.c_str(), length);

			char* pch;
			pch = strtok(str, charStarDelimiters);
			while (NULL != pch)
			{
				container.push_back(pch);
				pch = strtok(NULL, charStarDelimiters);
			}

			return true;
		}
		catch(...)
		{
			return false;
		}
	}
}

int main() 
{
	vector<string> stringVec;
	string s("This is a sample string.\nIt is a nice day.\nHow are you?\n");
	string delimiters("\n");
	if (split(s, delimiters, stringVec))
	{
		copy(stringVec.begin(), stringVec.end(), ostream_iterator<string>(cout, "\n"));
	}	
	return 0;
}

//上面的C函数strtok无法处理分隔符处于最后的形式，如abc;def;这种字符串将被分隔成abc-def。
//用string的成员函数重新写的分隔函数，可以处理abc;def;这种形式的字符串，将分隔成abc-def-""。
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

template<typename T>
void split(const string& s, const string& delimiters, T& container)
{
	size_t firstPos = 0;
	size_t secondPos = s.find(delimiters);
	size_t delimitersLength = delimiters.size();
	string temp;
	while (secondPos != string::npos)
	{
		temp = s.substr(firstPos, secondPos - firstPos);
		container.push_back(temp);
		firstPos = secondPos + delimitersLength;
		secondPos = s.find(delimiters, firstPos);
	}
	temp = s.substr(firstPos, secondPos - firstPos);
	container.push_back(temp);
}

int main()
{
	vector<string> stringVec;
	string s("abc;:;def:");
	split(s, ":;", stringVec);
	for_each(stringVec.begin(), stringVec.end(), [] (const string& s) {cout << s << endl;});
}

//--分隔函数strtok
#include <iostream>
#include <cstring>
using namespace std;

int main() 
{
	char* srcStr ="- This, a sample string.";
	char* str = new char[100];//char str[] = "- This, a sample string.";
	strncpy(str, srcStr, 30);
	char * pch;
	printf ("Splitting string \"%s\" into tokens:\n",str);
	pch = strtok (str," ,.-");
	while (pch != NULL)
	{
		printf ("%s\n",pch);
		pch = strtok (NULL, " ,.-");
	}
	delete [] str;
	return 0;
}

//参考VBA中的replace函数写的，string类型的replace函数代码
#include <iostream>
#include <string>

void stringReplace(std::string& srcString, const std::string& oldString, const std::string& newString, size_t startPos = 0, int count = -1)
{
	size_t pos = srcString.find(oldString, startPos);
	while (std::string::npos != pos && count-- != 0)
	{
		srcString.replace(pos, oldString.size(), newString);
		pos = srcString.find(oldString, pos);
	}
}

void main()
{
	std::string s("abc(n)333(n)");
	stringReplace(s, "(n)", "N", 3, 1);
	std::cout << s << std::endl;
}
//------------------------------------------------------------------------------------------------
//指针和引用差别
1、有空指针，但没有“空引用”
2、有指针的指针，但没有引用的引用
3、有函数指针，但没有函数的引用
4、有指针数组，但没有引用的数组
5、指针有 void * 类型，引用就傻眼了。
====================================================================
下面是可以用引用，但不能用指针的：
1、const 引用可以绑定到右值(rvalue)，而指针必须指向一个地址。
example:
1.1）const int &r = 0; // 初始化为常量
1.2）c++ 类中常用的，用 const 引用引用到临时对象
====================================================================
再说一个 const 引用跟 const 指针行为不同的：
绑定到不同类型时，const 引用会绑定到临时变量上，而对指针则不是：
上代码：

int main()
{
    float f = 0.0;
    const int *p = (const int *)&f;  // 不同类型的指针绑定
    const int &r = f;                // 不同类型的引用绑定
    cout << (int)f << " " << *p << " " << r << endl;
    f = 1.0;
    cout << (int)f << " " << *p << " " << r << endl;
}

改变了 f 的值之后，*p 的值改变了，而 r 的值还是 0.
因为在 r 实际上绑定到了一个值为 0 的 int 类型的 tmp 对象上去了。
//------------------------------------------------------------------------------------------------
//查找用数字5分隔的数字字符串，并排序输出
#include <iostream>
#include <string>
#include <set>
#include <cctype>
#include <algorithm>
#include <xfunctional>
#include <numeric>
using namespace std;

const size_t MAXLENGTH = 8;

long int stringToLInt(const string& s)
{
	char* offset;
	return strtol(s.c_str(), &offset, 10);
}

class CompareTwoNumberString
{
public:
	bool operator()(const string& lhs, const string& rhs) const
	{
		return stringToLInt(lhs) > stringToLInt(rhs);
	}
};

class FindADight: public unary_function<char, bool>
{
public:
	bool operator()(char c) const
	{
		return isdigit(c) ? true : false;
	}
};

class MakeOutputString
{
public:
	MakeOutputString(const string& delimiterString): delimiterString_(delimiterString) { }
	string operator()(const string& outputString, const string& eachString) const
	{
		return outputString + eachString + delimiterString_;
	}

private:
	string delimiterString_;
};

bool makeStringSet(string inputString, multiset<string, CompareTwoNumberString>& stringSet)
{
	//string eraseString("05");
	string tempString;

	char delimiterChar('5');

	inputString.append(1, delimiterChar);

	inputString.erase(0, inputString.find_first_not_of(delimiterChar));
	size_t pos = inputString.find(delimiterChar);

	while (string::npos != pos)
	{
		tempString = inputString.substr(0, pos);
		tempString.erase(0, tempString.find_first_not_of('0'));
		if (tempString.empty())
		{
			tempString = "0";
		}
		else if (tempString.size() > MAXLENGTH)
		{
			return false;
		}
		stringSet.insert(tempString);
		
		inputString = inputString.substr(pos + 1);

		inputString.erase(0, inputString.find_first_not_of(delimiterChar));
		pos = inputString.find(delimiterChar);
	}
	return true;
}

void getOutputString(multiset<string, CompareTwoNumberString>& lIntSet, string& output)
{
	output.clear();
	output = accumulate(lIntSet.begin(), lIntSet.end(), output, MakeOutputString(" "));
	output.erase(output.size() - 1);
}

int GetSortNum(const std::string& input, std::string& output)
{
	if (input.size() > 999 || input.empty())
	{
		return -1;
	}
	if (input.end() == find_if(input.begin(), input.end(), bind2nd(not_equal_to<char>(), '5')))
	{
		return -1;
	}
	if (input.end() != find_if(input.begin(), input.end(), not1(FindADight())))
	{
		return -1;
	}

	multiset<string, CompareTwoNumberString> lIntSet;
	if (!makeStringSet(input, lIntSet))
	{
		return -1;
	}

	getOutputString(lIntSet, output);
	return 0;
}

int main() 
{
	string input("0078505555000123505004559999998955000432155");
	string output;
	cout << GetSortNum(input, output) << endl;
	cout << output << endl;
	/*long int n = 100000000;
	cout << n << endl;*/
}
//------------------------------------------------------------------------------------------------
//将用空格分隔的字符串用stringstream分别输入到单个string中
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
using namespace std;

int main() 
{
	string s("hello world good luck");
	stringstream ss;
	ss << s;
	vector<string> stringVec;
	s.clear();
	ss >> s;
	while (!s.empty())
	{
		stringVec.push_back(s);
		s.clear();
		ss >> s;
	}
	return 0;
}

//开放的书名检索
#include <iostream>
#include <sstream>
#include <string>
#include <set>
#include <cstring>
#include <algorithm>
using namespace std;

void makeStringSet(string condition, set<string>& conditionStringSet)//这里因为需要改变condition的值，所以故意构造的临时变量，而没有引用&
{
	stringstream ss;
	ss << condition;
	condition.clear();
	ss >> condition;
	while (!condition.empty())
	{
		conditionStringSet.insert(condition);
		condition.clear();
		ss >> condition;
	}
}

class MakeSearchResult
{
public:
	MakeSearchResult(set<string>& conditionStringSet, int* pNumber, char* result[200]):
	conditionStringSet_(conditionStringSet), pNumber_(pNumber), result_(result) 
	{
		*pNumber_ = 0;
	}
	void operator()(const string& bookName)
	{
		set<string> tempBookNameStringSet;
		makeStringSet(bookName, tempBookNameStringSet);
		if (includes(tempBookNameStringSet.begin(), tempBookNameStringSet.end(), conditionStringSet_.begin(), conditionStringSet_.end()))
		{
			strncpy(result_[*pNumber_], bookName.c_str(), bookName.size() + 1);
			++(*pNumber_);
		}
	}
private:
	set<string>& conditionStringSet_;
	int* pNumber_;
	char** result_;//二维数组的引用
};

set<string> bookNameSet;

int AddBook(char* bookName)
{
	if (0 == bookName)
	{
		return -1;
	}
	bookNameSet.insert(bookName);
	return 0;
}

int ListAllBook(int* pNumber, char* result[200])
{
	if (0 == pNumber)
	{
		return -1;
	}

	*pNumber = bookNameSet.size();
	int i = 0;
	for (set<string>::iterator iter = bookNameSet.begin(); iter != bookNameSet.end(); ++iter, ++i)
	{
		strncpy(result[i], (*iter).c_str(), (*iter).size() + 1);
	}

	return 0;
}

int SearchBooks(char* condition, int* pNumber, char* result[200])
{
	if (0 == condition || 0 == pNumber)
	{
		return -1;
	}

	set<string> conditionStringSet;
	makeStringSet(condition, conditionStringSet);
	for_each(bookNameSet.begin(), bookNameSet.end(), MakeSearchResult(conditionStringSet, pNumber, result));
	return 0;
}

int ClearAllBooks()
{
	bookNameSet.clear();
	return 0;
}

int main() 
{
	AddBook("hello how are you");
	AddBook("world nice day you look good are");
	AddBook("hello good luck day you");

	char* result[200];
	for (int i = 0; i < 200; ++i)
	{
		result[i] = new char[100];
	}
	int number;
	//ListAllBook(&number, result);
	SearchBooks("you are", &number, result);

	for (int i = 0; i < 200; ++i)
	{
		delete [] result[i];
	}
}
//------------------------------------------------------------------------------------------------
//--http://blog.csdn.net/sibo626/article/details/6947004 wstring使用
#include <iostream>  
#include <string>  
using namespace std;  

#define tab "\t"  

int main()  
{  
	locale def;  
	cout<<def.name()<<endl;  
	locale current = cout.getloc();  
	cout<<current.name()<<endl;  

	double val=1234.56;  
	cout<<val<<endl;  

	//chage to french/france  
	cout.imbue(locale("chs"));  
	current=cout.getloc();  
	cout<<current.name()<<endl;  
	cout<<val<<endl;  

	//上面是说明locale的用法，下面才是本例的内容，因为其中用到了imbue函数  
	cout<<"*********************************"<<endl;  

	//为了保证本地化输出（文字/时间/货币等），chs表示中国，wcout必须使用本地化解析编码  
	wcout.imbue(std::locale("chs"));  

	//string 英文，正确颠倒位置，显示第二个字符正确  
	string str1("ABCabc");  
	string str11(str1.rbegin(),str1.rend());  
	cout<<"UK\ts1\t:"<<str1<<tab<<str1[1]<<tab<<str11<<endl;  

	//wstring 英文，正确颠倒位置，显示第二个字符正确  
	wstring str2=L"ABCabc";  
	wstring str22(str2.rbegin(),str2.rend());  
	wcout<<"UK\tws4\t:"<<str2<<tab<<str2[1]<<tab<<str22<<endl;  

	//string 中文，颠倒后，变成乱码，第二个字符读取也错误  
	string str3("你好么？");  
	string str33(str3.rbegin(),str3.rend());  
	cout<<"CHN\ts3\t:"<<str3<<tab<<str3[1]<<tab<<str33<<endl;  

	//正确的打印第二个字符的方法  
	cout<<"CHN\ts3\t:RIGHT\t"<<str3[2]<<str3[3]<<endl;  

	//中文，正确颠倒位置，显示第二个字符正确  
	wstring str4=L"你好么？";  
	wstring str44(str4.rbegin(),str4.rend());  
	wcout<<"CHN\tws4\t:"<<str4<<tab<<str4[1]<<tab<<str44<<endl;  

	wstring str5(str1.begin(),str1.end());//只有char类型的string时才可以如此构造  
	wstring str55(str5.rbegin(),str5.rend());  
	wcout<<"CHN\tws5\t:"<<str5<<tab<<str5[1]<<tab<<str55<<endl;  

	wstring str6(str3.begin(),str3.end());//如此构造将失败!!!!  
	wstring str66(str6.rbegin(),str6.rend());  
	wcout<<"CHN\tws6\t:"<<str6<<tab<<str6[1]<<tab<<str66<<endl;  

	return 0;  
}  
输出如下：
C
C
1234.56
Chinese (Simplified)_People's Republic of China.936
1,234.56
*********************************
UK      s1      :ABCabc B       cbaCBA
UK      ws4     :ABCabc B       cbaCBA
CHN     s3      :你好么？               浚疵煤隳
CHN     s3      :RIGHT  好
CHN     ws4     :你好么？       好      ？么好你
CHN     ws5     :ABCabc B       cbaCBA
CHN     ws6     :请按任意键继续. . .

//--string与wstring的互相转换
#include <iostream>
#include <string>
using namespace std;

std::string ws2s(const std::wstring& ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1;
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}

std::wstring s2ws(const std::string& s)
{
	setlocale(LC_ALL, "chs"); 
	const char* _Source = s.c_str();
	size_t _Dsize = s.size() + 1;
	wchar_t *_Dest = new wchar_t[_Dsize];
	wmemset(_Dest, 0, _Dsize);
	mbstowcs(_Dest,_Source,_Dsize);
	std::wstring result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, "C");
	return result;
}

int main() 
{
	wchar_t* str1 = L"Hello, 你好吗？";
	wcout.imbue(std::locale("chs")); 
	//wstring wStr1 = L"你好吗";//(str1);
	wstring wString1(str1);
	wcout << wString1 << endl;

	char* str2 = "World, 我很好。";
	string string2(str2);
	wstring wString2 = s2ws(string2);
	cout << string2 << endl;
	wcout << wString2 << endl;
}

//--判断每个字符是否是ANSI字符
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

class WideCharIsAnsi
{
public:
	void operator()(wchar_t wc) const
	{
		if (wc >= 0 && wc <= 127)
		{
			cout << "ANSI char." << endl;
		}
		else
		{
			cout << "Not ANSI char." << endl;
		}
	}
};

class CharIsAnsi
{
public:
	void operator()(char c) const
	{
		if (c >= 0 && c <= 127)
		{
			cout << "ANSI char." << endl;
		}
		else
		{
			cout << "Not ANSI char." << endl;
		}
	}
};

int main() 
{
	wcout.imbue(locale("chs")); 
	wstring wString1 = L"hi, 你好吗？";
	cout << wString1.size() << endl;
	wcout << wString1 << endl;
	for_each(wString1.begin(), wString1.end(), WideCharIsAnsi());

	string string2("hi, 你好吗？");
	cout << string2.size() << endl;
	cout << string2 << endl;
	for_each(string2.begin(), string2.end(), CharIsAnsi());
}
输出如下：
8
hi, 你好吗？
ANSI char.
ANSI char.
ANSI char.
ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
12
hi, 你好吗？
ANSI char.
ANSI char.
ANSI char.
ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
Not ANSI char.
请按任意键继续. . .

//--查找最长子串，string
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
using namespace std;

class SortStringByLength
{
public:
	bool operator()(const string& lhs, const string& rhs) const
	{
		return lhs.size() > rhs.size();
	}
};

void makeMatchVector(string& s1, string& s2, vector<string>& stringVec)
{
	string::iterator startIterOfStr2 = s2.begin();
	string::iterator endIterOfStr2 = s2.begin();
	for (; startIterOfStr2 != s2.end(); ++startIterOfStr2)
	{
		for (endIterOfStr2 = startIterOfStr2 + 1; ; ++endIterOfStr2)
		{
			string::iterator iter = search(s1.begin(), s1.end(), startIterOfStr2, endIterOfStr2);
			if (s1.end() != iter)
			{
				stringVec.push_back(string(startIterOfStr2, endIterOfStr2));
			}
			if (endIterOfStr2 == s2.end())
			{
				break;
			}
		}
	}
}

void findMaxSubString(char* str1, char* str2, char* outputStr)
{
	if (0 == str1 || 0 == str2 || 0 == strcmp(str1, "") || 0 == strcmp(str2, ""))
	{
		return;
	}
	string s1(str1), s2(str2);
	vector<string> stringVec;
	//makeMatchVector(s1, s2, stringVec);
	makeMatchVector(s2, s1, stringVec);
	stable_sort(stringVec.begin(), stringVec.end(), SortStringByLength());
	if (!stringVec.empty())
	{
		cout << stringVec.front() << endl;
	}
	else
	{
		cout << "not match" << endl;
	}
}

int main() 
{
	char* str1 = "ndmmmla";
	char* str2 = "island";
	char outputStr[10] = {'0'};
	findMaxSubString(str1, str2, outputStr);
}

//--查找最长子串，wstring
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
using namespace std;

std::wstring s2ws(const std::string& s)
{
	setlocale(LC_ALL, "chs"); 
	const char* _Source = s.c_str();
	size_t _Dsize = s.size() + 1;
	wchar_t *_Dest = new wchar_t[_Dsize];
	wmemset(_Dest, 0, _Dsize);
	mbstowcs(_Dest,_Source,_Dsize);
	std::wstring result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, "C");
	return result;
}

std::string ws2s(const std::wstring& ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1;
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}

class SortStringByLength
{
public:
	bool operator()(const wstring& lhs, const wstring& rhs) const
	{
		return lhs.size() > rhs.size();
	}
};

void makeMatchVector(wstring& s1, wstring& s2, vector<wstring>& stringVec)
{
	wstring::iterator startIterOfStr2 = s2.begin();
	wstring::iterator endIterOfStr2 = s2.begin();
	for (; startIterOfStr2 != s2.end(); ++startIterOfStr2)
	{
		for (endIterOfStr2 = startIterOfStr2 + 1; ; ++endIterOfStr2)
		{
			wstring::iterator iter = search(s1.begin(), s1.end(), startIterOfStr2, endIterOfStr2);
			if (s1.end() != iter)
			{
				stringVec.push_back(wstring(startIterOfStr2, endIterOfStr2));
			}
			if (endIterOfStr2 == s2.end())
			{
				break;
			}
		}
	}
}

void findMaxSubString(char* str1, char* str2, char* outputStr)
{
	if (0 == str1 || 0 == str2 || 0 == strcmp(str1, "") || 0 == strcmp(str2, ""))
	{
		return;
	}
	string s1(str1), s2(str2);
	wstring ws1 = s2ws(s1), ws2 = s2ws(s2);

	vector<wstring> wstringVec;
	//makeMatchVector(ws1, ws2, wstringVec);
	makeMatchVector(ws2, ws1, wstringVec);
	stable_sort(wstringVec.begin(), wstringVec.end(), SortStringByLength());

	if (!wstringVec.empty())
	{
		string resultString = ws2s(wstringVec.front());
		strncpy(outputStr, resultString.c_str(), resultString.size() + 1);
	}
}

int main() 
{
	char* str1 = "你好mmm输入法sougou";//char* str1 = "你好mmmsou";这种情况下，sou长度为3，占了三个单元，比“你好”多一个单元，因此输出为“sou”。但是实际只是两个字节，是否符合要求？
	char* str2 = "输入法sougoula你好";
	char outputStr[20] = {'\0'};//char outputStr[20] = {'a', 'b', '\0', 'c', 'd'};或者char outputStr[20] = {'a', 'b', 0, 'c', 'd'}; '\0'即为结束符0，ANSI码也为0
	wcout.imbue(std::locale("chs")); 
	findMaxSubString(str1, str2, outputStr);
	cout << outputStr << endl;
}
输出如下：
输入法sougou
请按任意键继续. . .

//--查找最长子串，wstring，并且解决上面的汉字字节占两个字符长度的问题
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <numeric>
#include <iterator>
using namespace std;

std::wstring s2ws(const std::string& s)
{
	setlocale(LC_ALL, "chs"); 
	const char* _Source = s.c_str();
	size_t _Dsize = s.size() + 1;
	wchar_t *_Dest = new wchar_t[_Dsize];
	wmemset(_Dest, 0, _Dsize);
	mbstowcs(_Dest,_Source,_Dsize);
	std::wstring result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, "C");
	return result;
}

std::string ws2s(const std::wstring& ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1;
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}

void makeMatchVector(wstring& s1, wstring& s2, vector<wstring>& stringVec)
{
	wstring::iterator startIterOfStr2 = s2.begin();
	wstring::iterator endIterOfStr2 = s2.begin();
	for (; startIterOfStr2 != s2.end(); ++startIterOfStr2)
	{
		for (endIterOfStr2 = startIterOfStr2 + 1; ; ++endIterOfStr2)
		{
			wstring::iterator iter = search(s1.begin(), s1.end(), startIterOfStr2, endIterOfStr2);
			if (s1.end() != iter)
			{
				stringVec.push_back(wstring(startIterOfStr2, endIterOfStr2));
			}
			if (endIterOfStr2 == s2.end())
			{
				break;
			}
		}
	}
}

class PairWsIntSort
{
public:
	bool operator()(const pair<wstring, int>& lhs, const pair<wstring, int>& rhs) const
	{
		return lhs.second > rhs.second;
	}
};

bool wcIsAnsi(wchar_t wc)
{
	return (wc >= 0 && wc <= 127) ? true : false;
}

class CalcWsLength
{
public:
	int operator()(int totalLength, wchar_t wc) const
	{
		return wcIsAnsi(wc) ? totalLength + 1 : totalLength + 2;
	}
};

class MakeWsLengthPair
{
public:
	pair<wstring, int> operator()(const wstring& ws) const
	{
		int wsLength = accumulate(ws.begin(), ws.end(), 0, CalcWsLength());
		return make_pair(ws, wsLength);
	}
};

void findMaxSubString(char* str1, char* str2, char* outputStr)
{
	if (0 == str1 || 0 == str2 || 0 == strcmp(str1, "") || 0 == strcmp(str2, ""))
	{
		return;
	}
	string s1(str1), s2(str2);
	wstring ws1 = s2ws(s1), ws2 = s2ws(s2);

	vector<wstring> wstringVec;
	//makeMatchVector(ws1, ws2, wstringVec);
	makeMatchVector(ws2, ws1, wstringVec);

	vector<pair<wstring, int> > wstringLengthVec;
	transform(wstringVec.begin(), wstringVec.end(), inserter(wstringLengthVec, wstringLengthVec.begin()), MakeWsLengthPair());
	stable_sort(wstringLengthVec.begin(), wstringLengthVec.end(), PairWsIntSort());

	if (!wstringLengthVec.empty())
	{
		string resultString = ws2s(wstringLengthVec.front().first);
		strncpy(outputStr, resultString.c_str(), resultString.size() + 1);
	}
}

int main() 
{
	char* str1 = "你好mmmsougo";
	char* str2 = "输入法sougoulam你好m";
	char outputStr[20] = {'\0'};
	wcout.imbue(std::locale("chs")); 
	findMaxSubString(str1, str2, outputStr);
	cout << outputStr << endl;
}
输出如下：
你好m
请按任意键继续. . .

//--上面的例子改为将pair插入到multiset中，但先后顺序就变掉了
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <numeric>
#include <iterator>
#include <set>
using namespace std;

std::wstring s2ws(const std::string& s)
{
	setlocale(LC_ALL, "chs"); 
	const char* _Source = s.c_str();
	size_t _Dsize = s.size() + 1;
	wchar_t *_Dest = new wchar_t[_Dsize];
	wmemset(_Dest, 0, _Dsize);
	mbstowcs(_Dest,_Source,_Dsize);
	std::wstring result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, "C");
	return result;
}

std::string ws2s(const std::wstring& ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1;
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}

void makeMatchVector(wstring& s1, wstring& s2, vector<wstring>& stringVec)
{
	wstring::iterator startIterOfStr2 = s2.begin();
	wstring::iterator endIterOfStr2 = s2.begin();
	for (; startIterOfStr2 != s2.end(); ++startIterOfStr2)
	{
		for (endIterOfStr2 = startIterOfStr2 + 1; ; ++endIterOfStr2)
		{
			wstring::iterator iter = search(s1.begin(), s1.end(), startIterOfStr2, endIterOfStr2);
			if (s1.end() != iter)
			{
				stringVec.push_back(wstring(startIterOfStr2, endIterOfStr2));
			}
			if (endIterOfStr2 == s2.end())
			{
				break;
			}
		}
	}
}

class PairWsIntSort
{
public:
	bool operator()(const pair<wstring, int>& lhs, const pair<wstring, int>& rhs) const
	{
		return lhs.second > rhs.second;
	}
};

bool wcIsAnsi(wchar_t wc)
{
	return (wc >= 0 && wc <= 127) ? true : false;
}

class CalcWsLength
{
public:
	int operator()(int totalLength, wchar_t wc) const
	{
		return wcIsAnsi(wc) ? totalLength + 1 : totalLength + 2;
	}
};

class MakeWsLengthPair
{
public:
	pair<wstring, int> operator()(const wstring& ws) const
	{
		int wsLength = accumulate(ws.begin(), ws.end(), 0, CalcWsLength());
		return make_pair(ws, wsLength);
	}
};

void findMaxSubString(char* str1, char* str2, char* outputStr)
{
	if (0 == str1 || 0 == str2 || 0 == strcmp(str1, "") || 0 == strcmp(str2, ""))
	{
		return;
	}
	string s1(str1), s2(str2);
	wstring ws1 = s2ws(s1), ws2 = s2ws(s2);

	vector<wstring> wstringVec;
	//makeMatchVector(ws1, ws2, wstringVec);
	makeMatchVector(ws2, ws1, wstringVec);

	//这两行是与上例不一样的地方
	multiset<pair<wstring, int>, PairWsIntSort> wstringLengthSet;
	transform(wstringVec.begin(), wstringVec.end(), inserter(wstringLengthSet, wstringLengthSet.begin()), MakeWsLengthPair());//第三个参数用插入迭代器inserter是唯一能把值作为输出插入set中的方法。对于vector来说，可以改成someVector.begin()，只要该vector有size()即可，如果没有，则可以用inserter或back_inserter。而如果改成了someSet.begin()，则transform方法认为这是要操作两个容器，而这个参数是第二个容器的第一个迭代器，但却缺少第二个迭代器和输出迭代器，编译报错。

	if (!wstringLengthSet.empty())
	{
		string resultString = ws2s((*wstringLengthSet.begin()).first);
		strncpy(outputStr, resultString.c_str(), resultString.size() + 1);
	}
}

int main() 
{
	char* str1 = "你好mmmsougo";
	char* str2 = "输入法sougoulam你好m";
	char outputStr[20] = {'\0'};
	wcout.imbue(std::locale("chs")); 
	findMaxSubString(str1, str2, outputStr);
	cout << outputStr << endl;
}
输出如下：
sougo
请按任意键继续. . .

//--查找最长子串，wstring。上面的修改方法过于麻烦，其实对于wstring的那个排序算法SortStringByLength修改一下即可，由原来的默认长度修改为计算Char的长度和。结合上两个程序的，修改如下：
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <numeric>
using namespace std;

std::wstring s2ws(const std::string& s)
{
	setlocale(LC_ALL, "chs"); 
	const char* _Source = s.c_str();
	size_t _Dsize = s.size() + 1;
	wchar_t *_Dest = new wchar_t[_Dsize];
	wmemset(_Dest, 0, _Dsize);
	mbstowcs(_Dest,_Source,_Dsize);
	std::wstring result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, "C");
	return result;
}

std::string ws2s(const std::wstring& ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1;
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}

bool wcIsAnsi(wchar_t wc)
{
	return (wc >= 0 && wc <= 127) ? true : false;
}

class CalcWsLength
{
public:
	int operator()(int totalLength, wchar_t wc) const
	{
		return wcIsAnsi(wc) ? totalLength + 1 : totalLength + 2;
	}
};

class SortStringByLength
{
public:
	bool operator()(const wstring& lhs, const wstring& rhs) const
	{
		int lhsCharLength = accumulate(lhs.begin(), lhs.end(), 0, CalcWsLength());
		int rhsCharLength = accumulate(rhs.begin(), rhs.end(), 0, CalcWsLength());
		return lhsCharLength > rhsCharLength;
	}
};

void makeMatchVector(wstring& s1, wstring& s2, vector<wstring>& stringVec)
{
	wstring::iterator startIterOfStr2 = s2.begin();
	wstring::iterator endIterOfStr2 = s2.begin();
	for (; startIterOfStr2 != s2.end(); ++startIterOfStr2)
	{
		for (endIterOfStr2 = startIterOfStr2 + 1; ; ++endIterOfStr2)
		{
			wstring::iterator iter = search(s1.begin(), s1.end(), startIterOfStr2, endIterOfStr2);
			if (s1.end() != iter)
			{
				stringVec.push_back(wstring(startIterOfStr2, endIterOfStr2));
			}
			if (endIterOfStr2 == s2.end())
			{
				break;
			}
		}
	}
}

void findMaxSubString(char* str1, char* str2, char* outputStr)
{
	if (0 == str1 || 0 == str2 || 0 == strcmp(str1, "") || 0 == strcmp(str2, ""))
	{
		return;
	}
	string s1(str1), s2(str2);
	wstring ws1 = s2ws(s1), ws2 = s2ws(s2);

	vector<wstring> wstringVec;
	//makeMatchVector(ws1, ws2, wstringVec);
	makeMatchVector(ws2, ws1, wstringVec);
	stable_sort(wstringVec.begin(), wstringVec.end(), SortStringByLength());

	if (!wstringVec.empty())
	{
		string resultString = ws2s(wstringVec.front());
		strncpy(outputStr, resultString.c_str(), resultString.size() + 1);
	}
}

int main() 
{
	char* str1 = "你好mmmsougo";
	char* str2 = "输入法sougoulam你好m";
	char outputStr[20] = {'\0'};
	wcout.imbue(std::locale("chs")); 
	findMaxSubString(str1, str2, outputStr);
	cout << outputStr << endl;
}
输出如下：
你好m
请按任意键继续. . .

//--set对于相等的对象不能保证插入顺序。但下面的例子并没有试出来，不太清楚到底插入顺序到底是怎样的？
#include <iostream>
#include <string>
#include <set>
#include <vector>
#include <algorithm>
#include <iterator>
using namespace std;

class StringLengthSort
{
public:
	bool operator()(const string& lhs, const string& rhs) const
	{
		return lhs.size() > rhs.size();//排序只能用>或<，而不能带=。因为排序时如果不满足lhs op rhs以及rhs op lhs，则认为lhs == rhs。而如果带了=比较，排序时当有相等的两个对象时，lhs >= rhs和rhs >= lhs同时满足，容器不知道该如何处理了，只能报错。
	}
};

class PairStringIntSort
{
public:
	bool operator()(const pair<string, int>& lhs, const pair<string, int>& rhs) const
	{
		return lhs.second > rhs.second;
	}
};

class MakeStringLengthPair
{
public:
	pair<string, int> operator()(const string& s) const
	{
		return make_pair(s, s.size());
	}
};

class GetPairFirstValue
{
public:
	string operator()(const pair<string, int>& p) const
	{
		return p.first;
	}
};

int main() 
{
	multiset<string, StringLengthSort> stringSet;
	stringSet.insert("hello");
	stringSet.insert("world");
	copy(stringSet.begin(), stringSet.end(), ostream_iterator<string>(cout, " "));

	cout << "\n======================\n";

	vector<string> stringVec;
	stringVec.push_back("hello");
	stringVec.push_back("world");
	multiset<pair<string, int>, PairStringIntSort> pairSet;
	transform(stringVec.begin(), stringVec.end(), inserter(pairSet, pairSet.begin()), MakeStringLengthPair());
	//transform(stringVec.begin(), stringVec.end(), pairSet.begin(), MakeStringLengthPair());//用这样的第三个参数编译报错，对于set来说只能用inserter。
	transform(pairSet.begin(), pairSet.end(), ostream_iterator<string>(cout, " "), GetPairFirstValue());
}
输出如下：
hello world
======================
hello world 请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//copy_backward
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main () {
	vector<int> myvector;
	vector<int>::iterator it;

	// set some values:
	for (int i=1; i<=5; i++)
		myvector.push_back(i*10);          // myvector: 10 20 30 40 50

	myvector.resize(myvector.size()+3);  // allocate space for 3 more elements

	copy_backward ( myvector.begin(), myvector.begin()+5, myvector.end() - 1);

	cout << "myvector contains:";
	for (it=myvector.begin(); it!=myvector.end(); ++it)
		cout << " " << *it;

	cout << endl;

	return 0;
}
myvector contains: 10 20 10 20 30 40 50 0
请按任意键继续. . .

//search
// search algorithm example
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

bool mypredicate (int i, int j) {
	return (i==j);
}

int main () {
	vector<int> myvector;
	vector<int>::iterator it;

	// set some values:        myvector: 10 20 30 40 50 60 70 80 90
	for (int i=1; i<10; i++) myvector.push_back(i*10);


	// using default comparison:
	int match1[] = {40,50,60,70};
	it = search (myvector.begin(), myvector.end(), match1, match1+4);

	if (it!=myvector.end())
		cout << "match1 found at position " << int(it-myvector.begin()) << endl;
	else
		cout << "match1 not found" << endl;

	// using predicate comparison:
	int match2[] = {20,30,50};
	it = search (myvector.begin(), myvector.end(), match2, match2+3, mypredicate);

	if (it!=myvector.end())
		cout << "match2 found at position " << int(it-myvector.begin()) << endl;
	else
		cout << "match2 not found" << endl;

	return 0;
}
输出如下：
match1 found at position 3
match2 not found
请按任意键继续. . .

//search不要求区间排序
// search algorithm example
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

bool mypredicate (int i, int j) {
	return (i==j);
}

int main () {
	vector<int> myvector;
	vector<int>::iterator it;

	// set some values:        myvector: 10 20 30 40 50 60 70 80 90
	for (int i=1; i<10; i++) myvector.push_back(i*10);
	myvector[3] = 50;
	myvector[4] = 40;


	// using default comparison:
	int match1[] = {50,40,60,70};
	it = search (myvector.begin(), myvector.end(), match1, match1+4);

	if (it!=myvector.end())
		cout << "match1 found at position " << int(it-myvector.begin()) << endl;
	else
		cout << "match1 not found" << endl;

	// using predicate comparison:
	int match2[] = {20,30,50};
	it = search (myvector.begin(), myvector.end(), match2, match2+3, mypredicate);

	if (it!=myvector.end())
		cout << "match2 found at position " << int(it-myvector.begin()) << endl;
	else
		cout << "match2 not found" << endl;

	return 0;
}
match1 found at position 3
match2 found at position 1
请按任意键继续. . .

//includes 两个区间必须要排好序
// includes algorithm example
#include <iostream>
#include <algorithm>
using namespace std;

bool myfunction (int i, int j) { return i<j; }

int main () {
	int container[] = {5,10,15,20,25,30,35,40,45,50};
	int continent[] = {40,30,20,10};

	sort (container,container+10);
	sort (continent,continent+4);

	// using default comparison:
	if ( includes(container,container+10,continent,continent+4) )
		cout << "container includes continent!" << endl;

	// using myfunction as comp:
	if ( includes(container,container+10,continent,continent+4, myfunction) )
		cout << "container includes continent!" << endl;

	return 0;
}
输出如下：
container includes continent!
container includes continent! 
//------------------------------------------------------------------------------------------------
//Jam的计数法
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
using namespace std;

class GenerateChar
{
public:
	GenerateChar(): initChar_('a') { }
	char operator()()
	{
		return initChar_++;
	}
private:
	char initChar_;
};

class MakePair
{
public:
	MakePair(const string& s): allCharsString_(s) { }
	pair<char, int> operator()(char c) const
	{
		return make_pair(c, allCharsString_.find(c));
	}
private:
	const string& allCharsString_;
};

class FindNextNumberPosition
{
public:
	FindNextNumberPosition(int maxCharNumber, int& indexOfChangePosition, const string& allCharsString): 
	maxCharNumber_(maxCharNumber), alreadySetNextNumber_(false), index_(0), indexOfChangePosition_(indexOfChangePosition), allCharsString_(allCharsString)
	{ }
	void operator()(pair<char, int>& pairCharInt)
	{
		--maxCharNumber_;
		if (false == alreadySetNextNumber_)
		{
			int tempNumber = pairCharInt.second;
			if (tempNumber < maxCharNumber_)
			{
				pairCharInt.second = tempNumber + 1;
				pairCharInt.first = allCharsString_[pairCharInt.second];
				alreadySetNextNumber_ = true;
				indexOfChangePosition_ = index_;
			}
		}
		++index_;
	}
	bool hasNextNumber() const
	{
		return alreadySetNextNumber_;
	}
private:
	int maxCharNumber_;
	bool alreadySetNextNumber_;
	int index_;
	int& indexOfChangePosition_;
	const string& allCharsString_;
};

class GenerateAllPositions
{
public:
	GenerateAllPositions(int basePosition, const string& allCharsString): basePosition_(basePosition), allCharsString_(allCharsString) { }
	void operator()(pair<char, int>& pairCharInt)
	{
		pairCharInt.second = ++basePosition_ ;
		pairCharInt.first = allCharsString_[pairCharInt.second];
	}
private:
	int basePosition_;
	const string& allCharsString_;
};

class GenerateString
{
public:
	string operator()(string& s, const pair<char, int>& pairCharInt)
	{
		return s.append(1, pairCharInt.first);
	}
};

bool getNextNumberString(string& nextString, int maxCharNumber, vector<pair<char, int> >& pairVec, string& allCharsString)
{
	int indexOfChangePosition;
	bool hasNext = for_each(pairVec.rbegin(), pairVec.rend(), FindNextNumberPosition(maxCharNumber, indexOfChangePosition, allCharsString)).hasNextNumber();
	if (hasNext)
	{
		vector<pair<char, int> >::reverse_iterator rChangedIter = pairVec.rbegin() + indexOfChangePosition;
		int changedPosition = (*rChangedIter).second;
		vector<pair<char, int> >::iterator changedIter = rChangedIter.base();
		for_each(changedIter, pairVec.end(), GenerateAllPositions(changedPosition, allCharsString));

		nextString.clear();
		nextString = accumulate(pairVec.begin(), pairVec.end(), nextString, GenerateString());
	}
	return hasNext;
}

const int number = 27;
char charArr[number] = {'0'};

void findNextFiveJamNumber(int startNumber, int endNumber, int numberLength, const char* pStr)
{
	generate(charArr + 1, charArr + 1 + number, GenerateChar());
	string allCharsString(charArr + startNumber, charArr + endNumber + 1);
	int maxCharNumber = allCharsString.size();
	string currentString(pStr);
	vector<pair<char, int> > pairVec(currentString.size());
	transform(currentString.begin(), currentString.end(), pairVec.begin(), MakePair(allCharsString));

	string nextString;
	bool hasNext;
	for (int i = 0; i < 5; ++i)
	{
		hasNext = getNextNumberString(nextString, maxCharNumber, pairVec, allCharsString);
		if (hasNext)
		{
			cout << nextString << endl;
		}
		else
		{
			break;
		}
	}
}

int main()
{
	//findNextFiveJamNumber(2, 10, 5, "bdfij");
	findNextFiveJamNumber(2, 10, 5, "eghij");
}
//------------------------------------------------------------------------------------------------
//主机地址排序
#include <iostream>
#include <list>
#include <string>
#include <vector>
#include <numeric>
#include <iterator>
#include <algorithm>
using namespace std;

class StringCompare
{
public:
	int operator()(const string& lhs, const string& rhs) const
	{
		return lhs.compare(rhs);
	}
};

class SortStringList
{
public:
	bool operator()(const list<string>& lhs, const list<string>& rhs) const
	{
		vector<int> intVec;
		if (lhs.size() == rhs.size())
		{
			transform(lhs.begin(), lhs.end(), rhs.begin(), back_inserter(intVec), StringCompare());
			vector<int>::iterator iter(find_if(intVec.begin(), intVec.end(), bind2nd(not_equal_to<int>(), 0)));
			return (1 == *iter) ? false : true;
		}
		else if (lhs.size() < rhs.size())
		{
			transform(lhs.begin(), lhs.end(), rhs.begin(), back_inserter(intVec), StringCompare());
			vector<int>::iterator iter(find_if(intVec.begin(), intVec.end(), bind2nd(not_equal_to<int>(), 0)));
			if (intVec.end() != iter)
			{
				return (1 == *iter) ? false : true;
			}
			else
			{
				return true;
			}
		}
		else
		{
			//rhs is compared to lhs, so "return (1 == *iter) ? true : false;" is opposite from above "return (1 == *iter) ? false : true;"
			transform(rhs.begin(), rhs.end(), lhs.begin(), back_inserter(intVec), StringCompare());
			vector<int>::iterator iter(find_if(intVec.begin(), intVec.end(), bind2nd(not_equal_to<int>(), 0)));
			if (intVec.end() != iter)
			{
				return (1 == *iter) ? true : false;
			}
			else
			{
				return false;
			}
		}
	}
};

class MakeOutputAddress
{
public:
	string operator()(string& s, const string& iterString) const
	{
		return s + iterString + '.';
	}
};

list<list<string> > stringListList;

void makeStringList(string& hostString, list<string>& stringList)
{
	char delimiterChar('.');
	hostString.append(1, delimiterChar);
	size_t pos = hostString.find(delimiterChar);
	while (string::npos != pos)
	{
		stringList.push_front(hostString.substr(0, pos));
		hostString = hostString.substr(pos + 1);
		pos = hostString.find(delimiterChar);
	}
}

string getOutputAddressString(list<string>& stringList)
{
	stringList.reverse();
	string s;
	s = accumulate(stringList.begin(), stringList.end(), s, MakeOutputAddress());
	return s.erase(s.size() - 1);
}

int add_host_name(const char* host_name)
{
	string hostString(host_name);
	list<string> stringList;
	makeStringList(hostString, stringList);
	stringListList.push_back(stringList);
	stringListList.sort(SortStringList());
	return 0;
}

int get_host_name(int serial_number, int host_name_max_length, char* host_name)
{
	if (serial_number < 1 || serial_number >stringListList.size())
	{
		return -1;
	}

	list<list<string> >::iterator iter(stringListList.begin());
	advance(iter, serial_number - 1);
	list<string> dstStringList(*iter);
	
	string outputString = getOutputAddressString(dstStringList);

	int length = outputString.size() + 1;
	if (host_name_max_length < length)
	{
		return -1;
	}
	strncpy(host_name, outputString.c_str(), length);
	return 0;
}

void clear(void)
{
	stringListList.clear();
}

int main()
{
	char out_str[20];
	add_host_name("mail.huawei.com");
	add_host_name("huawei.com");
	add_host_name("teltalk.hk");
	add_host_name("google.com.hk");
	add_host_name("imail.huawei.com");
	cout << get_host_name(4, sizeof(out_str), out_str) << endl;
	cout << out_str << endl;
}
//------------------------------------------------------------------------------------------------
//纪念品分组，每组最多两个纪念品，价格之和不超过给定整数，求最少分组
//void GetResult(int* Input, int& Get_Result);
//int* p指向一维数组，第一个数据为价格和上限，第二个数据为纪念品总数。其余为纪念品价格。入参不用判断，用例可保证。
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
using namespace std;

struct MakePairVector
{
	pair<int, int> operator()(int price) const
	{
		return make_pair(price, -1);
	}
};

struct PairSort
{
	bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) const
	{
		return lhs.first < rhs.first;
	}
};

class FindTheOtherPair
{
public:
	FindTheOtherPair(const pair<int, int>& firstPairIntInt, int maxPrice): firstPairIntInt_(firstPairIntInt), maxPrice_(maxPrice) {}
	bool operator()(const pair<int, int>& secondPairIntInt) const
	{
		if ((-1 == secondPairIntInt.second) && (secondPairIntInt.first + firstPairIntInt_.first <= maxPrice_) && (&secondPairIntInt != &firstPairIntInt_))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
private:
	const pair<int, int>& firstPairIntInt_;
	int maxPrice_;
};

class FindAPair
{
public:
	FindAPair(vector<pair<int, int> >& pairVector, int maxPrice): pairVector_(pairVector), maxPrice_(maxPrice) { }
	void operator()(pair<int, int>& pairIntInt)
	{
		if (-1 == pairIntInt.second)
		{
			vector<pair<int, int> >::reverse_iterator rIter = find_if(pairVector_.rbegin(), pairVector_.rend(), FindTheOtherPair(pairIntInt, maxPrice_));//倒序找到符合要求的另一个纪念品
			if (rIter != pairVector_.rend())
			{
				pairIntInt.second = 1;
				(*rIter).second = 1;
			}
		}
	}
private:
	vector<pair<int, int> >& pairVector_;
	int maxPrice_;
};

struct FindPairNumbers 
{
	bool operator()(const pair<int, int>& pairIntInt) const
	{
		return 1 == pairIntInt.second;
	}
};

void getResult(int* Input, int& Get_Result)
{
	int maxPrice = *Input;
	int numberSouvenir = *(Input + 1);
	vector<pair<int, int> > pairVector(numberSouvenir);
	transform(Input + 2, Input + 2 + numberSouvenir, pairVector.begin(), MakePairVector());
	sort(pairVector.begin(), pairVector.end(), PairSort());
	for_each(pairVector.begin(), pairVector.end(), FindAPair(pairVector, maxPrice));
	int pairNumbers = count_if(pairVector.begin(), pairVector.end(), FindPairNumbers());
	Get_Result = numberSouvenir - pairNumbers + pairNumbers/2; 
}

int main ()
{
	int a[11] = {100, 9, 90, 20, 20, 30, 50, 60, 70, 80, 90};
	//int a[16] = {177,14,47,114,159,109,81,115,8,40,83,157,122,121,41,117};
	int* p = a;
	int getNumber = 0;
	getResult(p, getNumber);
	cout << getNumber << endl;
}
//------------------------------------------------------------------------------------------------
//近义词维护
设置近义词
void setSynonym(char* word1, char* word2);

判断近义词，是就返回true，不是返回false
bool isSynonym(char* word1, char* word2);

#include <iostream>
#include <list>
#include <string>
#include <algorithm>
#include <map>
using namespace std;

class FindPairString
{
public:
	FindPairString(const string& word): word_(word) { }
	bool operator()(const pair<string, int>& pairStringInt) const
	{
		return pairStringInt.first == word_;
	}
private:
	const string& word_;
};

class ChangeSynonymNumber
{
public:
	ChangeSynonymNumber(int oldNumber, int newNumber): oldNumber_(oldNumber), newNumber_(newNumber) { }
	void operator()(pair<string, int>& pairStringInt) const
	{
		if (oldNumber_ == pairStringInt.second)
		{
			pairStringInt.second = newNumber_;
		}
	}
private:
	int oldNumber_;
	int newNumber_;
};

class PairSecondIsFalse
{
public:
	int operator()(const pair<int, bool>& pairIntBool) const
	{
		return pairIntBool.second == false;
	}
};

class MakeUsedSynonymMap
{
public:
	MakeUsedSynonymMap(map<int, string>& synonymStringMap): synonymStringMap_(synonymStringMap) { }
	void operator()(const pair<int, bool>& pairIntBool)
	{
		if (true == pairIntBool.second)
		{
			synonymStringMap_[pairIntBool.first] = "";
		}
	}
private:
	map<int, string>& synonymStringMap_;
};

class MakeSynonymString
{
public:
	MakeSynonymString(map<int, string>& synonymStringMap): synonymStringMap_(synonymStringMap) { }
	void operator()(const pair<string, int>& pairStringInt)
	{
		int synonymNumber = pairStringInt.second;
		map<int, string>::iterator iter = synonymStringMap_.find(synonymNumber);
		if (synonymStringMap_.end() != iter)
		{
			synonymStringMap_[synonymNumber] = synonymStringMap_[synonymNumber] + pairStringInt.first + "<==>";
		}
	}
private:
	map<int, string>& synonymStringMap_;
};

class Synonym
{
public:
	Synonym(): synonymNumber_(0) {}
	void setSynonym(const string& word1, const string& words2);
	bool isSynonym(const string& word1, const string& word2);
	void clear();
	void printSynonym();
private:
	int findNextSysnonymNumber();
	void setSynonymNumberUsable(int usableNumber);
	list<pair<string, int> > wordsIndexList_;
	int synonymNumber_;
	list<pair<int, bool> > usedSysnonymNumberList_;
};

void Synonym::setSynonym( const string& word1, const string& word2 )
{
	list<pair<string, int> >::iterator iterWord1 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word1));
	list<pair<string, int> >::iterator iterWord2 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word2));
	list<pair<string, int> >::iterator endIter = wordsIndexList_.end();
	if (endIter == iterWord1 && endIter == iterWord2)
	{
		int currentSysnonymNumber = findNextSysnonymNumber();
		wordsIndexList_.push_back(make_pair(word1, currentSysnonymNumber));
		wordsIndexList_.push_back(make_pair(word2, currentSysnonymNumber));
	}
	else if (endIter == iterWord1 && endIter != iterWord2)
	{
		wordsIndexList_.push_back(make_pair(word1, (*iterWord2).second));
	}
	else if (endIter != iterWord1 && endIter == iterWord2)
	{
		wordsIndexList_.push_back(make_pair(word2, (*iterWord1).second));
	}
	else
	{
		setSynonymNumberUsable((*iterWord1).second);
		for_each(wordsIndexList_.begin(), wordsIndexList_.end(), ChangeSynonymNumber((*iterWord1).second, (*iterWord2).second));
	}
}

bool Synonym::isSynonym( const string& word1, const string& word2 )
{
	list<pair<string, int> >::iterator iterWord1 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word1));
	list<pair<string, int> >::iterator iterWord2 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word2));
	if (wordsIndexList_.end() != iterWord1 && wordsIndexList_.end() != iterWord2 
		&& (*iterWord1).second == (*iterWord2).second)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void Synonym::clear()
{
	wordsIndexList_.clear();
}

int Synonym::findNextSysnonymNumber()
{
	list<pair<int, bool> >::iterator iter = find_if(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), PairSecondIsFalse());
	if (usedSysnonymNumberList_.end() != iter)
	{
		(*iter).second = true;
		return (*iter).first;
	}
	else
	{
		usedSysnonymNumberList_.push_back(make_pair(synonymNumber_, true));
		return synonymNumber_++;
	}
}

void Synonym::setSynonymNumberUsable( int usableNumber )
{
	list<pair<int, bool> >::iterator iter = usedSysnonymNumberList_.begin();// = find(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), pair<int, bool>(usableNumber, true));
	advance(iter, usableNumber);
	(*iter).second = false;
}

void Synonym::printSynonym()
{
	map<int, string> synonymStringMap;
	for_each(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), MakeUsedSynonymMap(synonymStringMap));
	for_each(wordsIndexList_.begin(), wordsIndexList_.end(), MakeSynonymString(synonymStringMap));
	for (map<int, string>::iterator iter = synonymStringMap.begin(); iter != synonymStringMap.end(); ++iter)
	{
		cout << (*iter).second << endl;
	}
}

Synonym synonym;

bool inputWordsAreLegal(char* word1, char* word2)
{
	if (0 == word1 || 0 == word2 || 0 == strcmp(word1, "") || 0 == strcmp(word2, "") || 0 == strcmp(word1, word2))
	{
		return false;
	}
	else
	{
		return true;
	}
}

void setSynonym(char* word1, char* word2)
{
	if (!inputWordsAreLegal(word1, word2))
	{
		return;
	}
	synonym.setSynonym(word1, word2);
}

bool isSynonym(char* word1, char* word2)
{
	if (0 == word1 || 0 == word2)
	{
		return false;
	}
	else if (0 == strcmp(word1, word2))
	{
		return true;
	}
	return synonym.isSynonym(word1, word2);
}

void clear()
{
	synonym.clear();
}

void printSynonym()
{
	synonym.printSynonym();
}

int main() 
{
	char* word1 = "a";
	char* word2 = "b";
	setSynonym(word1, word2);
	word1 = "b";
	word2 = "c";
	setSynonym(word1, word2);

	word1 = "e";
	word2 = "f";
	setSynonym(word1, word2);

	word1 = "e";
	word2 = "a";
	setSynonym(word1, word2);

	word1 = "o";
	word2 = "p";
	setSynonym(word1, word2);

	word1 = "m";
	word2 = "n";
	setSynonym(word1, word2);

	word1 = "n";
	word2 = "a";
	setSynonym(word1, word2);

	printSynonym();
	cout << isSynonym(word1, word2) << endl;
}

//将该程序做修改，写成了可交互；并且将对输入的判断用职责链模式来实现
//Synonym.h
#ifndef __SYNONYM_H__
#define __SYNONYM_H__
#include <string>
#include <list>

class Synonym
{
public:
	Synonym(): synonymNumber_(0) {}
	void setSynonym(const std::string& word1, const std::string& word2);
	bool isSynonym(const std::string& word1, const std::string& word2);
	void clear();
	void printSynonym();
private:
	int findNextSysnonymNumber();
	void setSynonymNumberUsable(int usableNumber);
	std::list<std::pair<std::string, int> > wordsIndexList_;
	int synonymNumber_;
	std::list<std::pair<int, bool> > usedSysnonymNumberList_;
};
#endif

//Synonym.cpp
#include <iostream>
#include <algorithm>
#include <map>
#include "Synonym.h"
using namespace std;;

class FindPairString
{
public:
	FindPairString(const string& word): word_(word) { }
	bool operator()(const pair<string, int>& pairStringInt) const
	{
		return pairStringInt.first == word_;
	}
private:
	const string& word_;
};

class ChangeSynonymNumber
{
public:
	ChangeSynonymNumber(int oldNumber, int newNumber): oldNumber_(oldNumber), newNumber_(newNumber) { }
	void operator()(pair<string, int>& pairStringInt) const
	{
		if (oldNumber_ == pairStringInt.second)
		{
			pairStringInt.second = newNumber_;
		}
	}
private:
	int oldNumber_;
	int newNumber_;
};

class PairSecondIsFalse
{
public:
	int operator()(const pair<int, bool>& pairIntBool) const
	{
		return pairIntBool.second == false;
	}
};

class MakeUsedSynonymMap
{
public:
	MakeUsedSynonymMap(map<int, string>& synonymStringMap): synonymStringMap_(synonymStringMap) { }
	void operator()(const pair<int, bool>& pairIntBool)
	{
		if (true == pairIntBool.second)
		{
			synonymStringMap_[pairIntBool.first] = "";
		}
	}
private:
	map<int, string>& synonymStringMap_;
};

class MakeSynonymString
{
public:
	MakeSynonymString(map<int, string>& synonymStringMap): synonymStringMap_(synonymStringMap) { }
	void operator()(const pair<string, int>& pairStringInt)
	{
		int synonymNumber = pairStringInt.second;
		map<int, string>::iterator iter = synonymStringMap_.find(synonymNumber);
		if (synonymStringMap_.end() != iter)
		{
			synonymStringMap_[synonymNumber] = synonymStringMap_[synonymNumber] + pairStringInt.first + "<==>";
		}
	}
	void eraseLastFourChars()
	{
		for (map<int, string>::iterator iter = synonymStringMap_.begin(); iter != synonymStringMap_.end(); ++iter)
		{
			string s = (*iter).second;
			s.erase(s.end() - 4, s.end());
			(*iter).second = s;
		}
	}
private:
	map<int, string>& synonymStringMap_;
};

void Synonym::setSynonym(const std::string& word1, const std::string& word2)
{
	list<pair<string, int> >::iterator iterWord1 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word1));
	list<pair<string, int> >::iterator iterWord2 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word2));
	list<pair<string, int> >::iterator endIter = wordsIndexList_.end();
	if (endIter == iterWord1 && endIter == iterWord2)
	{
		int currentSysnonymNumber = findNextSysnonymNumber();
		wordsIndexList_.push_back(make_pair(word1, currentSysnonymNumber));
		wordsIndexList_.push_back(make_pair(word2, currentSysnonymNumber));
	}
	else if (endIter == iterWord1 && endIter != iterWord2)
	{
		wordsIndexList_.push_back(make_pair(word1, (*iterWord2).second));
	}
	else if (endIter != iterWord1 && endIter == iterWord2)
	{
		wordsIndexList_.push_back(make_pair(word2, (*iterWord1).second));
	}
	else
	{
		setSynonymNumberUsable((*iterWord1).second);
		for_each(wordsIndexList_.begin(), wordsIndexList_.end(), ChangeSynonymNumber((*iterWord1).second, (*iterWord2).second));
	}
}

bool Synonym::isSynonym(const std::string& word1, const std::string& word2)
{
	list<pair<string, int> >::iterator iterWord1 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word1));
	list<pair<string, int> >::iterator iterWord2 = find_if(wordsIndexList_.begin(), wordsIndexList_.end(), FindPairString(word2));
	if (wordsIndexList_.end() != iterWord1 && wordsIndexList_.end() != iterWord2 
		&& (*iterWord1).second == (*iterWord2).second)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void Synonym::clear()
{
	wordsIndexList_.clear();
	synonymNumber_ = 0;
	usedSysnonymNumberList_.clear();
}

int Synonym::findNextSysnonymNumber()
{
	list<pair<int, bool> >::iterator iter = find_if(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), PairSecondIsFalse());
	if (usedSysnonymNumberList_.end() != iter)
	{
		(*iter).second = true;
		return (*iter).first;
	}
	else
	{
		usedSysnonymNumberList_.push_back(make_pair(synonymNumber_, true));
		return synonymNumber_++;
	}
}

void Synonym::setSynonymNumberUsable( int usableNumber )
{
	list<pair<int, bool> >::iterator iter = usedSysnonymNumberList_.begin();// = find(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), pair<int, bool>(usableNumber, true));
	advance(iter, usableNumber);
	(*iter).second = false;
}

void Synonym::printSynonym()
{
	map<int, string> synonymStringMap;
	for_each(usedSysnonymNumberList_.begin(), usedSysnonymNumberList_.end(), MakeUsedSynonymMap(synonymStringMap));
	for_each(wordsIndexList_.begin(), wordsIndexList_.end(), MakeSynonymString(synonymStringMap)).eraseLastFourChars();
	int i = 1;
	if (synonymStringMap.empty())
	{
		cout << "未设置近义词关系。\n";
	}
	else
	{
		for (map<int, string>::iterator iter = synonymStringMap.begin(); iter != synonymStringMap.end(); ++iter, ++i)
		{
			cout << "(" << i << ") " << (*iter).second << endl;
		}
	}
}

//MaintainSynonym.h
#ifndef __MAINTAINSYNONYM_H__
#define __MAINTAINSYNONYM_H__
#include <string>

void setSynonym(const std::string& word1, const std::string& word2);

bool isSynonym(const std::string& word1, const std::string& word2);

void clear();

void printSynonym();
#endif

//MaintainSynonym.cpp
#include <cstring>
#include "MaintainSynonym.h"
#include "Synonym.h"

Synonym synonym;

bool inputWordsAreLegal(const std::string& word1, const std::string& word2)
{
	if (0 == word1.compare(word2))
	{
		return false;
	}
	else
	{
		return true;
	}
}

void setSynonym(const std::string& word1, const std::string& word2)
{
	if (!inputWordsAreLegal(word1, word2))
	{
		return;
	}
	synonym.setSynonym(word1, word2);
}

bool isSynonym(const std::string& word1, const std::string& word2)
{
	if (0 == word1.compare(word2))
	{
		return true;
	}
	return synonym.isSynonym(word1, word2);
}

void clear()
{
	synonym.clear();
}

void printSynonym()
{
	synonym.printSynonym();
}

//HandleInput.h
#ifndef __HANDLEINPUT_H__
#define __HANDLEINPUT_H__
#include "boost/shared_ptr.hpp"
#include <string>

class HandleInput
{
public:
	virtual ~HandleInput();
	virtual bool handleInputNumber(const std::string& inputNumberString) = 0;
	void setNextHandler(boost::shared_ptr<HandleInput> pHandleInput);
	bool nextHandlerWork(const std::string& inputNumberString);
private:
	boost::shared_ptr<HandleInput> pHandleInput_;
};

class HandleOne: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};

class HandleTwo: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};

class HandleThree: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};

class HandleFour: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};

class HandleFive: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};

class HandleOther: public HandleInput
{
public:
	virtual bool handleInputNumber(const std::string& inputNumberString);
};
#endif

//HandleInput.cpp
#include <iostream>
#include "HandleInput.h"
#include "MaintainSynonym.h"
using namespace std;

HandleInput::~HandleInput()
{

}

void HandleInput::setNextHandler( boost::shared_ptr<HandleInput> pHandleInput )
{
	pHandleInput_ = pHandleInput;
}

bool HandleInput::nextHandlerWork( const std::string& inputNumberString )
{
	return pHandleInput_->handleInputNumber(inputNumberString);
}

bool HandleOne::handleInputNumber( const std::string& inputNumberString )
{
	string inputString1, inputString2;
	if ("1" == inputNumberString)
	{
		cout << "输入第一个单词：";
		getline(cin, inputString1);
		cout << "输入第二个单词：";
		getline(cin, inputString2);
		setSynonym(inputString1, inputString2);
		cout << "设置成功。\n";
		return false;
	}
	else
	{
		return nextHandlerWork(inputNumberString);
	}
}

bool HandleTwo::handleInputNumber( const std::string& inputNumberString )
{
	string inputString1, inputString2;
	if ("2" == inputNumberString)
	{
		cout << "输入第一个单词：";
		getline(cin, inputString1);
		cout << "输入第二个单词：";
		getline(cin, inputString2);
		if (true == isSynonym(inputString1, inputString2))
		{
			cout << inputString1 << " 和 " << inputString2 << " 是近义词。\n";
		}
		else
		{
			cout << inputString1 << " 和 " << inputString2 << " 不是近义词。\n";
		}
		return false;
	}
	else
	{
		return nextHandlerWork(inputNumberString);
	}
}

bool HandleThree::handleInputNumber( const std::string& inputNumberString )
{
	if ("3" == inputNumberString)
	{
		printSynonym();
		return false;
	}
	else
	{
		return nextHandlerWork(inputNumberString);
	}
}

bool HandleFour::handleInputNumber( const std::string& inputNumberString )
{
	if ("4" == inputNumberString)
	{
		clear();
		cout << "所有近义词关系被清空。\n";
		return false;
	}
	else
	{
		return nextHandlerWork(inputNumberString);
	}
}

bool HandleFive::handleInputNumber( const std::string& inputNumberString )
{
	if ("5" == inputNumberString)
	{
		return true;
	}
	else
	{
		return nextHandlerWork(inputNumberString);
	}
}

bool HandleOther::handleInputNumber( const std::string& inputNumberString )
{
	cout << "输入数字不正确，请重新选择。\n";
	return false;
}

//ControlAll.h
#ifndef __CONTROLALL_H__
#define __CONTROLALL_H__

void synonymOperations();
#endif

//ControlAll.cpp
#include <iostream>
#include "boost/shared_ptr.hpp"
#include "ControlAll.h"
#include "MaintainSynonym.h"
#include "HandleInput.h"
using namespace std;

void showMenu()
{
	cout << "\n====================================\n"
		<< "1. 设置近义词\n"
		<< "2. 判断近义词\n"
		<< "3. 打印所有近义词关系\n"
		<< "4. 清空所有近义词关系\n"
		<< "5. 退出\n====================================\n"
		<< "请输入数字选择操作：";
}

void showMenuAndGetInputString(string& inputString)
{
	showMenu();
	getline(cin, inputString);
}

void synonymOperations()
{
	boost::shared_ptr<HandleInput> pHandleOne(new HandleOne);
	boost::shared_ptr<HandleInput> pHandleTwo(new HandleTwo);
	boost::shared_ptr<HandleInput> pHandleThree(new HandleThree);
	boost::shared_ptr<HandleInput> pHandleFour(new HandleFour);
	boost::shared_ptr<HandleInput> pHandleFive(new HandleFive);
	boost::shared_ptr<HandleInput> pHandleOther(new HandleOther);

	pHandleOne->setNextHandler(pHandleTwo);
	pHandleTwo->setNextHandler(pHandleThree);
	pHandleThree->setNextHandler(pHandleFour);
	pHandleFour->setNextHandler(pHandleFive);
	pHandleFive->setNextHandler(pHandleOther);

	string inputString;
	bool stopFlag = false;
	while (true != stopFlag)
	{
		showMenuAndGetInputString(inputString);
		stopFlag = pHandleOne->handleInputNumber(inputString);
	}
}

//main.cpp
#include "ControlAll.h"

int main() 
{
	synonymOperations();
}
//------------------------------------------------------------------------------------------------
//将正整数数组内的数字排列成最小的数字字符串
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <sstream>
#include <set>
//#include <iterator>
#include <numeric>
#include <functional>
using namespace std;

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

class MakeMultiSet
{
public:
	MakeMultiSet(multiset<string, less<string> >& stringNumberSet): stringNumberSet_(stringNumberSet) { }
	void operator()(int number) const
	{
		stringNumberSet_.insert(intToString(number));
	}
private:
	multiset<string, less<string> >& stringNumberSet_;
};

int getMinimalString(int intArr[], int length, char* outputStr)
{
	multiset<string, less<string> > stringNumberSet;//这里不需要指定比较函数，传入的less<string>比较函数对象就是string的默认比较方式，所以用multiset<string> stringNumberSet;即可
	for_each(intArr, intArr + length, MakeMultiSet(stringNumberSet));
	//copy(stringNumberSet.begin(), stringNumberSet.end(), ostream_iterator<string>(cout, "\n"));
	string outputString;
	outputString = accumulate(stringNumberSet.begin(), stringNumberSet.end(), outputString);
	//cout << outputString << endl;
	strncpy(outputStr, outputString.c_str(), outputString.size() + 1);
	return 1;
}

int main ()
{
	int intArr[] = {259, 112, 98};
	int arrLength = 3;
	char outputChar[10] = {0};
	cout << getMinimalString(intArr, arrLength, outputChar) << endl;
	cout << outputChar << endl;
}
//------------------------------------------------------------------------------------------------
//求最大严格递减数，相邻的后一位比前一位小，则构成递减数。如9657820，965为最大递减数。
//负数返回-1，0返回0，严格递减995返回95，小于10返回本身，3333返回3，123返回3。
#include <iostream>
#include <algorithm>
#include <string>
#include <sstream>
#include <cstdlib>
using namespace std;

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

int stringToInt(const string& s)
{
	char* offset;
	return strtol(s.c_str(), &offset, 10);
}

class CountMax
{
public:
	CountMax(const string& s): 
	  s_(s), maxDegressiveStr_("0"), maxDegressiveNum_(0), lastChar_('0'), index_(0), tempNumLength_(1)  { }
	void operator()(char c)
	{
		if (c < lastChar_)
		{
			++tempNumLength_;
		}
		else 
		{
			string tempStringNum(index_ == 0 ? s_.substr(0, 1) : s_.substr(index_ - tempNumLength_, tempNumLength_));
			tempNumLength_ = 1;
			if (tempStringNum.size() >= maxDegressiveStr_.size())
			{
				int tempInt = stringToInt(tempStringNum);
				maxDegressiveNum_ = (tempInt > maxDegressiveNum_) ? (maxDegressiveStr_.assign(tempStringNum), tempInt) : maxDegressiveNum_;
			}
		}
		lastChar_ = c;
		++index_;
	}
	int getMax()
	{
		return maxDegressiveNum_;
	}
private:
	const string& s_;
	string maxDegressiveStr_;
	int maxDegressiveNum_;
	char lastChar_;
	int index_;
	int tempNumLength_;
};

int getMaxDegressiveNum(int num)
{
	if (num < 0)
	{
		return -1;
	}
	else if (0 == num)
	{
		return 0;
	}
	else if(num < 10)
	{
		return num;
	}

	string numberString(intToString(num));
	numberString.append("A");
	return for_each(numberString.begin(), numberString.end(), CountMax(numberString)).getMax();
}

int main ()
{
	int number = 32154;
	cout << getMaxDegressiveNum(number) << endl;
}
//------------------------------------------------------------------------------------------------
//对一个输入字符串判断由几个单词组成（单词组成为一个或一个以上数字或字母）
#include <iostream>
#include <algorithm>
#include <string>
#include <cctype>
using namespace std;

class CountWords
{
public:
	CountWords(): wordsNumber_(0), lastIsAWord_(false) {}
	void operator()(char c)
	{
		if (lastIsAWord_ && !currentCharIsWordSymbol(c))
		{
			++wordsNumber_;
			lastIsAWord_ = false;
		}
		else if (currentCharIsWordSymbol(c))
		{
			lastIsAWord_ = true;
		}
		else
		{
			lastIsAWord_ = false;
		}
	}
	int getWordsNumber() const
	{
		return wordsNumber_;
	}
private:
	bool currentCharIsWordSymbol(char c) const
	{
		return (isalpha(c) || isdigit(c));
	}
	int wordsNumber_;
	bool lastIsAWord_;
};

int getInputString(char* inputStr)
{
	string inputString(inputStr);
	inputString.append(" ");//用来分隔最后一个单词
	return for_each(inputString.begin(), inputString.end(), CountWords()).getWordsNumber();
}

int main ()
{
	char* s = "'''''''''''''''''NiceWok'Ni''----- Hao          Ma12345----------";
	cout << getInputString(s) << endl;;
}
//------------------------------------------------------------------------------------------------
//对输入字符串统计数字空格字母个数，并按个数从多到少排序，如果个数一样，则按ANSI码从小到大排序
#include <iostream>
#include <algorithm>
#include <string>
#include <iterator>
#include <list>
#include <map>
#include <cctype>
#include <cstring>
using namespace std;

class CountNumber
{
public:
	CountNumber(map<char, int>& charIntMap):charIntMap_(charIntMap) { }
	void operator()(char c)
	{
		if (isalpha(c) || isdigit(c) || ' ' == c)
		{
			++charIntMap_[c];
		}
	}
private:
	map<char, int>& charIntMap_;
};

class CharSort
{
public:
	bool operator()(pair<char, int>& lhs, pair<char, int>& rhs) const
	{
		if (lhs.second > rhs.second)
		{
			return true;
		}
		else if (lhs.second == rhs.second)
		{
			return lhs.first < rhs.first;	
		}
		else
		{
			return false;
		}
	}
};

class MakeStaticString
{
public:
	char operator()(pair<char, int>& charIntPair) const
	{
		return charIntPair.first;
	}
};

string outputStr("");
string tempStr("");

void getInputString(char* inputStr)
{
	if (0 == inputStr || 0 == strcmp(inputStr, ""))
	{
		return;
	}
	tempStr.append(inputStr);
	map<char, int> charIntMap;
	for_each(tempStr.begin(), tempStr.end(), CountNumber(charIntMap));

	list<pair<char, int> > charIntList;
	copy(charIntMap.begin(), charIntMap.end(), back_inserter(charIntList));
	charIntList.sort(CharSort());

	outputStr.assign(charIntList.size(), ' ');
	transform(charIntList.begin(), charIntList.end(), outputStr.begin(), MakeStaticString());
	//for (list<pair<char, int> >::iterator iter = charIntList.begin(); iter != charIntList.end(); ++iter)
	//{
	//	cout << (*iter).first << ": " << (*iter).second << endl;
	//}
	//cout << outputStr << endl;
}

int getStaticString(char** inputStr)
{
	if ("" == outputStr)
	{
		*inputStr = NULL;
		return 0;
	}

	int maxNumber = outputStr.size() + 1;
	*inputStr = new char[maxNumber];
	strncpy(*inputStr, outputStr.c_str(), maxNumber);
	return 1;
}

void clearStaticString()
{
	outputStr.assign("");
	tempStr.assign("");
}

int main ()
{
	char* s = "NiceWok Ni Hao Ma12345";
	getInputString(s);

	char* pOutputstr;
	int result = getStaticString(&pOutputstr);
	cout << result << endl;
	if (NULL != pOutputstr)
	{
		cout << pOutputstr << endl;
		delete [strlen(pOutputstr) + 1] pOutputstr;
	}
	else
	{
		cout << "pOutputStr is NULL." << endl;
	}
}
//------------------------------------------------------------------------------------------------
//检测一字符串中连续最长的数字串，返回长度。如果存在长度相同的连续字符串，返回最后一个。如果没有数字，返回空字符串“”，不是NULL。
//函数原型unsigned int Continumax(char** pOutputstr, char* inputstr)
//输入char* inputstr
//输出 char** pOutputstr，连续最长数字串，如果连续最长的数字串长度为0，返回空字符串，输入空也返回空字符串。
#include <iostream>
#include <algorithm>
#include <string>
#include <cctype>
#include <cstring>
using namespace std;

class CountContinuousNumber
{
public:
	CountContinuousNumber(const string& s, string& longestNumberS): 
	s_(s), longestNumberS_(longestNumberS), index_(0), endIndexOfLongestNumber_(0), n_(0), maxN_(0) 
	{

	}
	void operator()(char c)
	{
		if (isdigit(c))
		{
			n_++;
			maxN_ = (n_ >= maxN_ ? (endIndexOfLongestNumber_ = index_, n_) : maxN_);
		}
		else
		{
			n_ = 0;
		}
		index_++;
	}
	int getMaxContinuousNumberAndSetString()
	{
		longestNumberS_ = s_.substr(endIndexOfLongestNumber_ + 1 - maxN_, maxN_);
		return maxN_;
	}
private:
	const string& s_;
	string& longestNumberS_;
	int index_;
	int endIndexOfLongestNumber_;
	int n_;
	int maxN_;
};

unsigned int Continumax(char** pOutputstr, char* inputstr)
{
	if (0 == inputstr || strcmp(inputStr, "") == 0)
	{
		*pOutputstr = new char[1];
		(*pOutputstr)[0] = '\0';
		return 0;
	}
	string s(inputstr);
	string longestNumberS;
	unsigned maxNumber = for_each(s.begin(), s.end(), CountContinuousNumber(s, longestNumberS)).getMaxContinuousNumberAndSetString();
	*pOutputstr = new char[maxNumber + 1];
	strncpy(*pOutputstr, longestNumberS.c_str(), maxNumber + 1);
	return maxNumber;
}

int main ()
{
	char* s = "55555aa51235555555554a";
	char* pOutputstr;
	cout << Continumax(&pOutputstr, s) << endl;
	cout << pOutputstr << endl;
	delete [strlen(pOutputstr) + 1] pOutputstr;
	//string longestNumberS;
	//cout << for_each(s.begin(), s.end(), CountContinuousNumber(s, longestNumberS)).getMaxContinuousNumberAndSetString() << endl;
	//cout << longestNumberS << endl;
}
//------------------------------------------------------------------------------------------------
//对基类成员变量的初始化只能通过调用基类构造函数来完成，不能在派生类中调用初始化列表
#include <iostream>
using namespace std;

class Base
{
public:
	Base(int n): n_(n) {	}
	void show()
	{
		cout << n_ << endl;
	}
protected:
	int n_;
};

class Derived: public Base
{
public:
	Derived(): n_(5) { }//n_不是派生类成员，不能在这里用成员初始化列表初始化，必须用Derived(): Base(5) { }
};

int main ()
{
	Base* pD = new Derived;
	pD->show();
	delete pD;
}
//------------------------------------------------------------------------------------------------
//检测Hello的状态机程序
（
//首先，用string::find就可以直接搞定。。。
#include <iostream>
#include <string>
using namespace std;

int main ()
{
	char* s = "abcHellHelloabc";
	string str(s);
	size_t pos = str.find("Hello");
	if (pos != string::npos)
	{
		cout << "1" << endl;
	}
	else
	{
		cout << "0" << endl;
	}
}
）
//LetterState.h
#ifndef __LETTERSTATE_H__
#define __LETTERSTATE_H__

class CheckHello;

class LetterState
{
public:
	virtual ~LetterState();
	virtual void getALetter(char c) = 0;
};

class NoState: public LetterState
{
public:
	NoState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};

class HState: public LetterState
{
public:
	HState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};

class EState: public LetterState
{
public:
	EState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};

class FirstLState: public LetterState
{
public:
	FirstLState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};

class SecondLState: public LetterState
{
public:
	SecondLState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};

class OState: public LetterState
{
public:
	OState(CheckHello* ch);
	virtual void getALetter(char c);
private:
	CheckHello* pCheckHello_;
};
#endif

//LetterState.cpp
#include "LetterState.h"
#include "CheckHello.h"

LetterState::~LetterState()
{

}

NoState::NoState( CheckHello* ch ): pCheckHello_(ch)
{

}

void NoState::getALetter( char c )
{
	if ('H' == c)
	{
		pCheckHello_->setHState();
	}
}

HState::HState( CheckHello* ch ): pCheckHello_(ch)
{

}

void HState::getALetter( char c )
{
	if ('H' == c)
	{
	}
	else if ('e' == c)
	{
		pCheckHello_->setState(pCheckHello_->getEState());
	}
	else
	{
		pCheckHello_->setNoState();
	}
}

EState::EState( CheckHello* ch ): pCheckHello_(ch)
{

}

void EState::getALetter( char c )
{
	if ('l' == c)
	{
		pCheckHello_->setState(pCheckHello_->getFirstLState());
	}
	else if ('H' == c)
	{
		pCheckHello_->setHState();
	}
	else
	{
		pCheckHello_->setNoState();
	}
}

FirstLState::FirstLState( CheckHello* ch ): pCheckHello_(ch)
{

}

void FirstLState::getALetter( char c )
{
	if ('l' == c)
	{
		pCheckHello_->setState(pCheckHello_->getSecondLState());
	}
	else if ('H' == c)
	{
		pCheckHello_->setHState();
	}
	else
	{
		pCheckHello_->setNoState();
	}
}

SecondLState::SecondLState( CheckHello* ch ): pCheckHello_(ch)
{

}

void SecondLState::getALetter( char c )
{
	if ('o' == c)
	{
		pCheckHello_->setState(pCheckHello_->getOState());
		pCheckHello_->setCheckHelloFlag();
	}
	else if ('H' == c)
	{
		pCheckHello_->setHState();
	}
	else
	{
		pCheckHello_->setNoState();
	}
}

OState::OState( CheckHello* ch ): pCheckHello_(ch)
{

}

void OState::getALetter( char c )
{
	pCheckHello_->resetCheckHelloFlag();
	if ('H' == c)
	{
		pCheckHello_->setHState();
	}
	else
	{
		pCheckHello_->setNoState();
	}
}

//CheckHello.h
#ifndef __CHECKHELLO_H__
#define __CHECKHELLO_H__
#include <memory>
#include "LetterState.h"//或者加这行就不会报warning C4150

class LetterState;

class CheckHello
{
public:
	CheckHello();
	//~CheckHello();不加这个就会报warning C4150
	void getALetter(char c);
	std::auto_ptr<LetterState>& getNoState();
	std::auto_ptr<LetterState>& getHState();
	std::auto_ptr<LetterState>& getEState();
	std::auto_ptr<LetterState>& getFirstLState();
	std::auto_ptr<LetterState>& getSecondLState();
	std::auto_ptr<LetterState>& getOState();

	void setNoState();
	void setHState();

	void setState(std::auto_ptr<LetterState>& state);

	void setCheckHelloFlag();
	void resetCheckHelloFlag();
	bool getCheckHelloFlag();
private:
	std::auto_ptr<LetterState> pNoState_;
	std::auto_ptr<LetterState> pHState_;
	std::auto_ptr<LetterState> pEState_;
	std::auto_ptr<LetterState> pFirstLState_;
	std::auto_ptr<LetterState> pSecondLState_;
	std::auto_ptr<LetterState> pOState_;
	std::auto_ptr<LetterState>* pCurrentState_;
	bool checkHelloFlag_;
};
#endif

//CheckHello.cpp
#include "CheckHello.h"
#include "LetterState.h"

CheckHello::CheckHello():
pNoState_(),	pHState_(), pEState_(), pFirstLState_(), pSecondLState_(), pOState_(), pCurrentState_(0), checkHelloFlag_(false)
{
	pNoState_.reset(new NoState(this));
	pHState_.reset(new HState(this));
	pEState_.reset(new EState(this));
	pFirstLState_.reset(new FirstLState(this));
	pSecondLState_.reset(new SecondLState(this));
	pOState_.reset(new OState(this));
	pCurrentState_ = &pNoState_;
}

/* CheckHello::~CheckHello()
{

} */

void CheckHello::getALetter( char c )
{
	(*pCurrentState_)->getALetter(c);
}

std::auto_ptr<LetterState>& CheckHello::getNoState()
{
	return pNoState_;
}

std::auto_ptr<LetterState>& CheckHello::getHState()
{
	return pHState_;
}

std::auto_ptr<LetterState>& CheckHello::getEState()
{
	return pEState_;
}

std::auto_ptr<LetterState>& CheckHello::getFirstLState()
{
	return pFirstLState_;
}

std::auto_ptr<LetterState>& CheckHello::getSecondLState()
{
	return pSecondLState_;
}

std::auto_ptr<LetterState>& CheckHello::getOState()
{
	return pOState_;
}

void CheckHello::setState( std::auto_ptr<LetterState>& state )
{
	pCurrentState_ = &state;
}

void CheckHello::setCheckHelloFlag()
{
	checkHelloFlag_ = true;
}

void CheckHello::resetCheckHelloFlag()
{
	checkHelloFlag_ = false;
}

bool CheckHello::getCheckHelloFlag()
{
	return checkHelloFlag_;
}

void CheckHello::setNoState()
{
	pCurrentState_ = &pNoState_;
}

void CheckHello::setHState()
{
	pCurrentState_ = &pHState_;
}

//TestString.h
#ifndef __TESTSTRING_H__
#define __TESTSTRING_H__

int testString(char* s);
#endif

//TestString.cpp
#include <string>
#include <iostream>
#include "TestString.h"
#include "CheckHello.h"
using namespace std;

void clearWork(CheckHello& checkHello)
{
	checkHello.setNoState();
	checkHello.resetCheckHelloFlag();
}

int testString( char* s )
{
	if (0 == s)
	{
		return 0;
	}
	string str(s);
	CheckHello checkHello;
	for (string::iterator iter = str.begin(); iter != str.end(); ++iter)
	{
		checkHello.getALetter(*iter);
	}

	int result;
	result = (true == checkHello.getCheckHelloFlag()) ? 1 : 0;

	clearWork(checkHello);
	return result;
}

//main.cpp
#include <iostream>
#include "TestString.h"
using namespace std;

int main ()
{
	char* s = "abcHellHelloabc";
	cout << testString(s) << endl;
}

两个问题：
一、报一个warning，问题在哪里呢？
1>c:\program files\microsoft visual studio 10.0\vc\include\memory(931): warning C4150: 删除指向不完整“LetterState”类型的指针；没有调用析构函数
1>          d:\program files\vc projects\learningtest\learningtest\checkhello.h(5) : 参见“LetterState”的声明
1>          c:\program files\microsoft visual studio 10.0\vc\include\memory(930): 编译类 模板 成员函数“std::auto_ptr<_Ty>::~auto_ptr(void)”时
1>          with
1>          [
1>              _Ty=LetterState
1>          ]
1>          d:\program files\vc projects\learningtest\learningtest\checkhello.h(27): 参见对正在编译的类 模板 实例化“std::auto_ptr<_Ty>”的引用
1>          with
1>          [
1>              _Ty=LetterState
1>          ]
二、如果扩展需要检查HelloWorld，扩展的LetterState类应该放在哪里？如果放在LetterState.h里，那不是头文件还是重新编译一遍？如果放在LetterState.cpp里，那include LetterState.h还是无法看新增的类？

一、答：
（http://blog.csdn.net/zzw315/article/details/6026793
说是：
根据上面的warning知道了，是因为我调用删除对象的时候，CBaseData的定义不完整

在CheckHello.h里加这个就不会报错了
#include "LetterState.h"
或是
声明~CheckHello();并定义其空实现
CheckHello::~CheckHello()
{
	//在这种情况下，auto_ptr会自己释放吗。会的，见下面写的测试样例
}
不是很理解？？？
难道说如果不声明~CheckHello()，就走不到CheckHello.cpp里，CheckHello在析构时就看不到类LetterState的完整定义？
）
#include <iostream>
#include <memory>
using namespace std;

class Test
{
public:
	~Test()
	{
		cout << "~Test" << endl;
	}
};

class C
{
public:
	C(): pTest_(new Test) {}
	~C()
	{
		cout << "~C" << endl;
	}
private:
	auto_ptr<Test> pTest_;
};

int main ()
{
	C c;
}
输出如下：
~C
~Test
请按任意键继续. . .

析构函数里虽然空实现，啥都没干，但是在析构结束时，auto_ptr对象还是会自动释放掉。

另外http://blog.csdn.net/feiyinzilgd/article/details/6263822
里提到了
“这个waring会导致内存泄露。前向申明的类的析构函数没有被调用
出现原因：
class Phone;这种方式向前申明，其后面的类只能申明其指针，前向申明以后的类无法看到其类实体。
所以，delete的时候，Phone的析构函数对后面的类是透明不可见的，除非使用头文件包含。”

//------------------------------------------------------------------------------------------------
//虚函数可以定义为纯虚函数，同时也可以提供默认定义，但这时候的默认定义没什么作用，因为派生类必须要提供该成员函数的定义，否则无法实例化
//所以一般当某个基类需要不能实例化时，可以将纯虚函数的声明=0加在析构函数上。
//如果需要基类提供某些函数的默认定义，则该函数不能加纯虚声明=0。
#include <iostream>
using namespace std;

class Base
{
public:
	virtual ~Base()
	{

	}
	virtual void show() = 0
	{
		cout << "base::show" << endl;
	}
};

class Derived: public Base
{
private:
	virtual void show()
	{
		cout << "derived::show" << endl;
	}
};

int main ()
{
	Base* pD = new Derived();
	pD->show();
	delete pD;
}
//------------------------------------------------------------------------------------------------
//map里的key即为key
// map::key_comp
#include <iostream>
#include <map>
using namespace std;

int main ()
{
  map<char,int> mymap;
  map<char,int>::key_compare mycomp;
  map<char,int>::iterator it;
  char highest;

  mycomp = mymap.key_comp();

  mymap['a']=100;
  mymap['b']=200;
  mymap['c']=300;

  cout << "mymap contains:\n";

  highest=mymap.rbegin()->first;     // key value of last element

  it=mymap.begin();
  do {
    cout << (*it).first << " => " << (*it).second << endl;
  } while ( mycomp((*it++).first, highest) );

  cout << endl;

  return 0;
}

//map里存储的pair即为value
// map::value_comp
#include <iostream>
#include <map>
using namespace std;

int main ()
{
	map<char,int> mymap;
	map<char,int>::iterator it;
	map<char, int>::reverse_iterator rIt;
	pair<char,int> highest;

	mymap['x']=1001;
	mymap['y']=2002;
	mymap['z']=3003;

	cout << "mymap contains:\n";

	rIt = mymap.rbegin();
	++rIt;
	highest=*rIt;        // last element

	it=mymap.begin();
	do {
		cout << (*it).first << " => " << (*it).second << endl;
	} while ( mymap.value_comp()(*it++, highest) );

	return 0;
}
//------------------------------------------------------------------------------------------------
//如此理解面向对象，类似《大话设计模式》中的反射，不用if...else...的判断条件来扩展类。在工厂类中用一个map保存所有对象，当有新有对象时，只需要把新对象注册进工厂类中即可，从而避免了修改原代码的判断逻辑。
//OsDiscriminator.h
#ifndef __OSDISCRIMINATOR_H__
#define __OSDISCRIMINATOR_H__
#include <string>
#include <map>
#include "boost/shared_ptr.hpp"
//#include "BoxSpecifier.h"

class BoxSpecifier;//在头文件里如果不是需要该类的完整定义，就只需要包括一个该类的声明，以避免后续的头文件编译依赖

class OsDiscriminator
{
public:
	static boost::shared_ptr<BoxSpecifier> getBoxSpecifier();
	static void registerBoxSpecifier(const std::string& osName, boost::shared_ptr<BoxSpecifier> boxSpecifier);//这个就是注册新对象的方法
	static void registerKnowingBoxSpecifier();
private:
	static std::map<std::string, boost::shared_ptr<BoxSpecifier> > osTypeMap_;
};

#endif

//OsDiscriminator.cpp
#include "OsDiscriminator.h"
#include "BoxSpecifier.h"
using namespace std;

string getOsName()
{	
	string osName("Mac");
	return osName;
}

boost::shared_ptr<BoxSpecifier> OsDiscriminator::getBoxSpecifier()
{
	OsDiscriminator::registerKnowingBoxSpecifier();//这里会注册所有已知的对象
	string osName = getOsName();
	map<string, boost::shared_ptr<BoxSpecifier> >::iterator iter = osTypeMap_.find(osName);
	if (osTypeMap_.end() != iter)
	{
		return iter->second;
	}
	else
	{
		return boost::shared_ptr<BoxSpecifier>(new DefaultBox());
	}
}

void OsDiscriminator::registerBoxSpecifier( const string& osName, boost::shared_ptr<BoxSpecifier> boxSpecifier )
{
	osTypeMap_.insert(make_pair(osName, boxSpecifier));
}

void OsDiscriminator::registerKnowingBoxSpecifier()
{
	WindowsBox::registerToDiscriminator();
	UnixBox::registerToDiscriminator();
	MacBox::registerToDiscriminator();
}

map<string, boost::shared_ptr<BoxSpecifier> > OsDiscriminator::osTypeMap_;

//BoxSpecifier.h
#ifndef __BOXSPECIFIER_H__
#define __BOXSPECIFIER_H__
#include <string>
#include "boost/shared_ptr.hpp"

class BoxSpecifier
{
public:
	virtual ~BoxSpecifier();
	virtual std::string getStatement() = 0;
	//virtual void registerToDiscriminator() = 0;
};

class WindowsBox: public BoxSpecifier
{
public:
	static boost::shared_ptr<BoxSpecifier> getInstance();
	virtual std::string getStatement();
	static void registerToDiscriminator();
private:
	WindowsBox() { };
	WindowsBox(const WindowsBox&);
	WindowsBox& operator=(const WindowsBox&);
};

class UnixBox: public BoxSpecifier
{
public:
	static boost::shared_ptr<BoxSpecifier> getInstance();
	virtual std::string getStatement();
	static void registerToDiscriminator();
private:
	UnixBox() { };
	UnixBox(const UnixBox&);
	UnixBox& operator=(const UnixBox&);
};

class MacBox: public BoxSpecifier
{
public:
	static boost::shared_ptr<BoxSpecifier> getInstance();
	virtual std::string getStatement();
	static void registerToDiscriminator();
private:
	MacBox() { };
	MacBox(const MacBox&);
	MacBox& operator=(const MacBox&);
};

class DefaultBox: public BoxSpecifier
{
public:
	virtual std::string getStatement();
};

#endif

//BoxSpecifier.cpp
#include "BoxSpecifier.h"
#include "OsDiscriminator.h"
using namespace std;

BoxSpecifier::~BoxSpecifier()
{

}

boost::shared_ptr<BoxSpecifier> WindowsBox::getInstance()
{
	static boost::shared_ptr<BoxSpecifier> instance(new WindowsBox());
	return instance;
}

std::string WindowsBox::getStatement()
{
	return "This is Windows box and therefore bad.";
}

void WindowsBox::registerToDiscriminator()
{
	OsDiscriminator::registerBoxSpecifier("Windows7", getInstance());
	OsDiscriminator::registerBoxSpecifier("Windows8", getInstance());
	OsDiscriminator::registerBoxSpecifier("WindowsVista", getInstance());
}

boost::shared_ptr<BoxSpecifier> UnixBox::getInstance()
{
	static boost::shared_ptr<BoxSpecifier> instance(new UnixBox());
	return instance;
}

std::string UnixBox::getStatement()
{
	return "This is Unix box and therefore good.";
}

void UnixBox::registerToDiscriminator()
{
	OsDiscriminator::registerBoxSpecifier("Linux", getInstance());
	OsDiscriminator::registerBoxSpecifier("Unix", getInstance());
}

boost::shared_ptr<BoxSpecifier> MacBox::getInstance()
{
	static boost::shared_ptr<BoxSpecifier> instance(new MacBox());
	return instance;
}

std::string MacBox::getStatement()
{
	return "This is Mac box and therefore far superior.";
}

void MacBox::registerToDiscriminator()
{
	OsDiscriminator::registerBoxSpecifier("Mac", getInstance());
}

std::string DefaultBox::getStatement()
{
	return "This is not a box.";
}

//main.cpp
#include <iostream>
#include <string>
#include "OsDiscriminator.h"
#include "BoxSpecifier.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main()
{
	//boost::shared_ptr<BoxSpecifier> b(OsDiscriminator::getBoxSpecifier());
	//cout << b->getStatement() << endl;
	cout << OsDiscriminator::getBoxSpecifier()->getStatement() << endl;
}
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "myString.h"
#include <string>
using namespace std;

void show2()
{
	cout << "hello" << endl;
}

class Test
{
public:
	void show()
	{
		show2();//如果能在类中找到相应函数，类外的全局函数就不会被调用到，而不会有二义性；如果类中空间没有找到相应函数，就到类定义前的空间搜索，如果没有找到则编译错误；就是说，如果类中没有声明Test::show2()，并且::show2()声明在class Test之后，则编译错误，找不到对应函数；想调用全局函数，则::show();；但如果将::show2()声明放到class Test之后，并且调用::show2()，则编译错误，无法找到全局show2()
	}
	void show2()
	{
		cout << "world" << endl;
	}
};

int main(int argc, char* argv[])
{
	Test t;
	t.show();
}
//------------------------------------------------------------------------------------------------
//为什么进入haveALook没有构造临时变量？
#include <iostream>
using namespace std;

class Test 
{
public:
	Test(): i_(0)
	{
		cout << "constructor" << endl;
	}
	~Test()
	{
		cout << "destructor" << endl;
	}
	void changeVal(int number)
	{
		i_ = number;
		cout << "new value is " << number << endl;
	}
	void show()
	{
		cout << "value is " << i_ << endl;
	}
private:
	int i_;
};

void haveALook(Test test)
{
	test.changeVal(10);
	cout << "do nothing" << endl;
}

int main(int argc, char* argv[])
{
	Test test;
	haveALook(test);
	test.show();
}
//------------------------------------------------------------------------------------------------
//以前写的字符串匹配程序
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
using namespace std;

size_t num = 0;

void match(char *source, int index1, int index2, char *dest, size_t head_flag, size_t tail_flag)
{
	char *temp = NULL;
	char *p = NULL;
		
	size_t length_temp = index2 - index1 + 1;

	size_t length_dest = strlen(dest); 
	temp = (char *)malloc(length_temp + 1);
	if(NULL == temp)
	{
		return;
	}
	
	memcpy(temp, source + index1, length_temp*sizeof(char));
	*(temp + length_temp) = '\0';
	p = strstr(temp, dest);
	if(NULL != p)
	{
		char *test = NULL;
		test = (char *)malloc(length_dest + 1);
		if(NULL == test)
		{
			return;
		}

		if(0 == head_flag && 0 == tail_flag && length_temp == length_dest)
		{
			cout<<temp<<endl;
			num++;
			cout<<num<<endl;
		}
		else if(1 == head_flag && 0 == tail_flag/* && length_dest ==(temp + length_temp - p)*/)
		{
			memcpy(test, temp + length_temp - length_dest, length_dest);
			*(test + length_dest) = '\0';
			if(0 == strcmp(test, dest) || length_dest == (temp + length_temp - p))
			{
				cout<<temp<<endl;
				num++;
				cout<<num<<endl;
			}
			free(test);
			test = NULL;
		}
		else if(0 == head_flag && 1 == tail_flag && p == temp )
		{
			cout<<temp<<endl;
			num++;
			cout<<num<<endl;
		}
		else if(1 == head_flag && 1 == tail_flag)
		{
			cout<<temp<<endl;
			num++;
			cout<<num<<endl;
		}
	}
	free(temp);
	temp = NULL;
	p = NULL;
}

int FindString(char *source, char *dest)
{	
	if((NULL == dest)||(NULL == source))
	{
		return 0;
	}
	
	size_t length_source = strlen(source);
	size_t length_dest = strlen(dest);

	size_t index_for_finding_star = 0, index_of_starting_char = 0, index_of_ending_char = length_dest - 1;

	size_t head_flag = 0, tail_flag = 0, already_finding_char = 0, finding_star_after_char = 0, turn_off_flag = 0;

	char *dest_erasering_star = NULL;

	for(index_for_finding_star = 0; index_for_finding_star< length_dest; index_for_finding_star++)
	{
		if(1 == already_finding_char && '*' == *(dest + index_for_finding_star) && 0 == finding_star_after_char && 0 == turn_off_flag)
		{
			finding_star_after_char = 1;
		}

		if(0 == index_for_finding_star && '*'== *(dest + index_for_finding_star))
		{
			head_flag = 1;
		}

		if(0 == already_finding_char /*&& 1 == head_flag */&& '*'!= *(dest + index_for_finding_star))
		{
			index_of_starting_char = index_for_finding_star;
			already_finding_char = 1;
		}
		
		if(1 == finding_star_after_char && 0 == tail_flag && '*'== *(dest + index_for_finding_star))
		{
			index_of_ending_char = index_for_finding_star - 1;
			finding_star_after_char = 0;
			turn_off_flag = 1;
		}
		
		if((length_dest - 1) == index_for_finding_star && '*'== *(dest + index_for_finding_star))
		{
			tail_flag = 1;
		}
	}
	size_t length_dest_erasering_star = index_of_ending_char - index_of_starting_char + 1;
	dest_erasering_star = (char *)malloc(length_dest_erasering_star + 1);
	if(NULL == dest_erasering_star)
	{
		return 0;
	}
	memcpy(dest_erasering_star, dest + index_of_starting_char, length_dest_erasering_star);
	*(dest_erasering_star + length_dest_erasering_star) = '\0';
	
	size_t index1 = 0, index2 = length_dest_erasering_star - 1;
	for(index1 = 0; index1 <= (length_source - length_dest_erasering_star);index1++)
	{
		for(index2 = (index1 + length_dest_erasering_star - 1); index2 <=length_source-1; index2++)
		{
			match(source, index1, index2, dest_erasering_star, head_flag, tail_flag);
		}
	}
	return 0;
}

int main()
{
 	char *source_str = "abcbbc";
	char *dest_str = "*bc";
	//size_t t = 0;
	int t = 0;
	t = FindString(source_str, dest_str);
	return 0;
}
//------------------------------------------------------------------------------------------------
//内置类型上下限
#include <limits>
numeric_limits<double>::max()
numeric_limits<double>::min()

cout << numeric_limits<int>::max() << endl;
cout << numeric_limits<int>::min() << endl;
2147483647
-2147483648
//------------------------------------------------------------------------------------------------
//输入输出迭代器实现文件读入输出
#include <iostream>
#include <iterator>
#include <fstream>
#include <string>
using namespace std;

int main () 
{
	ifstream ifs("input.txt");
	ofstream ofs("output.txt");
	istream_iterator<string> in(ifs);//in(cin)
	istream_iterator<string> eof;
	ostream_iterator<string> o(ofs, "\n");//o(ofs, " ")
	/*vector<string> vecStr(in, eof);*/
	while(in != eof)
	{
		/*vecStr.push_back(*in++);*/
		*o++ = *in++;
	}

	return 0;
}
//------------------------------------------------------------------------------------------------
//复数类，运算符重载练习（标准库中有复数库 #include <complex>）
//complex.h
#ifndef __COMPLEX__
#define __COMPLEX__
#include <iosfwd>

class complexType
{
	friend std::ostream& operator<<(std::ostream&, const complexType&);
	//friend istream& operator>>(istream&, complexType&);
	friend complexType operator+(const complexType&, const complexType&);//这种两个对象构造的运算符重载，声明为友元函数，可以让系统构造临时变量，而不用声明两个成员函数
	friend complexType operator-(const complexType&, const complexType&);
	friend complexType operator*(const complexType&, const complexType&);
public:
	void setValue(double, double imaginaryPart = 0);
	complexType(double realPart = 0, double imaginaryPart = 0);

private:
	double realPart_;
	double imaginaryPart_;
};
#endif

//complex.cpp
#include <iostream>
#include "complex.h"

std::ostream& operator<<(std::ostream& osobj, const complexType& a)
{
	osobj << "(" << a.realPart_ << ", " << a.imaginaryPart_ << ")";
	return osobj;
}

void complexType::setValue(double realPart, double imaginaryPart)
{
	realPart_ = realPart;
	imaginaryPart_ = imaginaryPart;
}

complexType operator+(const complexType& a, const complexType& b)
{
	complexType temp;
	temp.realPart_ = a.realPart_ + b.realPart_;
	temp.imaginaryPart_ = a.imaginaryPart_ + b.imaginaryPart_;
	return temp;
}

complexType operator-(const complexType& a, const complexType& b)
{
	complexType temp;
	temp.realPart_ = a.realPart_ - b.realPart_;
	temp.imaginaryPart_ = a.imaginaryPart_ - b.imaginaryPart_;
	return temp;
}

complexType operator*(const complexType& a, const complexType& b)
{
	complexType temp;
	temp.realPart_ = a.realPart_ * b.realPart_ - a.imaginaryPart_ * b.imaginaryPart_;
	temp.imaginaryPart_ = a.realPart_ * b.imaginaryPart_ + a.imaginaryPart_ * b.realPart_;
	return temp;
}

complexType::complexType(double realPart, double imaginaryPart): realPart_(realPart), imaginaryPart_(imaginaryPart)
{

}

//main.cpp
#include <iostream>
#include "complex.h"
using namespace std;

int main()
{
	complexType a;
	complexType b;
	a.setValue(3,6);
	b = 1 - a;
	
	cout << b << endl;
	return 0;
}
//------------------------------------------------------------------------------------------------
//递归实现汉诺塔
#include <iostream>
using namespace std;

void move(char pos1, char pos2, char pos3, int n)
{
	static int i = 1;
	if (1 == n)
	{
		cout << i++ << endl;
		cout << pos1 << " -> " << pos2 << endl; 
	}
	else
	{
		move(pos1, pos3, pos2, n - 1);
		cout << i++ << endl;
		cout << pos1 << " -> " << pos2 << endl; 
		move(pos3, pos2, pos1, n - 1);
	}
}

int main()
{
	move('a', 'c', 'b', 10);
}
//------------------------------------------------------------------------------------------------
//写一个接口类，实现矩形，正方形，圆的面积计算
#include <iostream>
#include <memory>
using namespace std;

//interface class
class Shape
{
public:
	virtual bool setParameter() = 0;
	virtual double getArea() const = 0;
	virtual void showShapeInfomation() const = 0;
	virtual ~Shape() {};
};

//shape Rectangle
class Rectangle: public Shape
{
public:
	Rectangle(): height_(0), width_(0) {}
	virtual bool setParameter()
	{
		return rectangleSetParameter();
	}
	virtual double getArea() const
	{
		return height_ * width_;
	}
	virtual void showShapeInfomation() const
	{
		showInformationOfRectangle();
	}
private:
	bool rectangleSetParameter();
	void showInformationOfRectangle() const;
	double height_;
	double width_;
};

bool Rectangle::rectangleSetParameter()
{
	cout << "Please set height and width for the rectangle: ";
	cin >> height_ >> width_;
	return true;
}

void Rectangle::showInformationOfRectangle() const
{
	cout << "This is a Rectangle: height(" << height_ << "), width(" << width_ << ")." << endl;
}

//shape Square
class Square: public Shape
{
public:
	Square(): sideLength_(0) {}
	virtual bool setParameter()
	{
		return squareSetParameter();
	}
	virtual double getArea() const
	{
		return sideLength_ * sideLength_;
	}
	virtual void showShapeInfomation() const
	{
		showInformationOfSquare();
	}
private:
	bool squareSetParameter();
	void showInformationOfSquare() const;
	double sideLength_;
};

bool Square::squareSetParameter()
{
	cout << "Please set length of side for the square: ";
	cin >> sideLength_;
	return true;
}

void Square::showInformationOfSquare() const
{
	cout << "This is a Square: side length(" << sideLength_ << ")." << endl;
}

//shape Circle
class Circle: public Shape
{
public:
	Circle(): radius_(0) {}
	virtual bool setParameter()
	{
		return circleSetParameter();
	}
	virtual double getArea() const
	{
		return pi * radius_ * radius_;
	}
	virtual void showShapeInfomation() const
	{
		showInformationOfCircle();
	}
private:
	bool circleSetParameter();
	void showInformationOfCircle() const;
	double radius_;
	static const double pi;//只有静态常量整型数据成员才可以在类中初始化，但是也要在类外再次定义，不用赋值
};

const double Circle::pi = 3.141592653;

bool Circle::circleSetParameter()
{
	cout << "Please set radius for the circle: ";
	cin >> radius_;
	return true;
}

void Circle::showInformationOfCircle() const
{
	cout << "This is a Circle: radius(" << radius_ << ")." << endl;
}

class ShapeFactory
{
public:
	enum ShapeType {ShapeRectangle, ShapeSquare, ShapeCircle};
	static auto_ptr<Shape> CreateNewShape(ShapeType shapeType)
	{
		switch  (shapeType)
		{
		case  ShapeRectangle:
			return auto_ptr<Shape>(new Rectangle);
		case ShapeSquare:
			return auto_ptr<Shape>(new Square);
		case ShapeCircle:
			return auto_ptr<Shape>(new Circle);
		default :
			return auto_ptr<Shape>();//默认返回空的智能指针
		}
	}
};

int main()
{
	auto_ptr<Shape> pShape(ShapeFactory::CreateNewShape(ShapeFactory::ShapeCircle));
	pShape->showShapeInfomation();
	pShape->setParameter();
	pShape->showShapeInfomation();
	cout << pShape->getArea() << endl;
}
//--改进的工厂函数，感觉有问题，Factory不可能知道要知道要建什么类型的枚举值
class Factory
{
public:
	enum ShapeType {ShapeRectangle, ShapeSquare, ShapeCircle};
	virtual ~Factory() { }
	virtual auto_ptr<Shape> createNewShape(ShapeType shapeType) = 0;
};

class ShapeFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape(ShapeType shapeType)
	{
		switch  (shapeType)
		{
		case  ShapeRectangle:
			return auto_ptr<Shape>(new Rectangle);
		case ShapeSquare:
			return auto_ptr<Shape>(new Square);
		case ShapeCircle:
			return auto_ptr<Shape>(new Circle);
		default :
			return auto_ptr<Shape>();//默认返回空的智能指针
		}
	}
};

int main()
{
	auto_ptr<Factory> pFactory(new ShapeFactory);
	auto_ptr<Shape> pShape(pFactory->createNewShape(Factory::ShapeCircle));
	pShape->showShapeInfomation();
	pShape->setParameter();
	pShape->showShapeInfomation();
	cout << pShape->getArea() << endl;
}
//--另一种改进
class Factory
{
public:
	virtual ~Factory() { }
	virtual auto_ptr<Shape> createNewShape() = 0;
};

template<typename T>
class ShapeFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape()
	{
		return auto_ptr<Shape>(new T);
	}
};

int main()
{
	auto_ptr<Factory> pFactory(new ShapeFactory<Circle>);
	auto_ptr<Shape> pShape(pFactory->createNewShape());
	pShape->showShapeInfomation();
	pShape->setParameter();
	pShape->showShapeInfomation();
	cout << pShape->getArea() << endl;
}
//设计模式中说：在实现中我们可以通过参数化工厂方法，即给FactoryMethod()传递一个参数用以决定是创建具体哪一个具体的Shape？。当然也可以通过模板化避免子类创建子类，其方法就是将具体Shape类作为模板参数。
//------------------------------------------------------------------------------------------------
//验证一个字符串数字是否合法，并将其变成数字输出 CookBook第3章
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>
using boost::lexical_cast;
using boost::bad_lexical_cast;
using namespace std;

bool isValid(string& s)
{
	bool ret = true;
	try
	{
		double integer = lexical_cast<double>(s);
	}
	catch (bad_lexical_cast &e)
	{
		ret =false;
		cerr << e.what() << endl;
	}
	return ret;
}

int main()
{
	string s("-75.0");
	//int a = boost::lexical_cast<int>(s);
	if (isValid(s))
	{
		cout << "valid number" << endl;
		cout << lexical_cast<double>(s) << endl;
	}
	else
	{
		cout << "not valid" << endl;
	}
	//cout << a << endl;
	return 0;
}
//--模板函数
#include <iostream>
#include <boost/lexical_cast.hpp>

using namespace std;
using boost::lexical_cast;
using boost::bad_lexical_cast;

template<typename T>
bool isValid(const string& num) {

   bool res = true;

   try {
      T tmp = lexical_cast<T>(num);
   }
   catch (bad_lexical_cast &e) {
      res = false;
   }

   return(res);
}

void test(const string& s) {

   if (isValid<int>(s))
      cout << s << " is a valid integer." << endl;
   else
      cout << s << " is NOT a valid integer." << endl;

   if (isValid<double>(s))
      cout << s << " is a valid double." << endl;
   else
      cout << s << " is NOT a valid double." << endl;

   if (isValid<float>(s))
      cout << s << " is a valid float." << endl;
   else
      cout << s << " is NOT a valid float." << endl;
}

int main( ) {

   test("12345");
   test("1.23456");
   test("-1.23456");
   test(" - 1.23456");
   test("+1.23456");
   test("  1.23456  ");
   test("asdf");
}
//------------------------------------------------------------------------------------------------
//--标准库函数实现字符串变数字
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

long hex2int(const string& hexStr) {
   char *offset;
   if (hexStr.length( ) > 2) {
      if (hexStr[0] == '0' && hexStr[1] == 'x') {
         return strtol(hexStr.c_str( ), &offset, 0);
      }
   }
   return strtol(hexStr.c_str( ), &offset, 16);
}

int main( ) {
   string str1 = "0x12AB";
   cout << hex2int(str1) << endl;
   string str2 = "12AB";
   cout << hex2int(str2) << endl;
   string str3 = "QAFG";
   cout << hex2int(str3) << endl;
}
//--用boost库实现，只能转换10进制数字
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>

using namespace std;

int main( ) {
   string str1 = "750";
   string str2 = "2.71";
   string str3 = "0x7FFF";
   try {
      cout << boost::lexical_cast<int>(str1) << endl;
      cout << boost::lexical_cast<double>(str2) << endl;
      cout << boost::lexical_cast<int>(str3) << endl;
   }
   catch (boost::bad_lexical_cast& e) {
      cerr << "Bad cast: " << e.what( ) << endl;
   }
}
//------------------------------------------------------------------------------------------------
//用stringstream实现数字变字符串，stringstream对象可以配合getline()实现一次读一段文本存成字符串流形式，
//然后再while(ss >> word){}实现处理单个字符串
//如下：
string line, word;
ifstream ifs("input.txt");
ofstream ofs("output.txt");
while (getline(ifs, line))
{
	istringstream lineStream(line);
	while (lineStream >> word)
	{
		ofs << word << endl;
	}
	ofs << endl;
}

#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>

using namespace std;

int main( ) {

   stringstream ss;

   ss << "There are " << 9 << " apples in my cart.";
   cout << ss.str( ) << endl;  // stringstream::str( ) returns a string
                              // with the contents

   ss.str("");                   // Empty the string
   ss << showbase << hex << 16;  // Show the base in hexadecimal
   cout << "ss = " << ss.str( ) << endl;

   ss.str("");
   ss << 3.14;
   cout << "ss = " << ss.str( ) << endl;
}
//------------------------------------------------------------------------------------------------
//直接用stringstrema实现数字与字符串之间的相互转换
#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>
using namespace std;

int main( ) 
{
	stringstream ss;
	int a = 123;

	ss << a;
	string str(ss.str());
	reverse(str.begin(), str.end());

	ss << endl;
	//标准流类知道如何解析数值，会根据对象的类型进行解析，如string，char，int等，不需要自己写实现，如果写入失败，
	//ss会设置fail()，并且右值a不会改变
	ss >> a;
	

	cout << a << endl;
}
//------------------------------------------------------------------------------------------------
//科学记数法的字符串转换成double数字
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

double sciToDub(const string& str) {

   stringstream ss(str);
   double d = 0;
   //标准流类知道如何解析数值，会根据对象的类型进行解析，如string，char，int等，不需要自己写实现，如果写入失败，
   //ss会设置fail()，并且右值不会改变
   ss >> d;

   if (ss.fail( )) {
      string s = "Unable to format ";
      s += str;
      s += " as a number!";
      throw (s);
   }

   return (d);
}

int main( ) {

   try {
      cout << sciToDub("1.234e5") << endl;
      cout << sciToDub("6.02e-2") << endl;
      cout << sciToDub("asdf") << endl;
   }
   catch (string& e) {
      cerr << "Whoops: " << e << endl;
   }
}
//------------------------------------------------------------------------------------------------
//不同类型之间的转换，如果转换出错，会抛异常
#include <iostream>
#include <boost/cast.hpp>

using namespace std;
using boost::numeric_cast;
using boost::bad_numeric_cast;

int main( ) {

   // Integer sizes
   try {
      int i = 32767;
      short s = numeric_cast<short>(i);

      cout << "s = " << s << endl;

      i++; // Now i is out of range (if sizeof(short) is 2)
      s = numeric_cast<short>(i);
   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }

   try {
      int i = 300;
      unsigned int ui = numeric_cast<unsigned int>(i);

      cout << ui << endl; // Fine

      i *= -1;
      ui = numeric_cast<unsigned int>(i); // i is negative!
   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }

   try {
      double d = 3.14;
      int i = numeric_cast<int>(d);

      i = numeric_cast<int>(d); // This shaves off the 0.14!

      cout << i << endl;  // i = 3

   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }
}
//------------------------------------------------------------------------------------------------
//显示本地时间和世界时间 CookBook例5-1
#include <iostream>
#include <ctime>
using namespace std;

void main()
{
	time_t now = time(0);
	tm* localTime = localtime(&now);
	cout << "The local date and time is " << asctime(localTime);

	tm* gTime = gmtime(&now);
	if (NULL != gTime)
	{
		cout << "The UTC date and time is " << asctime(gTime);
	}
	else
	{
		cerr << "Failed to get UTC date and time" << endl;
	}
}
//------------------------------------------------------------------------------------------------
//计算两个时间之间相差多少天
#include <ctime>
#include <iostream>
#include <cstdlib>

using namespace std;

time_t dateToTimeT(int month, int day, int year) {
	// january 5, 2000 is passed as (1, 5, 2000)
	tm tmp = tm( );
	tmp.tm_mday = day;
	tmp.tm_mon = month - 1;
	tmp.tm_year = year - 1900;
	return mktime(&tmp);
}

time_t badTime( ) {
	return time_t(-1);
}

time_t now( ) {
	return time(0);
}

int main( ) {
	time_t date1 = dateToTimeT(1,1,2000);
	time_t date2 = dateToTimeT(1,1,2001);

	if ((date1 == badTime( )) || (date2 == badTime( ))) {
		cerr << "unable to create a time_t struct" << endl;
		return EXIT_FAILURE;
	}
	double sec = difftime(date2, date1);
	long days = static_cast<long>(sec / (60 * 60 * 24));
	cout << "the number of days between Jan 1, 2000, and Jan 1, 2001, is ";
	cout << days << endl;
	return EXIT_SUCCESS;
}
//------------------------------------------------------------------------------------------------
//用Boost库计算两个时间之间差多少天
#include <iostream>
#include <boost/date_time/gregorian/gregorian.hpp>

using namespace std;
using namespace boost::gregorian;

int main( )
{
	date_duration dd = date(2000, 1, 1) - date(1900, 1, 1);
	cout << "The twentieth century had " << dd.days( ) << " days" << endl;
	dd = date(2100, 1, 1) - date(2000, 1, 1);
	cout << "The twenty-first century will have " << dd.days( ) << " days" << endl;
}
//------------------------------------------------------------------------------------------------
//某年的一天是当年的第几天 CookBook例5-9，这个代码有问题，公司学习文件已经修改过
#include <iostream>

using namespace std;

enum MonthEnum  {
	jan = 0, feb = 1, mar = 2, apr = 3, may = 4, jun = 5,
	jul = 6, aug = 7, sep = 8, oct = 9, nov = 10, dec = 11
};

bool isLeapYear(int y) {
	return (y % 4 == 0) && ((y % 100 != 0) || (y % 400 == 0));
}

const int arrayDaysInMonth[] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

int n;
int arrayFirstOfMonth[] = {
	n = 0,
	n += arrayDaysInMonth[jan],
	n += arrayDaysInMonth[feb],
	n += arrayDaysInMonth[mar],
	n += arrayDaysInMonth[apr],
	n += arrayDaysInMonth[may],
	n += arrayDaysInMonth[jun],
	n += arrayDaysInMonth[jul],
	n += arrayDaysInMonth[aug],
	n += arrayDaysInMonth[sep],
	n += arrayDaysInMonth[::oct], 
	n += arrayDaysInMonth[nov]
};

int daysInMonth(MonthEnum month, int year) {
	if (month == feb) {
		return isLeapYear(year) ? 29 : 28;
	}
	else {
		return arrayDaysInMonth[month];
	}
}

int firstOfMonth(MonthEnum month, int year) {
	return arrayFirstOfMonth[month] + isLeapYear(year);
}

int dayOfYear(MonthEnum month, int monthDay, int year) {
	return firstOfMonth(month, year) + monthDay ;
}

int main( ) {
	cout << "July 1, 1971, was the " << dayOfYear(jan, 1, 2000);
	cout << " day of the year" << endl;
}
//------------------------------------------------------------------------------------------------
//模板在函数指针上的应用C++PrimerP539
#include <iostream>
#include <string>
using namespace std;
template<typename T>
int compare(const T& lhs, const T& rhs)
{
	return lhs < rhs ? -1 : 1;
}

void fun(int(*m) (const int &a, const int& b))//可以写成void fun(int m(const int &a, const int& b))
{
	cout << m(2,3) << endl;
}

void fun2(int(*m) (const string& a, const string& b))
{
	cout << m("a", "b") << endl;
}

typedef int (*pFun)(const int&, const int&);

void main()
{
	fun(compare);
	fun2(compare);
	
	int (*p)(const int&, const int&) = compare;
	cout << p(3, 2) << endl;
	
	pFun p1 = compare;
	cout << p1(3, 2) << endl;
	
	pFun p2 = &compare;
	cout << (*p1)(3, 2) << endl;
}
//------------------------------------------------------------------------------------------------
//非类型形参模板
template<int a>//模板参数必须是常量值，不能通过cin >> a来确定模板参数
void show()
{
	cout << a << endl;
}

void main()
{
	show<3>();
}
//------------------------------------------------------------------------------------------------
//抛异常
void show(int a)
{
	if (a < 0)
	{
		throw runtime_error("error");//这里抛出的是一个异常对象
	}
	else
	{
		cout << a << endl;
	}
}
void main()
{
	try
	{
		show(-3);
	}
	catch(runtime_error &e)//捕捉异常对象，取为e，用what()输出异常信息
	{
		cerr << e.what() << endl;
	}
}
//------------------------------------------------------------------------------------------------
//使用allocator类进行内存分配与撤消CppPrimer Page633
//void *operator new(size_t)
//void *operator new[](size_t)
//void operator delete(void*)
//void operator delete[](void*)操作void*指针而不是类型化指针

//定位new表达式只接受指定内存指针初始化，不分配内存，两种方式，比allocator.construct更灵活，
//直接构造对象，而construct需要先构造默认对象，再调用复制构造函数，有可能复制构造函数私有而无法调用
//new (place_address) type
//new (place_address) type(initializer-list) 括号里可以是迭代器

//operator new			是	allocate	的低级形式
//operator delete		是	deallocate	的低级形式
//定位new表达式			是	construct	的低级形式
//析构函数显式调用->~T()是	destroy		的低级形式
//前两项负责内存分配与释放，后两项负责对象构造与析构

//对于new操作，实际new一条语句做了两个操作，先在内存上随机申请了一块大小等于该对象的内存，然后在该内存上构造了一个对象，
//不管是默认构造还是带参数的构造，然后返回指向该内存的指针；
//对于delete操作，一条语句做了两个操作，先调用对象的析构函数删除该对象，然后释放保存该对象的内存

//对于标准容器，每新增一个对象，由程序自动申请一块内存，然后用该对象的复制构造函数在这块内存上复制构造出一个新对象，（这也是为什么不能用容器保存智能指针的原因）
//用户不用自己管理这个对象和内存，由标准容器算法负责在退出作用域时，自动调用该对象的析构函数删除对象，然后释放这块内存。

//所以如果容器内保存对象是new出来的指针，仍必须由用户自己负责delete删除这些指针，才能将这些指针动态申请的内存上的对象析构并释放保存这些对象的内存，
//然后由容器删除这些指针对象以及释放保存这些指针的内存。
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
using namespace std;

void main()
{
	string strArr[] = {"my", "name", "is", "ding", "ben"};
	allocator<string> strAlloc;//声明一个string类型allocater对象
	
	//可以用operator new代替，string *begin = static_cast<string *>(operator new[](5 * sizeof(string)))。new表达式实际是调用了operator new来分配内存并构造对象
	string *begin = strAlloc.allocate(5);//分配5个string类的的内存
	
	uninitialized_fill(begin, begin + 5, "hello");//该算法希望目的地是原始的未构造内存，在目的地复制构造每个元素，而不是将原始对象赋值给目的地
	ostream_iterator<string> out(cout, "\n");//声明流输出迭代器
	copy(begin, begin + 5, out);
	string *pStr = begin;
	
	//可以用new (pStr++) string(strArr[0])代替
	strAlloc.construct(pStr++, strArr[0]);//复制构造一个元素
	
	uninitialized_copy(strArr + 1, strArr + 5, pStr);//该算法希望目的地是原始的未构造内存，在目的地复制构造每个元素，而不是将输入范围的元素赋值给目的地
	//for (pStr = begin; pStr != (begin + 5); pStr)
	//{
	//	cout << *pStr++ << endl;
	//}//利用for循环输出
	copy(begin, begin + 5, out);
	for ( ; pStr != begin; )
	{
		//可以用(--pStr)->~string()代替，显式调用析构函数来删除对象
		strAlloc.destroy(--pStr);//用destroy调用每个对象的析构函数释放资源
	}
	
	//可以用operator delete代替，operator delete[](begin)。delete表达式调用了析构函数和operator delete来删除对象及释放内存
	strAlloc.deallocate(begin, 5);//释放原数组空间，调用deallocate之前必须由用户先destroy每个对象，并且保证第一个指针参数非空，即一定是指向一个实际对象的
}
//------------------------------------------------------------------------------------------------
//编写类CatheObj重载operator new和operator delete来管理内存分配和释放
#include <iostream>

using namespace std;

template<class T>
class CacheObj
{
public:
	void *operator new(size_t);
	void operator delete(void *, size_t);
	virtual ~CacheObj();
protected:
	T* next;
private:
	static void add_to_freelist(T*);
	static allocator<T> alloc_mem_;
	static T* freeStore_;
	static const size_t chunk_;
};

template<class T>
allocator<T> CacheObj<T>::alloc_mem_;

template<class T>
T* CacheObj<T>::freeStore_ = 0;

template<class T>
const size_t CacheObj<T>::chunk_ = 1;

template<class T>
void CacheObj<T>::add_to_freelist(T*  p)
{
	p->CacheObj<T>::next = freeStore_;
	freeStore_ = p;
}
template<class T>
void * CacheObj<T>::operator new(size_t  sz)
{
	cout << "调用一次operator new" << endl;
	if (sz != sizeof(T))
	{
		throw runtime_error("CacheObj: wrong size object in operator new.");
	}
	if (!freeStore_)
	{
		cout << "调用一次allocate" << endl;
		T* arr =  alloc_mem_.allocate(chunk_);
		for (size_t i = 0; i != chunk_; ++i)
		{
			add_to_freelist(&arr[i]);
		}
	}
	T* p = freeStore_;
	freeStore_ = freeStore_->CacheObj<T>::next;
	return p;
}

template<class T>
void CacheObj<T>::operator delete(void* p, size_t)
{
	add_to_freelist(static_cast<T*>(p));
}

template<class T>
CacheObj<T>::~CacheObj()
{
	while (freeStore_ != 0)
	{
		T* p = freeStore_;
		freeStore_ = freeStore_->CacheObj::next;
		alloc_mem_.deallocate(p, 1);
	}
}

class test: public CacheObj<test>
{
public:
	test()
	{
		cout << "default construct" << endl;
	}
	test(int n): n_(n)
	{
		cout << "construct with " << n_ << endl;
	}
	~test()
	{
		cout << "destroy" << endl;
	}
private:
	int n_;
};

void main()
{
	test *p1 = new test;
	test *p2 = new test(3);
	delete p1;
	delete p2;
}
//------------------------------------------------------------------------------------------------
//（增加内存释放的版本）编写类CatheObj重载operator new和operator delete来管理内存分配和释放
//原书上的版本没有释放申请的内存，感觉不太正确，增加了一个vector保存每次申请内存的地址，最后如果派生对象都被析构删除，就释放所有内存
#include <iostream>
#include <vector>
using namespace std;

template<class T>
class CacheObj
{
public:
	void *operator new(size_t);
	void operator delete(void *, size_t);
	virtual ~CacheObj();
protected:
	T* next;
private:
	static void add_to_freelist(T*);
	static allocator<T> alloc_mem_;
	static size_t num_;
	static T* freeStore_;
	static const size_t chunk_;
	static vector<T*> mem_block_list_;
};

template<class T>
size_t CacheObj<T>::num_ = 0;

template<class T>
allocator<T> CacheObj<T>::alloc_mem_;

template<class T>
T* CacheObj<T>::freeStore_ = 0;

template<class T>
const size_t CacheObj<T>::chunk_ = 1;

template<class T>
vector<T*> CacheObj<T>::mem_block_list_;

template<class T>
void CacheObj<T>::add_to_freelist(T*  p)
{
	p->CacheObj<T>::next = freeStore_;
	freeStore_ = p;
}
template<class T>
void * CacheObj<T>::operator new(size_t  sz)
{
	cout << "调用一次operator new" << endl;
	if (sz != sizeof(T))
	{
		throw runtime_error("CacheObj: wrong size object in operator new.");
	}
	if (!freeStore_)
	{
		cout << "调用一次allocate" << endl;
		T* arr =  alloc_mem_.allocate(chunk_);
		//cout << arr << endl;
		for (size_t i = 0; i != chunk_; ++i)
		{
			add_to_freelist(&arr[i]);
		}
		mem_block_list_.push_back(arr);
	}
	++num_;//每New出来一个对象，计数就加一
	T* p = freeStore_;
	freeStore_ = freeStore_->CacheObj<T>::next;
	return p;
}

template<class T>
void CacheObj<T>::operator delete(void* p, size_t)
{
	add_to_freelist(static_cast<T*>(p));
}

template<class T>
CacheObj<T>::~CacheObj()
{
	if (--num_ == 0)//每Delete一次，就删除一个New出来的对象，计数就减一。当所有New出来的对象都Delete掉，就将所有申请的内存释放掉。
	{
		for (vector<T*>::iterator iter = mem_block_list_.begin(); iter != mem_block_list_.end(); ++iter)
		{
			cout << "deallocate" << endl;
			alloc_mem_.deallocate(*iter, chunk_);
		}
	}
}

class test: public CacheObj<test>
{
public:
	test()
	{
		cout << "default construct" << endl;
	}
	test(int n): n_(n)
	{
		cout << "construct with " << n_ << endl;
	}
	~test()
	{
		cout << "destroy" << endl;
	}
private:
	int n_;
};

void main()
{
	test *p1 = new test;
	test *p2 = new test(3);
	test *p3 = new test;
	delete p3;
	delete p1;
	delete p2;
}
//------------------------------------------------------------------------------------------------
//dynamic_cast 动态转换，将基类指针或引用对象转换成派生类对象 CppPrimer Page647
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void show()
	{
		cout << "this is base class" << endl;
	}
};

class Derived: public Base
{
public:
	virtual void show()
	{
		cout << "this is derived class" << endl;
	}
	void showDerived()
	{
		cout << "derived added" << endl;
	}
};

void main()
{	//指针的动态转换，必须有虚函数，动态转换dynamic_cast才能通过编译
	//Base *pBase =  new Derived;
	//pBase->show();
	//if (Derived *pDerived = dynamic_cast<Derived*>(pBase))//放在if里的几个好处，指针转换不成功，返回0指针
	//{
	//	pDerived->showDerived();
	//}
	//else
	//{
	//	//操作基类
	//}
	//delete pBase;

	//引用的动态转换
	Derived derivedItem;
	Base &baseItem = derivedItem;
	baseItem.show();
	try
	{
		Derived derivedItem2 = dynamic_cast<Derived&>(baseItem);//引用转换不成功，抛出bad_cast异常
		derivedItem2.showDerived();
	}
	catch(bad_cast)
	{
		//处理异常
	}
}
//------------------------------------------------------------------------------------------------
//派生类到基类的转换，也必须有虚函数才可以通过编译
#include <iostream>
#include <typeinfo>

using namespace std;

class Base {
public:
   virtual ~Base( ) {} // Make this a polymorphic class
};
class Derived : public Base {
public:
   virtual ~Derived( ) {}
};

int main( ) {

   Derived d;

   // Query the type relationship
   if (dynamic_cast<Base*>(&d)) {//转换成功则返回一个非空指针
      cout << "Derived is a subclass of Base" << endl;
   }
   else {
      cout << "Derived is NOT a subclass of Base" << endl;
   }
}
//------------------------------------------------------------------------------------------------
//typeid操作符使用，运行时系统标识(RTTI)
#include <iostream>
#include <typeinfo>
using namespace std;

class Base
{
public:
	virtual void show()//如果去掉virtual，则main函数中的if检查静态类型，判断不成功
	{
		cout << "this is base class" << endl;
	}
};

class Derived: public Base
{
public:
	void show()
	{
		cout << "this is derived class" << endl;
	}
	void showDerived()
	{
		cout << "derived added" << endl;
	}
};

void main()
{
	Base *pBase =  new Derived;
	Derived *pDerived = new Derived;

	if (typeid(*pBase) == typeid(Derived))//if (typeid(*pBase) == typeid(*pDerived)),要加指针符号*
	{
		cout << "the pointer points to derived object" << endl;
	}
	delete pBase;
	
	Base b, bb;
    Derived d;

	// Use typeid to test type equality
	if (typeid(b) == typeid(d)) { // No
	  cout << "b and d are of the same type.\n";
	}
	if (typeid(b) == typeid(bb)) { // Yes
	  cout << "b and bb are of the same type.\n";
	}
	if (typeid(d) == typeid(Derived)) { // Yes
	  cout << "d is of type Derived.\n";
	}
}
//------------------------------------------------------------------------------------------------
//比较继承层次中的两个类对象是否相等，包括类型相等和数据成员相等两部分
#include <iostream>
//#include <typeinfo>
using namespace std;

class Base
{
	friend bool operator==(const Base& lhs, const Base& rhs);
public:
	Base(int baseNum = 0): baseNum_(baseNum)
	{
		cout << "baseNum is " << baseNum_ << endl; 
	}
protected:
	virtual int getNum() const
	{
		return baseNum_;
	}
	int baseNum_;
private:
	virtual bool equal(const Base& rhs) const
	{
		return baseNum_ == rhs.getNum();
	}
};

class Derived: public Base
{
	friend void setNum(int, Derived&);
	friend bool operator==(const Base& lhs, const Base& rhs);//友元函数不会继承，要重新声明
public:
	Derived(int baseNum = 0, int derivedNum = 0): Base(baseNum), derivedNum_(derivedNum) 
	{
		cout << "derivedNum is " << derivedNum_ << endl;
	}
private:
	bool equal(const Base& rhs) const
	{
		if (const Derived *pDerived = dynamic_cast<const Derived*>(&rhs))
		{
			return (derivedNum_ == pDerived->getNum()) && (baseNum_ == pDerived->Base::getNum());
		}
		else
		{
			return false;
		}
	}
	int getNum() const
	{
		return derivedNum_;
	}
	int derivedNum_;
};

bool operator==(const Base& lhs, const Base& rhs)
{
	return (typeid(lhs) == typeid(rhs)) && lhs.equal(rhs);//只有两个对象类型一样时，才会进行.euqal()的判断
}

void setNum(int num, Derived& derivedItem)//友元函数可以访问私有成员
{
	int Derived::*p = &Derived::derivedNum_;//数据成员指针Page656，成员指针必须加&，函数指针加不加&都可以
	derivedItem.*p = num;
}

void main()
{
	cout << "baseitem1: ";
	Base baseItem1(1);
	cout << "baseitem2: ";
	Base baseItem2(2);
	cout << "derivedItem1: ";
	Derived derivedItem1(0, 2);
	cout << "derivedItem2: ";
	Derived derivedItem2(0, 2);
	if (baseItem1 == baseItem2)
	{
		cout << "baseItem1 is eqaul to baseItem2" << endl;
	}
	if (derivedItem1 == derivedItem2)
	{
		cout << "derivedItem1 is eqaul to derivedItem1" << endl;
	}
	if (baseItem1 == derivedItem2)
	{
		cout << "baseItem1 is eqaul to derivedItem2" << endl;
	}
	if (derivedItem2 == baseItem2)
	{
		cout << "derivedItem2 is eqaul to baseItem2" << endl;
	}
	
	set(3, derivedItem2);
	if (derivedItem1 == derivedItem2)
	{
		cout << "derivedItem1 is eqaul to derivedItem1" << endl;
	}
	
	//type_info类用于比较类型，还提供t1 == t2, t1 != t2, t1.before(t2)比较
	cout << typeid(3).name() << endl;
	cout << typeid(3.1).name() << endl;
	cout << typeid(string).name() << endl;
	cout << typeid(Base).name() << endl;//调试用，尤其是继承层次中可以改变类型的对象
	cout << typeid(Derived).name() << endl;
	
	cout << typeid(Derived).before(typeid(Base)) << endl;//0
	cout << typeid(Base).before(typeid(Derived)) << endl;//1
}
//------------------------------------------------------------------------------------------------
//另一个版本的成员函数指针，成员函数指针的一个公共用途是函数表！！！CppPrimer Page657，类似于5张扑克牌组成牌型的8种函数判断那种实现方法
class Base
{
	friend bool operator==(const Base& lhs, const Base& rhs);
public:
	Base(int baseNum = 0): baseNum_(baseNum)
	{
		cout << "baseNum is " << baseNum_ << endl; 
	}
protected:
	virtual int getNum() const
	{
		return baseNum_;
	}
	int baseNum_;
private:
	virtual bool equal(const Base& rhs) const
	{
		return baseNum_ == rhs.getNum();
	}
};

class Derived: public Base
{
	friend void setNum(int, Derived&);
	friend bool operator==(const Base& lhs, const Base& rhs);//友元函数不会继承，要重新声明
public:
	Derived(int baseNum = 0, int derivedNum = 0): Base(baseNum), derivedNum_(derivedNum) 
	{
		cout << "derivedNum is " << derivedNum_ << endl;
	}
private:
	bool equal(const Base& rhs) const
	{
		if (const Derived *pDerived = dynamic_cast<const Derived*>(&rhs))
		{
			return (derivedNum_ == pDerived->getNum()) && (baseNum_ == pDerived->Base::getNum());
		}
		else
		{
			return false;
		}
	}
	int getNum() const
	{
		return derivedNum_;
	}
	void setNum2(int num)
	{
		derivedNum_ = num;
	}
	int derivedNum_;
};

bool operator==(const Base& lhs, const Base& rhs)
{
	return (typeid(lhs) == typeid(rhs)) && lhs.equal(rhs);
}

void setNum(int num, Derived& derivedItem)
{
	void (Derived::*p) (int) = &Derived::setNum2;//成员函数指针CppPrimer Page656，成员指针必须加&，函数指针加不加&都可以
	(derivedItem.*p)(num);
}

void main()
{
	cout << "derivedItem1: ";
	Derived derivedItem1(0, 2);
	cout << "derivedItem2: ";
	Derived derivedItem2(0, 2);
	
	setNum(3, derivedItem2);

	if (derivedItem1 == derivedItem2)
	{
		cout << "derivedItem1 is eqaul to derivedItem1" << endl;
	}	
}
//------------------------------------------------------------------------------------------------
//remove_copy和插入迭代器的使用
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;

int main () {
	int myints[] = {10,20,30,30,20,10,10,20};          // 10 20 30 30 20 10 10 20
	vector<int> myvector;
	vector<int>::iterator it;

	//如果不用插入迭代器，就只能在声明myvector时就指定好大小:vector<int> myvector(8);
	//实际back_inserter(myvector)可以这样声明和使用(另外back_inserter是函数模板，不是类模板，所以back_inserter<int>(myvector)中的<int>可以不用加)
	//back_insert_iterator< vector<int> > p = back_inserter(myvector);
	//remove_copy (myints,myints+8, p, 20);
	//不过有时候虽然使用了插入迭代器，但是为了防止超过最大容量而进行的拷贝和删除，
	//还是应该用reserve先声明一个足够大的容量，用resize的话会默认构造每一个对象的
	remove_copy (myints,myints+8,back_inserter(myvector),20); // 10 30 30 10 10，或者使用remove_copy (myints,myints+8,inserter(myvector, myvector.begin()),20); 
	
	cout << "myvector contains:";
	for (it=myvector.begin(); it!=myvector.end(); ++it)
		cout << " " << *it;
	cout << endl;
	return 0;
}
//------------------------------------------------------------------------------------------------
//随机打乱数据 CppCookBook 7-3 使用插入迭代器，流迭代器和算法
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <ctime>

using namespace std;

int main( ) 
{
	srand ( unsigned ( time (NULL) ) );
	vector<int> v;
	back_insert_iterator<vector<int> > p =	back_inserter(v);

	for (int i = 0; i < 10; ++i)
	{
		*p = i;
	}

	copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
	cout << endl;

	random_shuffle(v.begin( ), v.end( ));

	copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
}
//------------------------------------------------------------------------------------------------
//标准算法中给出的random_shuffle例子
#include <iostream>
#include <algorithm>
#include <functional>
#include <vector>
#include <ctime>
#include <cstdlib>
using namespace std;

// random generator function:
ptrdiff_t myrandom (ptrdiff_t i) { return rand()%i;}
/*//随机算法还可以写成函数对象的形式，这时random_shuffle ( myvector.begin(), myvector.end(), rng);
class RanNumGenFtor 
{
public:
	size_t operator( )(size_t n) const 
	{
		return(rand( ) % n);
	}
}rng;
*/

// pointer object to it:
//ptrdiff_t (*p_myrandom)(ptrdiff_t) = myrandom;//random_shuffle ( myvector.begin(), myvector.end(), p_myrandom);

int main () 
{
	srand ( unsigned ( time (NULL) ) );
	vector<int> myvector;
	vector<int>::iterator it;

	// set some values:
	for (int i=0; i<10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9

	// using built-in random generator:
	random_shuffle ( myvector.begin(), myvector.end() );

	// using myrandom:
	random_shuffle ( myvector.begin(), myvector.end(), myrandom);

	// print out content:
	cout << "myvector contains:";
	for (it=myvector.begin(); it!=myvector.end(); ++it)
		cout << " " << *it;

	cout << endl;

	return 0;
}
//------------------------------------------------------------------------------------------------
//异常安全，和用交换实现赋值操作 CookBook 9.5
#include <iostream>
#include <string>

const static int DEFAULT_BUF_SIZE = 3;
const static int MAX_SIZE         = 4096;

class Message {

public:
   Message(int bufSize = DEFAULT_BUF_SIZE) :
      bufSize_(bufSize),
      initBufSize_(bufSize),
      msgSize_(0),
      key_("") {
      buf_ = new char[bufSize]; // Note: now this is in the body
   }

  ~Message( ) {
      delete[] buf_;
   }

   // Exception-safe copy ctor
   Message(const Message& orig) : 
      bufSize_(orig.bufSize_),
      initBufSize_(orig.initBufSize_),
      msgSize_(orig.msgSize_),
      key_(orig.key_) { // This can throw...

      buf_ = new char[orig.bufSize_];  // ...so can this
      copy(orig.buf_, orig.buf_+msgSize_, buf_); // This can't
   }

   // Exception-safe assignment, using the copy ctor
   Message& operator=(const Message& rhs) {

      Message tmp(rhs);   // Copy construct a temporary
      swapInternals(tmp); // Swap members with it
      return(*this);      // When we leave, tmp is destroyed, taking
                          // the original data with it
   }

   const char* data( ) {
      return(buf_);
   }

private:
   void swapInternals(Message& msg) {
      // Since key_ is not a built-in data type it can throw,
      // so do it first.
      swap(key_, msg.key_);

      // If it hasn't thrown, then do all the primitives
      swap(bufSize_,     msg.bufSize_);
      swap(initBufSize_, msg.initBufSize_);
      swap(msgSize_,     msg.msgSize_);
      swap(buf_,         msg.buf_);
   }
   int bufSize_;
   int initBufSize_;
   int msgSize_;
   char* buf_;
   string key_;
};

//------------------------------------------------------------------------------------------------
//格式化输出
#include <iostream>
#include <iomanip>
#include <string>

using namespace std;

int main( ) {

	ios_base::fmtflags flags = cout.flags( );
	string first, last, citystate;
	int width = 20;

	first = "Richard";
	last  = "Stevens";
	citystate = "Tucson, AZ";
	
	//除了setw(int w)，其他的操作符都是设置了之后一直就存在的
	cout << right                      // Left-justify in each field
		<< setfill('.')
		<< setw(width) << first      // Then, repeatedly set the width
		<< setw(width) << last       // and write some data
		<< setw(width) << citystate << endl;

	cout.flags(flags);
	cout << boolalpha << true << noboolalpha << '\t' << false << endl;
}
//------------------------------------------------------------------------------------------------
//模板格式化输出容器
#include <iostream>
#include <iomanip>
#include <string>
#include <vector>

using namespace std;

// TableFormatter formats data for output to a stream of characters
// of type T.
template<typename T>
class TableFormatter {

public:
	TableFormatter(basic_ostream<T>& os) : out_(os) {}
	~TableFormatter( ) {out_ << flush;}

	template<typename valT>
	void writeTableRow(const vector<valT>& v, int width);
	//...

private:
	basic_ostream<T>& out_;
};

template<typename T>    // refers to class template param list
template<typename valT> // refers to mem fn template param list
void TableFormatter<T>::writeTableRow(const std::vector<valT>& v,
	int width) {

		ios_base::fmtflags flags = out_.flags( );

		out_.flush( );
		out_ << setprecision(2) << fixed;  // Set the precision, in case
		// this is floating-point data
		for (vector<valT>::const_iterator p = v.begin( );
			p != v.end( ); ++p)
			out_ << setw(width) << left << *p;  // Set the width, justify,
		// and write the element
		out_ << endl;     // Flush
		out_.setf(flags); // Set the flags back to normal
}

int main( ) {

	TableFormatter<char> fmt(cout);

	vector<string> vs;

	vs.push_back( "Sunday" );
	vs.push_back( "Monday" );
	vs.push_back( "Tuesday" );

	fmt.writeTableRow(vs, 12);
	fmt.writeTableRow(vs, 14);
	fmt.writeTableRow(vs, 15);

	vector<double> vd;

	vd.push_back(4.0);
	vd.push_back(3.0);
	vd.push_back(2.0);
	vd.push_back(1.0);

	fmt.writeTableRow(vd, 5);
}
//------------------------------------------------------------------------------------------------
//格式化浮点数输出
#include <iostream>
#include <iomanip>
#include <string>

using namespace std;

int main( ) {

	ios_base::fmtflags flags =  // Save old flags
		cout.flags( );

	double pi = 3.141592653;

	cout << "pi = " << setprecision(5)  // Normal (default) mode; only
		<< pi << '\n';                 // show 5 digits, including both
	// sides of decimal point.

	cout << "pi = " << fixed            // Fixed-point mode; 不做设置，默认6位小数，设了fixed之后，setprecision就变成小数的位数了，浮点数的精度指小数位数
		<< showpos                     // show a "+" for positive nums,
		<< setprecision(4)             // show 3 digits to the *right*
		<< pi << '\n';                 // of the decimal.

	cout << "pi = " << scientific       // Scientific mode; 
		<< noshowpos                   // don't show plus sign anymore
		<< pi * 1000 << '\n';

	cout << 123.456 << '\n';

	cout.flags(flags);  // Set the flags to the way they were

	flags = cout.flags();
	cout << setprecision(2) << fixed << showpoint << 2.0 << '\n';
	cout.flags(flags);

	//cout <<  showbase << 0x30 << '\n';
}
//------------------------------------------------------------------------------------------------
//求数组的维数，以及用指针操纵二维数组
#include <iostream>
using namespace std;

int main( ) 
{
	int a[2][3] = {1,2,3,4,5,6};//2行3列的数组
	int (*p)[3] = a;//p是一个指针，指向包含3个int变量的数组首地址；int (*p)[4] = a;编译出错，无法转换
	cout << *(*(p + 1)+1) << endl;
	cout << sizeof(a) << endl;
	cout << sizeof(a)/sizeof(a[0]) << endl;	

	int *pI[2][3];
	cout << sizeof(pI) << endl;
}
//------------------------------------------------------------------------------------------------
//计算容器大小
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

int main( ) 
{
	istream_iterator<int> in(cin);
	istream_iterator<int> eof;
	vector<int> intVec(in, eof);
	cout << intVec.size() << endl;
	cout << distance(intVec.begin(), intVec.end()) << endl;
}
//------------------------------------------------------------------------------------------------
//自定义比较函数对象实现查找最大值
#include <algorithm>
#include <vector>
#include <iostream>

using namespace std;

struct ChessPlayer {
  ChessPlayer(const char* name, int rating)
    : name_(name), rating_(rating)
  { }
  const char* name_;
  int rating_;
};

struct IsWeakerPlayer {
  bool operator( )(const ChessPlayer& x, const ChessPlayer& y) {
    return x.rating_ < y.rating_;
  }
};

int main( )
{
  ChessPlayer kasparov("Garry Kasparov", 2805);
  ChessPlayer anand("Viswanathan Anand ", 2788);
  ChessPlayer topalov("Veselin Topalov", 2788);
  vector<ChessPlayer> v;
  v.push_back(kasparov);
  v.push_back(anand);
  v.push_back(topalov);
  cout << "the best player is ";
  cout << max_element(v.begin( ), v.end( ), IsWeakerPlayer( ))->name_;//min_element返回的都是一个迭代器，这里不建议用->，虽然指针是迭代器，但迭代器不一定都是指针，所以最好用*取得对象，再调用.name_。
  cout << endl;
}
//------------------------------------------------------------------------------------------------
//求总和与平均值
#include <numeric>
#include <iostream>
#include <vector>

using namespace std;

int main( ) {
	vector<int> v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);
	int sum = accumulate(v.begin( ), v.end( ), 0);
	double mean = double(sum) / v.size( );
	cout << "sum = " << sum << endl;
	cout << "count = " << v.size( ) << endl;
	cout << "mean = " << mean << endl;
}

template<class Iter_T>
double computeMean(Iter_T first, Iter_T last) {
  return static_cast<double>(accumulate(first, last, 0.0)) 
    / distance(first, last);
}
//------------------------------------------------------------------------------------------------
//流迭代器实现，istream_iterator和ostream_iterator就是迭代器！！！所有普通迭代器可以做的事情，它们都可以做
#include <stdexcept>
#include <iostream>
#include <iterator>

using namespace std;

template<class Value_T, class Iter_T>
Value_T computeMean(Iter_T first, Iter_T last) {
	if (first == last) throw domain_error("mean is undefined");
	Value_T sum = 0;
	int cnt = 0;
	while (first != last)
	{
		sum += *first++;
		++cnt;
	}
	return sum / cnt;
}

int main( ) {
	cout << "please type in several integers separated by newlines" << endl;
	cout << "and terminated by an EOF character (i.e., Ctrl-Z)" << endl;
	try
	{
		double mean = computeMean<double>(istream_iterator<int>(cin),istream_iterator<int>( ));
		cout << "the mean is " << mean << endl;
	}
	catch(domain_error& e)
	{
		cerr << e.what() << endl;
	}
}
//------------------------------------------------------------------------------------------------
//remove_copy_if使用，去掉范围之外的元素
#include <algorithm>
#include <vector>
#include <iostream>
#include <iterator>

using namespace std;

struct OutOfRange
{
  OutOfRange(int min, int max)
    : min_(min), max_(max)
  { }
  bool operator( )(int x) {
    return (x < min_) || (x > max_);
  }
  int min_;
  int max_;
};

int main( )
{
  vector<int> v;
  v.push_back(6);
  v.push_back(12);
  v.push_back(18);
  v.push_back(24);
  v.push_back(30);
  remove_copy_if(v.begin( ), v.end( ),
    ostream_iterator<int>(cout, "\n"), OutOfRange(10,25));
}
//------------------------------------------------------------------------------------------------
//生成随机数
#include <cstdlib>
#include <ctime>
#include <iostream>

using namespace std; 

double doubleRand( ) {
	return double(rand( )) / (double(RAND_MAX) + 1.0);//int rand ( void ); Return Value: An integer value between 0 and RAND_MAX. RAND_MAX:short的最大值，跟numeric_limits<short>::max()的值一样
}

int main( ) {
	srand(static_cast<unsigned int>(clock( )));
	cout << "expect 5 numbers within the interval [0.0, 1.0)" << endl;
	for (int i=0; i < 5; i++) 
	{
		cout << doubleRand( ) << "\n";
	}
}
//------------------------------------------------------------------------------------------------
//用boost库实现
#include <boost/random.hpp>
#include <iostream>
#include <cstdlib>

using namespace std;
using namespace boost;

typedef boost::mt19937 BaseGenerator;
typedef boost::uniform_real<double> Distribution;
typedef boost::variate_generator<BaseGenerator, Distribution> Generator;

double boostDoubleRand( ) {
  static BaseGenerator base;
  static Distribution dist;
  static Generator rng(base, dist);
  return rng( );
}

int main( ) {
  cout << "expect 5 numbers within the interval [0,1)" << endl;
  for (int i=0; i < 5; i++) {
    cout << boostDoubleRand( ) << "\n";
  }
}
//------------------------------------------------------------------------------------------------
//生成随机数填充容器generate
#include <algorithm>
#include <vector>
#include <iterator>
#include <iostream>
#include <cstdlib>

using namespace std;

struct RndIntGen
{
  RndIntGen(int l, int h)
    : low(l), high(h)
  { }
  int operator( )( ) const {
    return low + (rand( ) % ((high - low) + 1));
  }
private:
  int low;
  int high;
};

int main( ) {
  srand(static_cast<unsigned int>(clock( )));
  vector<int> v(5);
  generate(v.begin( ), v.end( ), RndIntGen(1, 6));
  copy(v.begin( ), v.end( ), ostream_iterator<int>(cout, "\n"));
}
//------------------------------------------------------------------------------------------------
//生成随机数填充容器generate
// generate algorithm example
#include <iostream>
#include <algorithm>
#include <vector>
#include <ctime>
#include <cstdlib>
using namespace std;

// function generator:
int RandomNumber () { return (rand()%100); }

// class generator:
class c_unique 
{
public:
	c_unique(int current): current_(current) {}
	int operator()() {return ++current_;}
private:
	int current_;
} ;

int main () {
	srand ( unsigned ( time(NULL) ) );

	vector<int> myvector (8);
	vector<int>::iterator it;

	generate (myvector.begin(), myvector.end(), RandomNumber);

	cout << "myvector contains:";
	for (it=myvector.begin(); it!=myvector.end(); ++it)
		cout << " " << *it;

	generate (myvector.begin(), myvector.end(), c_unique(0));

	cout << "\nmyvector contains:";
	for (it=myvector.begin(); it!=myvector.end(); ++it)
		cout << " " << *it;

	cout << endl;

	return 0;
}
//模板实现
template<class Iter_T, class Fxn_T>
void generate(Iter_T first, Iter_T last, Fxn_T f) {
  while (first != last) *first++ = f( );
}

template<class Iter_T, class Fxn_T>
void generate_n(Iter_T first, int n, Fxn_T f) {
  for (int i=0; i < n; ++i) *first++ = f( );
}
//------------------------------------------------------------------------------------------------
//accumulate模板实现
template<class Iter_T, class Value_T, class BinOp_T>
Iter_T accumulate(Iter_T begin, Iter_T end, Value_T value, BinOp_T op) {
  while (begin != end) {
    value = op(value, *begin++)//op操作函数的两个入参数，第一个是value对象，第二个是迭代器解引用的对象
  }
  return value;
}
//------------------------------------------------------------------------------------------------
//数字矢量
#include <valarray>
#include <iostream>

using namespace std;

int main( ) {
	valarray<int> v(3);
	v[0] = 1; v[1] = 2; v[2] = 3;
	cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
	v = v + v;
	cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
	v /= 2;
	cout << v[0] << ", " << v[1] << ", " << v[2] << endl;
}
//模板实现迭代器，可以将这两个迭代器放到任何泛型算法中，这是自己写的，不是标准库中的模板
template<class T>
T* valarray_begin(valarray<T>& x) {
  return &x[0];
}

template<class T>
T* valarray_end(valarray<T>& x) {
  return valarray_begin(x) + x.size( );
}
//--用上面的两上模板实现迭代器的功能
#include <iostream>
#include <valarray>
#include <algorithm>
#include <iterator>
using namespace std;

template<class T>
T* valarray_begin(valarray<T>& x) {
	return &x[0];
}

template<class T>
T* valarray_end(valarray<T>& x) {
	return valarray_begin(x) + x.size( );
}

void main()
{
	valarray<int> v(3);
	fill(valarray_begin(v), valarray_end(v), 2);//因为v是个valarray<int>类型的变量，不是指针，不是迭代器，所以不可以直接在算法里写fill(v, v + 3, 2);
	copy(valarray_begin(v), valarray_end(v), ostream_iterator<int>(cout, " "));
}
//------------------------------------------------------------------------------------------------
//数目固定的数字矢量
#include <algorithm>
#include <cassert>
#include <algorithm>
#include <numeric>
#include <iostream>

using namespace std;

template<class Value_T, unsigned int N>
class kvector
{
public:
	// public fields
	Value_T m[N];

	// public typedefs
	typedef Value_T value_type;
	typedef Value_T* iterator;
	typedef const Value_T* const_iterator;
	typedef Value_T& reference;
	typedef const Value_T& const_reference;
	typedef size_t size_type;

	// shorthand for referring to kvector
	typedef kvector self;

	// member functions
	template<typename Iter_T>
	void copy(Iter_T first, Iter_T last) { copy(first, last, begin( )); }
	iterator begin( ) { return m; }
	iterator end( ) { return m + N; }
	const_iterator begin( ) const { return m; }
	const_iterator end( ) const { return m + N; }
	reference operator[](size_type n) { return m[n]; }
	const_reference operator[](size_type n) const { return m[n]; }
	static size_type size( ) { return N; }

	// vector operations
	self& operator+=(const self& x) {
		for (int i=0; i<N; ++i) m[i] += x.m[i]; return *this;
	}
	self& operator-=(const self& x) {
		for (int i=0; i<N; ++i) m[i] -= x.m[i]; return *this;
	}

	// scalar operations
	self& operator=(value_type x) {
		std::fill(begin( ), end( ), x); return *this;
	}
	self& operator+=(value_type x) {
		for (int i=0; i<N; ++i) m[i] += x; return *this;
	}
	self& operator-=(value_type x) {
		for (int i=0; i<N; ++i) m[i] -= x; return *this;
	}
	self& operator*=(value_type x) {
		for (int i=0; i<N;  ++i) m[i] *= x; return *this;
	}
	self& operator/=(value_type x) {
		for (int i=0; i<N; ++i) m[i] /= x; return *this;
	}
	self& operator%=(value_type x) {
		for (int i=0; i<N; ++i) m[i] %= x; return *this;
	}
	self operator-( ) {
		self x;
		for (int i=0; i<N; ++i) x.m[i] = -m[i];
		return x;
	}

	// friend operators
	friend self operator+(self x, const self& y) { return x += y; }
	friend self operator-(self x, const self& y) { return x -= y; }
	friend self operator+(self x, value_type y) { return x += y; }
	friend self operator-(self x, value_type y) { return x -= y; }
	friend self operator*(self x, value_type y) { return x *= y; }
	friend self operator/(self x, value_type y) { return x /= y; }
	friend self operator%(self x, value_type y) { return x %= y; }
};

int main( ) {
	kvector<int, 4> v = { 1, 2, 3, 4 };
	cout << "sum = " << accumulate(v.begin( ), v.end( ), 0) << endl;
	v *= 3;
	cout << "sum = " << accumulate(v.begin( ), v.end( ), 0) << endl;
	v += 1;
	cout << "sum = " << accumulate(v.begin( ), v.end( ), 0) << endl;
}
//------------------------------------------------------------------------------------------------
//计算点积inner_product，还可以计算两个矢量之间的距离或者计算一个矢量的范数
#include <numeric>
#include <iostream>
#include <vector>

using namespace std;

int main( ) {
  int v1[] = { 1, 2, 3 };
  int v2[] = { 4, 6, 8 };
  cout << "the dot product of (1,2,3) and (4,6,8) is ";
  cout << inner_product(v1, v1 + 3, v2, 0) << endl;
}

template<class In, class In2, class T>
T inner_product(In first, In last, In2 first2, T init);

template<class In, class In2, class T, class BinOp, class BinOp2>
T inner_product(In first, In last, In2 first2, T init, BinOp op, Binop2 op2);

template<class In, class In2, class T, class BinOp, class BinOp2>
T inner_product(In first, In last, In2 first2, T init, BinOp op, Binop2 op2) {
  while (first != last) {
    BinOp(init, BinOp2(*first++, *first2++));    
  }
  return init;
}
//------------------------------------------------------------------------------------------------
//计算矢量的范数（长度）
#include <numeric>
#include <vector>
#include <cmath>
#include <iostream>

using namespace std;

template<typename Iter_T>
long double vectorNorm(Iter_T first, Iter_T last) {
	return sqrt(inner_product(first, last, first, 0.0L));
}

int main( ) 
{
	int v[] = { 3, 4 };
	cout << "The length of the vector (3,4) is ";
	cout << vectorNorm(v, v + 2) << endl;
}
//------------------------------------------------------------------------------------------------
//计算矢量距离
#include <cmath>
#include <iostream>

using namespace std;

template<class Iter_T, class Iter2_T>
double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2) {
  double ret = 0.0;
  while (first != last) {
    double dist = (*first++) - (*first2++);
    ret += dist * dist;
  }
  return ret > 0.0 ? sqrt(ret) : 0.0;
}

int main( ) {
  int v1[] = { 1, 5 };
  int v2[] = { 4, 9 };
  cout << "distance between vectors (1,5) and (4,9) is ";
  cout << vectorDistance(v1, v1 + 2, v2) << endl;
}
//--使用点积和算符计算矢量距离
#include <numeric>
#include <cmath>
#include <iostream>
#include <functional>

using namespace std;

template<class Value_T>
struct DiffSquared {
  Value_T operator( )(Value_T x, Value_T y) const {
    return (x - y) * (x - y);
  }
};

template<class Iter_T, class Iter2_T>
double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2)  
{
  double ret = inner_product(first, last, first2, 0.0L,
    plus<double>( ), DiffSquared<double>( ));//加操作和自定义的乘操作，元素都是对迭代器解引用再放进去运算的
  return ret > 0.0 ? sqrt(ret) : 0.0;
}

int main( ) {
  int v1[] = { 1, 5 };
  int v2[] = { 4, 9 };
  cout << "distance between vectors (1,5) and (4,9) is ";
  cout << vectorDistance(v1, v1 + 2, v2) << endl;
}
//------------------------------------------------------------------------------------------------
//跨步迭代器 CookBook 11-24
#include <cassert>
#include <algorithm>
#include <iterator>
#include <iostream>

using namespace std;

template<class Iter_T>
class stride_iter
{
public:
	// public typedefs
	typedef typename std::iterator_traits<Iter_T>::value_type value_type;//嵌套从属类型！带泛型类型的typedef要加typename来定义？迭代器？
	typedef typename std::iterator_traits<Iter_T>::reference reference;
	typedef typename std::iterator_traits<Iter_T>::difference_type difference_type;
	typedef typename std::iterator_traits<Iter_T>::pointer pointer;
	typedef std::random_access_iterator_tag iterator_category;
	typedef stride_iter self;

	// constructors
	stride_iter( ) : m(NULL), step(0) { };
	stride_iter(const self& x) : m(x.m), step(x.step) { }
	stride_iter(Iter_T x, difference_type n) : m(x), step(n) { }

	// operators
	self& operator++( ) { m += step; return *this; }//前置自增操作符返回引用
	self operator++(int) { self tmp = *this; m += step; return tmp; }//后置自增操作符返回自己
	self& operator+=(difference_type x) { m += x * step; return *this; }
	self& operator--( ) { m -= step; return *this; }
	self operator--(int) { self tmp = *this; m -= step; return tmp; }
	self& operator-=(difference_type x) { m -= x * step; return *this; }
	reference operator[](difference_type n) { return m[n * step]; }
	reference operator*( ) { return *m; }

	// friend operators
	friend bool operator==(const self& x, const self& y) {
		assert(x.step == y.step);
		return x.m == y.m;
	}
	friend bool operator!=(const self& x, const self& y) {
		assert(x.step == y.step);
		return x.m != y.m;
	}
	friend bool operator<(const self& x, const self& y) {
		assert(x.step == y.step);
		return x.m < y.m;
	}
	friend difference_type operator-(const self& x, const self& y) {
		assert(x.step == y.step);
		return (x.m - y.m) / x.step;
	}
	friend self operator+(const self& x, difference_type y) {
		assert(x.step == y.step);
		return x += y * x.step;
	}
	friend self operator+(difference_type x, const self& y) {
		assert(x.step == y.step);
		return y += x * x.step;
	}
private:
	Iter_T m;
	difference_type step;
};

int main( ) {
	int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
	stride_iter<int*> first(a, 2);
	stride_iter<int*> last(a + 8, 2);
	copy(first, last, ostream_iterator<int>(cout, "\n"));
	cout << first[3] << endl;
}
//编译时知道步长的跨步迭代器
#include <iterator>
#include <algorithm>
#include <iostream>

using namespace std;
template<class Iter_T, int Step_N>//非类型参数必须为常量，不能在执行时输入
class kstride_iter
{
public:
	// public typedefs
	typedef typename std::iterator_traits<Iter_T>::value_type value_type;
	typedef typename std::iterator_traits<Iter_T>::reference reference;
	typedef typename std::iterator_traits<Iter_T>::difference_type difference_type;
	typedef typename std::iterator_traits<Iter_T>::pointer pointer;
	typedef std::random_access_iterator_tag iterator_category;
	typedef kstride_iter self;

	// constructors
	kstride_iter( ) : m(NULL) { }
	kstride_iter(const self& x) : m(x.m) { }
	explicit kstride_iter(Iter_T x) : m(x) { }

	// operators
	self& operator++( ) { m += Step_N; return *this; }
	self operator++(int) { self tmp = *this; m += Step_N; return tmp; }
	self& operator+=(difference_type x) { m += x * Step_N; return *this; }
	self& operator--( ) { m -= Step_N; return *this; }
	self operator--(int) { self tmp = *this; m -= Step_N; return tmp; }
	self& operator-=(difference_type x) { m -= x * Step_N; return *this; }
	reference operator[](difference_type n) { return m[n * Step_N]; }
	reference operator*( ) { return *m; }

	// friend operators
	friend bool operator==(self x, self y) { return x.m == y.m; }
	friend bool operator!=(self x, self y) { return x.m != y.m; }
	friend bool operator<(self x, self y) { return x.m < y.m; }
	friend difference_type operator-(self x, self y) {
		return (x.m - y.m) / Step_N;
	}
	friend self operator+(self x, difference_type y) { return x += y * Step_N; }
	friend self operator+(difference_type x, self y) { return y += x * Step_N; }
private:
	Iter_T m;
};

int main( ) {
	int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
	kstride_iter<int*, 2> first(a);
	kstride_iter<int*, 2> last(a + 8);
	copy(first, last, ostream_iterator<int>(cout, "\n"));
}
//------------------------------------------------------------------------------------------------
//矩阵相乘 CookBook 11-32
//固定宽度的大整数运算 CookBook 11-38
//固定小数位数值 CookBook 11-40
//------------------------------------------------------------------------------------------------
//函数指针，回调函数
#include <iostream>

// A typedef to make for easier reading
typedef bool (*FuncPtrBoolInt)(int);//带typedef声明的是一个类型，不带typedef声明的是一个变量

// A function that runs for a while
void longOperation(FuncPtrBoolInt f) {

	for (long l = 0; l < 100000000; l++)
		if (l % 10000000 == 0)
			f(l / 1000000);
}

// An example of a callback function
bool updateProgress(int pct) {

	std::cout << pct << "% complete...\n";
	return(true);
}

int main( ) 
{
	longOperation(updateProgress); // ok
}
//------------------------------------------------------------------------------------------------
//容器中保存函数指针
#include <iostream>
#include <vector>

// A typedef to make for easier reading
typedef bool (*FuncPtrBoolInt)(int);

// An example of a callback function
bool updateProgress(int pct) {

	std::cout << pct << "% complete...\n";
	return(true);
}

int main( ) 
{
	std::vector<FuncPtrBoolInt>	vecFun;
	vecFun.push_back(updateProgress);
	std::vector<FuncPtrBoolInt>::iterator iter = vecFun.begin();
	(*iter)(100);
}
//
#include <iostream>
#include <vector>

typedef bool (*FuncPtrBoolInt)(int);

bool updateProgress(int pct) {

	std::cout << pct << "% complete...\n";
	return(true);
}

int main( ) 
{
	std::vector<FuncPtrBoolInt>	vecFun;
	FuncPtrBoolInt fun1 = &updateProgress;//指针引用，去掉&之后是复制函数指针？？？
	vecFun.push_back(fun1);
	std::vector<FuncPtrBoolInt>::iterator iter = vecFun.begin();
	(*iter)(100);
}
//int*指针是指向int数据的指针
//CppPrimer 7.9节原文
//函数指针是指向函数对象的指针，
//在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，
//此时，直接引用函数名 等效于 在函数名上应用取地址操作符（这是个毛啊。。。）

//指向函数的指针可用于调用它所指向的函数，可以不需要使用解引用操作符，直接通过指针调用函数

//具有函数类型的所对应的实参将被自动转换为指向相应函数类型的指针，但是，当返回的是函数时，同样的转换操作则无法实现
//typedef int func(int*, int);//func是函数类型，不是函数指针
//void f1(func);//ok
//func f2(int);//error
//func *f3(int);//ok
#include <iostream>
using namespace std;

typedef void (*FuncPtr)(int);

void show(int pct) 
{
	cout << pct << endl;
}

typedef int * intPtr;

int *p0 = new int(3);

int main( ) 
{
	FuncPtr funPtr1 = show;
	funPtr1(10);
	(*funPtr1)(20);
	FuncPtr funPtr2 = &show;
	funPtr2(30);
	(*funPtr2)(40);
	//FuncPtr &funPtr3 = show;
	
	void (*funPtr3)(int) = show;
	funPtr3(50);
	(*funPtr3)(60);
	void (*funPtr4)(int) = &show;
	funPtr4(70);
	(*funPtr4)(80);

	intPtr p1 = p0;//声明了一个int指针p1，和p0指向同一个地址
	intPtr &p2 = p0;//声明了一个p0的引用p2，即p2和p0是同一个int指针
	*p2 = 4;
	cout << *p2 << endl;
	cout << *p0 << endl;
}

//lambda表达式的类型无法用函数指针来声明，需要用function或auto来声明
#include <iostream>
#include <functional>
using namespace std;

typedef void (*FuncPtr)(int);

void show(int pct) 
{
	cout << pct << endl;
}

int main()
{
	FuncPtr funPtr1 = show;
	funPtr1(10);

	function<void (int)> funPtr2 = [] (int n) {cout << n << endl;};
	funPtr2(10);
}
//------------------------------------------------------------------------------------------------
//指向成员的指针
#include <iostream>
#include <string>

class MyClass 
{
	friend void testPointerToClass();
public:
	MyClass( ) : ival_(0), sval_("foo") {}
	~MyClass( ) {}

	void incr( ) {++ival_;}
	void decr( ) {ival_--;}

private:
	std::string sval_;
	int ival_;
};

void testPointerToClass()
{
	MyClass obj;

	int MyClass::* mpi = &MyClass::ival_;  // Data member pointers 这里的&可以理解为类MyClass对象的起始地址，通过地址偏移量定位成员
	std::string MyClass::* mps = &MyClass::sval_;  // Data member pointers

	void (MyClass::*mpf)( ); // A pointer to a member function that
	// takes no params and returns void
	void (*pf)( );           // A normal function pointer

	int* pi = &obj.ival_;   // int pointer referring to int member--no
	// problem.

	mpf = &MyClass::incr;   // A pointer to a member function. You can't
	// write this value to a stream. Look at it
	// in your debugger to see what its
	// representation looks like.

	//pf = &MyClass::incr;    // Error: &MyClass::incr is not an instance of a function. pf之所以不能这么引用，可以理解为类函数成员是要引用数据成员的，
	//前面并没有为pf声明上下文，所以pf不知道该操作谁

	std::cout << "mpi = " << mpi << '\n';
	std::cout << "mps = " << mps << '\n';
	std::cout << "pi =  " << pi << '\n';
	std::cout << "*pi = " << *pi << '\n';

	obj.*mpi = 5;
	obj.*mps = "bar";

	(obj.*mpf)( ); // now obj.ival_ is 6 指针用  ->.  操作

	std::cout << "obj.ival_ = " << obj.ival_ << '\n';
	std::cout << "obj.sval_ = " << obj.sval_ << '\n';
}

int main( ) 
{
	testPointerToClass();
	return 0;	
}
//------------------------------------------------------------------------------------------------
//尽量为参数加const，确保函数不会改变参数
#include <iostream>
#include <string>

void concat(const std::string& s1, // These are declared const, so they
	const std::string &s2, // cannot be changed
	std::string& out)
{
		out = s1 + s2;
}

void concatUnsafe(std::string& s1,
	std::string& s2,
	std::string& out) 
{
		out = s1 += s2; // Whoops, wrote to s1
}

void myFunc(const std::string& s) 
{ // Notice that s is const

	std::string dest;
	std::string tmp = "foo";
	//const_cast<std::string&>(s); //怎么用？？？
	concatUnsafe(s, tmp, dest);  // Error: s is const
}

int main( ) {

	std::string s1 = "Cabo ";
	std::string s2 = "Wabo";
	std::string s3;

	concat(s1, s2, s3);

	std::cout << "s1 = " << s1 << '\n';
	std::cout << "s2 = " << s2 << '\n';
	std::cout << "s3 = " << s3 << '\n';
}
//------------------------------------------------------------------------------------------------
//类成员函数加const限制修改数据成员
#include <iostream>
#include <string>

class RecordSet {
public:
   bool getFieldVal(int i, std::string& s) const;
   // ...
};

bool RecordSet::getFieldVal(int i, std::string& s) const {
   // In here, you can't modify any nonmutable data
   // members (see discussion)
}

void displayRecords(const RecordSet& rs) {
   // Here, you can only invoke const member functions
   // on rs，这里类对象rs只能调用const成员函数，因为rs是const的，如果可以调用非const成员函数，则可以修改rs，与const相违
}
//------------------------------------------------------------------------------------------------
//初始化由逗号分隔的序列 CookBook 15-6
#include <vector>
#include <iostream>
#include <iterator>
#include <algorithm>

using namespace std; 

template<class Seq_T>
struct comma_helper
{
	typedef typename Seq_T::value_type value_type;
	explicit comma_helper(Seq_T& x) : m(x) { }
	comma_helper& operator=(const value_type& x) 
	{
		m.clear( );//vector，list，deque有.clear()成员
		return operator+=(x);
	}
	comma_helper& operator+=(const value_type& x)
	{
		m.push_back(x);
		return *this;
	}
	Seq_T& m;
};

template<typename Seq_T>
comma_helper<Seq_T> initialize(Seq_T& x) 
{
		return comma_helper<Seq_T>(x);
}

//逗号操作符可称为构造序列操作符，默认功能从左到右构造表达式，并且最右边的值具有相同的类型和值
//重载之后，原来的默认语义就不存在了，并且不能再保证从左到右的读取参数
// ||，&&操作符有短路特性，即满足第一个条件之后就不会去求第二个条件，重载之后也没有了短路特性
template<class Seq_T, class Scalar_T>
comma_helper<Seq_T>& operator ,(comma_helper<Seq_T>& h, Scalar_T x) 
{
		h += x;
		return h;
}

int main( ) {
	vector<int> v;
	int a = 2;
	int b = 5;
	initialize(v) = 0, 1, 1, a, 3, b, 8, 13;
	copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
	
	
	try
	{
		cout << v.at(2) << endl; //v.at(idx)在下标越界后抛异常，v[idx] 不会抛异常，会直接崩溃
	}
	catch(exception &e)
	{
		cerr << e.what() << endl;
	}
	return 0;
}
//--逗号操作符中间加函数提示用户输入
int prompt_user( ) {
	int n;
	cout << "give me an integer ... ";
	cin >> n;
	return n;
}

void f( ) {
	vector<int> v;
	initialize(v) = prompt_user( ), prompt_user( );//C++编程规范101 P65 这里可能会有问题，无法确定先调用的哪个函数，如果输入有依赖先后顺序，则无法确保存入v中的顺序
}
//--模仿comma_helper做一个类似的功能add_helper，其实完全没有必要，comma_helper的+=已经做了这个功能
#include <vector>
#include <iostream>
#include <iterator>
#include <algorithm>

using namespace std; 

template<class Seq_T>
struct comma_helper
{
	typedef typename Seq_T::value_type value_type;
	explicit comma_helper(Seq_T& x) : m(x) { }
	comma_helper& operator=(const value_type& x) 
	{
		m.clear( );
		return operator+=(x);
	}
	comma_helper& operator+=(const value_type& x)
	{
		m.push_back(x);
		return *this;
	}
	Seq_T& m;
};

template<typename Seq_T>
comma_helper<Seq_T> initialize(Seq_T& x) 
{
	return comma_helper<Seq_T>(x);
}

template<class Seq_T>
struct add_helper
{
	typedef typename Seq_T::value_type value_type;
	explicit add_helper(Seq_T& x) : m(x) { }
	add_helper& operator=(const value_type& x) 
	{
		m.push_back(x);
		return *this;
	}
	Seq_T& m;
};

template<typename Seq_T>
add_helper<Seq_T> addSeq(Seq_T& x) 
{
	return add_helper<Seq_T>(x);
}

template<class Seq_T, class Scalar_T>
comma_helper<Seq_T>& operator ,(comma_helper<Seq_T>& h, Scalar_T x) 
{
	h += x;
	return h;
}

int main( ) {
	vector<int> v;
	int a = 2;
	int b = 5;
	initialize(v) = 0, b, 3, 8;
	addSeq(v) = 2;//initialize(v) += 2;
	addSeq(v) = a;//initialize(v) += a;

	copy(v.begin(), v.end(), ostream_iterator<int>(cout, " "));
	return 0;
}
//------------------------------------------------------------------------------------------------
//传入属于命名空间的函数参数时，在这个函数体的内部执行这个函数的名字查找功能时编译器就会包含这个命名空间
void f(dev::Device& d)
{
	register(d);//register是dev::register
}
//------------------------------------------------------------------------------------------------
//重载函数只要名字，所有的重载函数都会被引用进来
namespace mylib {
   void foo(int);
   void foo(double);
   void foo(std::string);
   // More overloads of foo( )...
}

// In some other file...
using mylib::foo; // Which one does this use?
//------------------------------------------------------------------------------------------------
//在头文件中包含内联文件，就不会在头文件中有很多实现，使头文件显得很乱
//模板类和模板函数也要使用这种包含功能（要么放在头文件中实现，要么放在被头文件包含的内嵌文件中）
// Value.h
#ifndef VALUE_H_  _
#define VALUE_H_  _

#include <string>

class Value {
public:
   Value (const std::string& val) : val_(val) {}
   std::string getVal( ) const;
private:
   std::string val_;
};

#include "Value.inl"

#endif VALUE_H_  _

// Value.inl
inline std::string Value::getVal( ) const {
   return(val_);
}

//模板的内嵌
//utilities.h
#ifndef __UTILITIES__
#define __UTILITIES__
template <typename T> 
int compare(const T& lhs, const T& rhs);
#include "utilities.cpp"
#endif

//utilities.cpp
template<typename T>
int compare(const T& lhs, const T& rhs)
{
	return lhs < rhs ? -1 : 1;
}

//main.cpp
#include <iostream>
#include "utilities.h"
using namespace std;

int main()
{
	cout << compare('d', 'c') << endl;
}
//------------------------------------------------------------------------------------------------
//类对象的工厂模式
#include <iostream>

class Session {};

class SessionFactory {

public:
	Session Create( );
	Session* CreatePtr( );
	void Create(Session*& p);
	// ...
};

//这里先用s的拷贝构造函数新建一个临时对象，再用=操作符赋值给调用函数的对象，所以建了两个临时对象，一个s，一个临时对象
//在这种情况下，一般是用智能指针返回，另一个方法是传对象引用进来
// Return a copy of a stack object 
Session SessionFactory::Create( ) 
{
	Session s;
	return(s);
}

//任何接口如果要求客户必须记得做某些事情，就有着“不正确使用”的倾向
//下面两种方法，客户都必须要记得删除delete工厂函数返回的指针，这里可能发生两种错误：忘记删除，或者同一个指针删除两次
//可以返回智能指针类型tr1::share_ptr或auto_ptr（前者用得更多一些），就强制客户用智能指针类型对象来调用工厂函数，
//几乎消弭了忘记删除底部对象Session（当它不再使用时）的可能性
//条款14，shared_ptr允许当智能指针被建立起来时指定一个资源释放函数（所谓删除器，deleter）绑定于智能指针身上，auto_ptr没有这种功能
//（p98如class Lock对象构造时，将互斥对象放入shared_ptr中，并用unlock作为第二参数，这样当lock对象析构时会调用unlock释放互斥量，而不是删除）
// Return a pointer to a heap object
Session* SessionFactory::CreatePtr( ) {
	return(new Session( ));
}

// Update the caller's pointer with the address
// of a new object
void SessionFactory::Create(Session*& p) {
	p = new Session( );
}

static SessionFactory f; // The one factory object

int main( ) {
	Session* p1 = 0;
	Session* p2 = new Session( );
	delete p2;
	p2 = 0;
	*p2 = f.Create( );   // Just assign the object returned from Create
	p1 = f.CreatePtr( ); // or return a pointer to a heap object
	delete p1;
	p1 = 0;
	f.Create(p1);       // or update the pointer with the new address
	delete p1;
	p1 = 0;
}
//--创建对象的函数模板
template<typename T>
T* createObject( ) {
   return(new T( ));
}

MyClass* p1 = createObject( );
MyOtherClass* p2 = createObject( );
//------------------------------------------------------------------------------------------------
//自动添加类实例，跟踪所有类对象
#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

class MyClass 
{
public:
	static list<MyClass*> instances_;
	MyClass(int val);
	~MyClass( );
	static void showList( );
private:
	int value_;
};

list<MyClass*> MyClass::instances_;//如果写成头文件.h和实现文件.cpp的形式的话，应该在实现文件定义静态变量，不是在头文件中

MyClass::MyClass(int val): value_(val)//内置类型数据成员也可以放到{}中，因为它们构造并没有什么代价，放在成员列表中和实现{}中没什么差别
{
	instances_.push_back(this);
}

MyClass::~MyClass( ) 
{
	list<MyClass*>::iterator p =
		find(instances_.begin( ), instances_.end( ), this);
	if (p != instances_.end( ))
		instances_.erase(p);
}

void MyClass::showList( ) 
{
	for (list<MyClass*>::iterator p = instances_.begin( );
		p != instances_.end( ); ++p)
		cout << (*p)->value_ << endl;
}

int main( ) {
	MyClass a(1);
	MyClass b(10);
	MyClass c(100);
	MyClass::showList( );
}
//------------------------------------------------------------------------------------------------
//为一个类对象分配一个唯一的标识ID。将上例中的list换成static map<int, MyClass*> instmap，就可以随时随地的根据标识找到这个类对象
//如果是要将这个对象放入容器中（不是对象指针）就要考虑是否要容器中的对象要跟原对象有相同ID，这时要考虑拷贝构造函数和=操作符中的
//id = orig.id是否要写成id = ++orig.id
#include <iostream>

class UniqueID {
protected:
   static int nextID;
public:
   int id;
   UniqueID( );
   UniqueID(const UniqueID& orig);
   UniqueID& operator=(const UniqueID& orig);
};

int UniqueID::nextID = 0;

UniqueID::UniqueID( ) {
   id = ++nextID;
}

UniqueID::UniqueID(const UniqueID& orig) {
   id = orig.id;
}

UniqueID& UniqueID::operator=(const UniqueID& orig) {
   id = orig.id;
   return(*this);
}
    
int main( ) {
   UniqueID a;
   std::cout << a.id << std::endl;
   UniqueID b;
   std::cout << b.id << std::endl;
   UniqueID c;
   std::cout << c.id << std::endl;
}
//------------------------------------------------------------------------------------------------
//静态成员变量，所有类共有一个对象，实际这个静态变量不属于任何类
// Static.h
class OneStatic {
public:
    int getCount( ) {return count;}//非静态成员函数可以访问静态成员变量，但是静态成员函数只能访问静态成员变量，因为如果可以访问非静态成员变量，则在对象还未构造时，该静态成员函数要访问的成员变量还是未知
    OneStatic( );
protected:
    static int count;
};

// Static.cpp
#include "Static.h"

int OneStatic::count = 0;//在实现文件中定义

OneStatic::OneStatic( ) {
   count++;
}

// StaticMain.cpp
#include <iostream>
#include "static.h"

using namespace std;

int main( ) {
   OneStatic a;
   OneStatic b;
   OneStatic c;

   cout << a.getCount( ) << endl;
   cout << b.getCount( ) << endl;
   cout << c.getCount( ) << endl;
}
//静态成员变量声明中公有之后，可以直接访问
#include <iostream>

using namespace std;

class OneStatic {
public:
	int getCount( ) {return count;}
	OneStatic( );
	static int count;
};

// Static.cpp


int OneStatic::count = 0;

OneStatic::OneStatic( ) {
	count++;
}


int main( ) {
	OneStatic a;
	OneStatic b;
	OneStatic c;

	cout << a.getCount( ) << endl;
	cout << b.getCount( ) << endl;
	cout << c.getCount( ) << endl;

	cout << ++OneStatic::count << endl;

	cout << a.getCount( ) << endl;
	cout << b.getCount( ) << endl;
	cout << c.getCount( ) << endl;
}
//------------------------------------------------------------------------------------------------
//单例模式（单类），所有类对象只有一个实例。当你决定只需要某个事物的一个实例时，首先应该想到static关键字
#include <iostream>

using namespace std;

class Singleton
{
public:
	static Singleton* getInstance();//返回指针
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	static Singleton* instance_;
	//默认构造函数，拷贝构造函数和赋值操作符全设为私有，不允许用户实例化这个类，只能通过getInstance来获得对象
	//对于设为私有的拷贝构造函数和赋值操作符，如果有人设了公有函数来调用它，还是可以调用的
	//一个更好的方法是只声明它们，而不去实现即不加{}，这样如果有人调用，则会得到一个连接错误(linkage error)
	Singleton(): value_(0){}
	Singleton(const Singleton&);
	Singleton& operator = (const Singleton&);
	int value_;
};

Singleton* Singleton::instance_ = 0;

Singleton* Singleton::getInstance()
{
	if (0 == instance_)
	{
		instance_ = new Singleton();
		return instance_;
	}
	else
	{
		return instance_;
	}
}

void main()
{
	Singleton* p1 = Singleton::getInstance();
	p1->setValue(5);
	cout << p1->getValue() << endl;
	Singleton *p2 = Singleton::getInstance();
	cout << p2->getValue() << endl;
}
//--返回引用
#include <iostream>

using namespace std;

class Singleton
{
public:
	static Singleton& getInstance();
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	static Singleton* instance_;
	Singleton(): value_(0){}
	Singleton(const Singleton&){}
	Singleton& operator = (const Singleton&){}
	int value_;
};

Singleton* Singleton::instance_ = 0;

Singleton& Singleton::getInstance()
{
	if (0 == instance_)
	{
		instance_ = new Singleton();
		return *instance_;
	}
	else
	{
		return *instance_;
	}
}

void main()
{
	Singleton &p1 = Singleton::getInstance();//这里如果不加引用，则调用拷贝构造函数，但是拷贝构造函数已经被声明为私有，不可用，编译不通过
	p1.setValue(5);
	cout << p1.getValue() << endl;
	Singleton &p2 = Singleton::getInstance();
	cout << p2.getValue() << endl;
}
//--单例类CSingleton有以下特征：
//(1)它有一个指向唯一实例的静态指针m_pInstance，并且是私有的；
//(2)它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；
//(3)它的构造函数是私有的，这样就不能从别处创建该类的实例。
 
//大多数时候，这样的实现都不会出现问题。有经验的读者可能会问，instance_指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？
//如果在类的析构行为中有必须的操作，比如关闭文件，释放外部资源，那么上面的代码无法实现这个要求。我们需要一种方法，正常的删除该实例。
//可以在程序结束时调用getInstance()，并对返回的指针掉用delete操作。这样做可以实现功能，但不仅很丑陋，而且容易出错。因为这样的附加代码很容易被忘记，而且也很难保证在delete之后，没有代码再调用GetInstance函数。
//一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上，使其在恰当的时候被自动执行。
//我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样（注意，这里只是析构静态成员变量，指针变量会被释放掉，但是它所指向的内存空间无法释放）。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。如下面的代码中的Garbo类（Garbo意为垃圾工人）：
#include <iostream>
using namespace std;

class Singleton
{
public:
	static Singleton* getInstance();//返回指针
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	Singleton(): value_(0){}
	Singleton(const Singleton&);
	Singleton& operator = (const Singleton&);
	static Singleton* instance_;
	int value_;
	class Garbo//它的唯一工作就是在析构函数中删除Singleton的实例
	{
	public:
		~Garbo()
		{
			if (Singleton::instance_)
			{
				delete Singleton::instance_;
			}
		}
	};
	static Garbo garbo;
};

Singleton* Singleton::instance_ = 0;
Singleton::Garbo Singleton::garbo;//上面只是声明，这里要定义

Singleton* Singleton::getInstance()
{
	if (0 == instance_)
	{
		instance_ = new Singleton();
		return instance_;
	}
	else
	{
		return instance_;
	}
}

void main()
{
	Singleton* p1 = Singleton::getInstance();
	p1->setValue(5);
	cout << p1->getValue() << endl;
	Singleton *p2 = Singleton::getInstance();
	cout << p2->getValue() << endl;
}
//类Garbo被定义为Singleton的私有内嵌类，以防该类被在其他地方滥用。
//程序运行结束时，系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。
//使用这种方法释放单例对象有以下特征：
//(1)在单例类内部定义专有的嵌套类；
//(2)在单例类内定义私有的专门用于释放的静态成员；
//(3)利用程序在结束时析构全局变量的特性，选择最终的释放时机；
//(4)使用单例的代码不需要任何操作，不必关心对象的释放。

//进一步的讨论
//但是添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重现实现单例和解决它相应的问题，代码如下：
#include <iostream>
using namespace std;

class Singleton
{
public:
	static Singleton& getInstance()
	{
		static Singleton instance;
		return instance;
	}
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	Singleton(): value_(0) {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
	int value_;
};

void main()
{
	Singleton& s1 = Singleton::getInstance();
	s1.getValue();
	s1.setValue(5);
	cout << s1.getValue() << endl;
	Singleton& s2 = Singleton::getInstance();
	cout << s2.getValue() << endl;
}
//使用局部静态变量，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。
//这里同样要把拷贝构造函数和赋值操作符声明为私有，防止单例的拷贝构造和赋值操作，这些操作违反了单例的特性
//另外，还可以修改成如下友元函数的形式（优点如下所述：好像没什么问题，上述代码不是声明了静态成员变量，只是一个成员函数，个人感觉静态成员函数更好）：
#include <iostream>
using namespace std;

class Singleton
{
	friend Singleton& getInstance();
public:
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	Singleton(): value_(0) {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
	int value_;
};

Singleton& getInstance()
{
	static Singleton instance;
	return instance;
}

void main()
{
	Singleton& s1 = getInstance();
	Singleton& s2 = getInstance();
	cout << s1.getValue() << endl;
	s1.setValue(5);
	cout << s1.getValue() << endl;
	cout << s2.getValue() << endl;
}
//上述两种方法改进成线程安全的
//第一种方法
#include <iostream>
#include "ace/RW_Thread_Mutex.h"
#include "ace/Guard_T.h"

class Singleton
{
public:
	static Singleton* getInstance();//返回指针
	void setValue(int val)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> writeGuard(rwMutex_);
		value_ = val;
	}
	int getValue()
	{
		ACE_Read_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);
		return value_;
	}
private:
	Singleton(): value_(0) { }
	Singleton(const Singleton&);
	Singleton& operator = (const Singleton&);
	int value_;
	static Singleton* instance_;
	static ACE_RW_Thread_Mutex rwMutex_;
	class Garbo//它的唯一工作就是在析构函数中删除Singleton的实例
	{
	public:
		~Garbo()
		{
			if (Singleton::instance_)
			{
				delete Singleton::instance_;
			}
		}
	};
	static Garbo garbo;
};

ACE_RW_Thread_Mutex Singleton::rwMutex_;
Singleton* Singleton::instance_ = 0;
Singleton::Garbo Singleton::garbo;//上面只是声明，这里要定义

Singleton* Singleton::getInstance()
{
	ACE_Write_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);//这里用的读锁，为什么不是写锁？
	if (0 == instance_)
	{
		instance_ = new Singleton();
	}
	return instance_;
}

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	Singleton* p1 = Singleton::getInstance();
	Singleton *p2 = Singleton::getInstance();
	std::cout << p1->getValue() << std::endl;
	p1->setValue(5);
	std::cout << p1->getValue() << std::endl;
	std::cout << p2->getValue() << std::endl;
	return 0;
}

//第二种方法，将静态变量定义在类中静态成员函数里
#include <iostream>
#include "ace/RW_Thread_Mutex.h"
#include "ace/Guard_T.h"

class Singleton
{
public:
	static Singleton& getInstance()
	{
		static Singleton instance;//这里的静态成员变量不用加锁，因为该静态成员变量是在程序开始时自动初始化创建的，无论哪个线程先访问，都只会创建仅一个对象
		return instance;
	}
	void setValue(int val)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> writeGuard(rwMutex_);
		value_ = val;
	}
	int getValue()
	{
		ACE_Read_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);
		return value_;
	}
private:
	Singleton(): value_(0) { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
	int value_;
	static ACE_RW_Thread_Mutex rwMutex_;
};

ACE_RW_Thread_Mutex Singleton::rwMutex_;

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	Singleton& s1 = Singleton::getInstance();
	Singleton& s2 = Singleton::getInstance();
	std::cout << s1.getValue() << std::endl;
	s1.setValue(5);
	std::cout << s1.getValue() << std::endl;
	std::cout << s2.getValue() << std::endl;
	return 0;
}

//第二种方法，将静态变量定义在友元函数里
#include <iostream>
#include "ace/RW_Thread_Mutex.h"
#include "ace/Guard_T.h"

class Singleton
{
	friend Singleton& getInstance();
public:
	void setValue(int val)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> writeGuard(rwMutex_);
		value_ = val;
	}
	int getValue()
	{
		ACE_Read_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);
		return value_;
	}
private:
	Singleton(): value_(0) { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
	int value_;
	static ACE_RW_Thread_Mutex rwMutex_;
};

ACE_RW_Thread_Mutex Singleton::rwMutex_;

Singleton& getInstance()
{
	static Singleton instance;
	return instance;
}

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	Singleton& s1 = getInstance();
	Singleton& s2 = getInstance();
	std::cout << s1.getValue() << std::endl;
	s1.setValue(5);
	std::cout << s1.getValue() << std::endl;
	std::cout << s2.getValue() << std::endl;
	return 0;
}

总结：第一种方法的实例在没有加内部私有静态成员Garbo之前，instance_指向的空间无法正常释放，该实例的析构函数也无法正常执行，如果需要在类的析构行为中有必须的操作，如关闭文件、释放外部资源等，该实例也无法满足这个要求。可以在程序结束时调用getInstance()，并对返回的指针调用delete操作。这样做可以实现功能，但不仅很丑陋，而且容易出错。因为这样的附加代码很容易被忘记，而且也很难保证在delete之后，没有代码再调用getInstance函数。在增加了Garbo类及静态成员garbo之后，可以满足以上要求，在程序结束时系统会调用Singleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。
使用这种方法释放单例对象有以下特征：
在单例类内部定义专有的嵌套类；
在单例类内定义私有的专门用于释放的静态成员；
利用程序在结束时析构全局变量的特性，选择最终的释放时机；
使用单例的代码不需要任何操作，不必关心对象的释放。（以上为CSDN博客中找到的相关解释，http://blog.csdn.net/boyhailong/article/details/6645681）

第二种方法使用静态局部变量，实现了单例的全部特性，代码量更少，也没有销毁的问题。这个方法里用到了静态变量声明在函数里，而不是类中的静态成员，这样做是很重要。在类中的静态对象实际上总是被构造（和释放），即使不使用该对象。与此相反，将静态变量定义在函数中，只有第一次执行函数时，才会建立函数中的静态对象，所以如果没有调用函数，就不会建立对象。与一个函数的静态成员相比，把instance声明为类中的静态成员还有一个缺点，它的初始化时间不确定。我们能够准确地知道函数的静态成员什么时候被初始化：“在第一次执行定义静态成员的函数时”。而没有定义一个类的静态成员被初始化的时间。C++为一个translation unit（也就是生成一个object文件的源代码的集合）内的静态成员的初始化顺序提供某种保证，但是对于在不同translation unit中的静态成员的初始化顺序则没有这种保证。（以上为More Effective C++ 7.2 限制某个类所能产生的对象数量 中的部分解释）

另外，有几个问题我不太明白，请帮忙解答一下，谢谢！
(1)在More Effective C++ 7.2 限制某个类所能产生的对象数量 中有如下两段关于友元函数不声明为inline函数的解释，我没太看懂：
除了第一次执行这个函数时（也就是构造p时），其它时候这就是一个一行函数――它由“return p;”一条语句组成。这个函数最适合做为内联函数使用。然而它不能被声明为内联。为什么呢？请想一想，为什么你要把对象声明为静态呢？通常是因为你只想要该对象的一个拷贝。现在再考虑“内联”意味着什么呢？从概念上讲，它意味着编译器用函数体替代该对函数的每一个调用，不过非成员函数还不只这些。非成员函数还有其它的含义。它还意味着internal linkage（内部链接）。
通常情况下，你不需要理解这种语言上令人迷惑的东西，你只需记住一件事：“带有内部链接的函数可能在程序内被复制（也就是说程序的目标（object）代码可能包含一个以上的内部链接函数的代码），这种复制也包括函数内的静态对象。”结果如何？如果建立一个包含局部静态对象的非成员函数，你可能会使程序的静态对象的拷贝超过一个！所以不要建立包含局部静态数据的非成员函数。
(2)关于静态变量所在的函数应该声明为类中的静态成员函数还是友元函数应该如何选择？Effective C++ 23.宁以non-member,non-friend 替换member函数 中提到成员函数和友元函数有同样的访问权限，所以两者没有什么太多的选择差异（隐式类型转换时需要做出更好的选择）。所以这里静态成员函数和友元函数没什么差别吗？

//--限制对象的建立个数 More Effective C++ 7.2
//这里用一个友元函数中声明一个静态类对象的方法，有点类似不同文件中的对象初始化先后顺序的方法，怪不得当时说这个方法是单例模式的方法 Effective C++ 条款4
//C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化
namespace PrintingStuff 
{
  class Printer 
  {                                       // 在命名空间 
  public:                                 // PrintingStuff中的类
    void submitJob(const PrintJob& job);
    void reset();
    void performSelfTest();
    friend Printer& thePrinter(); 
  private:
    Printer();
    Printer(const Printer& rhs);
 }; 
 Printer& thePrinter()                   // 这个函数也在命名空间里
 {
    static Printer p;
    return p;
 }
} 

//使用这个命名空间后，客户端可以通过使用fully-qualified name（完全限制符名）（即包括命名空间的名字），
PrintingStuff::thePrinter().reset();
PrintingStuff::thePrinter().submitJob(buffer);
//但是也可以使用using声明，以简化键盘输入：
using PrintingStuff::thePrinter;    // 从命名空间"PrintingStuff"
                                    //引入名字"thePrinter" 
                                     // 使其成为当前域
thePrinter().reset();               // 现在可以象使用局部命名
thePrinter().submitJob(buffer);    // 一样，使用thePrinter 

//在thePrinter的实现上有两个微妙的不引人注目的地方，值得我们看一看。
//第一，唯一的Printer对象是位于函数里的静态成员而不是在类中的静态成员，这样做是非常重要的。在类中的静态对象实际上总是被构造（和释放），即使不使用该对象。与此相反，只有第一次执行函数时，才会建立函数中的静态对象，所以如果没有调用函数，就不会建立对象。（不过你得为此付出代价，每次调用函数时都得检查是否需要建立对象。）建立C++一个理论支柱是你不需为你不用的东西而付出，在函数里，把类似于Printer这样的对象定义为静态成员就是坚持这样的理论。你应该尽可能坚持这种理论。
//与一个函数的静态成员相比，把Printer声明为类中的静态成员还有一个缺点，它的初始化时间不确定。我们能够准确地知道函数的静态成员什么时候被初始化：“在第一次执行定义静态成员的函数时”。而没有定义一个类的静态成员被初始化的时间。C++为一个translation unit（也就是生成一个object文件的源代码的集合）内的静态成员的初始化顺序提供某种保证，但是对于在不同translation unit中的静态成员的初始化顺序则没有这种保证（参见Effective C++条款47）。在实际使用中，这会给我们带来许多麻烦。当函数的静态成员能够满足我们的需要时，我们就能避免这些麻烦。在这里的例子里，既然它能够满足需要，我们为什么不用它呢？
//除了第一次执行这个函数时（也就是构造p时），其它时候这就是一个一行函数――它由“return p;”一条语句组成。这个函数最适合做为内联函数使用。然而它不能被声明为内联。为什么呢？请想一想，为什么你要把对象声明为静态呢？通常是因为你只想要该对象的一个拷贝。现在再考虑“内联”意味着什么呢？从概念上讲，它意味着编译器用函数体替代该对函数的每一个调用，不过非成员函数还不只这些。非成员函数还有其它的含义。它还意味着internal linkage（内部链接）。
//通常情况下，你不需要理解这种语言上令人迷惑的东西，你只需记住一件事：“带有内部链接的函数可能在程序内被复制（也就是说程序的目标（object）代码可能包含一个以上的内部链接函数的代码），这种复制也包括函数内的静态对象。”结果如何？如果建立一个包含局部静态对象的非成员函数，你可能会使程序的静态对象的拷贝超过一个！所以不要建立包含局部静态数据的非成员函数。
//--允许建立任意数量的对象，但是不允许派生，把构造函数和拷贝构造函数声明为private
class FSA 
{
public:
  // 伪构造函数
  static FSA * makeFSA();
  static FSA * makeFSA(const FSA& rhs);
private:
  FSA();
  FSA(const FSA& rhs);
}; 

FSA * FSA::makeFSA()
{ return new FSA(); } 
FSA * FSA::makeFSA(const FSA& rhs)
{ return new FSA(rhs); } 
//不象thePrinter函数总是返回一个对象的引用（引用的对象是固定的），每个makeFSA的伪构造函数则是返回一个指向对象的指针（指向的对象都是惟一的，不相同的）。也就是说允许建立的FSA对象数量没有限制。
//那好，不过每个伪构造函数都调用new这个事实暗示调用者必须记住调用delete。否则就会发生资源泄漏。如果调用者希望退出生存空间时delete会被自动调用，他可以把makeFSA返回的指针存储在auto_ptr中（参见条款M9）；当它们自己退出生存空间时，这种对象能自动地删除它们所指向的对象：
// 间接调用缺省FSA构造函数
auto_ptr<FSA> pfsa1(FSA::makeFSA()); 
// indirectly call FSA copy constructor
auto_ptr<FSA> pfsa2(FSA::makeFSA(*pfsa1)); //象通常的指针一样使用pfsa1和pfsa2,不过不用操心删除它们。
//--使用计算限制对象的个数
class Printer {
public:
  class TooManyObjects{}; 
  // 伪构造函数
  static Printer * makePrinter();
  static Printer * makePrinter(const Printer& rhs); 
private:
  static size_t numObjects;
  static const size_t maxObjects = 10;       // 见下面解释 
  Printer();
  Printer(const Printer& rhs);
}; 
// Obligatory definitions of class statics
size_t Printer::numObjects = 0;

const size_t Printer::maxObjects; 

Printer::Printer()
{
  if (numObjects >= maxObjects) {
    throw TooManyObjects();
  } 
} 

Printer::Printer(const Printer& rhs)
{
  if (numObjects >= maxObjects) {
    throw TooManyObjects();
  } 
} 

Printer * Printer::makePrinter()
{ return new Printer; } 

Printer * Printer::makePrinter(const Printer& rhs)
{ return new Printer(rhs); }
//--一个具有对象计数功能的基类More Effective C++ 7.1 私有继承一个计数基类
//------------------------------------------------------------------------------------------------
//effective c++ p69 条款06 不自动生成的函数，就明确拒绝
//如果只是声明了私有拷贝构造函数，而不提供实现的话，在成员函数或者友元函数里要拷贝该对象，就会报连接错误，这种错误不太好看出来具体原因
//但是可以将这种错误移到编译，看到错误提示迟早处理掉，用一继承类的方法
#include <iostream>

using namespace std;

//带多态性质的base classes应该声明一个virtual析构函数，如果class带有任何virtual函数，它就应该拥有一个virtual析构函数
//如果classes设计的目的不是作为base classes使用，或者不是为了具备多态性（经由base class接口处置derived class对象），就不该声明virtual析构函数
//如这个Uncopyable类
class Uncopyable
{
protected:
	Uncopyable(){}//将构造函数声明为protected也可以防止实例化对象，并且只能通过继承，有点类似纯虚函数的功能
	~Uncopyable(){}
private:
	Uncopyable(const Uncopyable&);
	Uncopyable& operator =(const Uncopyable&);
};

class DerivedUncopyable: private Uncopyable
{

};

void main()
{
	DerivedUncopyable a, b;
	a = b;//编译不过
}

//不可继承的类，借用辅助类
class Usable;  
class Usable_lock 
{   
	friend class Usable;//只有Usable类可以访问其构造函数
private:   
		Usable_lock() { }
		Usable_lock(const Usable_lock&) { }   
};           
class Usable : public virtual Usable_lock 
{   
// ...  
public:   
	Usable();   
	Usable(char* );   
	// ...  
} ;           
Usable a//没有问题
class DD : public Usable {  } ;           
DD dd;  // error: DD::DD() cannot access, Usable_lock::Usable_lock(): private member
//------------------------------------------------------------------------------------------------
//抽象类除了不能实例化对象，其他跟普通类没什么差别，也可以写函数实现，虽然不能实例化对象，但是还是可以加Person::来调用基类版本函数
//如果声明了虚析构函数，就要提供一个函数体，因为派生类需要调用

//如果抽象类的派生类想实例化对象，就必须实现所有的纯虚函数
//基类的虚函数加了virtual之后，派生类及其派生类无论是否加virtual，都具有多态特性
#include <iostream>
#include <string>
using namespace std;

class Person {
public:
	virtual void   eat( )  = 0
	{
		cout << "person eat" << endl;
	}
	virtual void   sleep( ) = 0
	{
		cout << "person sleep" << endl;
	}
	virtual void   walk( ) = 0
	{
		cout << "person walk" << endl;
	}
	virtual void   jump( )  = 0
	{
		cout << "person jump" << endl;
	}
	virtual void   setFirstName(const string& s) {firstName_ = s;}
	virtual void   setLastName(const string& s) {lastName_ = s;}
	virtual string getFirstName( ) {return(firstName_);}
	virtual string getLastName( ) {return(lastName_);} 
	//这里必须提供花括号{}，不可以写成virtual ~Person() = 0; 会出现“无法解析的外部符号”“无法解析的外部命令”错误，
	//看到此类错误要想到是否写了函数声明却没有写实现，哪怕只是一个空的花括号{}
	virtual ~Person() = 0 {}
protected:
	string firstName_;
	string lastName_;
};

class SuperMan: public Person
{
public:
	virtual void   eat( )
	{
		cout << "superman eat" << endl;
	}
	void   sleep( )//这里的virtual已经去掉了
	{
		cout << "superman sleep" << endl;
	}
	virtual void   walk( )
	{
		cout << "superman walk" << endl;
	}
	virtual void   jump( ) 
	{
		cout << "superman jump" << endl;
	}
};

class superSuperMan: public SuperMan
{
	virtual void   eat( )
	{
		cout << "supersuperman eat" << endl;
	}
	virtual void   sleep( )
	{
		cout << "supersuperman sleep" << endl;
	}
	virtual void   walk( )
	{
		cout << "supersuperman walk" << endl;
	}
	virtual void   jump( ) 
	{
		cout << "supersuperman jump" << endl;
	}
};

void main()
{

	superSuperMan supersuperman;
	SuperMan &superperson = supersuperman;
	superperson.sleep();//仍然有动态绑定特性
	superperson.setFirstName("ding");
	string s(superperson.getFirstName());
	cout << s << endl;
}
//------------------------------------------------------------------------------------------------
//类模板实现二叉树 CookBook 例8-12
#include <iostream>
#include <string>

using namespace std;

template<typename T>
class TreeNode {
public:
	TreeNode(const T& val) : val_(val), left_(NULL), right_(NULL) {}
	/*~TreeNode( )//原例中写了析构函数，删除了左孩子和删除右孩子，这两个根本不是new出来的，删除不是堆上的内存会出错
	{
		delete left_;
		delete right_;
	}*/

	const T& getVal( ) const
	{
		return(val_);
	}
	void setVal(const T& val) 
	{
		val_ = val;
	}
	void addChild(TreeNode<T>* p) 
	{
		const T& other = p->getVal( );
		if (other > val_)
			if (right_)
				right_->addChild(p);
			else
				right_ = p;
		else
			if (left_)
				left_->addChild(p);
			else
				left_ = p;
	}
	const TreeNode<T>* getLeft( ) 
	{
		return(left_);
	}
	const TreeNode<T>* getRight( ) 
	{
		return(right_);
	}

private:
	T val_;
	TreeNode<T>* left_;
	TreeNode<T>* right_;
};

int main( ) {

	TreeNode<string> node1("frank");
	TreeNode<string> node2("larry");
	TreeNode<string> node3("bill");

	node1.addChild(&node2);
	node1.addChild(&node3);

	const TreeNode<string> *node = node1.getLeft();
	cout << node->getVal() << endl;
}
//------------------------------------------------------------------------------------------------
//成员函数模板，只对类的成员函数调用的模板
//如果类成员函数的某个参数是继承层次中的某个类，这时候不需要模板，只要传基类的指针或引用即可动态绑定，但是如果
//这个成员函数的某个参数是几种不同继承层次的类，就需要使用成员函数模板了
class ObjectManager {
public:
   template<typename T>
   T* gimmeAnObject( );

   template<typename T>
   void gimmeAnObject(T*& p);
};

template<typename T>
T* ObjectManager::gimmeAnObject( ) {
   return(new T);
}

template<typename T>
void ObjectManager::gimmeAnObject(T*& p) {
   p = new T;
}

class X { /* ... */ };
class Y { /* ... */ };

int main( ) 
{
	ObjectManager om;

	X* p1 = om.gimmeAnObject<X>( ); // You have to specify the template
	Y* p2 = om.gimmeAnObject<Y>( ); // parameter

	delete p1;
	delete p2;

	om.gimmeAnObject(p1);  // Note here, though, since the compiler can
	om.gimmeAnObject(p2);  // deduce T from the arguments，函数模板可以不加参数

	delete p1;
	delete p2;
}
//------------------------------------------------------------------------------------------------
//重载单目操作符，前置单目操作符返回的是引用&，后置单目操作符返回的是临时变量，没有引用&
#include <iostream>

using namespace std;

class Score {
public:
	Score( ) : score_(0) {}
	Score(int i) : score_(i) {}

	Score& operator++( ) { // prefix
		++score_;
		return(*this);
	}
	Score operator++(int) { // postfix
		Score tmp(*this);
		++(*this); // Take advantage of the prefix operator
		return(tmp);//tmp是临时变量，返回引用将引用一个不存在的变量。以后返回引用时一定要看引用的这个变量是从哪里来的
	}
	Score& operator--( ) {
		--score_;
		return(*this);
	}
	Score operator--(int x) {
		Score tmp(*this);
		--(*this);
		return(tmp);
	}
	int getScore( ) const {return(score_);}

private:
	int score_;
};

int main( ) {
	Score player1(50);

	player1++;
	++player1; // score_ = 52
	cout << "Score = " << player1.getScore( ) << '\n';
	Score player2 = --(player1--); // score_ = 50
	cout << player2.getScore() << endl;
	cout << "Score = " << player1.getScore( ) << '\n';
}
//------------------------------------------------------------------------------------------------
//重构const和非const成员函数，让非const调用const版本以避免重复，怎么改？？？
#include <iostream>

using namespace std;

class test
{
public:
	test(): i_(0){}
	const int& get() const
	{
		return i_;
	}
	int& get()
	{
		return const_cast<int&>
			(
			static_cast<const test&>(*this)get()//怎么写呢？effective C++ P55
			);
	}
private:
	int i_;
};

int main( ) 
{

}
//------------------------------------------------------------------------------------------------
//effective c++ p67 条款05
//如果类中成员变量为引用或者const属性，则必须自己写赋值操作符，编译器无法为引用重新赋值，引用一经初始化就不允许改指不同对象了
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class NameObject
{
public:
	NameObject(string& name, const T& value): name_(name), value_(value){}
private:
	string& name_;
	const T value_; 
};

void main()
{
	string s("per");
	NameObject<int> newDog(s, 2);
	string s2("he");
	NameObject<int> oldDog(s2, 3);
	newDog = oldDog;
}
//------------------------------------------------------------------------------------------------
//动态申请和释放二维数组
#include <iostream>
#include <string>
using namespace std;

void main()
{
	//--string **p相当于string p[x][y]
	string **p = (string**)new string*[3];//p是一个指向string*数组的指针，相当于以下两句string **p; p = (string**)new string*[3];
	*p = new string[4];//*p指向一个string*数组的首地址
	*(*p) = string("my");
	*(*p + 1) = string("name");
	
	*(p + 1) = new string[4];
	*(*(p + 1)) = string("is");

	*(p + 2) = new string[4];
	*(*(p + 2)) = string("ding");
	*(*(p + 2) + 1) = string("da");
	*(*(p + 2) + 2) = string("ben");
	cout << p[0][0] << endl;
	cout << p[0][1] << endl;
	cout << p[1][0] << endl;
	cout << p[2][0] << endl;
	cout << p[2][1] << endl;
	cout << p[2][2] << endl;
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 4; ++j)
		{
			cout << *(*(p + i) + j) << endl;
		}	
	}
	delete [] p[0];
	delete [] p[1];
	delete [] p[2];
	delete [] p;

	//string **p
	p = new string*[3];//一次性分配内存，保证内存的连续性
	*p = new string[3*4];
	*(*p) = string("my");
	*(*p + 1) = string("name");

	*(*p + 4) = string("is");

	*(*p + 8) = string("ding");
	*(*p + 9) = string("da");
	*(*p + 10) = string("ben");
	for (int i = 0; i < 12; ++i)
	{
		cout << *(*p + i) << endl;
	}
	delete [] *p;
	delete [] p;
	
	//--string* p[3]相当于string p[3][y]，即string **p进行第一次分配之后的状态
	string* p2[3];//p2是指向二维string*数组的首地址，其中每一个对象都指向一个string*
	*p2 = new string[4];
	*(*p2) = string("my");
	*(*p2 + 1) = string("name");

	*(p2 + 1) = new string[4];
	*(*(p2 + 1)) = string("is");

	*(p2 + 2) = new string[4];
	*(*(p2 + 2)) = string("ding");
	*(*(p2 + 2) + 1) = string("da");
	*(*(p2 + 2) + 2) = string("ben");
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 4; ++j)
		{
			cout << *(*(p2 + i) + j) << endl;
		}	
	}
	delete [] p2[0];
	delete [] p2[1];
	delete [] p2[2];
	
	//string* p2[3]
	*p2 = new string[3*4];//一次性分配内存，保证内存的连续性

	*(*p2) = string("my");
	*(*p2 + 1) = string("name");

	*(*p2 + 4) = string("is");

	*(*p2 + 8) = string("ding");
	*(*p2 + 9) = string("da");
	*(*p2 + 10) = string("ben");
	for (int i = 0; i < 12; ++i)
	{
		cout << *(*p2 + i) << endl;
	}
	delete [] *p2;

	//--string(*p)[3]相当于string p[x][3]
	string (*p3)[3] = (string (*)[3])new string[4*3];//分配的一块连续的内存，相当于string (*p3)[3]; p3 = (string (*)[3])new string[4*3];
	*(*p3) = string("my");
	*(*p3 + 1) = string("name");

	*(*(p3 + 1)) = string("is");

	*(*(p3 + 2)) = string("ding");
	*(*(p3 + 2) + 1) = string("da");
	*(*(p3 + 2) + 2) = string("ben");

	for (int i = 0; i < 4; ++i)//这是一个4行，3列的数组，所以外层i应该是4，里层j是3
	{
		for (int j = 0; j < 3; ++j)
		{
			cout << *(*(p3 + i) + j) << endl;
		}	
	}
	for (int i = 0; i < 12; ++i)
	{
		cout << *(*p3 + i) << endl;
	}
	delete [] p3;
}
//------------------------------------------------------------------------------------------------
//operator=处理自我赋值
//第一种是比较“来源对象”和“目标对象”地址，没有异常安全
//第二种通过安排语句顺序实现异常安全
//第三种通过copy and swap实现异常安全，如果拷贝构造是异常安全的，那么这种技术就是异常安全的
#include <iostream>
#include <string>
using namespace std;

class Person
{
public:
	Person(const string& name, const string& fatherName = "");//如果想给参数默认值，要么const引用，要么非const非引用
	~Person();

	Person(const Person&);
	Person& operator=(const Person&);

	void showName()
	{
		cout << name_ << endl;
	}
	void showFatherName()
	{
		if (0 == father_)
		{
			cout << "haven't set father" << endl;
		}
		else
		{
			father_->showName();
		}	
	}
private:
	void swapPerson(Person&);
	void swapName(string&);
	void swapFatherPtr(Person*&);
	string name_;
	Person *father_;
};

Person::Person( const string& name, const string& fatherName): name_(name), father_(0)
{
	if (!fatherName.empty())
	{
		father_ = new Person(fatherName);
	}
}

Person::Person( const Person& rhs): name_(rhs.name_), father_(0)
{
	if (0 != rhs.father_)
	{
		father_ = new Person(rhs.father_->name_);
	}
}

Person::~Person()
{
	delete father_;
}

//没有异常安全，如果new抛异常了，则当前的this->father_也已经删掉了
//Person& Person::operator=( const Person& rhs)
//{
//	if (this != &rhs)
//	{
//		name_ = rhs.name_;
//		delete father_;
//		if (0 == rhs.father_)
//		{
//			father_ = 0;
//		}
//		else
//		{
//			father_ = new Person(*rhs.father_);
//		}
//		
//	}
//	return *this;
//}

////实现异常安全的版本
//Person& Person::operator=( const Person& rhs)
//{
//	Person *orig = father_;//先记住原来的
//	if (rhs.father_ == 0)
//	{
//		father_ = 0;
//	}
//	else
//	{
//		father_ = new Person(*rhs.father_);//new出新的对象，如果抛异常，则原来的this->father_没有变化
//	}
//	delete orig;
//	return *this;
//}

//copy and swap实现异常安全
Person& Person::operator=( const Person& rhs)
{
	Person tmp(rhs);
	swapPerson(tmp);
	return *this;
}

void Person::swapPerson(Person& rhs)
{
	swapName(rhs.name_);
	swapFatherPtr(rhs.father_);
}

void Person::swapName(string& rhs)
{
	string tmp = rhs;
	rhs = name_;
	name_ = tmp;
}

void Person::swapFatherPtr(Person*& rhs)
{
	Person* tmp = rhs;
	rhs = father_;
	father_ = tmp;
}

void main()
{
	Person xiaoMing("Xiao Ming");
	xiaoMing.showName();
	xiaoMing.showFatherName();
	Person xiaoDong("Xiao Dong", "Da Dong");
	xiaoDong.showName();
	xiaoDong.showFatherName();

	Person hong(xiaoDong);
	hong.showName();
	hong.showFatherName();

	hong = xiaoMing;
	hong.showName();
	hong.showFatherName();
}
//------------------------------------------------------------------------------------------------
//std::tr1::shared_ptr支持复制操作，用计数统计指向对象的指针个数，可以把该类型指针放入vector中
//auto_ptr不支持复制操作，放入容器中编译报错，effective C++ 条款13
#include <iostream>
#include <memory>
#include <vector>
using namespace std;
using namespace std::tr1;

void main()
{
	shared_ptr<int> intAutoPtr(new int(5));
	vector< shared_ptr<int> > vecIntAutoPtr;
	vecIntAutoPtr.push_back(intAutoPtr);
	cout << **(vecIntAutoPtr.begin()) << endl;
	cout << *intAutoPtr << endl;
}
//------------------------------------------------------------------------------------------------
//类型转换
class Widget
{
	explicit Widget(int size);
	...
};
void doSomeWork(const Widget& w);
doSomeWork(Widget(15));//以一个int加上“函数风格”的转型动作创建一个Widget，实际是一个类型转换，而不是“对象生成”
doSomeWork(static_cast<Widget>(15));//以一个int加上“C++风格”的转型动作创建一个Widget，应该始终理智的使用新式转型
//------------------------------------------------------------------------------------------------
//异常安全Effective C++条款29 P161，copy and swap，全有或者全无
//写新代码或者修改旧码时，请具备异常安全性。首先，以对象管理资源(条款13)，以阻止资源泄漏。
//然后挑选三个“异常安全保证”中的某一个实施于所写的每一个函数上，应该挑选“现实可施作”条件下的最强烈等级。
//只有当你的函数调用了传统代码，才别无选择地将它设为“无任何保证”，将决定写成文档，一是为函数用户着想，二是为将来维护者着想。
struct PMImpl
{
	std::tr1::shared_ptr<Image> bgImage;
	int imageChanges;
};

class PrettyMenu
{
	void changeBackground(std::istream&);
private:
	Mutex mutex;
	//将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象(implementation object，即副本)
	//这种手法常被称为pimpl idiom，可以实现接口和实现分离，降低编译依存性，条款31
	std::tr1::<PMImpl> pImpl;
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	using std::swap;
	Lock ml(&mutex);//自动释放，异常安全的保证之一，条款14，以对象管理资源(条款13)
	std::tr1::shared_ptr<PMImpl> pNew(new PMImpl(*pImpl));
	pNew->bgImage.reset(new Image(imgSrc));
	++pNew->imageChanges;
	
	//思想就是先构造一个新的对象，然后swap
	swap(pImpl, pNew);
}
//------------------------------------------------------------------------------------------------
//virtual函数的几种替换方案
//non-virtual interface(NVI)手法，Template Method设计模式中的一种特殊模式，以public non-virtual成员函数包裹较低访问性(private或protected)的virtual函数
//借tr1::function完成的Strategy模式 条款35
#include <iostream>
#include <functional>
using namespace std;

class GameCharacter;
int defaultHealthCalc(const GameCharacter& gc);
class GameCharacter
{
public:
	//HealthCalcFunc可以是任何“可调用物”，可被调用并接受
	//任何兼容于GameCharacter之物，返回任何兼容于int的东西
	//接受一个reference指向const GameCharacter，并返回int
	//这个tr1::function类型产生的对象可以持有(保存)任何与此签名式兼容的可调用物(callable entity)
	//所谓兼容，是这个可调用物的参数可被隐式转换为const GameCharacter&，而其返回类型可被隐式转换为int
	typedef tr1::function<int (const GameCharacter&)> HealthCalcFunc;//不用tr1::function的话，就用函数指针，不过使用上会受限很多
	explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)
		: healthFunc(hcf)
	{

	}
	int healthValue() const 
	{
		return healthFunc(*this);
	}
private:
	HealthCalcFunc healthFunc;
};

class EvilBadGuy: public GameCharacter
{
public:
	explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc)
		: GameCharacter(hcf)
	{}
};

short calcHealth(const GameCharacter&);

struct HealthCalculator
{
	int operator()(const GameCharacter&) const
	{}
};

class GameLevel
{
public:
	float health(const GameCharacter&) const;
};

void main()
{
	EvilBadGuy ebg1(calcHealth);//人物1，使用某个函数计算健康指数
	EvilBadGuy ebg2(HealthCalculator());//人物2，使用某个函数对象计算健康指数
	GameLevel currentLevel;
	EvilBadGuy ebg3(tr1::bind(&GameLevel::health, currentLevel, _1));//人物3，使用某个成员函数计算健康指数
}
//--古典的Strategy模式
#include <iostream>
using namespace std;

class GameCharacter;
class HealthCalcFunc
{
public:
	virtual int calc(const GameCharacter& gc) const
	{}
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter
{
public:
	//当GameCharacter继承层次中的类想拥有不同的健康计算方法时，只需要在HealthCalcFunc类中的继承体系中添加一个derived Calss即可，
	//然后将继承类对象作为构造的指针参数传入，由于是指针参数，可以在计算健康值时动态绑定pHealthCalc->calc(*this)
	//GameCharacter类没有虚函数，没有动态绑定特性
	explicit GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc)
		: pHealthCalc(phcf)
	{}
	int healthValue() const
	{
		return pHealthCalc->calc(*this);
	}
private:
	HealthCalcFunc* pHealthCalc;//声明一个指向健康计算的类
};

void main()
{
	
}
//------------------------------------------------------------------------------------------------
//条款37，绝不重新定义继承而来的缺省参数值
//non-virtual已经在条款36中强调过，绝不重新定义，所以这个条款指的就是不重新定义继承而来的virtual函数缺省参数值
#include <iostream>
using namespace std;

class Shape
{
public:
	enum ShapeColor { Red, Green, Blue };
	//提供一个缺省颜色来画自己
	virtual void draw(ShapeColor color = Red) const = 0
	{
		cout << "base color is " << color << endl;
	}
};

class Rectangle: public Shape
{
public:
	//赋予不同的缺省参数值，真糟糕！
	virtual void draw(ShapeColor color = Green) const
	{
		cout << "derived color is " << color << endl;
	}
};

class Circle: public Shape
{
public:
	//如果这样写不提供缺省参数，当客户以对象调用此函数时，一定要指定参数值
	//因为静态绑定下这个函数并不从其base继承缺省参数值
	//但若以指针(或引用)调用此函数，可以不指定参数值
	//因为动态绑定下这个函数会从其base继承缺省参数值
	virtual void draw(ShapeColor color) const
	{
		cout << "derived color is " << color << endl;
	}
};

void main()
{
	Rectangle rec;
	rec.draw();//对象类型没有问题，参数值由derived类的缺省参数提供

	Circle cir;
	//cir.draw();//编译不通过，静态绑定不从base继承缺省参数值
	
	Shape *pc = &cir;
	pc->draw();//通过，动态绑定从base继承缺省参数值
	
	/*Circle *pcc = &cir;
	pcc->draw();*/ //编译不通过，动态类型还是Circle。静态类型就看指针类型是什么，动态类型就看指针是指向什么类型的

	Shape *pr = &rec;
	pr->draw();//！！！这个动态绑定的函数很畸形，调用的是动态类型Rectangle的draw()函数，参数color值却是静态类型base类draw()函数的缺省参数
}
//--可以考虑条款35中的第一种virtual函数的替代设计，NVI(non-virtual interface)手法：
//令base class内的一个public non-virtual函数调用private virtual函数，后者可被derived classes重新定义
//这里可以让non-virtual函数指定缺省参数，而pirvate virtual函数负责真正的工作
//virtual不一定非要为了动态绑定，也可以做为重定义函数来使用，如上述private virtual成员函数
//------------------------------------------------------------------------------------------------
//条款44：与参数无关的代码抽离templates，以及boost::scoped_array<T>，数组智能指针的使用 p246
//------------------------------------------------------------------------------------------------
//条款46：编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，
//请将那些函数定义为“class template”内部的friend函数 p256
//------------------------------------------------------------------------------------------------
//通过重载避免隐式类型转换 More Effective C++ 6.6
//通过重载可以不建立临时对象，降低开销
class UPInt {                                 // unlimited precision
public:                                       // integers 类
  UPInt();
  UPInt(int value);
}; 
const UPInt operator+(const UPInt& lhs,      // add UPInt
                      const UPInt& rhs);     // and UPInt 
const UPInt operator+(const UPInt& lhs,      // add UPInt
                      int rhs);              // and int 
const UPInt operator+(int lhs,               // add int and
                      const UPInt& rhs);     // UPInt 
UPInt upi1, upi2; 
UPInt upi3 = upi1 + upi2;                  // 正确,没有由upi1 或 upi2
                                           // 生成的临时对象
upi3 = upi1 + 10;                          // 正确, 没有由upi1 or 10
                                           // 生成的临时对象
upi3 = 10 + upi2;                          //正确, 没有由10 or upi2
                                           //生成的临时对象。 
//在C++中有一条规则是每一个重载的operator必须带有一个用户定义类型（user-defined type）的参数
//int不是用户定义类型，所以我们不能重载operator成为仅带有此[int]类型参数的函数。
//（如果没有这条规则，程序员将能改变预定义的操作，这样做肯定把程序引入混乱的境地。比如企图重载上述的operator，将会改变int类型相加的含义。）
const UPInt operator+(int lhs, int rhs);           // 错误!
//------------------------------------------------------------------------------------------------
//将构造函数和非成员函数虚拟化 More Effective C++ 7.1 
//考虑一下readComponent所做的工作。它根据所读取的数据建立了一个新对象，或是TextBlock或是Graphic。因为它能建立新对象，它的行为与构造函数相似，而且因为它能建立不同类型的对象，我们称它为虚拟构造函数。虚拟构造函数是指能够根据输入给它的数据的不同而建立不同类型的对象。虚拟构造函数在很多场合下都有用处，从磁盘（或者通过网络连接，或者从磁带机上）读取对象信息只是其中的一个应用。
class NewsLetter {
public:
  ... 
private:
  // 为建立下一个NLComponent对象从str读取数据,
  // 建立component 并返回一个指针。
  static NLComponent * readComponent(istream& str);
   ...
};
NewsLetter::NewsLetter(istream& str)
{
    while (str) {
        // 把readComponent返回的指针添加到components链表的最后，
        // "push_back" 一个链表的成员函数，用来在链表最后进行插入操作。
        components.push_back(readComponent(str));
    }
}
//--
//还有一种特殊种类的虚拟构造函数DD虚拟拷贝构造函数DD也有着广泛的用途。虚拟拷贝构造函数能返回一个指针，指向调用该函数的对象的新拷贝。因为这种行为特性，虚拟拷贝构造函数的名字一般都是copySelf，cloneSelf或者是象下面这样就叫做clone。很少会有函数能以这么直接的方式实现它：
//正如我们看到的，类的虚拟拷贝构造函数只是调用它们真正的拷贝构造函数。因此“拷贝”的含义与真正的拷贝构造函数相同。如果真正的拷贝构造函数只做了简单的拷贝，那么虚拟拷贝构造函数也做简单的拷贝。如果真正的拷贝构造函数做了全面的拷贝，那么虚拟拷贝构造函数也做全面的拷贝。如果真正的拷贝构造函数做一些奇特的事情，象引用计数或copy-on-write（参见条款M29），那么虚拟构造函数也这么做。完全一致，太棒了。
//被派生类重定义的虚拟函数不用必须与基类的虚拟函数具有一样的返回类型。如果函数的返回类型是一个指向基类的指针（或一个引用），那么派生类的函数可以返回一个指向基类的派生类的指针（或引用）。这不是C++的类型检查上的漏洞，它使得有可能声明象虚拟构造函数这样的函数。这就是为什么TextBlock的clone函数能够返回TextBlock*和Graphic的clone能够返回Graphic*的原因，即使NLComponent的clone返回值类型为NLComponent*。（设计模式的PPrototype原型模式）
class NLComponent {
public:
  // declaration of virtual copy constructor
  virtual NLComponent * clone() const = 0;
  ... 
}; 

class TextBlock: public NLComponent {
public:
  virtual TextBlock * clone() const         // virtual copy
  { return new TextBlock(*this); }          // constructor
  ... 
};
 
class Graphic: public NLComponent {
public:
  virtual Graphic * clone() const            // virtual copy
  { return new Graphic(*this); }             // constructor
  ... 
};
//在NLComponent中的虚拟拷贝构造函数能让实现NewLetter的(正常的)拷贝构造函数变得很容易：
class NewsLetter {
public:
  NewsLetter(const NewsLetter& rhs);
  ... 
private:
  list<NLComponent*> components;
}; 

NewsLetter::NewsLetter(const NewsLetter& rhs)
{
  // 遍历整个rhs链表，使用每个元素的虚拟拷贝构造函数
  // 把元素拷贝进这个对象的component链表。
  // 有关下面代码如何运行的详细情况，请参见条款M35.
  for (list<NLComponent*>::const_iterator it =
          rhs.components.begin();
       it != rhs.components.end();
       ++it) { 
  // "it" 指向rhs.components的当前元素，调用元素的clone函数，
  // 得到该元素的一个拷贝，并把该拷贝放到
  // 这个对象的component链表的尾端。
    components.push_back((*it)->clone());
  }
}
//--虚拟非成员函数
//如果想让<<多态输出，则必须将<<重载为成员函数，但是如果重载为成员函数virtual ostream& operator<<(ostream& str) const，则这样调用t << cout，这与平时习惯不同，所以只能将<<声明为非成员函数，但是非成员函数又不具有虚函数多态特性
//所以我们想要的是一个称为operator<<的非成员函数，其具有象print虚拟函数的行为特性。有关我们想要什么的描述实际上已经很接近如何得到它的描述。我们定义operator<< 和print函数，让前者调用后者！
//具有虚拟行为的非成员函数很简单。你编写一个虚拟函数来完成工作，然后再写一个非虚拟函数，它什么也不做只是调用这个虚拟函数。为了避免这个句法花招引起函数调用开销，你当然可以内联这个非虚拟函数
class NLComponent {
public:
  virtual ostream& print(ostream& s) const = 0;
  ... 
};
 
class TextBlock: public NLComponent {
public:
  virtual ostream& print(ostream& s) const;
  ... 
};
 
class Graphic: public NLComponent {
public:
  virtual ostream& print(ostream& s) const;
  ... 
}; 

inline
ostream& operator<<(ostream& s, const NLComponent& c)
{
  return c.print(s);
}
//------------------------------------------------------------------------------------------------
//限制某个类所能产生的对象数量More Effective C++ 7.3，其中有个方法是定义一个计数的基类，让其他类去继承这个计数基类。
//在浮生类中用到了using，这个方法为了让派生类使用基类中的某个private成员，或者是使用private继承基类中的公有成员，在派生类中的public域中using成员，就可以让这个基类成员变成派生类中的公有
//------------------------------------------------------------------------------------------------
//限制必须在堆中建立对象 More Effective C++ 7.3
//把析构函数声明为私有，则声明对象时没错误，但是编译器会提示无法调用private的析构函数
//把这些调用变得不合法的一种最直接的方法是把构造函数和析构函数声明为private。这样做副作用太大。没有理由让这两个函数都是private。最好让析构函数成为private，让构造函数成为public。处理过程与条款26相似，你可以引进一个专用的伪析构函数，用来访问真正的析构函数。客户端调用伪析构函数释放他们建立的对象。（WQ加注：注意，异常处理体系要求所有在栈中的对象的析构函数必须申明为公有！）
//另一种方法是把全部的构造函数都声明为private。这种方法的缺点是一个类经常有许多构造函数，类的作者必须记住把它们都声明为private。否则如果这些函数就会由编译器生成，构造函数包括拷贝构造函数，也包括缺省构造函数；编译器生成的函数总是public（参见Effecitve C++ 条款45）。因此仅仅声明析构函数为private是很简单的，因为每个类只有一个析构函数。
class UPNumber {
public:
  UPNumber();
  UPNumber(int initValue);
  UPNumber(double initValue);
  UPNumber(const UPNumber& rhs);
  // 伪析构函数 (一个const 成员函数， 因为
  // 即使是const对象也能被释放。)
  void destroy() const { delete this; }
private:
  ~UPNumber();
};

//然后客户端这样进行程序设计：
UPNumber n;                          // 错误! (在这里合法， 但是
                                     // 当它的析构函数被隐式地
                                     // 调用时，就不合法了)
UPNumber *p = new UPNumber;          //正确
delete p;                            // 错误! 试图调用
                                     // private 析构函数
p->destroy();                        // 正确


//通过限制访问一个类的析构函数或它的构造函数来阻止建立非堆对象，但是在条款26已经说过，这种方法也禁止了继承和包容（containment）：
class UPNumber { ... };              // 声明析构函数或构造函数
                                     // 为private
class NonNegativeUPNumber:
  public UPNumber { ... };           // 错误! 析构函数或
                                     //构造函数不能编译

class Asset {
private:
  UPNumber value;
  ...                                // 错误! 析构函数或
                                     //构造函数不能编译
};

//这些困难不是不能克服的。通过把UPNumber的析构函数声明为protected（同时它的构造函数还保持public）就可以解决继承的问题，需要包含UPNumber对象的类可以修改为包含指向UPNumber的指针：
class UPNumber { ... };              // 声明析构函数为protected
class NonNegativeUPNumber:
  public UPNumber { ... };           // 现在正确了; 派生类
                                     // 能够访问
                                     // protected 成员

class Asset {
public:
  Asset(int initValue);
  ~Asset();
  ...
private:
  UPNumber *value;
};

Asset::Asset(int initValue)
: value(new UPNumber(initValue))      // 正确
{ ... }

Asset::~Asset()
{ value->destroy(); }                 // 也正确

//--判断一个对象是否是堆对象，声明一个虚基类用来记录堆对象地址，并让其他类对象继承这个HeapTracked对象
class HeapTracked 
{                  // 混合类; 跟踪
public:                              // 从operator new返回的ptr
  class MissingAddress{};            // 异常类，见下面代码
  virtual ~HeapTracked() = 0;
  static void *operator new(size_t size);
  static void operator delete(void *ptr);
  bool isOnHeap() const;
private:
  typedef const void* RawAddress;
  static list<RawAddress> addresses;
};

// mandatory definition of static class member
list<RawAddress> HeapTracked::addresses;
// HeapTracked的析构函数是纯虚函数，使得该类变为抽象类。
// (参见Effective C++条款14). 然而析构函数必须被定义，
//所以我们做了一个空定义。.
HeapTracked::~HeapTracked() {}

void * HeapTracked::operator new(size_t size)
{
  void *memPtr = ::operator new(size);  // 获得内存
  addresses.push_front(memPtr);         // 把地址放到list的前端
  return memPtr;
}

void HeapTracked::operator delete(void *ptr)
{
  //得到一个 "iterator"，用来识别list元素包含的ptr；
  //有关细节参见条款35
  list<RawAddress>::iterator it =
    find(addresses.begin(), addresses.end(), ptr);
  if (it != addresses.end()) {       // 如果发现一个元素
    addresses.erase(it);             //则删除该元素
    ::operator delete(ptr);          // 释放内存
  } else {                           // 否则
    throw MissingAddress();          // ptr就不是用operator new
  }                                  // 分配的，所以抛出一个异常
} 

bool HeapTracked::isOnHeap() const
{
  // 得到一个指针，指向*this占据的内存空间的起始处，
  // 有关细节参见下面的讨论
  const void *rawAddress = dynamic_cast<const void*>(this);
  // 在operator new返回的地址list中查到指针
  list<RawAddress>::iterator it =
    find(addresses.begin(), addresses.end(), rawAddress);
  return it != addresses.end();      // 返回it是否被找到
} 
//只有一个地方可能让你感到困惑，就是这个语句（在isOnHeap函数中）
//const void *rawAddress = dynamic_cast<const void*>(this);
//我前面说过带有多继承或虚基类的对象会有几个地址，这导致编写全局函数isSafeToDelete会很复杂。这个问题在isOnHeap中仍然会遇到，但是因为isOnHeap仅仅用于HeapTracked对象中，我们能使用dynamic_cast操作符（参见条款M2）的一种特殊的特性来消除这个问题。只需简单地放入dynamic_cast，把一个指针dynamic_cast成void*类型（或const void*或volatile void*），生成的指针将指向“原指针指向对象内存”的开始处。但是dynamic_cast只能用于“指向至少具有一个虚拟函数的对象”的指针上。我们该死的isSafeToDelete函数可以用于指向任何类型的指针，所以dynamic_cast也不能帮助它。isOnHeap更具有选择性（它只能测试指向HeapTracked对象的指针），所以能把this指针dynamic_cast成const void*，变成一个指向当前对象起始地址的指针。如果HeapTracked::operator new为当前对象分配内存，这个指针就是HeapTracked::operator new返回的指针。如果你的编译器支持dynamic_cast 操作符，这个技巧是完全可移植的。

//使用这个类，即使是最初级的程序员也可以在类中加入跟踪堆中指针的功能。他们所需要做的就是让他们的类从HeapTracked继承下来。例如我们想判断Assert对象指针指向的是否是堆对象：
class Asset: public HeapTracked {
private:
  UPNumber value;
};
//我们能够这样查询Assert*指针，如下所示：
void inventoryAsset(const Asset *ap)
{
  if (ap->isOnHeap()) {
    ap is a heap-based asset ― inventory it as such;
  }
  else {
    ap is a non-heap-based asset ― record it that way;
  }
}
//象HeapTracked这样的混合类有一个缺点，它不能用于内建类型，因为象int和char这样的类型不能继承自其它类型。不过使用象HeapTracked的原因一般都是要判断是否可以调用“delete this”，你不可能在内建类型上调用它，因为内建类型没有this指针。
//------------------------------------------------------------------------------------------------
//智能指针 More Effective C++ 7.4
//因为当调用auto_ptr的拷贝构造函数时，对象的所有权被传递出去，所以通过传值方式传递auto_ptr对象是一个很糟糕的方法
// 这个函数通常会导致灾难发生
void printTreeNode(ostream& s, auto_ptr<TreeNode> p)//这里传引用就可以解决问题了auto_ptr<TreeNode> &p
{ s << *p; }

int main()
{
  auto_ptr<TreeNode> ptn(new TreeNode);
  printTreeNode(cout, ptn);          //通过传值方式传递auto_ptr
}
//--智能指针保存继承层次中对象
#include <iostream>
#include <memory>
using namespace std;

class Base
{
public:
	virtual void display()
	{
		cout << "base display" << endl;
	}
};

class Derived: public Base
{
public:
	virtual void display()
	{
		cout << "derived display" << endl;
	}
};

void show(auto_ptr<Base> &p)
{
	p->display();
}

void main()
{
	auto_ptr<Base> ptr(new Derived());
	show(ptr);
}
//------------------------------------------------------------------------------------------------
//十进制与二进制的互相转换
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

string decToBinString(int num)
{
	if (num > 0)
	{
		string s;
		stringstream ss;
		s = decToBinString(num/2);
		ss << num % 2;
		return s + ss.str();
	}
	else
	{
		return "";
	}
}

void decToBinString(int num, string &s)
{
	if (num > 0)
	{
		decToBinString(num/2, s);
		stringstream ss;
		ss << num % 2;
		s += ss.str();
	}
}

void expandToFourBits(string &s)
{
	if (s.length() < 4)
	{
		s.insert(s.begin(), 4 - s.length(), '0');
	}
}

void binToDec(int binaryNumber, int &decimal, int &weight)
{
	int bit;
	if (binaryNumber > 0)
	{
		bit = binaryNumber % 10;
		decimal = decimal + bit * static_cast<int>(pow(2.0, weight));
		binaryNumber = binaryNumber / 10;
		++weight;
		binToDec(binaryNumber, decimal, weight);
	}
}

void main()
{
	//cout << decToBinString(10) << endl;
	string s;
	decToBinString(15, s);
	cout << s << endl;
	expandToFourBits(s);
	cout << s << endl;

	int decimal = 0;
	int weight = 0;
	binToDec(110, decimal, weight);
	cout << decimal << endl;
}
//------------------------------------------------------------------------------------------------
//代理类的几种用途
//More Effective C++ 4.1 代理类阻止单参数的构造函数被误用为类型转换函数
template<class T>
class Array 
{
public: 
  class ArraySize {                    // 这个类是新的
  public:
    ArraySize(int numElements): theSize(numElements) {}
    int size() const { return theSize; } 
  private:
    int theSize;
  }; 
  Array(int lowBound, int highBound);
  Array(ArraySize size);                  // 注意新的声明 
};
//More Effective C++ 7.6 代理类实现多维数组
template<class T>
class Array2D 
{
public:
  class Array1D {
  public:
    T& operator[](int index);
    const T& operator[](int index) const;
	...
  };
  Array1D operator[](int index);
  const Array1D operator[](int index) const;
  ...
};
//More Effective C++ 7.6 代理类帮助区分通过operator[]进行的是读操作还是写操作
//只有在String对象调用operator[]作并且作左值进行赋值操作=时才会判断是否需要重新生成新对象，否则只是调用String::operator[]进行读操作
String::CharProxy::operator=(const CharProxy& rhs)
{
  // if the string is sharing a value with other String objects,
  // break off a separate copy of the value for this string only
  if (theString.value->isShared()) {
    theString.value = new StringValue(theString.value->data);
  }
  // now make the assignment: assign the value of the char
  // represented by rhs to the char represented by *this
  theString.value->data[charIndex] = rhs.theString.value->data[rhs.charIndex];
  return *this;
}
//与原来的String类比较，没有代理类，则只要调用String::operator[]就会生成新对象 More Effective C++ 7.5 
char& String::operator[](int index)
{
  if (value->isShared()) {
    value = new StringValue(value->data);
  }
  value->markUnshareable();
  return value->data[index];
}
//------------------------------------------------------------------------------------------------
//pair的几种声明方式
#include <iostream>
#include <memory>
using namespace std;

void main()
{
	auto_ptr< pair<int, int> > a(new pair<int, int>(make_pair(1, 2)));//auto_ptr< pair<int, int> > a(new pair<int, int>(1, 2));
	cout << a->first << '\t' << a->second << endl;

	pair<int, int> b = pair<int, int>(3, 4);
	pair<int, int> c = make_pair(5, 6);//make_pair标准函数模板，免去了写类pair模板时的两个参数
	b.swap(c);
	cout << c.first << '\t' << c.second << endl;

	pair<int, int> *p = new pair<int, int>(7, 8);
	delete p;
}
//------------------------------------------------------------------------------------------------
//将你的代码设计得当需要变化时，影响是局部的！
//More Effective C++ 8.1指出有这样一句话：你需要虚析构函数，只要有人delete一个实际值向D的B *。
//这句话是对的，如下
class B { ... };                   // no virtual dtor needed
class D: public B { ... };
B *pb = new D;
//但是当加入下面一句话时
delete pb;
//这意味着，用户代码中的一个小变化－－增加了一个delete语句－－实际上能导致需要修改B的定义。如果这发生了的话，所有B的用户都必须重编译。采纳了这个作者的建议的话，一条语句的增加将导致大量代码的重编译和重链接。这绝不是一个高效的设计。

//--More Effective C++ 8.1指出有很多作者这样写到：如果一个公有基类没有虚析构函数，所有的派生类基其成员函数都不应该有析构函数。
//这句话是不对的，如下所示：
//B没有虚析构函数，如果声明了一个指向C的*B类型的指针p，则C中的A对象永远不会被析构掉，造成内存泄漏，这时候应该给B设上virtual ~B()
#include <iostream>
using namespace std;

class A
{
public:
	A(): i_(0)
	{
		i_ = new int(3);
		cout << "A()" << endl;
	}
	~A()
	{
		delete i_;
		cout << "~A()" << endl;
	}
private:
	int *i_;
};

class B
{
public:
	B()
	{
		cout << "B()" << endl;
	}
	~B()
	{
		cout << "~B()" << endl;
	}
};

class C: public B
{
	A a_;
};

void main()
{
	B *p = new C();
	delete p;
}
//再一次，一个关于B的使用的小小的变化（这里是增加了一个包含有析构函数的成员对象的派生类）可能需要大量代码的重编译和重链接。但在系统中，小的变化应该只有小的影响。这个设计在这个测试上失败了。
//同一作者写到：如果多重继承体系有许多析构函数，每个基类都应该有应该虚析构函数。
//所有这些引用，都在关注进行时态的考虑。用户现在在怎么操纵指针？当前类的什么成员有析构函数？继承系统中的什么类有析构函数？
//未来时态的考虑完全不同。不是问一个类现在正被怎么使用，而是问这个类是被设计为怎么去使用的。未来时态的考虑认为：如果一个类被设计为作一个基类使用（即使现在还没有被这么使用），它就应该有一个虚析构函数（见Item E14）。这样的类在现在和将来都行为正确，并且当新类从它们派生时并不影响其它库用户。（至少，它们没有任何影响，直到其析构函数被使用。如果需要对类的额外修改，其它用户将受影响。）
//------------------------------------------------------------------------------------------------
//More Effective C++ 8.2 申明一个函数为虚并不意味着它没有实现，它意味着：
//(1)当前类是抽象类
//(2)任何从此类派生的实体类必须将此函数申明为一个“普通”的虚函数（也就是说，不能带“= 0”）
//是的，绝大部分纯虚函数都没有实现，但纯虚析构函数是个特例。它们必须被实现，因为它们在派生类析构函数被调用时也将被调用。而且，它们经常执行有用的任务，诸如释放资源（见Item M9）或纪录消息。实现纯虚函数一般不常见，但对纯虚析构函数，它不只是常见，它是必须。

//需要通过公有继承将两个实体类联系起来，通常表示需要一个新的抽象类。
//否则会有这些问题：
//(1)从已存在的实体类派生出你的实体类，并容忍我们在本Item开始时说到的赋值问题。你还要注意在Item M3中说过的数组问题。
//(2)试图在类库的继承树的更高处找到一个完成了你所需的大部分功能的抽象类，从它进行继承。当然，可能没有合适的类；即使有，你可能不得不重复很多已经在（你试图扩展的）实体类中实现了的东西。
//(3)用包容你试图继承的类的方法来实现你的新类，这种方法需要你在类库每次升级时也要更新你自己的类。它还需要你放弃重定义类库中的类的虚函数的能力，因为你用的不是继承。
//(4)使用你得到。使用类库中的类，而将你自己的程序修改得那个类适用。用非成员函数来提供扩展功能（那些你想加入那个类而没有做到的）。结果，程序将不如你所期望中的清晰、高效、可维护、可扩展，但至少它完成了你所需要的功能。
//------------------------------------------------------------------------------------------------
//More Effective C++ 8.3 同一程序中混合使用C++和C
//可以给C++的函数加上extern "C"来禁止名称变换
//这样使用extern "C"简化了维护那些必须同时供C++和C使用的头文件的工作。当用C++编译时，你应该加extern "C"，但用C编译时，不应该这样。通过只在C++编译器下定义的宏__cplusplus，你可以将头文件组织得这样：
#ifdef __cplusplus
extern "C" {
#endif
  void drawLine(int x1, int y1, int x2, int y2);
  void twiddleBits(unsigned char bits);
  void simulate(int iterations);
#ifdef __cplusplus
}
#endif
//------------------------------------------------------------------------------------------------
//More Effective C++ 8.4
//注意在begin和end上的操作，只有“不等于”比较、反引用、前缀自增（参见More Effective C++ Item M6）、拷贝（对函数返回值进行的，参见More Effective C++ Item M19）
//------------------------------------------------------------------------------------------------
//auto_ptr的几个成员函数实现
#include <iostream>
#include <memory>
using namespace std;

class B
{
public:
	B()
	{
		cout << "B()" << endl;
	}
	~B()
	{
		cout << "~B()" << endl;
	}
};

void main()
{
	auto_ptr<int> p(new int(3));
	cout << p.operator->() << endl;
	cout << p.get() << endl;
	int *ptr = p.release();
	cout << ptr << endl;
	delete ptr;

	auto_ptr<B> pToB(new B());
	pToB.release();//这里不会释放动态申请的内存，当调用release时，必须用一个指针作为返回值，再delete掉这个指针

	B* rawPtrToB(new B());
	auto_ptr<B> pToB2(rawPtrToB);
	pToB2.reset(rawPtrToB);
}
//--More Effective C++ 9.2 一个auto_ptr的实现，这是简化版的实现，更具体可以参考标准C++库auto_ptr的实现
//标准auto_ptr位于名字空间std中（见Item M35）并且其成员函数承诺不抛任何异常。
template<class T>
class auto_ptr {
public:
  explicit auto_ptr(T *p = 0);              // Item M5 有"explicitfor"的描述
  template<class U>                         // 拷贝构造函数成员模板
  auto_ptr(auto_ptr<U>& rhs);               //  （见Item M28）：
                                            // 用另一个类型兼容的
                                            // auto_ptr对象
                                            // 初始化一个新的auto_ptr对象
  ~auto_ptr();
  template<class U>                         // 赋值操作成员模板
  auto_ptr<T>&                              // （见Item M28）：
  operator=(auto_ptr<U>& rhs);              // 用另一个类型兼容的
                                            // auto_ptr对象给它赋值
  T& operator*() const;                     // 见Item M28
  T* operator->() const;                    // 见Item M28
  T* get() const;                           // 返回包容指针的
                                            // 当前值
  T* release();                             // 放弃包容指针的
                                            // 所有权，
                                            // 并返回其当前值
  void reset(T *p = 0);                     // 删除包容指针，
                                            // 获得指针p的所有权
private:
  T *pointee;
template<class U>                           // 让所有的auto_ptr类
friend class auto_ptr<U>;                   // 成为友元
};

template<class T>
inline auto_ptr<T>::auto_ptr(T *p)
: pointee(p)
{}

template<class T>
  inline auto_ptr<T>::auto_ptr(auto_ptr<U>& rhs)
  : pointee(rhs.release())
  {}

template<class T>
inline auto_ptr<T>::~auto_ptr()
{ delete pointee; }

template<class T>
  template<class U>
  inline auto_ptr<T>& auto_ptr<T>::operator=(auto_ptr<U>& rhs)
  {
    if (this != &rhs) reset(rhs.release());
    return *this;
  }

template<class T>
inline T& auto_ptr<T>::operator*() const
{ return *pointee; }

template<class T>
inline T* auto_ptr<T>::operator->() const
{ return pointee; }

template<class T>
inline T* auto_ptr<T>::get() const
{ return pointee; }

template<class T>
inline T* auto_ptr<T>::release()
{
  T *oldPointee = pointee;
  pointee = 0;
  return oldPointee;
}

template<class T>
inline void auto_ptr<T>::reset(T *p)
{
  if (pointee != p) {
    delete pointee;
    pointee = p;
  }
}

//这是所有函数定义在类定义体内的auto_ptr模板。如你所见，它不会搞乱大脑：
template<class T>
class auto_ptr {
public:
  explicit auto_ptr(T *p = 0): pointee(p) {}
  template<class U>
  auto_ptr(auto_ptr<U>& rhs): pointee(rhs.release()) {}
  ~auto_ptr() { delete pointee; }
  template<class U>
  auto_ptr<T>& operator=(auto_ptr<U>& rhs)
  {
    if (this != &rhs) reset(rhs.release());
    return *this;
  }
  T& operator*() const { return *pointee; }
  T* operator->() const { return pointee; }
  T* get() const { return pointee; }
  T* release()
  {
    T *oldPointee = pointee;
    pointee = 0;
    return oldPointee;
  }
  void reset(T *p = 0)
  {
    if (pointee != p) {
      delete pointee;
      pointee = p;
    }
  }
  private:
    T *pointee;
  template<class U> friend class auto_ptr<U>;
  };
//------------------------------------------------------------------------------------------------
//禁止在堆中产生对象，More Effective C++ 9.3/7.3，计数基类如果设为virtual析构函数，就会增加开销，如果不设为virtual，则当客户调用B *p = new D();	delete p;时，就会出现内存泄漏，所以根本办法是禁止客户调用在堆中建立B对象
//在7.3中指出，最好把operator new和operator delete都声明为private，如果只声明一个operator new，会看起来不那么完整
//另外，单声明一个operator delete为private也可以满足要求，因为new操作中会先调用operator new分配内存，然后调用对象的构造函数来构造对象，但是如果这时候构造函数抛出异常，则会在new中调用operator delete删除分配的内存，所以operator delete声明为private之后，new操作也无法访问了，编译同样不通过
#include <iostream>
using namespace std;

class B
{
public:
	B()
	{
		cout << "B()" << endl;
	}
	virtual ~B() = 0
	{
		cout << "~B()" << endl;
	}
private:
	void operator delete(void *);
};

class D: public B
{

};

void main()
{
	B *p = new D();
	delete p;
}
//------------------------------------------------------------------------------------------------
//千万别惹程序员。。。四个0算24，算数运算(0! + 0! + 0! + 0!)! = 24
#include <iostream>
using namespace std;

void main()
{
	cout << '0'/(('0' + '0') / '0') << endl;//ANSI码中'0' == 48
	
	int result = ('0'>>'0'/'0' + 0);//48右移一位相当于除以2
	cout << result << endl;
	
	int oneNum = 0xffffffff;//~0，按位取反~0 == -1
	cout << oneNum << endl;
	int secNum = 0xfffffffe;//~1，按位取反~1 == -2，依次类推
	cout << secNum << endl;
	cout << -~-~-~-~-~-~0 << endl;
	cout << -~-~-~-~-~-~0-~-~-~-~-~-~0-~-~-~-~-~-~0-~-~-~-~-~-~0 << endl;
}
//------------------------------------------------------------------------------------------------
//More Effective C++ 9.3 计数类
//请注意它并没有 nonstatic data members，意味每一个型别为  Counter 的 object 其实没有内含任何东西。也许我们会以为每一个型别为 Counter 的 object，大小为 0？也许吧，但那并不正确。在这一点上，C++ 的表现相当清楚。所有 objects 都有至少 1 byte 的大小，甚至即使这些 objects 没有任何 nonstatic data members。
#include <iostream>
using namespace std;

template<typename T>
class Counter {
public:
	//Counter(){}
	//Counter(const Counter&){}
	//~Counter(){}
	static size_t howMany();
private:
	static size_t count;
};

void main()
{
	Counter<int> a;
	cout << sizeof(a) << endl;
}
//--将基类声明为private继承，则无法声明派生类指针对象再赋给基类指针
class Widget: private Counter<Widget>
{ ... };
Counter<Widget> *pw =
    new Widget;  // 错误! 没有隐式转换函式（implicit conversion）可以 
                 // 将 Widget* 转为 Counter<Widget>*
//此外，我们很开心地发现，以 Counter 做为 base class，并不会增加 Widget 的大小 ─ 如果和 Widget 独立个体的大小相比的话。是的，我知道我才刚刚告诉过你，没有任何 class 的大小为 0，但是 ─ 唔，那并不是我真正的意思。 我的真正意思是，没有任何一个 objects 的大小为 0。C++ 标准规格说得很清楚，一个 derived object 之中的「base-class 成份」的大小可以是 0。事实上，许多编译器都发展出所谓的「空白基础类别最佳化技术」（empty base optimization） [注4]。
//因此，如果一个 Widget 内含一个 Counter，Widget 的大小一定会增加。因为 Counter 的 data member 完全属於自己，而不是别人的base-class 成份，因此它必须有非零大小。但如果 Widget 继承自 Counter，编译器便得以将 Widget 的大小保持在原先状态。这个事实为那些「记忆体使用状态非常紧绷而类别设计中涉及空白基础类别」的设计，提出了一个有趣的规则：当「private 继承」和「复合技术（containment, composition）」都能完成相同目的时，尽量选用「private 继承」。（译注：这一点乍见之下和 Scott Meyers 的《Effective C++ 2/e》条款42有所抵触。该条款最後一段建议大家，如果「private 继承」和「复合技术」都能完成相同目的，尽量选用复合技术。然而请你注意，本文所给的这个建议是有前提的。）
//--私有继承实现计数类
template<typename T>
class Counter {
public:
    Counter() { ++count; }
    Counter(const Counter&) { ++count; }
    ~Counter() { --count; }
    static size_t howMany()
    { return count; }
private:
    static size_t count;
};
template<typename T>
size_t
Counter<T>::count = 0; // 现在这一行可以放进表头档中了。

class Widget: private Counter<Widget> {
public:
    // 让 howMany 成为 public
    using Counter<Widget>::howMany; 
    ..... // Widget 的剩馀部份没有改变。
};
class ABCD: private Counter<ABCD> {
public:
    // 让 howMany 成为 public
    using Counter<ABCD>::howMany;
    ..... // ABCD 的剩馀部份没有改变。
};
//然而，继承机制的使用，会导致两个值得注意的情况。第一件事是模棱两可（ambiguity）。假设我们打算对 Widgets 计数，而我们希望让这个计数值供一般运用。一如先前所展示，我们令 Widget 继承自 Counter<Widget>，并令 Widget::howMany( ) 成为 public。 现在假设我们有一个 class SpecialWidget，以 public 方式继承自 Widget，我们希望提供给 SpecialWidget 使用者一如 Widget 使用者所能享受的机能。没问题，只需令 SpecialWidget 继承自 Counter<SpecialWidget> 即可。
//但这里出现了模棱两可（ambiguity）的问题。哪一个 howMany( ) 对 SpecialWidget 而言才是可用的呢？是继承自 Widget 的那个，或是继承自 Counter<SpecialWidget> 的那个？我们所希望的，当然是来自 Counter<SpecialWidget> 的那个，但是我们没办法在未明确写出 SpecialWidget::howMany( ) 的情况下说出我们的心愿。幸运的是，它只是一个简单的 inline 函式：
class SpecialWidget: public Widget,
                  private Counter<SpecialWidget> {
public:
    .....
    static size_t howMany()
    { return Counter<SpecialWidget>::howMany(); }
    .....
};
//关於「使用继承机制来完成物件计数工作」的第二个意见是，Widget::howMany( ) 传回的值不只包括 Widget objects 的个数，也包括 Widget 衍生类别所产生的 objects。如果 Widget 的唯一衍生类别是 SpecialWidget，而一共有五个 Widget 独立物件和三个 SpecialWidgets独立物件，那麽 Widget::howMany( ) 将传回 8。毕竟，每一个 SpecialWidget 的建构，也同时会完成其基础类别（Widget 成份）的建构。
//四点注意：
//(1)物件计数工作的自动化并不困难，但也并非直观想像中的那麽简单。运用 "Do It For Me" pattern（Coplien 所谓的 "curiously recurring template pattern"）便有可能产生正确数量的计数器。运用 private 继承机制，可以提供物件计数能力，而又不扩张物件的大小。 
//(2)当客端有机会选择「继承自一个 empty class」或「内含某个 class object 做为 data member」时，继承是比较好的选择，因为它允许更紧密的物件。 
//(3)由於 C++ 尽一切努力要在 heap objects 建构动作失败时避免发生记忆体漏洞（memory leaks），所以凡是需要用到 operator new 之程式码，通常也需要用到对应的 operator delete。 
//(4)Counter class template 并不在乎你是否继承它，或内含它的一个 object。它看起来都一样。因此，客端可以自由选择使用「继承机制」或「复合（组合）技术」，甚至在同一个应用程式或程式库的不同地点使用不同的策略。 
//------------------------------------------------------------------------------------------------
//More Effective C++ 9.3 sidebar : Placement new 与 placement delete
//operator new 的正常标记（signature）是：
void * operator new(size_t) throw (std::bad_alloc);
//operator new 的重载版本只能增加新叁数，所以一个 operator new 重载版本可能长这个样子：
void * operator new(size_t, void *whereToPutObject)
{ return whereToPutObject; }
//随着时间过去，任何「要求额外引数」的 operator new 版本，也都渐渐采用 placement new 这个术语。事实上这个术语已经被铭记於 C++ 标准规格中。因此，当 C++ 程序员谈到所谓的 placement new 函式，他们所谈的可能是上述那个「需要额外一个 void* 叁数，用以指出物件置於何处」的版本，但也可能是指那些「所需引数比单一而必要之 size_t 引数更多」的任何 operator new 版本，包括上述函式，也包括其他「引数更多」的 operator new 函式。
//换句话说，当我们把焦点集中在记忆体配置时，"placement new" 意味「operator new 的某个版本，接受额外引数」。这个术语在其他场合可能有其他意义，但我们不需继续深入，所以，到此为止。

//和 placement new 类似，术语 "placement delete" 意味「operator delete 的某个版本，接受额外引数」。operator delete 的「正常」标记如下：
void operator delete(void*);
//所以，任何版本的 operator delete，只要接受的引数多於上述的 void*，就是一个 placement delete 函式。
//------------------------------------------------------------------------------------------------
//More Effective C++ 9.4 成员函数指针的原始使用
#include <iostream>
using namespace std;

class test
{
public:
	void show()
	{
		cout << "test show" << endl;
	}
};

void main()
{
	void (test::*pToShow)() = &test::show;
	
	test t = test();
	(t.*pToShow)();

	test *p = new test();
	(p->*pToShow)();
	delete p;
	
	//pc->*pmf();   // 错误！
	//视为： 
	//pc->*(pmf()); // 错误！

}
//------------------------------------------------------------------------------------------------
//Effective STL 条款2
//既然有了要一次次的改变容器类型的必然性，你可以用这个常用的方法让改变得以简化：使用封装，封装，再封装。其中一种最简单的方法是通过自由地对容器和迭代器类型使用typedef。因此，不要这么写: 
class Widget {...};
vector<Widget> vw;
Widget bestWidget;
...					// 给bestWidget一个值
vector<Widget>::iterator i =		// 寻找和bestWidget相等的Widget
	find(vw.begin(), vw.end(), bestWidget);
//要这么写：
class Widget { ... };
typedef vector<Widget> WidgetContainer;
typedef WidgetContainer::iterator WCIterator;
WidgetContainer cw;
Widget bestWidget;
...
WCIterator i = find(cw.begin(), cw.end(), bestWidget);
//这是改变容器类型变得容易得多，如果问题的改变是简单的加上用户的allocator时特别方便。（一个不影响对迭代器/指针/参考的失效规则的改变）
class Widget { ... };
template<typename T>					// 关于为什么这里需要一个template
SpecialAllocator { ... };					// 请参见条款10
typedef vector<Widget, SpecialAllocator<Widget> > WidgetContainer;
typedef WidgetContainer::iterator WCIterator;
WidgetContainer cw;					// 仍然能用 
Widget bestWidget;
...
WCIterator i = find(cw.begin(), cw.end(), bestWidget);	// 仍然能用
//--如果typedef带来的代码封装作用对你来说没有任何意义的话，你仍然会称赞它们可以节省许多工作。比如，你有一个如下类型的对象
map<string,	vectorWidget>::iterator, CIStringCompare>		// CIStringCompare是“忽略大小写的字符串比较”
					// 参见条款19
//而且你要用const_iterator遍历这个map，你真的想不止一次地写下
map<string, vectorWidget>::iterator, CIStringCompare>::const_iterator

//--对容器的类封装，可以将泛型算法作为public接口提供给用户，这样用户只需要调用接口就可以了，不用每次自己调用泛型算法，而且当类内的容器类型改变时，只要接口不变，就可以使它对用户的影响最小
//typedef只是其它类型的同义字，所以它提供的的封装是纯的词法（译注：不像#define是在预编译阶段替换的）。typedef并不能阻止用户使用（或依赖）任何他们不应该用的（或依赖的）。如果你不想暴露出用户对你所决定使用的容器的类型，你需要更大的火力，那就是class。
//要限制如果用一个容器类型替换了另一个容器可能需要修改的代码，就需要在类中隐藏那个容器，而且要通过类的接口限制容器特殊信息可见性的数量。比如，如果你需要建立一个客户列表，请不要直接用list。取而代之的是，建立一个CustomerList类，把list隐藏在它的private区域：
class CustomerList {
private:
	typedef list<Customer> CustomerContainer;
	typedef CustomerContainer::iterator CCIterator;
	CustomerContainer customers;
public:			// 通过这个接口
	...			// 限制list特殊信息的可见性
};
//一开始，这样做可能有些无聊。毕竟一个CustomerList是一个list，对吗？哦，可能是。稍后你可能发现从列表的中部插入和删除客户并不像你想象的那么频繁，但你真的需要快速确定客户列表顶部的20%――一个为nth_element算法量身定做的任务（参见条款31）。但nth_element需要随机访问迭代器，不能兼容list。在这种情况下，你的客户“list”可能更应该用vector或deque来实现。
//当你决定作这种更改的时候，你仍然必须检查每个CustomerList的成员函数和每个友元，看看他们受影响的程度（根据性能和迭代器/指针/引用失效的情况等等），但如果你做好了对CustomerList地实现细节做好封装的话，那对CustomerList的客户的影响将会很小。你写不出容器无关性代码，但他们可能可以。
//------------------------------------------------------------------------------------------------
//对reverse_iterator迭代器调用.base()函数可以得到对应的iterator，以进行各类算法的iterator要求 Effective STL 条款28/C++ Primer p355
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;

struct myGenerate
{
	myGenerate(int i = 0): i_(i){}
	int operator()()
	{
		return ++i_;
	}
	int i_;
};

void main()
{
	vector<int> vecInt(10);
	generate(vecInt.begin(), vecInt.end(), myGenerate());
	ostream_iterator<int> out(cout, " ");
	copy(find(vecInt.begin(), vecInt.end(), 3), find(vecInt.rbegin(), vecInt.rend(), 7).base(), out);
	cout << endl;
	vector<int>::reverse_iterator ri = find(vecInt.rbegin(), vecInt.rend(), 3);		// 同上，ri指向3
	vecInt.erase(--ri.base());				// 尝试删除ri.base()前面的元素，对于vector，一般来说编译不通过，但是vs2010可以编译过。。。
	copy(vecInt.begin(), vecInt.end(), out);
	cout << endl;
	//cout << *ri << endl;//这里编译不过，因为ri所指向的元素已经被删掉了
	ri = vecInt.rbegin();
	vecInt.erase((++ri).base());//删除reverse_iterator所指对象最好用这种方法
	copy(vecInt.begin(), vecInt.end(), out);
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款5：尽量使用区间成员函数代替它们的单元素兄弟
//(1)从直观上来说：输入代码少，更清晰
//(2)从性能上来说：如果以vector的begin()插入来说，少调用n-1次insert成员函数；少元素移动（这里包括赋值操作和一次拷贝构造）；少超出capacity时新内存申请，元素复制，旧元素析构，旧内存回收
//两个vector容器v1,v2，把v2的后面一半对象复制给v1
v1.assign(v2.begin() + v2.size()/2, v2.end());

//循环的写法
vector<Widget> v1, v2;		// 假设v1和v2是Widget的vector
v1.clear();
for (vector<Widget>::const_iterator ci = v2.begin() + v2.size() / 2; ci != v2.end();	++ci)
	v1.push_back(*ci);
//copy算法，实际也是循环
v1.clear();
copy(v2.begin() + v2.size() / 2, v2.end(), back_inserter(v1));
//在这里，我要离题一下来指出几乎所有目标区间是通过插入迭代器（比如，通过inserter，back_inserter或front_inserter）指定的copy的使用都可以――应该――通过调用区间成员函数来代替。比如这里，这个copy的调用可以用一个insert的区间版本代替：
v1.clear();
v1.insert(v1.end(), v2.begin() + v2.size() / 2, v2.end());
//这个输入量稍微比调用copy少，但它发生的也比说的要直接：数据插入v1。调用copy也表达了那个意思，但没那么直接。这把重点放到了错误的地方。对于发生了什么的关注点不应该是元素被拷贝，而是有新的数据加入v1。insert成员函数使这变得清晰了。copy的使用把它变得晦涩。关于东西被拷贝这个事实并没有什么好关注的，因为STL构建在东西会被拷贝的假定上。
//太多的STL程序员过度使用copy，所以我重复一遍我的建议：几乎所有目标区间被插入迭代器指定的copy的使用都可以用调用的区间成员函数的来代替。
//------------------------------------------------------------------------------------------------
//Effective STL 条款6：警惕C++最令人恼怒的解析
ifstream dataFile("ints.dat");
list<int> data(istream_iterator<int>(dataFile),	// 警告！这完成的并不
		istream_iterator<int>());		// 是像你想象的那样
//我们会从最基本的开始。这行声明了一个函数f带有一个double而且返回一个int：
int f(double d);
//第二行作了同样的事情。名为d的参数左右的括号是多余的，被忽略：
int f(double (d));	// 同上；d左右的括号被忽略下面这行声明了同样的函数。它只是省略了参数名：
int f(double);		// 同上；参数名被省略		
		
//现在让我们再看看三个函数声明。第一个声明了一个函数g，它带有一个参数，那个参数是指向一个没有参数、返回double的函数的指针：
int g(double (*pf)());	// g带有一个指向函数的指针作为参数这是完成同一件事的另一种方式。唯一的不同是pf使用非指针语法来声明（一个在C和C++中都有效的语法）：
int g(double pf());	// 同上；pf其实是一个指针照常，参数名可以省略，所以这是g的第三种声明，去掉了pf这个名字：
int g(double ());		//同上；参数名省略注意参数名左右的括号（就像f的第二种声明中的d）和单独的括号（正如本例）之间的区别。参数名左右的括号被忽略，但单独的括号指出存在一个参数列表：它们声明了存在指向函数的指针的参数。

//但这符合C++里的一条通用规则――几乎任何东西都可能被分析成函数声明。
class Widget {...};	// 假设Widget有默认构造函数
Widget w();		// 嗯哦……

//解决方法
//用括号包围一个实参的声明是不合法的，但用括号包围一个函数调用的观点是合法的，所以通过增加一对括号，我们强迫编译器以我们的方式看事情：
list<int> data((istream_iterator<int>(dataFile)), 	// 注意在list构造函数
			istream_iterator<int>());	// 的第一个实参左右的
						// 新括号
//这是可能的声明数据方法，给予istream_iterators的实用性和区间构造函数（再次，参见条款5），值得知道它是怎样完成的。

//例如将cin作为流迭代器的输入参数
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;

void main()
{
	//istream_iterator<int> in(cin);
	//istream_iterator<int> eof;
	vector<int> vecInt((istream_iterator<int>(cin)), istream_iterator<int>());//这里的第一个参数必须加小括号
	copy(vecInt.begin(), vecInt.end(), ostream_iterator<int>(cout, " "));
}

//一个更好的解决办法是在数据声明中从时髦地使用匿名istream_iterator对象后退一步，仅仅给那些迭代器名字。以下代码到哪里都能工作：
ifstream dataFile("ints.dat");
istream_iterator<int> dataBegin(dataFile);
istream_iterator<int> dataEnd;
list<int> data(dataBegin, dataEnd);
//------------------------------------------------------------------------------------------------
//Effective STL 条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针
void doSomething()
{
	vector<Widget*> vwp;
	for (int i = 0; i < SOME_MAGIC_NUMBER; ++i)
		vwp.push_back(new Widget);
							// 使用vwp
}						// Widgets在这里泄漏！

//可以这样删除指针
void doSomething() 
{
	vector<Widget*> vwp;
	... // 同上
	for (vector<Widget*>::iterator i = vwp.begin();
			i != vwp.end(),
			++i) { 
		delete *i;//这里只是调用对象的析构函数，该指针对象所指的内容无效，但是指针还在容器中，等容器出作用域就会自动删除为这些指针申请的内存
	} 
}

//这可以工作，除非你不是对你“工作”的意思很吹毛求疵。一个问题是新的for循环代码比for_each多得多，但没有使用for_each来的清楚（参见条款43）。另一个问题是这段代码不是异常安全的。如果在用指针填充了vwp和你要删除它们之间抛出了一个异常，你会再次资源泄漏。幸运的是，两个问题都可以克服。

//要把你的类似for_each的循环转化为真正使用for_each，你需要把delete转入一个函数对象中。这像儿戏般简单，假设你有一个喜欢和STL一起玩的孩子：

template<typename T>
struct DeleteObject :				// 条款40描述了为什么
	public unary_function<const T*, void> {	// 这里有这个继承
	void operator()(const T* ptr) const
	{
		delete ptr;
	}
};
//现在你可以这么做：

void doSomething()
{
	...	// 同上
	for_each(vwp.begin(), vwp.end(), DeleteObject<Widget>);
}

//可以通过编译器推断传给DeleteObject::operator()的指针的类型来消除这个错误（也减少DeleteObject的用户需要的击键次数）。我们需要做的所有的事就是把模板化从DeleteObject移到它的operator()：

struct DeleteObject {				// 删除这里的
						// 模板化和基类
	template<typename T> 			// 模板化加在这里
	void operator()(const T* ptr) const 
	{ 
		delete ptr; 
	} 
}
//编译器知道传给DeleteObject::operator()的指针的类型，所以我们可以让它通过指针的类型自动实例化一个operator()。这种类型演绎下降让我们放弃使DeleteObject可适配的能力（参见条款40）。想想DeleteObject的设计目的，会很难想象那会是一个问题。

//使用新版DeleteObject，用于SpecialString的客户代码看起来像这样：

void doSomething()
{
	deque<SpecialString*> dssp;
	...
	for_each(dssp.begin(), dssp.end(),
		DeleteObject());			// 啊！良好定义的行为！
}
//直截了当而且类型安全，正如我们喜欢的一样。

//但仍不是异常安全的。如果在SpecialString被new但在调用for_each之前抛出一个异常，就会发生泄漏。那个问题可以以多种方式被解决，但最简单的可能是用智能指针的容器来代替指针的容器，典型的是引用计数指针
//幸运的是，基本上不需要你自己写，因为经过检验的实现不难找到。一个这样的智能指针是Boost库（参见条款50）中的shared_ptr。利用Boost的shared_ptr，本条款的原始例子可以重写为这样：
void doSomething()
{
	typedef boost::shared_ptr<Widget> SPW;	//SPW = "shared_ptr
						// to Widget"
	vector<SPW> vwp;
	for (int i = 0; i < SOME_MAGIC_NUMBER; ++i)
		vwp.push_back(SPW(new Widget));	// 从一个Widget建立SPW,
						// 然后进行一次push_back
		...			// 使用vwp
}					// 这里没有Widget泄漏，甚至
					// 在上面代码中抛出异常
//你不能有的愚蠢思想是你可以通过建立auto_ptr的容器来形成可以自动删除的指针。那是很可怕的想法，非常危险。我在条款8讨论了为什么你应该避免它。
//------------------------------------------------------------------------------------------------
//Effective STL 条款13：尽量使用vector和string来代替动态分配的数组
//string的引用计数功能会带来多线程性能问题？什么性能问题呢？
//------------------------------------------------------------------------------------------------
//Effective STL 条款16: 如何将vector和string的数据传给遗留的API
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void show(const int *p, int num)
{
	for (int *temp = p; temp != p + num; ++temp)
	{
		cout << *temp << endl;
	}
}
//对于vector
void main()
{
	vector<int> vecInt(10);//vector的对象保证储存在一块连续的内存中
	fill(vecInt.begin(), vecInt.end(), 3);
	//最好加个判断条件if(!vecInt.empty())
	show(&vecInt[0], vecInt.size());//show(&*vecInt.begin(), vecInt.size())也可以，不过更晦涩难懂， 并且打更多代码	
}

//对于string
void doSomething(const char *pString);
//像这样：
doSomething(s.c_str());

//如果你想用C风格API返回的元素初始化一个vector，你可以利用vector和数组潜在的内存分布兼容性将存储vecotr的元素的空间传给API函数：
// C API：此函数需要一个指向数组的指针，数组最多有arraySize个double
// 而且会对数组写入数据。它返回写入的double数，不会大于arraySize
size_t fillArray(double *pArray, size_t arraySize);
vector<double> vd(maxNumDoubles);				// 建立一个vector，
							// 它的大小是maxNumDoubles
vd.resize(fillArray(&vd[0], vd.size()));			// 让fillArray把数据
							// 写入vd，然后调整vd的大小
							// 为fillArray写入的元素个数

//这个技巧只能工作于vector，因为只有vector承诺了与数组具有相同的潜在内存分布。但是，如果你想用来自C风格API的数据初始化string对象，也很简单。只要让API将数据放入一个vector<char>，然后从vector中将数据拷到string：
// C API：此函数需要一个指向数组的指针，数组最多有arraySize个char
// 而且会对数组写入数据。它返回写入的char数，不会大于arraySize
size_t fillString(char *pArray, size_t arraySize);
vector<char> vc(maxNumChars);				// 建立一个vector，
							// 它的大小是maxNumChars
size_t charsWritten = fillString(&vc[0], vc.size());		// 让fillString把数据写入vc
string s(vc.begin(), vc.begin()+charsWritten);		// 从vc通过范围构造函数
							// 拷贝数据到s（参见条款5）

//事实上，让C风格API把数据放入一个vector，然后拷到你实际想要的STL容器中的主意总是有效的： 
size_t fillArray(double *pArray, size_t arraySize);		// 同上
vector<double> vd(maxNumDoubles);				// 一样同上
vd.resize(fillArray(&vd[0], vd.size()));

deque<double> d(vd.begin(), vd.end());			// 拷贝数据到deque
list<double> l(vd.begin(), vd.end());			// 拷贝数据到list
set<double> s(vd.begin(), vd.end());				// 拷贝数据到set

//此外，这也提示了vector和string以外的STL容器如何将它们的数据传给C风格API。只要将容器的每个数据拷到vector，然后将它们传给API：
void doSomething(const int* pints, size_t numInts);		// C API (同上)
set<int> intSet;						// 保存要传递给API数据的set
vector<int> v(intSet.begin(), intSet.end());			// 拷贝set数据到vector
if (!v.empty()) doSomething(&v[0], v.size());			// 传递数据到API
//------------------------------------------------------------------------------------------------
//Effective STL 条款17：使用“交换技巧”来修整过剩容量
//用swap技术来消除过多的容量
//另外，交换技巧的变体可以用于清除容器和减少它的容量到你的实现提供的最小值
//string同样，string(s).swap(s)
//string().swap(s)
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void main()
{
	vector<int> vecInt;
	vecInt.reserve(1000);
	cout << vecInt.size() << endl;
	cout << vecInt.capacity() << endl;

	vecInt.insert(vecInt.end(), 100, 24);//fill_n(vecInt.begin(), 100, 24)不行，fill和generate都必须要求容器中已经构建好（空）对象了
	cout << vecInt.size() << endl;
	cout << vecInt.capacity() << endl;

	vector<int>(vecInt).swap(vecInt);//消除过剩容量
	cout << vecInt.size() << endl;
	cout << vecInt.capacity() << endl;
	
	vector<int>().swap(vecInt);//清除容器和减少容量到最小值
	cout << vecInt.size() << endl;
	cout << vecInt.capacity() << endl;
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款18：避免使用vector<bool>
//bool值保存成bit，而不是byte，所以为了满足operator[]返回一个引用的要求，vector<bool>内部用一个代理类，关于代理对象的信息，参考《More Effective C++》的条款30，还有Gamma等人的《设计模式》[6]中的“Proxy”章节。）
//vector<bool>的两个替代品，deque<bool>和bitset
#include <iostream>
#include <vector>
using namespace std;

void main()
{
	vector<bool> boolVec;
	boolVec.push_back(1);
	boolVec.push_back(0);
	cout << boolVec.back() << endl;
	bool *p = &boolVec[0];//错误！右边的表达式是vector<bool>::reference*类型，不是bool*
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase
//只有容器的成员函数可以删除元素，remove并不“真的”删除东西，因为它做不到，它不知道容器的类型
//正如条款33所解释的，事实上当remove在删除时覆盖的值是指针时，会有重要的影响。但是对于本条款，知道remove不从容器中除去任何元素因为它做不到就够了。只有容器成员函数可以除去容器元素，而那是本条款的整个要点：如果你真的要删除东西的话，你应该在remove后面接上erase。
//你要erase的元素很容易识别。它们是从区间的“新逻辑终点”开始持续到区间真的终点的原来区间的元素。要除去那些元素，你要做的所有事情就是用那两个迭代器调用erase的区间形式（参见条款5）。因为remove本身很方便地返回了区间新逻辑终点的迭代器，这个调用很直截了当：
vector<int> v;						// 正如从前
v.erase(remove(v.begin(), v.end(), 99), v.end());		// 真的删除所有
							// 等于99的元素
cout << v.size();						// 现在返回7
//一旦你知道了remove不能“真的”从一个容器中删除东西，和erase联合使用就变成理所当然了。你要记住的唯一其他的东西是remove不是唯一这种情况的算法。另外有两种“类似remove”的算法：remove_if和unique。
//remove和remove_if之间的相似性很直截了当。所以我不会细讲，但unique行为也像remove。它用来从一个区间删除东西（邻近的重复值）而不用访问持有区间元素的容器。结果，如果你真的要从容器中删除元素，你也必须成对调用unique和erase，unique在list中也类似于remove。正像list::remove真的删除东西（而且比erase-remove惯用法高效得多）。list::unique也真的删除邻近的重复值（也比erase-unique高效）。
//------------------------------------------------------------------------------------------------
//Effective STL 条款33：提防在指针的容器上使用类似remove的算法
//remove算法通过类似填洞的方法将后面的元素值赋给前面的元素，所以当指针作为容器对象时，调用remove只会将后面的对象地址赋给前面的指针，导致前面的指针所指对象丢失，更可能造成内存泄漏
//现在你也很清楚为什么应该努力避免在动态分配的指针的容器上使用remove和类似算法（也就是，remove_if和unique）。在很多情况下，你会发现partition算法（参见条款31）是合理的替代品。

//如果你无法避免在那样的容器上使用remove，排除这个问题一种方法是在应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针：
void delAndNullifyUncertified(Widget*& pWidget)		// 如果*pWidget是一个
{							// 未通过检验Widget，
	if (!pWidget->isCertified()) {			// 删除指针
		delete pWidget;				// 并且设置它为空
		pWidget = 0;
	}
}

for_each(v.begin(), v.end(),			// 把所有指向未通过检验Widget的
			delAndNullifyUncertified);	// 指针删除并且设置为空

v.erase(remove(v.begin(), v.end(),			// 从v中除去空指针
			static_cast<Widget*>(0)),	// 0必须映射到一个指针，
			v.end());			// 让C++可以
						// 正确地推出remove的
						// 第三个参数的类型
//当然，这假设vector并不容纳任何你想保留的空指针。如果有的话，你可能必须自己写循环来按你的方式删除指针。在你遍历容器时从容器中删除元素有一些细微的要注意的地方，在考虑那种方法之前确定已经读过条款9。

//如果你把指针的容器替换成执行引用计数的智能指针的容器，删除相关的困难就不存在了，你可以直接使用erase-remove惯用法：
template<typename T>					// RCSP = “引用计数
class RCSP { ...};						// 智能指针”
typedef RCSP< Widget> RCSPW;				// RCSPW = “RCSP to Widget”
vector<RCSPW > v;						// 建立一个vector，用动态
...							// 分配Widget的
v.push_back(RCSPW(new Widget));				// 智能指针填充它
...
v.erase(remove_if(v.begin(), v.end(),			// erase未通过检验的
		not1 (mem_fun(&Widget::isCertified))),	// Widget的指针
			v.end());				// 没有资源泄漏
//要让这些工作，你的智能指针类型就必须可以（比如RCSP<Widget>）隐式转换为相应的内建指针类型（比如Widget*）。那是因为容器持有智能指针，但被调用的成员函数（比如Widget::isCertified）要的是内建指针。如果不存在隐式转换，你的编译器会抗议的。
//如果在你的程序工具箱中碰巧没有一个引用计数智能指针模板，你应该从Boost库中得到shared_ptr模板。关于Boost的介绍，请看条款50。
//
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;
using namespace std::tr1;

class MyClass
{
public:
	MyClass(int i): i_(i){}
	bool isEven() const
	{
		return i_%2 == 0;
	}
	void show()
	{
		cout << i_ << endl;
	}
	int get() const
	{
		return i_;
	}
private:
	int i_;
};

struct MyFun1
{
	void operator()(shared_ptr<MyClass>& p) const
	{
		p->show();
	}
};

struct MyFun2
{
	int operator()(shared_ptr<MyClass>& p) const
	{
		return p->get();
	}
};

void main()
{
	vector< shared_ptr<MyClass> > myClassPtrVec;
	for (int i = 0; i < 10; ++i)
	{
		myClassPtrVec.push_back(shared_ptr<MyClass>(new MyClass(i)));
	}
	//for_each(myClassPtrVec.begin(), myClassPtrVec.end(), MyFun1());
	myClassPtrVec.erase(remove(myClassPtrVec.begin(), myClassPtrVec.end(), &MyClass::isEven), myClassPtrVec.end());//这行通不过编译，无法从shared_ptr<MyClass>转换成MyClass*指针对象，怎么做？？？（当前只知道的是适配成员函数的mem_fun和mem_fun_ref，要求迭代器解引用的对象为类对象和类指针对象，而不是智能指针对象）
	transform(myClassPtrVec.begin(), myClassPtrVec.end(), ostream_iterator<int>(cout, "\n"), MyFun2());
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款34：注意哪个算法需要有序区间
//只能操作有序数据的算法的表：
binary_search 
lower_bound 
upper_bound 
equal_range 
set_union 
set_intersection 
set_difference 
set_symmetric_difference 
merge 
inplace_merge 
includes   
//下面的算法一般用于有序区间，虽然它们不要求：
unique 
unique_copy 
//保证给定算法的排序顺序和区间的排序顺序相同
vector<int> v;					// 建立一个vector，
...						// 把一些数据放进去
sort(v.begin(), v.end(), greater<int>());		// 降序排列
...						// 使用这个vector
						// （没有改变它）
bool a5Exists =					// 在这个vector中搜索5
	binary_search(v.begin(), v.end(), 5);	// 假设它是升序排列！会导致未定义的结果

//要让代码行为正确，你必须告诉binary_search要使用和sort同样的比较函数：
bool a5Exists =							// 搜索5
	binary_search(v.begin(), v.end(), 5. greater<int>());		// 把greater作为
								// 比较函数
//所有需要有序区间的算法（也就是除了unique和unique_copy外本条款的所有算法）通过等价来判断两个值是否“相同”，就像标准关联容器（它们本身是有序的）。相反，unique和unique_copy判断两个对象“相同”的默认方式是通过相等，但是你可以通过传给这些算法一个定义了“相同”的意义的判断式来覆盖这个默认情况。等价和相等之间区别的详细讨论，参考条款19。
//------------------------------------------------------------------------------------------------
//Effective STL 条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较
//用算法mismatch实现
int ciCharCompare(char c1, char c2)			// 忽略大小写比较字符
{						// c1和c2，如果c1 < c2返回-1，
						// 如果c1==c2返回0，如果c1 > c2返回1
	int Ic1 = tolower(static_cast<unsigned char>(c1));// 这些语句的解释
	int Ic2 = tolower(static_cast<unsigned char>(c2));// 看下文

	if (Ic1 < Ic2) return -1;
	if (lc1 > Ic2) return 1;
	return 0;
}

//not2是传入二元参数的否定，not1是传入一元参数的否定，bind1，bind2
int ciStringCompareImpl(const string& si, const strings s2)
{
	typedef pair<string::const_iterator,			// PSCI = “pair of
			string::const_iterator> PSCI;	// string::const_iterator”
	PSCI p = mismatch(					// 下文解释了
			s1.begin(), s1.end(),		// 为什么我们
			s2.begin(),			// 需要not2；参见
			not2(ptr_fun(ciCharCompare)));	// 条款41解释了为什么
							// 我们需要ptr_fun
	if (p.first== s1.end()) {				// 如果为真，s1等于
		if (p.second == s2.end()) return 0;		// s2或s1比s2短
		else return -1;
	}
	return ciCharCompare(*p.first, *p.second);		// 两个字符串的关系
}	

int ciStringCompare(const string& s1, const string& s2)
{
	if (s1.size() <= s2.size()) return ciStringCompareImpl(s1, s2);
	else return -ciStringCompareImpl(s2, s1);
}
//幸运的是，注释把所有东西都弄清楚了。基本上，一旦你知道了字符串中第一个不同字符的位置，就可以很容易决定哪个字符串, 如果有的话，在另一个前面。唯一可能感到奇怪的是传给mismatch的判断式，也就是not2(ptr_fun(ciCharCompare))。当字符匹配时这个判断式返回true，因为当判断式返回false时mismatch会停止。我们不能为此使用ciCharCompare，因为它返回-1、1或0，而当字符匹配时它返回0，就像strcmp。如果我们把ciCharCompare作为判断式传给mismatch，C++会把ciCharCompare的返回类型转换为bool，而当然bool中零的等价物是false，正好和我们想要的相反！同样的，当ciCharCompare返回1或-1，那会被解释成true，因为，就像C，所有非零整数值都看作true。这再次和我们想要的相反。要修正这个语义倒置，我们在ciCharCompare前面放上not2和ptr_fun，而且我们都会一直很快乐地生活。

//用lexicographical_compare实现
bool ciCharLess(char c1, char c2)				// 返回在忽略大小写
{								// 的情况下c1是否
								// 在c2前面；
	tolower(static_cast<unsigned char>(c1)) < 		// 条款46解释了为什么
		tolower(static_cast<unsigned char>(c2));	// 一个函数对象可能
}								// 比函数好

bool ciStringCompare(const string& s1, const string& s2)
{
	return lexicographical_compare(s1.begin(), s1.end(),		// 关于这个
					s2.begin(), s2.end(),	// 算法调用的
					ciCharLess);		// 讨论在下文
}

//C++ library中的lexicogrphical_compare的例子，从第一个区间的每一个元素和第二个区间的对应元素比较，如果找到了第一个区间的元素<第二个区间的元素，则返回1；如果第一个区间先到头，则返回1；如果区间全都比较完了，两区间长度相等，则返回0，表示没找到；如果第二个区间先到头，则返回0。
// lexicographical_compare example
#include <iostream>
#include <algorithm>
#include <cctype>
using namespace std;

// a case-insensitive comparison function:
bool mycomp (char c1, char c2)
{ return tolower(c1)<tolower(c2); }

int main () {
	char first[]="Apartments";         // 5 letters
	char second[]="apartment";    // 9 letters

	cout << "Using default comparison (operator<): ";
	if (lexicographical_compare(first,first+10,second,second+9))
		cout << first << " is less than " << second << endl;
	else
		if (lexicographical_compare(second,second+9,first,first+10))
			cout << first << " is greater than " << second << endl;
		else
			cout << first << " and " << second << " are equivalent\n";

	cout << "Using mycomp as comparison object: ";
	if (lexicographical_compare(first,first+5,second,second+9,mycomp))
		cout << first << " is less than " << second << endl;
	else
		if (lexicographical_compare(second,second+9,first,first+5,mycomp))
			cout << first << " is greater than " << second << endl;
		else
			cout << first << " and " << second << " are equivalent\n";

	return 0;
}

//忽略大小写字符串比较函数作为对标准C库的非标准扩展而广泛存在，stricmp
#include <iostream>
#include <algorithm>
#include <cctype>
using namespace std;

int main () 
{
	string s1("abc");
	string s2("ABC");
	cout << _stricmp(s1.c_str(), s2.c_str()) << endl;
	return 0;
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款36：了解copy_if的正确实现
//有11个带copy的算法：
copy 
copy_backward 
replace_copy 
reverse_copy 
replace_copy_if 
unique_copy 
remove_copy 
rotate_copy 
remove_copy_if 
partial_sort_copy 
unintialized_copy   
//没有copy_if
//这是copy_if正确的微不足道的实现。知道为什么只是传函数名了，这里传的函数名作为函数指针传入的，在被调用函数里会调用这个函数指针
template<typename InputIterator,				// 一个copy_if的
			typename OutputIterator,		// 正确实现
			typename Predicate>
OutputIterator copy_if(InputIterator begin,
				InputIterator end,
				OutputIterator destBegin,
				Predicate p) {
	while (begin != end) {
		if (p(*begin))*destBegin++ = *begin;
		++begin;
	}
	return destBegin;
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款37：用accumulate或for_each来统计区间
//有时，你需要用一些自定义的方式统计（summarize）区间，而且在那些情况中，你需要比count、count_if、min_element或max_element更灵活的东西。比如，你可能想要对一个容器中的字符串长度求和。你可能想要数的区间的乘积。你可能想要point区间的平均坐标。在那些情况中，你需要统计一个区间，但你需要有定义你需要统计的东西的能力。没问题。STL为你准备了那样的算法，它叫作accumulate。你可能不熟悉accumulate，因为，不像大部分算法，它不存在于<algorithm>。取而代之的是，它和其他三个“数值算法”都在<numeric>中。（那三个其它的算法是inner_product、adjacent_difference和partial_sum。）
list<double> ld;						// 建立一个list，放
...							// 一些double进去
double sum = accumulate(ld.begin(), ld.end(), 0.0);		// 计算它们的和，
							// 从0.0开始，这里是0.0，如果是0，则结果会变成int

//accumulate只需要输入迭代器，所以你甚至可以使用istream_iterator和istreambuf_iterator（参见条款29）：
#include <iostream>
#include <numeric>
#include <iterator>
using namespace std;

int main () 
{
	cout << "The sum of the ints on the standard input is "	
		<< accumulate(istream_iterator<int>(cin), istream_iterator<int>(), 0);
}
//进行数值算法是accumulate的默认行为。但当使用accumulate的另一种形式，带有一个初始和值与一个任意的统计函数，这变得一般很多。
//比如，考虑怎么使用accumulate来计算容器中的字符串的长度和。要计算这个和，accumulate需要知道两个东西。第一，同上，它必须知道和的开始。在我们的例子中，它是0。第二，它必须知道每次看到一个新的字符串时怎么更新这个和。要完成这个任务，我们写一个函数，它带有目前的和与新的字符串，而且返回更新的和：
#include <iostream>
#include <numeric>
#include <iterator>
#include <string>
using namespace std;

string::size_type					// string::size_type的内容
	stringLengthSum(string::size_type sumSoFar,		// 请看下文
	const string& s)
{
	return sumSoFar + s.size();
}
int main () 
{
	cout << "The sum of the ints on the standard input is "	
		<< accumulate(istream_iterator<string>(cin), istream_iterator<string>(), 0, stringLengthSum);
}
//这个函数的函数体非常简单，但你可能发现自己陷于string::size_type的出现。不要那样。每个标准STL容器都有一个typedef叫做size_type，那是容器计量东西的类型。比如，这是容器的size函数的返回类型。对于所有的标准容器，size_type必须是size_t，但理论上非标准STL兼容的容器可能让size_type使用一个不同的类型（虽然我花了很多时间来想为什么它们要那么做）。对于标准容器，你可以把Container::size_type看作size_t写法的一个奇异方式。
set<string> ss;					// 建立字符串的容器，
...						// 进行一些操作
string::size_type lengthSum =			// 把lengthSum设为对
	accumulate(ss.begin(), ss.end(),		// ss中的每个元素调用
			0, stringLengthSum);	// stringLengthSum的结果，使用0
						// 作为初始统计值

//计算数值区间的积甚至更简单，因为我们不用写自己的求和函数。我们可以使用标准multiplies仿函数类：
vector<float> vf;					// 建立float的容器
...						// 进行一些操作
float product =					// 把product设为对vf
	accumulate(vf.begin(), vf.end(),		// 中的每个元素调用
			1.0f, multiplies<float>());	// multiplies<float>的结果，用1.0f
						// 作为初始统计值

//for_each算法返回一个函数对象，即传入的第三个参数类型是什么，返回一个什么类型的对象
//正如accumulate，for_each带有一个区间和一个函数（一般是一个函数对象）来调用区间中的每个元素，但传给for_each的函数只接收一个实参（当前的区间元素），而且当完成时for_each返回它的函数。（实际上，它返回它的函数的一个拷贝――参见条款38。）值得注意的是，传给（而且后来要返回）for_each的函数可能有副作用。
//除了副作用问题，for_each和accumulate的不同主要在两个方面。首先，accumulate的名字表示它是一个产生区间统计的算法，for_each听起来好像你只是要对区间的每个元素进行一些操作，而且，当然，那是那个算法的主要应用。用for_each来统计一个区间是合法的，但是它没有accumulate清楚。
//其次，accumulate直接返回那些我们想要的统计值，而for_each返回一个函数对象，我们必须从这个对象中提取想要的统计信息。在C++里，那意味着我们必须给仿函数类添加一个成员函数，让我们找回我们追求的统计信息。
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function f)
  {
    while ( first!=last ) f(*first++);
    return f;
  }
//统计点的平均值
struct Point {
	Point(double initX, double initY): x(initX), y(initY) {}
	double x, y;
};

class PointAverage:
		public unary_function<Point, void> {		// 参见条款40
public:
	PointAverage(): xSum(0), ySum(0), numPoints(0) {}
	void operator()(const Point& p)
	{
		++numPoints;
		xSum += p.x;
		ySum += p.y;
	}
	Point result() const
	{
		return Point(xSum/numPoints, ySum/numPoints);
	}

private:
	size_t numPoints;
	double xSum;
	double ySum;
};

list<Point> Ip;
...
Point avg = for_each(lp.begin(), lp.end(), PointAverage()).result();
//C++ FAQs 百度文库 P32 下面我们再从设计模式的角度来更深入地理解function objects，这是Visitor模式的典型应用。当我们要对某个/某些对象施加某种操作，但又不想将这种操作限定死，那么就可以采用Visitor模式。在Design Patterns一书中，作者把这种模式实作为，通过一个Visitor类来提供这种操作，在前面Bjarne Stroustrup的代码中，Sum就是一个Visitor的变体，用Visitor类实例化一个visitor对象，当然，在前面的代码中对应的是s，然后在Iterator的迭代过程中，为每一个对象调用visitor.visit()。这里visit()是Visitor类的一个成员函数，作用相当于Sum类中那个“特殊的成员函数”――operator()。visit()也完全可以被定义为内联函数，以去除间接性，提高性能。在此提请读者注意，C+ +把重载的操作符也看作函数，只不过是具有特殊函数名的函数。所以实际上Design Patterns一书中Visitor模式的示范实作和这里function object的实作大体上是等价的。一个function object也就是一个特殊的Visitor。
//参考上例for_each()写的一个小程序
#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <functional>
using namespace std;

class MyFunc: public unary_function<string, void>
{
public:
	void operator()(const string& str)
	{
		s_ += str + "+";
	}
	void show()
	{
		cout << s_ << endl;
	}
private:
	string s_;
};

int main()
{
	vector<string> stringVec((istream_iterator<string>(cin)), (istream_iterator<string>()));
	sort(stringVec.begin(), stringVec.end());
	for_each(stringVec.begin(), stringVec.end(), MyFunc()).show();
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款38：把仿函数类设计为用于值传递 如上例for_each()算法
//因为函数对象以值传递和返回，你的任务就是确保当那么传递（也就是拷贝）时你的函数对象行为良好。这暗示了两个东西。第一，你的函数对象应该很小。否则它们的拷贝会很昂贵。第二，你的函数对象必须单态（也就是，非多态）――它们不能用虚函数。那是因为派生类对象以值传递代入基类类型的参数会造成切割问题：在拷贝时，它们的派生部分被删除。（切割问题怎么影响你使用STL的另一个例子参见条款3。）

//这就是了。带着你要放进你的仿函数类的数据和/或多态，把它们移到另一个类中。然后给你的仿函数一个指向这个新类的指针。比如，如果你想要建立一个包含很多数据的多态仿函数类。
template<typename T>
class BPFC:						// BPFC = “Big Polymorphic
	public						// Functor Class”
		unary_function<T, void> {		// 条款40解释了这个基类
private:
	Widget w;					// 这个类有很多数据，
	Int x;						// 所以用值传递
	...						// 会影响效率

public:
	virtual void operator()(const T& val) const;	// 这是一个虚函数，
	...						// 所以切割时会出问题
};

//建立一个包含一个指向实现类的指针的小而单态的类，然后把所有数据和虚函数放到实现类：
template<typename T>					// 用于修改的BPFC
class BPFCImpl
	public unary_function<T, void> {		// 的新实现类
private:
	Widget w;					// 以前在BPFC里的所有数据
	int x;						// 现在在这里
	...
	virtual ~BPFCImpl();				// 多态类需要
							// 虚析构函数
	virtual void operator()(const T& val) const;
	friend class BPFC<T>;				// 让BPFC可以访问这些数据
};

template<typename T>
class BPFC:						// 小的，单态版的BPFC
	public unary_function<T, void> {
private:
	BPFCImpl<T> *pImpl;				// 这是BPFC唯一的数据

public:
	void operator()(const T& val) const		// 现在非虚；
	{						// 调用BPFCImpl的
		pImpl->operator() (val);
	}
	...
};
//BPFC::operator()的实现例证了BPFC所有的虚函数是怎么实现的：它们调用了在BPFCImpl中它们真的虚函数。结果是仿函数类（BPFC）是小而单态的，但可以访问大量状态而且行为多态。
//我在这里忽略了很多细节，因为我勾勒出的基本技术在C++圈子中已经广为人知了。《Effective C++》的条款34中有。在Gamma等的《设计模式》[6]中，这叫做“Bridge模式”。Sutter在他的《Exceptional C++》[8]中叫它“Pimpl惯用法”.
//从STL的视角看来，要记住的最重要的东西是使用这种技术的仿函数类必须支持合理方式的拷贝。如果你是上面BPFC的作者，你就必须保证它的拷贝构造函数对指向的BPFCImpl对象做了合理的事情。也许最简单的合理的东西是引用计数，使用类似Boost的shared_ptr，你可以在条款50中了解它. 
//实际上，对于本条款的目的，唯一你必须担心的是BPFC的拷贝构造函数的行为，因为当在STL中被传递或从一个函数返回时，函数对象总是被拷贝――值传递，记得吗？那意味着两件事。让它们小，而且让它们单态。
//------------------------------------------------------------------------------------------------
//Effective STL 条款39：用纯函数做判断式
//纯函数是返回值只依赖于参数的函数。如果f是一个纯函数，x和y是对象，f(x, y)的返回值仅当x或y的值改变的时候才会改变。
//在C++中，由纯函数引用的所有数据不是作为参数传进的就是在函数生存期内是常量。（一般，这样的常量应该声明为const。）如果一个纯函数引用的数据在不同次调用中可能改变，在不同的时候用同样的参数调用这个函数可能导致不同的结果，那就与纯函数的定义相反。 
//在判断式类中把operator()声明为const对于正确的行为来说是必要的，但不够充分。一个行为良好的operator()当然是const，但不只如此。它也得是一个纯函数。
bool anotherBadPredicate(const Widget&, const Widget&)
{
	static int timesCalled = 0;			// 不！不！不！不！不！不！不！
	return ++timesCalled == 3;			// 判断式应该是纯函数，
}		
//------------------------------------------------------------------------------------------------
//Effective STL 条款40：使仿函数类可适配
#include <iostream>
#include <iterator>
#include <vector>
#include <ctime>
#include <algorithm>
using namespace std;

class myGenerate
{
public:
	myGenerate(int i = 0): i_(i)	{}
	int operator()()
	{
		return ++i_;
	}
private:
	int i_;
};

struct myCompareWithOneInput: public unary_function<int, bool>
{
	bool operator()(int lhs) const
	{
		return lhs < 5 ;
	}
};

struct myCompareWithTwoInputs: public binary_function<int, int, bool>//这种比较其实都可以直接用标准库里的函数对象模板，less<int>()，以后不需要自己再手写了，如果比较的对象是用户自己定义类型，则或者特化标准库中的函数对象模板，或者写自己的函数对象
{
	bool operator()(int lhs, int rhs) const
	{
		return lhs < rhs;
	}
};

int main () 
{
	srand ( unsigned ( time (NULL) ) );
	vector<int> intVec(10);	
	generate(intVec.begin(), intVec.end(), myGenerate());
	cout << distance(intVec.begin(), find_if(intVec.begin(), intVec.end(), not1(myCompareWithOneInput())));//not1是对一元参数函数对象的否定
	cout << '\n' << "------------------------" << endl;
	
	//bind2nd其实是binder2nd对象，所以可以如下声明和使用
	//binder2nd< myCompareWithTwoInputs > b2(bind2nd(myCompareWithTwoInputs(), 3));
	//cout << distance(intVec.begin(), find_if(intVec.begin(), intVec.end(), b2));
	cout << distance(intVec.begin(), find_if(intVec.begin(), intVec.end(), bind2nd(myCompareWithTwoInputs(), 3)));//bind2nd把二元参数的函数对象绑成一元函数对象来使用，并且把不变参数绑在原二元参数函数的第二个参数上
	
	cout << '\n' << "------------------------" << endl;
	
	//bind1st也一样，binder1st对象，所以可以如下声明和使用
	//binder1st<myCompareWithTwoInputs> b1(bind1st(myCompareWithTwoInputs(), 3));
	//cout << distance(intVec.begin(), find_if(intVec.begin(), intVec.end(), b1));
	cout << distance(intVec.begin(), find_if(intVec.begin(), intVec.end(), bind1st(myCompareWithTwoInputs(), 3)));//bind1st把二元参数的函数对象绑成一元函数对象来使用，并且把不变参数绑在原二元参数函数的第一个参数上
	cout << '\n' << "------------------------" << endl;
	random_shuffle(intVec.begin(), intVec.end());
	sort(intVec.begin(), intVec.end(), not2(myCompareWithTwoInputs()));//not2是对原二元函数对象的返回结果bool/true的否定
	copy(intVec.begin(), intVec.end(), ostream_iterator<int>(cout, " "));
}

//网上找的bind1st在for_each算法上的一个应用（未运行，应该有错）
struct doSomethingDirect : public 
std::binary_function<const char *, int, void>
{
    void operator()(const char *cValue, int iValue) const
    {
        std::cout << cValue 
        << " " 
        << iValue 
        << ". "  << std::endl;
    }
};

// 这是个帮助器模板，因为我比较懒，它能减少打字量。
template <class Collection, class Function>
Function for_all(Collection &c, const Function &f) 
{
    return std::for_each(c.begin(), c.end(), f);
}

int main()
{
// 首先，建立vector。
    std::vector<int> vect;
    for (int i=1; i<10; ++i) {
        vect.push_back(i);
    }
    for_all(vect, std::bind1st(doSomethingWrapper(), "Wrapper:"));
    std::cout << "\n";
	for_all(vect, std::bind1st(doSomethingDirect(), "Direct:"));
    getchar();
    return 0;
}

// 我独树一帜的第三方库函数

void doSomething(const char *c, int i)
{
    std::cout << c << " " << i << ". " << std::endl;
}

/* 运行结果：
Wrapper: 1.
Wrapper: 2.
Wrapper: 3.
Wrapper: 4.
Wrapper: 5.
Wrapper: 6.
Wrapper: 7.
Wrapper: 8.
Wrapper: 9.

Direct: 1.
Direct: 2.
Direct: 3.
Direct: 4.
Direct: 5.
Direct: 6.
Direct: 7.
Direct: 8.
Direct: 9.
*/
//------------------------------------------------------------------------------------------------
//条款41：了解使用ptr_fun、mem_fun和mem_fun_ref的原因
//如果我有一个函数f和一个对象x，我希望在x上调用f，而且我在x的成员函数之外。C++给我三种不同的语法来实现这个调用：
f(x);			// 语法#1：当f是一个非成员函数
x.f();			// 语法#2：当f是一个成员函数
			// 而且x是一个对象或一个对象的引用
p->f();			// 语法#3：当f是一个成员函数
			// 而且p是一个对象的指针
//而且我有一个Widget的容器：
vector<Widget> vw;			// vw容纳Widget要测试vw中的每个Widget，我很显然可以这么使用for_each：
for_each(vw.begin(), vw.end(), test);	// 调用#1（可以编译）

class Widget {
public:
	void test();		// 进行自我测试；如果没通过
				// 就把*this标记为“failed”
};

for_each(vw.begin(), vw.end(),
		mem_fun_ref(&Widget::test));		// #2可以编译过了

list<Widget*> lpw;				// 同上
for_each(lpw.begin(), lpw.end(),
		mem_fun(&Widget::test));	// #3这个现在可以编译了

//第一个调用（调用#1）传递一个真的函数，因此用于for_each时不需要适配它的调用语法；这个算法将固有地使用适当的语法调用它。而且，for_each没有使用ptr_fun增加的typedef，所以当把test传给for_each时不必使用ptr_fun。另一方面，增加的typedef不会造成任何损伤，所以这和上面的调用做相同的事情：
for_each(vw.begin(), vw.end(), ptr_fun(test));	// 可以编译，行为
						// 就像上面的调用#1
//mem_fun和mem_fun_ref的情况则完全不同。只要你传一个成员函数给STL组件，你就必须使用它们，因为，除了增加typedef（可能是或可能不是必须的）之外，它们把调用语法从一个通常用于成员函数的适配到在STL中到处使用的。当传递成员函数指针时如果你不使用它们，你的代码将永远不能编译。

//总结一下
//ptr_fun()是给非成员函数用的函数适配器，当不需要适配的时候，加不加ptr_fun()都没有什么影响
//mem_fun_ref()是给普通对象的成员函数用的函数适配器
//mem_fun()是给指针对象的成员函数用的函数适配器
//可以将成员函数设定为静态成员函数，则可以不需要使用适配器，而当成普通的函数来使用
#include <iostream>
#include <vector>
#include <algorithm>
#include <xfunctional>
using namespace std;

class Widget
{
public:
	Widget(int id): id_(id) { }
	void show()//这里两点要注意，一个是要声明为public，另一个是不需要任何参数
	{
		cout << id_ << endl;
	}
private:
	int id_;
};

int main()
{
	vector<Widget*> widgetVector;

	Widget* pWidget1(new Widget(4));
	widgetVector.push_back(pWidget1);

	Widget* pWidget2(new Widget(2));
	widgetVector.push_back(pWidget2);

	for_each(widgetVector.begin(), widgetVector.end(), mem_fun(&Widget::show));
}
//------------------------------------------------------------------------------------------------
//条款42：确定less<T>表示operator<
//通过对less<T>的特化来保证排序

//但是假设我们想建立一个按照最高速度排序Widget的multiset<Widget>。我们知道multiset<Widget>的默认比较函数是less<Widget>，而且我们知道默认的less<Widget>通过调用Widget的operator<来工作。鉴于这种情况，好像得到以最高速度排序的multiset<Widget>很明显一种方法是通过特化less<Widget>来切断less<Widget>和operator<之间的纽带，让它只关注Widget的最高速度：
template<>						// 这是一个std::less
struct std::less<Widget>:					// 的Widget的特化；
	public							// 也是非常坏的主意
	std::binary_function<Widget,
				Widget,			// 关于这个基类更多
				bool> {			// 的信息参见条款40
	bool operator()(const Widget& lhs, const Widget& rhs) const
	{
		return lhs.maxSpeed() < rhs.maxSpeed();
	}
};
//通常，试图修改std里的组件确实是禁止的（而且这么做通常被认为是行为未定义的范畴)，但是在一些情况下，修补是允许的。具体来说，程序员被允许用自定义类型特化std内的模板。特化std模板的选择几乎总是更为优先，但很少发生，这确实合理的。例如，智能指针类的作者经常想让他们的类在排序的时候行为表现得像内建指针，因此用于智能指针类型的std::less特化并不罕见。例如下面内容，是Boost库的shared_ptr的一部分，你可以在条款7和50中获悉智能指针：
namespace std {
	template<typename T>				// 这是一个用于boost::shared_ptr<T>
	struct less<boost::shared_ptr<T> >:			// 的std::less的特化
		public					// （boost是一个namespace）
		binary function<boost::shared_ptr<T>,
					boost::shared_ptr<T>,// 这是惯例的
					bool> {		// 基类（参见条款40）
		bool operator()(const boost::shared_ptr<T>& a,
					const boost::shared_ptr<T>& b) const
		{
			return less<T*>()(a.get(),b.get());	// shared_ptr::get返回
		}					// shared_ptr对象内的
							// 内建指针
	};
}

//operator<不仅是实现less的默认方式，它还是程序员希望less做的。让less做除operator<以外的事情是对程序员预期的无故破坏。它与所被称为“最小惊讶的原则”相反。它是冷淡的。它是低劣的。它是坏的。你不该那么做。
//就是说如果要特化less<T>，一定要让它表现出operator<一样的行为。下面一段就是说所有用到less<T>特化的地方，都可以通过另外声明一个函数或者函数对象的方式来做到

//特别是当没有理由时。在STL中没有一个用到less的地方你不能指定一个不同的比较类型。回到我们原先以最高速度排序的multiset<Widget>的例子，我们要得到希望的结果所需的所有事情就是建立一个叫做除了less以外的几乎任何名字的仿函数类来对我们感兴趣的东西进行比较。嗨，这里有一个例子：
struct MaxSpeedCompare:
	public binary_function<Widget, Widget, bool> {
	bool operator()(const Widget& lhs, const Widget& rhs) const
	{
		return lhs.maxSpeed() < rhs.maxSpeed();
	}
};

//要创造我们的multiset，我们使用MaxSpeedCompare作为比较类型，因此避免了默认比较类型的使用（当然也就是less<Widget>）：
multiset<Widget, MaxSpeedCompare> widgets;
//这条代码确切地说出了它的意思。它建立了一个Widget的multiset，按照仿函数类MaxSpeedCompare所定义方法排序。
//对比这个：
multiset<Widget> widgets;
//这个表示widgets是一个以默认方式排序的Widget的multiset。在技术上，那表示它使用了less<Widget>，但是实际上每人都要假设那真的意味着它是按operator<来排序。
//不要通过把less的定义当儿戏来误导那些程序员。如果你使用less（明确或者隐含），保证它表示operator<。如果你想要使用一些其他标准排序对象，建立一个特殊的不叫做less的仿函数类。它真的很简单。
//------------------------------------------------------------------------------------------------
//C++ Primer P452 标准库中定义的函数对象
//算术函数对象类型
plus<Type>//加+
minus<Type>//减-
multiplies<Type>//乘*
divides<Type>//除/
modulus<Type>//取余%
negate<Type>//取反-
//关系函数对象类型
equal_to<Type>//等于==
not_equal_to<Type>//不等于==
greater<Type>//大于>
greate_equal<Type>//大于等于>=
less<Type>//小于<
less_equal<Type>//小于等于<=
//逻辑函数对象类型
logical_and<Type>//逻辑与&&
logical_or<Type>//逻辑或||
logical_not<Type>//逻辑非!
//------------------------------------------------------------------------------------------------
//Effective STL 条款43：尽量用算法调用代替手写循环
//假设有一个数组data（大概是因为遗留的C API――参见条款16），你想获得其中的每一个元素，把它加上41，然后将结果插入一个deque的前端
//用算法一句话搞定：
transform(data, data + numIntegers, inserter(intDeque, intDeque.begin()), bind2nd(plus<int>(), 41));
//关键在于已知词汇的力量。在STL中约有70个算法的名字――总共超过100个不同的函数模板，每个重载都算一个。每个算法都完成一些精心定义的任务，而且有理由认为专业的C++程序员知道（或应该去看一下）每个算法都完成了什么。因此，当程序员调用transform时，他们认为对区间内的每个元素都施加了某个函数，而结果将被写到另外一个地方。当程序员调用replace_if时，他（她）知道区间内满足判定条件的对象都将被修改。当调用partition时，她（他）明白区间中所有满足判定条件的对象将被聚集在一起（参见条款31）。STL算法的名字传达了大量的语义信息，这使得它们比随机的循环清晰多了。
//在算法调用与手写循环正在进行的较量中，关于代码清晰度的底线是：这完全取决于你想在循环里做的是什么。如果你要做的是算法已经提供了的，或者非常接近于它提供的，调用泛型算法更清晰。如果循环里要做的事非常简单，但调用算法时却需要使用绑定和适配器或者需要独立的仿函数类，你恐怕还是写循环比较好。最后，如果你在循环里做的事相当长或相当复杂，天平再次倾向于算法。因为长的、复杂的通常总应该封装入独立的函数。只要将循环体一封装入独立函数，你几乎总能找到方法将这个函数传给一个算法（通常是for_each），以使得最终代码直截了当。

//写了一个string中对象转换成大写的字母的程序
#include <iostream>
#include <cctype>
#include <string>
#include <algorithm>
#include <functional>
using namespace std;

class MyCapitalize: public unary_function<char, char>
{
public:
	char operator()(char c)
	{
		return toupper(c);
	}
};

int main()
{
	string s("hello");
	transform(s.begin(), s.end(), s.begin(), MyCapitalize());
	cout << s << endl;
}
//------------------------------------------------------------------------------------------------
//关联容器自定义排序类型
#include <iostream>
#include <iterator>
#include <set>
#include <functional>
#include <algorithm>
using namespace std;

bool myCompare(int lhs, int rhs)
{
	return lhs > rhs;
}

int main () 
{
	set< int, greater<int> > intSet;//用标准函数对象，前面的参数greate<int>应该为类型，然后greater<int>就被认为是默认的排序类型，自定义的函数对象也可以
	intSet.insert(5);
	intSet.insert(6);
	copy(intSet.begin(), intSet.end(), ostream_iterator<int>(cout, " "));

	set< int, bool(*)(int, int) > intSet2(myCompare);//自定义函数，类型为bool(*)(int, int)，但这时就要把函数指针传给被声明的set对象
	intSet2.insert(5);
	intSet2.insert(6);
	copy(intSet2.begin(), intSet2.end(), ostream_iterator<int>(cout, " "));
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款44：尽量用成员函数代替同名的算法
//我们以对关联容器的实验开始。假如有一个set<int>，它容纳了一百万个元素，而你想找到元素727的第一个出现位置（如果存在的话）。这儿有两个最自然的方法来执行搜索：
set<int> s;					// 建立set，放入1,000,000个数据

set<int>::iterator i = s.find(727);			// 使用find成员函数
if (i != s.end()) ...
set<int>::iterator i = find(s.begin(), s.end(), 727);	// 使用find算法
if (i != s.end()) ...
//find成员函数运行花费对数时间，所以不管727是否存在于此set中，set::find只需执行不超过40次比较来查找它，而一般只需要大约20次。相反，find算法运行花费线性时间，所以如果727不在此set中，它需要执行1,000,000次比较。即使727在此set中，也平均需要执行500,000次比较来找到它。效率得分如下：
//find成员：大约40（最坏的情况）至大约20（平均情况）
//find算法：1,000,000（最坏的情况）至500,000（平均情况）

//效率不是find成员函数和find算法间的唯一差别。正如条款19所解释的，STL算法判断两个对象是否相同的方法是检查的是它们是否相等，而关联容器是用等价来测试它们的“同一性”。 因此，find算法搜索727用的是相等，而find成员函数用的是等价。相等和等价间的区别可能造成成功搜索和不成功搜索的区别。比如说，条款19演示了用find算法在关联容器搜索失败而用find成员函数却搜索成功的情况！因此，如果使用关联容器的话，你应该尽量使用成员函数形式的find、count、lower_bound等等，而不是同名的算法，因为这些成员函数版本提供了和其它成员函数一致的行为。由于相等和等价间的差别，算法不能提供这样的一致行为。

//这一差别对map和multimap尤其明显，因为它们容纳的是对象对（pair object），而它们的成员函数只在意对象对的key部分。因此，count成员函数只统计key值匹配的对象对的数目（所谓“匹配”，自然是检测等价情况）；对象对的value部份被忽略。成员函数find、lower_bound、upper_bound和equal_range也是如此。但是如果你使用count算法，它的寻找将基于（a）相等和（b）对象对的全部组成部分；算法find、lower_bound等同样如此。要想让算法只关注于对象对的key部分，必须要跳出条款23描述的限制（那儿介绍了用相等测试代替等价测试的方法）。

//对于标准的关联容器，选择成员函数而不是同名的算法有几个好处。首先，你得到的是对数时间而不是线性时间的性能。其次，你判断两个元素“相同”使用的是等价，这是关联容器的默认定义。第三，当操纵map和multimap时，你可以自动地只处理key值而不是(key, value)对。这三点给了优先使用成员函数完美的铁甲。
// list::merge
#include <iostream>
#include <list>
#include <functional>
using namespace std;

// this compares equal two doubles if
//  their interger equivalents are equal
bool mycomparison (double first, double second)
{ return ( int(first)>int(second) ); }

int main ()
{
	list<double> first, second;

	first.push_back (3.1);
	first.push_back (2.2);
	first.push_back (2.9);

	second.push_back (3.7);
	second.push_back (7.1);
	second.push_back (1.4);

	first.sort(greater<double>());
	second.sort(greater<double>());

	first.merge(second, greater<double>());

	second.push_back (2.1);

	first.merge(second, mycomparison);//first.merge(second)这样写编译没问题，运行报错"sequence not order"，merge可以有自己的排序算法，但是要与sort中的排序算法有相同的升降序，不可以sort中是降序，merge是升序，反之亦然

	cout << "first contains:";
	for (list<double>::iterator it=first.begin(); it!=first.end(); ++it)
		cout << " " << *it;
	cout << endl;

	return 0;
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别
list<Widget> lw;			// Widget的list
Widget w;				// 特定的Widget值
...
if (count(lw.begin(), lw.end(), w)) {
	...			// w在lw中
} else {
	...			// 不在
}

if (find(lw.begin(), lw.end(), w) != lw.end()) {
	...				// 找到了
} else {
	...				// 没找到
}
//如果是为了检查是否存在，count这个惯用法编码起来比较简单。但是，当搜索成功时，它的效率比较低，因为当找到匹配的值后find就停止了，而count必须继续搜索，直到区间的结尾以寻找其他匹配的值。对大多数程序员来说，find在效率上的优势足以证明略微增加复杂度是合适的。

// //当你用lower_bound来寻找一个值的时候，它返回一个迭代器，这个迭代器指向这个值的第一个拷贝（如果找到的话）或者到可以插入这个值的位置（如果没找到）。因此lower_bound回答这个问题：“它在吗？如果是，第一个拷贝在哪里？如果不是，它将在哪里？”和find一样，你必须测试lower_bound的结果，来看看它是否指向你要寻找的值。但又不像find，你不能只是检测lower_bound的返回值是否等于end迭代器。取而代之的是，你必须检测lower_bound所标示出的对象是不是你需要的值。（解释了条款23 vector中用lower_bound和条款24 map中用lower_bound）
//很多程序员这么用lower_bound：
vector<Widget>::iterator i = lower_bound(vw.begin(), vw.end(), w);
if (i != vw.end() && *i == w) {	// 保证i指向一个对象；
				// 也就保证了这个对象有正确的值。
				// 这是个bug！ 
	...			// 找到这个值，i指向
				// 第一个等于该值的对象
} else {
	...			// 没找到
}
//大部分情况下这是行得通的，但不是真的完全正确。再看一遍检测需要的值是否找到的代码：
if (i != vw.end() && *i == w) ...//这是一个相等的测试，但lower_bound搜索用的是等价。大部分情况下，等价测试和相等测试产生的结果相同，但就像条款19论证的，相等和等价的结果不同的情况并不难见到。在这种情况下，上面的代码就是错的。

//要完全完成，你就必须检测lower_bound返回的迭代器指向的对象的值是否和你要寻找的值等价。你可以手动完成（条款19演示了你该怎么做，当它值得一做时条款24提供了一个例子），但可以更狡猾地完成，因为你必须确认使用了和lower_bound使用的相同的比较函数。一般而言，那可以是一个任意的函数（或函数对象）。如果你传递一个比较函数给lower_bound，你必须确认和你的手写的等价检测代码使用了相同的比较函数。这意味着如果你改变了你传递给lower_bound的比较函数，你也得对你的等价检测部分作出修改。保持比较函数同步不是火箭发射，但却是另一个要记住的东西，而且我想你已经有很多需要你记的东西了。

//这儿有一个简单的方法：使用equal_range。equal_range返回一对迭代器，第一个等于lower_bound返回的迭代器，第二个等于upper_bound返回的（也就是，等价于要搜索值区间的末迭代器的下一个）。因此，equal_range，返回了一对划分出了和你要搜索的值等价的区间的迭代器。一个名字很好的算法，不是吗？（当然，也许叫equivalent_range会更好，但叫equal_range也非常好。）
//对于equal_range的返回值，有两个重要的地方。第一，如果这两个迭代器相同，就意味着对象的区间是空的；这个只没有找到。这个结果是用equal_range来回答“它在吗？”这个问题的答案。你可以这么用：
vector<Widget> vw;
...
sort(vw.begin(), vw.end());
typedef vector<Widget>::iterator VWIter;	// 方便的typedef
typedef pair<VWIter, VWIter> VWIterPair;
VWIterPair p = equal_range(vw.begin(), vw.end(), w);
if (p.first != p.second) {			// 如果equal_range不返回
					// 空的区间...
	...				// 说明找到了，p.first指向
					// 第一个而p.second
					// 指向最后一个的下一个
} else {
	...				// 没找到，p.first和
					// p.second都指向搜索值
}					// 的插入位置
//这段代码只用等价，所以总是正确的。
//第二个要注意的是equal_range返回的东西是两个迭代器，对它们作distance就等于区间中对象的数目，也就是，等价于要寻找的值的对象。结果，equal_range不光完成了搜索有序区间的任务，而且完成了计数。比如说，要在vw中找到等价于w的Widget，然后打印出来有多少这样的Widget存在，你可以这么做：
VWIterPair p = equal_range(vw.begin(), vw.end(), w);
cout << "There are " << distance(p.first, p.second)
		<< " elements in vw equivalent to w.";

//到目前为止，我们所讨论的都是假设我们要在一个区间内搜索一个值，但是有时候我们更感兴趣于在区间中寻找一个位置。比如，假设我们有一个Timestamp类和一个Timestamp的vector，它按照老的timestamp放在前面的方法排序：
class Timestamp { ... };
bool operator<(const Timestamp& lhs,		// 返回在时间上lhs
	const Timestamp& rhs);		// 是否在rhs前面
vector<Timestamp> vt;			// 建立vector，填充数据，
...					// 排序，使老的时间
sort(vt.begin(), vt.end());			// 在新的前面
//现在假设我们有一个特殊的timestamp――ageLimit，而且我们从vt中删除所有比ageLimit老的timestamp。在这种情况下，我们不需要在vt中搜索和ageLimit等价的Timestamp，因为可能不存在任何等价于这个精确值的元素。 取而代之的是，我们需要在vt中找到一个位置：第一个不比ageLimit更老的元素。这是再简单不过的了，因为lower_bound会给我们答案的：
Timestamp ageLimit;
...
vt.erase(vt.begin(), lower_bound(vt.begin(),	// 从vt中排除所有
	vt.end(),				// 排在ageLimit的值
	ageLimit));			// 前面的对象
//如果我们的需求稍微改变了一点，我们要排除所有至少和ageLimit一样老的timestamp，也就是我们需要找到第一个比ageLimit年轻的timestamp的位置。这是一个为upper_bound特制的任务：
vt.erase(vt.begin(), upper_bound(vt.begin(),	// 从vt中除去所有
	vt.end(),				// 排在ageLimit的值前面
	ageLimit));			// 或者等价的对象

//如果你要把东西插入一个有序区间，而且对象的插入位置是在有序的等价关系下它应该在的地方时，upper_bound也很有用。比如，你可能有一个有序的Person对象的list，对象按照name排序：
class Person {
public:
	...
	const string& name() const;
	...
};

struct PersonNameLess:
public binary_function<Person, Person, bool> {	// 参见条款40
	bool operator()(const Person& lhs, const Person& rhs) const
	{
		return lhs.name() < rhs.name();
	}
};

list<Person> lp;
...
lp.sort(PersonNameLess());			// 使用PersonNameLess排序lp
//要保持list仍然是我们希望的顺序（按照name，插入后等价的名字仍然按顺序排列），我们可以用upper_bound来指定插入位置：
Person newPerson;
...
lp.insert(upper_bound(lp.begin(),		// 在lp中排在newPerson
	lp.end(),				// 之前或者等价
	newPerson,			// 的最后一个
	PersonNameLess()),			// 对象后面
	newPerson);			// 插入newPerson

//按照上述所说写的一个例子，个人感觉upper_bound和lower_bound都可以，反正这两个bound都是用等价查找，所以找到等价的位置之后，插在等价的最前面和最后面一样；但是如果有多个等价对象，就会分别放在所有等价对象最前面或最后面。对于上面的时间戳例子查找迭代器是有差别的
#include <iostream>
#include <list>
#include <string>
#include <functional>
#include <algorithm>
#include <iterator>
using namespace std;

int main ()
{
	string strArr[] = {"dingdayu", "hanmeimei", "dingben", "dingliwen", "mayian", "mashiqiang"};
	list<string> nameList(strArr, strArr + 6);
	nameList.sort();
	copy(nameList.begin(), nameList.end(), ostream_iterator<string>(cout, "\n"));
	cout << "-----------------------------------" << endl;
	string newName("dingliwu");
	nameList.insert(lower_bound(nameList.begin(), nameList.end(), newName), newName);
	copy(nameList.begin(), nameList.end(), ostream_iterator<string>(cout, "\n"));

	return 0;
}

//一直到这里，我都只考虑我们有一对定义了搜索区间的迭代器的情况。通常我们有一个容器，而不是一个区间。在这种情况下，我们必须区别序列和关联容器。对于标准的序列容器（vector、string、deque和list），你应该遵循我在本条款提出的建议，使用容器的begin和end迭代器来划分出区间。
//这种情况对标准关联容器（set、multiset、map和multimap）来说是不同的，因为它们提供了搜索的成员函数，它们往往是比用STL算法更好的选择。条款44详细说明了为什么它们是更好的选择，简要地说，是因为它们更快行为更自然。幸运的是，成员函数通常和相应的算法有同样的名字，所以前面的讨论推荐你使用的算法count、find、equal_range、lower_bound或upper_bound，在搜索关联容器时你都可以简单的用同名的成员函数来代替。
//调用binary_search的策略不同，因为这个算法没有提供对应的成员函数。要测试在set或map中是否存在某个值，使用count的惯用方法来对成员进行检测：
set<Widget> s;		// 建立set，放入数据 
...
Widget w;			// w仍然是保存要搜索的值
...
if (s.count(w)) {
	...		// 存在和w等价的值
} else {
	...		// 不存在这样的值
}
//要测试某个值在multiset或multimap中是否存在，find往往比count好，因为一旦找到等于期望值的单个对象，find就可以停下了，而count，在最遭的情况下，必须检测容器里的每一个对象。（对于set和map，这不是问题，因为set不允许重复的值，而map不允许重复的键。）
//但是，count给关联容器计数是可靠的。特别，它比调用equal_range然后应用distance到结果迭代器更好。首先，它更清晰：count 意味着“计数”。第二，它更简单；不用建立一对迭代器然后把它的组成（译注：就是first和second）传给distance。第三，它可能更快一点。
//对于multiset和multimap，当你在搜索第一个等于特定值的对象的那一行，这个表列出了find和lower_bound两个算法作为候选。 已对于这个任务find是通常的选择，而且你可能已经注意到在set和map那一列里，这项只有find。但是对于multi容器，如果不只有一个值存在，find并不保证能识别出容器里的等于给定值的第一个元素；它只识别这些元素中的一个。如果你真的需要找到等于给定值的第一个元素，你应该使用lower_bound，而且你必须手动的对第二部分做等价检测，条款19的内容可以帮你确认你已经找到了你要找的值。（你可以用equal_range来避免作手动等价检测，但是调用equal_range的花费比调用lower_bound多得多。）
//也就是说find是找完全相等的元素，lower_bound是找等价的元素，但是找到的元素可能并不相等；

//另一方面，find找到则返回非.end()迭代器，没找到则返回.end()迭代器，lower_bound则返回所查找元素k的等价的位置，所以在用lower_bound查找时，必须要对返回的迭代器iter进行两次判断，如果是.end()，则肯定没找到等价元素，或者说等价元素的位置是在.end()，如果不是.end()，还要进行第二次判断，!someSet.key_comp()(k, *iter)，这里不可以用someSet.key_comp()(*iter, k)以及其的方式。
//首先，nameSet.key_comp()(*iter, newName)和!nameSet.key_comp()(*iter, newName)的形式肯定不对，因为无论是否找到等价元素的迭代器位置，nameSet.key_comp()(*iter, newName)函数总返回0，这是因为：如果找到了等价元素迭代器，则两个等价元素进行<比较返回0（条款21），如果没有找到等价元素，则返回的迭代器是刚好>所查找元素的，则key_comp()返回0，因此这个形式的key_comp()无法分辨出是否找到了等价元素；同理!nameSet.key_comp()(*iter, newName)总返回1，一样无法分辨
//其次 nameSet.key_comp()(newName, *iter) 的形式是可以分辨出来是否找到了等价元素的，如果找到等价元素，则两个等价元素key_comp()返回0， 如果没有找到等价元素，该元素k用等价比较是<通过lower_bound查找k返回的迭代器元素的，所以该key_comp()比较函数返回1。但是找到了等价元素返回0，没有找到等价元素返回1，这与判断是否找到的真假值相反，所以应该用! nameSet.key_comp()(newName, *iter) 的比较形式！

//关联对象的key_comp()用的排序的等价比较，没有额外的函数对象比较参数形式，下例中所写不效率，对于set应该用其成员函数的lower_bound，而不是用算法中的对应函数

//泛型算法的lower_bound()加了函数对象比较的参数一定要用排序的等价比较形式查找；不加函数对象参数虽然不会报错，但是查找结果好像没有规律，并且是错的，就是上文中“//要完全完成”这行所说的“一般而言，那可以是一个任意的函数（或函数对象）。”用equal_range()同样需要传入排序时所用的等价函数，如果不传排序的等价函数，则报错"sequence not ordered"


#include <iostream>
#include <set>
#include <string>
#include <functional>
#include <algorithm>
#include <iterator>
using namespace std;

struct StringSetLess: public binary_function<string, string, bool>
{
	bool operator()(const string& lhs, const string& rhs) const
	{
		return lhs.size() < rhs.size();
	}
};

int main ()
{
	string strArr[] = {"yanchunping", "linling", "hanmeimei", "dingben", "dingliwen", "mayian", "mashiqiang"};
	multiset<string, StringSetLess> nameSet(strArr, strArr + 7);
	copy(nameSet.begin(), nameSet.end(), ostream_iterator<string>(cout, "\n"));
	cout << "-----------------------------------" << endl;
	string newName("dinglei");//找到等价元素的情况
	multiset<string, StringSetLess>::iterator iterForDefaultStringLess = lower_bound(nameSet.begin(), nameSet.end(), newName);//不加排序函数虽然不会报错，但是结果毫无规律，是错的
	cout << *iterForDefaultStringLess << endl;
	multiset<string, StringSetLess>::iterator iter = lower_bound(nameSet.begin(), nameSet.end(), newName, StringSetLess());//不效率，应该用multiset<string, StringSetLess>::iterator iter = nameSet.lower_bound(newName);的形式
	cout << *iter << endl;
	cout << nameSet.key_comp()(newName, *iter) << endl;
	cout << !nameSet.key_comp()(newName, *iter) << endl;//正确的方式
	cout << nameSet.key_comp()(*iter, newName) << endl;
	cout << !nameSet.key_comp()(*iter, newName) << endl;

	string newName2("majialin");//没有找到等价元素的情况
	multiset<string, StringSetLess>::iterator iter2 = lower_bound(nameSet.begin(), nameSet.end(), newName2, StringSetLess());//不效率，应该用multiset<string, StringSetLess>::iterator iter = nameSet.lower_bound(newName2);
	cout << *iter2 << endl;
	cout << nameSet.key_comp()(newName2, *iter2) << endl;
	cout << !nameSet.key_comp()(newName2, *iter2) << endl;//正确的方式
	cout << nameSet.key_comp()(*iter2, newName2) << endl;
	cout << !nameSet.key_comp()(*iter2, newName2) << endl;
	
	pair<multiset<string, StringSetLess>::iterator, multiset<string, StringSetLess>::iterator> iterPair = nameSet.equal_range("majialin");
	cout << *iterPair.first << endl;
	cout << *iterPair.second << endl;
	pair<multiset<string, StringSetLess>::iterator, multiset<string, StringSetLess>::iterator> iterPair2 = equal_range(nameSet.begin(), nameSet.end(), "majialin", StringSetLess());//不传第4个参数StringSetLess()则运行报错
	cout << *iterPair2.first << endl;
	cout << *iterPair2.second << endl;
	return 0;
}
//------------------------------------------------------------------------------------------------
//Effective STL 条款46：考虑使用函数对象代替函数作算法的参数
inline
bool doubleGreater(double d1, double d2)
{
	return dl > d2;
}

sort(v.begin(), v.end(), doubleGreater);
//这个行为的解释很简单：内联。如果一个函数对象的operator()函数被声明为内联（不管显式地通过inline或者隐式地通过定义在它的类定义中），编译器就可以获得那个函数的函数体，而且大部分编译器喜欢在调用算法的模板实例化时内联那个函数。在上面的例子中，greater<double>::operator()是一个内联函数，所以编译器在实例化sort时内联展开它。结果，sort没有包含一次函数调用，而且编译器可以对这个没有调用操作的代码进行其他情况下不经常进行的优化。（内联和编译器优化之间交互的讨论，参见《Effective C++》的条款33和Bulka与Mayhew的《Efficient C++》[10]的第8-10章。)
//使用doubleGreater调用sort的情况则不同。要知道有什么不同，我们必须知道不可能把一个函数作为参数传给另一个函数。当我们试图把一个函数作为参数时，编译器默默地把函数转化为一个指向那个函数的指针，而那个指针是我们真正传递的。因此，这个调用
sort(v.begin(), v.end(), doubleGreater);不是真的把doubleGreater传给sort，它传了一个doubleGreater的指针。当sort模板实例化时，这是产生函数的声明：
void sort(vector<double>::iterator first,			// 区间起点
		vector<double>::iterator last,		// 区间终点
		bool (*comp)(double, double));
//因为comp是一个指向函数的指针，每次在sort中用到时，编译器产生一个间接函数调用――通过指针调用。大部分编译器不会试图去内联通过函数指针调用的函数，甚至，正如本例中，那个函数已经声明为inline而且这个优化看起来很直接。

//还有另一个使用函数对象代替函数作为算法参数的理由，而它与效率无关。它涉及到让你的程序可以编译。对于任何理由，STL平台经常完全拒绝有效代码，即使编译器或库或两者都没问题。比如，一个广泛使用的STL平台拒绝了下面（有效的）代码来从cout打印出set中每个字符串的长度：

set<string> s;
...
transform(s.begin(), s.end(),
			ostream_iterator<string::size_type>(cout, "\n"),
			mem_fun_ref(&string::size));
//这个问题的原因是这个特定的STL平台在处理const成员函数时有bug（比如string::size）。一个变通方法是改用函数对象：
struct StringSize:
	public unary_function<string, string::size_type>{	// 参见条款40
	string::size_type operator()(const string& s) const
	{
		return s.size();
	}
};

transform(s.begin(), s.end(),
		ostream_iterator<string::size_type>(cout, "\n"),
		StringSize());
//解决这问题的还有其他变通办法，但这个不仅在我知道的每个STL平台都可以编译。而且它简化了string::size的内联调用，那是几乎不会在上面把mem_fun_ref(&string::size)传给transform的代码中发生的事情。换句话说，仿函数类StringSize的创造不仅避开了编译器一致性问题，而且可能会带来性能提升。

//把函数对象作为算法的参数所带来的不仅是巨大的效率提升。在让你的代码可以编译方面，它们也更稳健。当然，真函数很有用，但是当涉及有效的STL编程时，函数对象经常更有用。
//------------------------------------------------------------------------------------------------
//Effective STL 条款47：避免产生只写代码
//假设你有一个vector<int>，你想去掉vector中出现在和y一样大的最后一个元素之后的值小于x的所有元素。下面代码立刻出现在你脑中吗？
vector<int> v;
int x, y;
...
v.erase(
	remove_if(find_if(v.rbegin(), v.rend(),
				bind2nd(greater_equal<int>(), y)).base(),
				v.end(),
				bind2nd(less<int>(), x)),
				v.end());
//这是一种你可以使用的方法。（注释不光为了本书。我也会把它们放入代码。）
typedef vector<int>::iterator VecIntIter;
// 把rangeBegin初始化为指向最后一个// 出现一个大于等于y的值后面的元素。// 如果没有那样的值，// 把rangeBegin初始化为v.begin()。如果那个值的// 最后一次出现是v中的最后一个元素，// 就把rangeBegin初始化为v.end()。
VecIntIter rangeBegin = find_if(v.rbegin(), v.rend(),
					bind2nd(greater_equal<int>(), y)).base();
// 从rangeBegin到v.end()，删除所有小于x的值
v.erase(remove_if(rangeBegin, v.end(), bind2nd(less<int>(), x)), v.end());

//当转换代码时，要注意我并没有放弃算法并试图自己写的循环。条款43解释了为什么那一般是一个劣等的选择，它的论点在这里。当写源代码时，目标是写出对编译器和人都有意义的代码，并提供可接受的性能。算法基本上总是最好地达到那个目标的方式。但是，条款43也解释了增加算法的时候会自然导致增加嵌套函数调用并大量使用绑定器和其他仿函数适配器。再看看本条款开头的问题描述：
//假设你有一个vector<int>，你想去掉vector中值小于x而出现在至少和y一样大的最后一个元素之后的所有元素。
//一个方案的轮廓跳入脑中：
//(1)找到vector中一个值的最后一次出现需要用逆向迭代器调用find或find_if的某种形式。 
//(2)去掉元素需要调用erase或erase-remove惯用法。 

//一旦你完成了这个，确定something就不是很难了，下一个事情你是知道的，你有原例中的代码。那是为什么这种语句一般被称为“只写（write-only）”代码。当你写代码时，它似乎很直截了当，因为它是一些基本想法（也就是，erase-remove惯用法加上使用逆向迭代器调用find的想法）的自然产物。但是，读者们很难把最后的产物分解回它基于的想法。这就被称为只写代码：很容易写，但很难读和理解。

//代码是否是只写依赖于读它的人。正如我提到的，有些C++程序员不反感本条款中的代码。如果这是你工作环境的典型而且你希望它在未来也典型，那就自由释放出你最多的高级STL编程爱好。但是，如果你的同时不适应函数式编程风格而且STL经验很少，收回你的野心，写一些接近我前面演示的两条语句的方法的东西。

//代码的读比写更经常，这是软件工程的真理。也就是说软件的维护比开发花费多得多的时间。不能读和理解的软件不能被维护，不能维护的软件几乎没有不值得拥有。你用STL越多，你会感到它越来越舒适，而且你会越来越多的使用嵌套函数调用和即时（on the fly）建立函数对象。这没有什么错的，但永远记住你今天写的代码会被某个人――也可能是你――在未来的某一天读到。为那天做准备吧。

//当然，使用STL，好好使用，有效使用。但避免产生只写代码。最后，这样的代码完全不高效。
//------------------------------------------------------------------------------------------------
//Effective STL 条款49：学习破解有关STL的编译器诊断信息
//这里有一些应该能帮助你理解有关STL的编译器消息的其它提示：
//(1)对于vector和string，迭代器有时是指针，所以如果你用迭代器犯了错误，编译器诊断信息可能会提及涉及指针类型。例如，如果你的源代码涉及vector<double>::iterator，编译器消息有时会提及double*指针。（一个值得注意的例外是当你使用来自STLport的STL实现，而且你运行在调试模式。那样的话，vector和string的迭代器干脆不是指针。对STLport和它调试模式的更多信息，转向条款50。） 
//(2)提到back_insert_iterator、front_insert_iterator或insert_iterator的消息经常意味着你错误调用了back_inserter、front_inserter或inserter，一一对应，（back_inserter返回back_insert_iterator类型的对象，front_inserter返回front_insert_iterator类型的对象，而inserter返回insert_iterator类型的对象。关于使用这些inserter的信息，参考条款30。）如果你没有调用这些函数，你（直接或间接）调用的一些函数做了。 
//(3)类似地，如果你得到的一条消息提及binder1st或binder2nd，你或许错误地使用了bind1st或bind2nd。（bind1st返回binder1st类型的对象，而bind2nd返回binder2nd类型的对象。） 
//(4)输出迭代器（例如ostream_iterator、ostreambuf_iterators（参见条款29），和从back_inserter、front_inserter和inserter返回的迭代器）在赋值操作符内部做输出或插入工作，所以如果你错误使用了这些迭代器类型之一，你很可能得到一条消息，抱怨在你从未听说过的一个赋值操作符里的某个东西。为了明白我的意思，试着编译这段代码： 
vector<string*> v;					// 试图打印一个
copy(v.begin(), v.end(),				// string*指针的容器，
	ostream_iterator<string>(cout, "\n"));	// 被当作string对象
错误信息如下：c:\program files\microsoft visual studio 10.0\vc\include\xutility(2144): error C2679: 二进制“=”: 没有找到接受“std::basic_string<_Elem,_Traits,_Ax> *”类型的右操作数的运算符(或没有可接受的转换)	
//(5)你得到一条源于STL算法实现内部的错误信息（即，源代码引发的错误在<algorithm>中），也许是你试图给那算法用的类型出错了。例如，你可能传了错误种类的迭代器。要看看这样的用法错误是怎样报告的，通过把这段代码喂给你的编译器来启发（并愉快！）自己： 
list<int>::iterator i1, i2;		// 把双向迭代器
sort(i1, i2);			// 传给一个需要
					// 随机访问迭代器的算法
错误信息如下：c:\program files\microsoft visual studio 10.0\vc\include\algorithm(3642): error C2784: “_RanIt1::difference_type std::operator -(std::move_iterator<_RanIt> &,const std::move_iterator<_RanIt2> &)”: 未能从“std::_List_iterator<_Mylist>”为“std::move_iterator<_RanIt> &”推导 模板 参数					
//(6)你使用常见的STL组件比如vector、string或for_each算法，而编译器说不知道你在说什么，你也许没有#include一个需要的头文件。正如条款48的解释，这问题会降临在长期以来都可以顺利编译而刚移植到新平台的代码。 
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款1 Iterator
使用iterator时，务必清楚以下四点：
(1)有效的数值：这个iterator可以解引用吗？如果你写*e.end()，绝对是个错误
(2)有效的寿命：这个iterator被使用时还有效吗？或者它已经因为某些操作而变得无效了。（如经过序列容器插入删除操作之后）
(3)有效的范围：一对iterators是否组成一个有效范围？是否first真的在last之前（或相等）？是否两者指向同一个container？
(4)不合法的操作行为：程式码是否企图修改内建型别的暂时物件，像--e.end()这样？（幸运的是编译器通常能够捕捉这种错误。至于【指向class型别】（而非内建型别）的iterator，程式库作者往往会允许这种事情发生，为的是语法层面上的方便性）
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款2~3 不区分大小写的string(Case-Insensitive Strings)
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

struct ci_char_traits: public char_traits<char>
{
	static bool eq(char c1, char c2)
	{
		return toupper(c1) == toupper (c2);
	}
	static bool ne(char c1, char c2)
	{
		return toupper(c1) != toupper (c2);
	}
	static bool lt(char c1, char c2)
	{
		return toupper(c1) < toupper(c2);
	}
	static int compare(const char *s1, const char *s2, size_t n)
	{
		return _memicmp(s1, s2, n);
	}
	static const char* find(const char *s, int n, char a)
	{
		while (n-- > 0 && toupper(*s) != toupper(a))
		{
			++s;
		}
		return s;
	}
};

typedef basic_string<char, ci_char_traits> ci_string;

int main () 
{
	ci_string s1("ABC");
	ci_string s2("abc");
	cout << (s1 == s2) << endl;
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款4~5：具有最大可复用性的通用Containers
//模板类的拷贝构造函数和赋值操作成员函数模板实际上不是拷贝构造函数和赋值操作函数！
//因为真正的拷贝构造函数或者赋值操作符只对完全相同类型的对象以构造或者赋值操作，并且，如果是一个模板类的话，模板的参数也都必须完全相同
#include <iostream>
using namespace std;

template<typename T>
class Test
{
	template<typename T2>
	friend class Test;
public:
	Test(T i): i_(i)
	{
		cout << "construction function" << endl;
	}
	template<typename T3>
	Test(const Test<T3>& test): i_(test.i_)
	{
		cout << "not real copy construction function" << endl;
	}
private:
	T i_;
};

int main () 
{
	Test<int> intTest(3);
	Test<double> doubleTest(intTest);

	Test<int> intTest2(intTest);
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款6：临时对象
(1)请使用const &而不是传值拷贝
(2)请使用先增操作，避免使用后增操作
(3)时刻注意因为参数转换操作而产生的隐藏的临时对象。一个避免它的好办法就是尽可能显式（explicit）的使用构造函数（constructor）
(4)请遵循所谓的“单入口/单出口”规则。绝不要在一个函数里面写有多个return语句？？？
(5)绝对不要返回局部对象的引用
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款20：CLASS技术
//注意operator+和operator+=，前者是以后者为实现基础的
//(1)一元运算子应该是members
//(2)= () [] ->必须是members
//(3)assignment版的运算子(+= -= /= *=等等)都必须是members
//(4)其他所有二元运算子都应该是nonmembers
//operator<<不应该成为一个member function，nonmember operator<<通常应该以一个member function(往往virtual)为实现基础，后者负责真正的工作，常取名为Print()//搜索return c.print(s);
T& T::operator+=(const T& other)
{
	//...
	return *this;
}
const T operator+(const T& a, const T& b)
{
	T temp(a);
	temp += b;
	return temp;
}

ostream& operator<<(ostream& os, const T& a)
{
	os << ...
	return os;
}
istream& operator>>(instream& is, T& a)
{
	is >> ...
	return is;
}

T& operator++()//前置一元操作符返回非const引用
{
	//...
	return *this;
}

const T operator++(int)//后置一元操作符返回const非引用临时对象，因为是临时对象，所以不可以加&，又因为是临时对象，所以要加const，表示不可修改，如果不加，修改了，也没有效果
{
	T temp = *this;//T temp(*this);
	++*this;
	return temp;
}

//标准库中的复数类
#include <iostream>
#include <complex>
using namespace std;

int main () 
{
	complex<int> com(3, 4);
	complex<int> com2(3, 4);
	cout << com*com2 << endl;
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款21：改写虚拟函式
//三个常见术语：
//(1)所谓overload(重载)一个函数f()，意思是在同一个scope内提供另一个同名（但有不同的参数型别）的函数。当f()被呼叫，编译器会根据实际提供的参数类型，设法选择最吻合的一个
//(2)所谓override(改写)一个虚拟函数f()，意思是在derived class内提供一个名称相同，参数类型也相同的函数
//(3)所谓hide(遮掩)一个函数f()，意思是在一个外围scope（如 base class或outer class或namespace）的内层spope（如derived class或nested class或namesapce）中提供一个同名函数。它会将外围scope的那个同名函数遮掩掉（使它不可见）
#include <iostream>
#include <complex>
using namespace std;

class Base
{
public:
	virtual void f(int)
	{
		cout << "base::f(int)" << endl;
	}
	virtual void f(double)
	{
		cout << "base::f(double)" << endl;
	}
	virtual void g(int i = 10)
	{
		cout << "base::g(): i = " << i << endl;
	}
};

class Derived: public Base
{
public:
	//using Base::f;//如果坚持要把Base::f带进Derived scope内，可以用using声明（就算用using Base::f声明了，如果调用d.f()，也会先在Derived scope中进行搜索f函数，如果没找到，再在Base::f中搜索，此时并不会造成二义性，根据接口原则，当一个函数是一个class的组成部分时，成员函数与class之间有比非成员函数更强的关联关系），或者通过d.Base::f()和pToDerived->Base::f()的调用方式
	virtual void f(complex<double>)//这个f不会重载Base::f（不是同一个scope），也不是Base::f的虚拟形式（参数类型不同，唯一可以参数类型不同的虚函数是返回类型不同），而是会虚掩掉。如果要谨慎而偷窥地遮掩base class内的某个名称，比较干净的做法是把该函数声明为private
	{
		cout << "derived::f(complex)" << endl;
	}
 	/*virtual void f(int)
	{
		cout << "derived::f(int)" << endl;
	}
	virtual void f(double)
	{
		cout << "derived::f(double)" << endl;
	} */
	virtual void g(int i = 20)
	{
		cout << "derived::g(): i = " << i << endl;
	}
};

int main () 
{
	Base b;
	Derived d;
	Base* pb = new Derived;
	b.f(1.0);
	d.f(1.0);
	pb->f(1.0);//因为派生类中并没有和Base中一样的虚函数，所以该调用会调用Base::f，如果派生类中声明virtual f(double)和virtual f(int)，则会动态绑定
	b.g();
	d.g();
	pb->g();//调用的是派生类的函数，参数却是基类参数！
	delete pb;//不安全，删除指向派生类的基类指针，则基类应该有虚析构函数。如果基类没有数据成员，则单继承看不出有什么问题，但是是多重继承肯定有问题
}
//------------------------------------------------------------------------------------------------
//Execptional C++ 条款22：Classes之间的关系（一）
当我们希望模塑出“is implemented in terms of”的关系时，请选择membership/aggregation（组合）而不要使用inheritance（私有继承）。只有在绝对必要的情况下才使用private inheritance――也就是说当你需要存取protected members或是需要改写虚函数时。绝对不要只为了重复运用程式码而使用public inheritance（d is a b）
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款23：Classes之间的关系（二）
为了广泛运用classes，最好使用【编译器防火墙】手法（compiler-firewall idiom，或称为Pimpl Idiom）来遮掩实现细节。使用一个不透明指标（此指标指向一个已宣告而未定义的class），将之宣告为“struct XxxxImpl* pimpl_”，用来存放private members（包括state variables和member functions）。例如“class Map{private: struct MapImpl* pimpl_;};”
记住计算机科学的箴言：大部分问题都可以藉由【多加一层间接性】获得解决
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款24：使用/滥用继承
(1)Nonpublic inheritance应该总表现“根据某物实做出(is-implemented-in-terms-of)”的意义（）。它可以使用基类的public/protected成份
(2)Containment总表现出“有一个（has-a）”的意义，连带也有“根据某物实作出(is-implemented-in-terms-of)“的意义。它可以使用基类的public成份
可以看出，inheritance是single containment的一个超集，也就是说，没有什么是可以用一个MyList<T> member组合完成而却无法以”继承自MyList<T>“完成的事。当然，inheritance的运用造成我们只能拥有一份MyList<T>(作为base subobject)；如果需要拥有多份MyList<T>实体，就必须改用containment
设计准则：尽量采用aggregation(又名”composition“，”layering“，”has-a“，”delegation“)来取代inheritance。当我们准备模塑”is-implemented-in-terms-of“关系时，尽量采用aggregation而不要使用inheritance
//在inheritance比较合适的情况下，有下例
class Base
{
public:
	virtual int Func1();
protected:
	bool Func2();
private:
	bool Func3();//
};
//如果必须要改写虚函数Func1，或存取protected member如Func2，就必须采用inheritance不可，如下写Derived
class Derived: public Base
{
public:
	virtual int Func1();
	//...其他函数，其中某些使用了Base::Func2()，另外某些则不用
};
//这份代码允许Derived改写Base::Func1，那很好。不幸的是，它也允许让所有的Derived members取用Base::Func2。或者只有一些（或甚至一个）Derived member functions真正需要取用Base::Func2。但是通过上面的继承机制，我们却让所有的Derived members仰赖Base的protected interface，那是不必须的。
//很明显，inheritance是有必要，但是只导入我们真正需要的耦合就好了
class DerivedImpl: private Base
{
	virtual int Func1();
	//...这里的函数需要使用Func2
};

class Derived
{
//...这里的函数不需要使用Func2...
private:
	DerivedImpl impl_;
};
//这个设计好多了，因为它良好地隔离并封装了对Base的依存性。Derived只直接依赖Base的public函数及DerivedImpl的public函数。这个设计成功的原因是：它遵循了”一个class一个任务“的基本设计准则。在前一个设计中，Derived的任务是同时订制Base并以Base为基础实现自己，在这个设计中，那些都被很好地分隔开了。
现在再来看组合的情况，组合有它自己的某些优点，第一，它允许我们拥有多个used class实体，这对inheritance而言并不实用，甚至不可能
如果你既需要衍生又需要多份实体，请使用上例所展示的手法：衍生一个辅助类别（如DerivedImpl）负责继承事务，然后再在这辅助类别中内含多个实体。
第二，它令used class成为一个data member，这带来更多弹性。那个member可以在一个Pimpl之中被隐藏于编译器防火墙后面（然而base class的定义必须总是可见），而且如果有必要在执行期被改变的话，它甚至可以轻易地被转换为一个指针。（继承体系是静态的并于编译期就固定了）

关于public inheritance，记住：永远只把public inheritance用来模塑真正的is-a关系！也就是说任何情况下，只要可以使用基类对象的地方，就可以使用public类派生对象。
(1)如果非公有继承可以用，就绝对不要考虑公有继承。公有继承绝不应该在缺乏真正is-a关系的情况下被拿来模塑is-implemented-in-terms-of关系。另一个忠告：当好的旧的组合还可以用时，绝不要使用继承。如果不需要额外的存取能力或是更紧绷的耦合性，就不要使用它。
(2)如果class相互关系可以多种方式来表现，请使用其中最弱的一种关系。绝对不要以公有继承来实现”is-almost-a“的关系。很多经验丰富的程序员，以public方式继承一个base，并以”保存base class的语意“的方式改写大部分虚函数，然后在此情况下，某些时候以Derived object做为一个Base object，其行为并不完全是Base的client所期望。例，从Rectangle class身上衍生下来Square class。正方形是矩形，这在数学上或者为真，但在classes的世界中不一定为真。如Rectangle class有一个虚函数SetWidth(int)。并不改变高度，但是此时如果有一个代码，以多态方式运用Rectangle objects，并不预期宽度的改变也会影响高度，毕竟那对矩形而言并不是真的，但是如果动态对象是Squre，则public inheritance违反了LSP的一个好例子，因为derived class并未陈述与base class相同的语义。它违反了public inheritance的关键诫律：不要求更多，也不承诺更少。

LSP-Liskov Substitution PrincipleLiskov 定义：如果对于类型S的每一个对象o1，都有一个类型T的对象o2，使对于任意用类型T定义的程序P，将o2替换为o1，P的行为保持不变，则称S为T的一个子类型。 子类型必须能够替换它的基类型。LSP又称里氏替换原则里氏替换原则里氏替换原则里氏替换原则。
对于这个原则，通俗一些的理解就是，父类的方法都要在子类中实现或者重写

设计准则：
(1)总是确定public inheritance用以模塑is-a和works-like-a的关系，并符合LSP。所有被改写的member functions都必须“不要求更多，也不承诺更少”。
(2)绝对不要为了重复使用base class中的代码而使用public inheritance。Public inheritance的目的是为了被既有代码以多态方式重复运用base objects。
明智地运用inheritance。如果能够单独以组合表现出某个class相互关系，应该那么做。如果需要inheritance但不想模塑出is-a的关系，请使用nonpublic inheritance。如果不需要多重继承，请使用单一继承。一般而言，大而深的继承体系特别难以理解，因此也难以维护。Inheritance是一个设计期的决定，必须舍去许多执行期的弹性。
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款26~28：编译期的依赖性
有一个（也只有一个）主要的原因使我们在派生类的时候使用private继承，那就是想要重载虚函数。所以如果私有继承的一个基类没有虚函数，则更应该让这个基类成为原派生类的一个私有数据成员
头文件包含：
(1)函数声明中用到的类型不需要包含其头文件，只需要一个类型声明
(2)数据成员对象需要头文件，因为需要知道其大小，如果是数据成员指针对象则不需要包含头文件，也只需要一个类型声明
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款29：编译级防火墙
使用一种常见的技术就是利用一个不透明指针来隐藏一部分实现细节：
这是“句柄/本体”惯用法（handle/body idiom）的一种变体，这种方法主要用于在共享代码的情况下进行引用计数。
“句柄/本体”惯用法（表现为所称为的“pimpl惯用法”之形式；这样的叫法缘自给其特意取的、易发音的“pimpl_”指针）对于打破编译期的依赖性也是非常有用的

私有虚函数有什么用？
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款30：“Fast Pimpl”技术
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款31：名称搜索
Koening Lookup（简化版）：如果你给函数提供一个class类型的实参，那么在名称搜索时，编译器将认为包含参类型的命名空间中的同名函数为可选函数。
简单来说，Koenig lookup指的是：如果函数的参数类型定义在名字空间内，那么函数被调用时，首先应该在此名字空间内搜索被调用函数，然后再是其他地方。比如调用“std::cout << someObject”，应该首先在定义someObject的名字空间内搜索操作符“<<”的实现。像<<这样的操作符函数，如果在被它操作的类型的名字空间内也有定义，Koenig lookup就发挥作用了。 
#include <iostream>
#include <string>//这个头文件中声明了对于输出string类型的std::operator<<重载，通过Koenig Lookup就可以不用声明这个<<而可以直接用其输出string

int main()
{
	std::string s("abc");
	std::cout << s << std::endl;//如果没有Koenig Lookup，则必须写std::operator<<(std::cout, s);这样会很麻烦
}

//一个标准C++的例子：
#include <iostream>
using namespace std;

namespace NS 
{
	class T 
	{
	public:
		T(): i_(0)
		{
			cout << "construct" << endl;
		}
		void show()
		{
			cout << "i = " << i_ << endl;
		}
	private:
		int i_;
	};
	void f(T& t)
	{
		t.show();
	}
}

int main()
{
	NS::T parm;
	f(parm);//ok, calls NS::f
}
//如果有两个候选函数，并且编译器无法选出哪个更合适，则会造成二义性，如下：
#include <iostream>
using namespace std;

namespace NS 
{
	class T 
	{
	public:
		T(): i_(0)
		{
			cout << "construct" << endl;
		}
		void show()
		{
			cout << "i = " << i_ << endl;
		}
	private:
		int i_;
	};
	void f(T& t)
	{
		t.show();
	}
}

void f(NS::T& t)
{
	t.show();
}

int main()
{
	NS::T parm;
	f(parm);//编译不通过，函数调用不明确，这时候需要指明调用的是哪个f，::f(parm)或NS::f(parm)
}

#include <iostream>
using namespace std;

namespace A 
{
	class T 
	{
	public:
		T(): i_(0)
		{
			cout << "construct" << endl;
		}
		void show()
		{
			cout << "i = " << i_ << endl;
		}
	private:
		int i_;
	};
	void f(T& t)
	{
		t.show();
	}
}

namespace B
{
	void f(A::T& t)
	{
		t.show();
	}
	void g(A::T& t)
	{
		f(t);//编译报错，函数调用不明确，必须指明是A::f(t)还是B::f(t)
	}
}

int main()
{

}

//如果把命名空间B换成class B则没有二义性问题
#include <iostream>
using namespace std;

namespace A 
{
	class T 
	{
	public:
		T(): i_(0)
		{
			cout << "construct" << endl;
		}
		void show()
		{
			cout << "i = " << i_ << endl;
		}
	private:
		int i_;
	};
	void f(T& t)
	{
		t.show();
	}
}

class B
{
	void f(A::T& t)
	{
		t.show();
	}
	void g(A::T& t)
	{
		f(t);//没问题，根据接口原则，当一个函数是一个class的组成部分时，成员函数与class之间有比非成员函数更强的关联关系
	}
};

int main()
{

}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款32~34：接口原则
接口原则：
对于一个类X，所有的函数，包括自由函数，只要同时满足：
（a）“提到”X，并且
（b）与X“同期提供”
那么这些函数就是X的逻辑组成部分，因为它们形成了X的接口。
Koenig Lookup是一个例子
总结：如果你在同一命名空间中提供一个class和一个“提及”此class的自由函数，编译器在两者间建立一个强关联。

//在如何实现一个class的operator<<方法上，有两种，第一种：
class X
{
	//ostream is never mentioned here
};

ostream& operator<<(ostream& o, const X& x)
{
	//...
	return o;
}
//第二种：
class X
{
pubic:
	virtual ostream& print(ostream& o)
	{
		//...code to output an X to a stream
		return o;		
	}
};

ostream& operator<<(ostream& o, const X& x)
{
	return x.print();
}

运用接口原则：
（1）根据接口原则，只要operator<<“提及”了X（两种情况下都是如此）并且与X“同期提供”（两种情况下都是如此），它就是X的逻辑组成部分。
（2）两种情况下，operator<<都“提及”了流，所以operator<<依赖流。
（3）因为两种情况下operator<<都是X的逻辑组成部分且都依赖于流，所以，两种情况下X都依赖于流。
所以，我们素来认为的第一种选择不依赖流的好处根本不存在――两种情况下X都依赖于流！如果operator<<和X出现在相同的X.h中，两种情况下X的实现体和使用了X的实体的用户模块都依赖流，并至少需要流的前身申明以完成编译。
随着第一大好处的破灭，选择第一种就只剩下没有虚函数调用开销的好处了。不借助于接口原则的话，我们就没法如此容易的在这个很常见的例子上分析依赖性上的真象（以及事实上的取舍）。
底线：区分成员还是非成员没有太大的意义（尤其是分析依赖性时），而这正是接口原则所要阐述的
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款35：内存管理（一）
常量数据区
栈区
自由存储区
堆区
全局/静态区
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款36：内存管理（二） 没太看懂？
void operator delete(void*, size_t);
void operator delete[](void*, size_t);
//两种都是正常的回收函数，而不是placement deletes(深度探索C++对象模型6.2节)。（与More Effective C++ 9.3 sidebar : Placement new 与 placement delete中说法不太一样？？？）

//通过基类指针删除派生类对象时，如果有virtual ~B()，那么即使B::operator delete()不声明成virtual，D::operator delete()也必将必调用
//多态和指针算法不能混合使用，数组和多态也不能混合使用More Effective C++ M3，M33

B b;
typedef void (B::*PMF)(void*, size_t);
PMF p1 = &B::f;//合法
PMF p2 = &B::operator delete;//不合法
//第一个赋值语句没问题，第二个不合法，因为“void operator delete(void*, size_t) throw()”并不是B的成员函数，即使它被写在B中使其看上去很像是。这里一个小伎俩需要弄清楚，即new和delete总是静态的，即使它们不被显式的声明为static。总是把它们声明为static是个很好的习惯 ，这可以让所有阅读你代码的程序员明白无误地认识到这一点。
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款37：auto_ptr
class C
{
public://...
private:
	auto_ptr<CImpl> pimpl_;
};
//auto_ptr以前是，现在仍然是对指针成员的有效封装。它工作得非常象我们在开始处的“背景”一段中提起的例子，只是用不需要在C的析构函数中应付执行清楚工作的麻烦替换了不需要在函数结束时执行清理工作的麻烦（以防构造函数或者成员函数中抛异常导致初始化的动态内存无法自动释放）。这儿仍然有一个警告，就如同仍然使用的是普通成员指针成员一样，必须处理拷贝构造函数和赋值函数（哪怕是用申明它们为私有而不定义它们的方法来禁止它们），因为默认版本的行为是错误的。
//const auto_ptr的习惯用法
const auto_ptr<T> pt1(new T);
auto_ptr<T> pt2(pt1);//illegal
auto_ptr<T> pt3;//auto_ptr对象没有=初始化的函数
pt3 = pt1//illegal
//这个“const auto_ptr”的习惯用法可能成为常用技巧之一！
//------------------------------------------------------------------------------------------------
//Effective C++ 条款17 独立语句将newed对象植入智能指针 
show(std::tr1::shared_ptr<Widget>(new Widget), priority());
//这条语句可能造成内存泄露，调用函数之前可能先new，然后调用priority()，然后再构造shared_ptr对象，但是可能在函数priority()调用中抛异常，导致new出来的内存无法释放，所以最好以独立语句将new出来的对象放入智能指针中
std::tr1::shared_ptr<Widget> pW(new Widget);
show(pW, priority());
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款39：自动转换
//如果有从string到const char*的自动转换，则如下代码可以编译，然而却完成了与预期完全不同的操作：
string s1, s2, s3;
s1 = s2 - s3;
//其中的减法毫无意义，本来想要“+”，应该是错误的，但是如果存在从string到const char*的隐式转换，那么这段代码就会被编译通过，将两个string转换为const char*，然后对两个指针施以相减操作
//小结：避免编写转换运算符
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款40：对象的生存期（一）
class Base
{
public:
	~Base(){}
}

class Derived: Base
{
public:
	~Derived() {}
}

void main()
{
	Derived d;
	d.~Derived();//可以显示调用析构函数，这时会先调用派生类析构函数，然后调用基类析构函数，但是如果没有给d再次构造对象的话，自动对象在离开作用域之后会再次再析构一次，这将造成不可预见的副作用。所以这样写代码是一个坏习惯，如果将这种代码写在基类成员函数中，则派生类调用这种函数也会将Base对象写在Derived对象内存中，后果不堪设想。在定位new操作中用到过这种写法。
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款41：对象的生存期（二）
接上条款，构造操作和析构操作的含义：构造操作和析构操作分别准确的对应于对象生存期的开始和结束，对象通常分别在这两个时刻获取和释放资源。构造操作和析构操作不是用来改变对象值的操作（实际上它们压根儿也不会改变对象的值，它们只是销毁原来的对象并替换上一个看起来一样、恰好拥有新数值的东西，其实这个新的东西与原来的对象根本就不是一回事儿）。

不可靠的指针比较：C++保证【对指向同一个对象的多个指针的比较之结果必须是“相等”】，但却并不保证【对指向不同对象的多个指针的比较之结果必须是“不相等”】。如果这种情况发生，用指针比较的赋值操作就无法如愿完成。
GotW条款11中的简要论述：所有“必须”检查自赋值（self-assignment）的拷贝赋值操作都不是异常安全的。

这里的惯用法：拷贝构造操作应该以拷贝赋值操作来实现。（与之前看的copy and swap异常安全方法相反？）

摘自GotW编码标准：
如果需要的话，请编写一个私有函数来使拷贝操作和拷贝赋值共享代码；千万不要利用【使用显式的析构函数并且后跟一个placement new】的方法来达到【以拷贝构造操作来实现拷贝赋值操作】这样的目的，即使这个所谓的技巧会每隔三个月就在新闻组中出现几次。（也就是说，决不要编写如下的代码：）
T& T::operator=(const T& other)
{
	if(this != &other)
	{
		this->~T();
		new (this) T(other);
	}
	return *this;
}

摘自GotW编码标准：
(1)将拷贝赋值操作声明为“T& T::operator=(const T&)”；（这说明了赋值操作是有返回值的，正是while(k = 0){}循环一次都不执行的原因）
(2)不要返回const T&，尽管这样做避免了诸如“(a = b) = c”的用法；这样做意味着：你无法出于移植性的考虑而将T对象放入标准程序库之容器――因为其需要赋值操作返回一个单纯的T&。
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款42：变量的初始化
SomeType t = u;//这是拷贝初始化，变量t通过SomeType的拷贝构造函数（Copy Constructor）被初始化。（注意，这条语句虽然含有“=”，但仍然是一个初始化操作，而不是一个赋值操作，因为在这里，允许使用'='只是为了可以沿用C语言的语法，operator=是不会被调用的）。如果u恰好也是SomeType类型，那么这条语句与"SomeType(u);"是等同的，将调用SomeType的拷贝构造函数（Copy Constructor）。如果u是SomeType以外的其它类型，那么这条语句与“SomeType t(SomeType(u))”是等同的。可以看到，在语句“SomeType t(SomeType(u))”里，u被转换成一个临时的SomeType对象，而t则是由此拷贝构造出来的
SomeType t(u);//这是直接初始化，变量t通过构造函数SomeType::SomeType(u)被初始化
SomeType t();//骗局，这是一个函数声明，声明了一个函数t，没有参数，返回值类型为SomeType，在一条语句可以理解为函数声明和变量声明时，编译器优先选择为函数声明
SomeType t;//变量t被缺省构造函数SomeType::SomeType()初始化
【学习指导】：建议总是使用“SomeType t(u)”的形式，一来是因为只要可以用“SomeType t = u”的地方也同样可以用它；二来因为它还有一些其它的优点，比如支持多个参数等。
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款43：正确使用const
【学习指导】：在函数对非内建（non-built-in）的类型采用值返回（return-by-value）的方法时，最好让函数返回一个const值。
6. 类中一定要让成员函数本身被声明为const？
void show(const int num);//int参数是值传递，加const毫无意义，不会对性能有显著影响
void show(SomeType* const pSomeType);//同上，指针并没有传引用，加const没意义。（这里想表达的是指针不可变）
void show(SomeType& const someType)//这里的const毫无作用，因为无论如何一个引用是不可能被改变使其指向另一个对象的。（这里想表达的是引用不可变，引用本来就不可变）

//另外，对于const对象的修改
class SomeType {};

void show(const SomeType& someType)
{
	//...做一些可以修改someType的操作，如const_cast<SomeType&>(someType).SomeFunction();
}

void main()
{
	SomeType someType1 = 3;
	const SomeType someType2 = 3;
	show(someType1);//没有问题
	show(someType2);//在这里，show()企图放弃const属性从而修改其参数的时候，会产生不确定的结果（我自己测试int可以编译运行，但是int值并没有被修改，见下例），所以要么不要给someType2加const修饰，要么就去掉show()参数的const修饰，修改为void show(SomeType& someType)，这时候带有const的someType2就无法传进show中，编译不通过
}

#include <iostream>
using namespace std;

void modify(const int& num)
{
	const_cast<int&>(num) = 2;
}

int main()
{
	const int a = 3;
	modify(a);
	cout << a << endl;
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款44：类型转换
//C++风格中的类型转换只有dynamic_cast不能与C的转型相对应，其它的新风格转型（static_cast, const_cast, reinterpret_cast）都可以与C的转型相对应
//const_cast<>()只能对引用或指针对象使用，即()中对象必须是引用对象或者指针对象，如有一个int对象a，int引用对象ra ，则const_cast<int*>(&ra)正确
#include <iostream>
using namespace std;

int main()
{
	int a = 3;
	const int &ra = a;
	int &b = const_cast<int&>(ra);
	b = 2;
	cout << a << endl;
	cout << b << endl;

	int *p = const_cast<int*>(&ra);//这一句合法，但是使用转型来去掉const-ness（常量性）是潜在的不良风格的体现。
	*p = 1;
	cout << a << endl;

	const int a2 = 5;
	int *pA2 = const_cast<int*>(&a2);//对于const object对象使用const_cast，结果未定义，见上一条款43：正确使用const，要明白其原因，可以试想如果一个编译器了解到“a2是作为const object而被创建的”这个情况，并出于优化的考虑而将其放在只读存储区，会发生什么事情。所以，想通过转型而去掉这样一个对象的const属性是危险的。如果想使用const_cast把一个non_const指针转型为一个const指针，这样做是多此一举的，将一个non_const指针赋值给一个const指针，这本来就是合法的。我们只需要使用const_cast做相反的操作。
	*pA2 = 6;
	cout << a2 << endl;
}

//完全不相关类型的转换用reinterpret_cast
#include <iostream>
using namespace std;

int main()
{
	int a = 3;
	unsigned int* pUI = reinterpret_cast<unsigned int*>(&a);//这里两处不能用static_cast，尽管int, unsigned int和signed int之间存在隐式转换，但是它们三个也是互无联系，区别开来的类型，因而指针它们的指针也是互无联系的，不同类型的对象转换要用reinterpret_cast
	signed int* pSI  = reinterpret_cast<signed int*>(&a);
	
	void* pv = static_cast<void*>(&a);//这里的转型不必要，本来就有一个对象指针到void*的隐式转换，可以写成void* pv = &a;
	int* pi = static_cast<int*>(pv);//从void*到int*必须要用static_cast转换
}
//dynamic_cast用于基类向派生类转换，也是只能用于&和*
//(1)但是如果涉及转型的类没有虚函数，则所有对dynamic_cast的使用都是错的
//(2)另外必须是public派生，如果是private派生则非法。（派生类向基类的转换不需要用类型转换，可以直接用&取地址或指针赋值，但这种转型在C中是错误的）
//从基类到派生类的转换可以用static_cast来完成，当目标已经的时候，向下转型（downcast）可以是静态的，此时要注意：你这样等于是在告诉编译，你知道“被指针所指的正是那种类型”这个事实。如果你错了，那么这个转型将无法告知你已经出现的问题（dynamic_cast在转型失败的时候能返回一个null pointer以告知你出现了问题或者抛出一个异常bad_cast，标准的bad_cast异常类由此而来），于是你此时至多也只能得到各种不同的运行期错误以及或者程序崩溃。
#include <iostream>
using namespace std;

class A {virtual...};
class B: private A {virtual...};
class C: public A {virtual...};
class D: public B, public C {virtual...};
int main()
{
	B* pB1 = new B;
	A* pA1 = dynamic_cast<A*>(pB1);//private继承不可转换

	B* pB2 = new D;
	A* pA2 = dynamic_cast<A*>(pB2);//可以从B*->D*->C*->A*转换，dynamic_cast可以穿越继承层次进行交叉转型（cross-cast），因此这一句是合法的并可以成功执行
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ 条款47：控制流
列举了一些常见的错误
(1)不同编译单元的全局变量初始化顺序
(2)多重继承类的初始化顺序
(3)数据成员在初始化列表中的初始化顺序
(4)看到手动执行的new，delete就要想到中间过程是否会抛异常，是否会导致内存泄露
(5)assert()语句在非debug编译时会被编译器自动删掉；绝不要在对assert()的调用中加入有副作用的代码（如改变数据成员的值等操作）
(6)当重载了operator+后，两个参数如果是两个函数的话，无法决定先后顺序（内建operator+没有这个问题）
(7)函数参数的初始顺序不定，int f(int &x, int y = x);
(8)一条语句中的多个函数执行顺序不定
//------------------------------------------------------------------------------------------------
//ACE程序员指南 P212 基本的起线程方法
#include "ace/Task.h"

class HA_CommandHandler : public ACE_Task_Base
{
public:
	virtual int svc (void)
	{
		ACE_DEBUG
			((LM_DEBUG, ACE_TEXT ("(%t) Handler Thread running\n")));
		ACE_OS::sleep (4);
		return 0;
	}
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ACE_DEBUG
		((LM_DEBUG, ACE_TEXT ("(%t) Main Thread running\n")));

	HA_CommandHandler handler;
	int result = handler.activate ();
	ACE_ASSERT (result == 0);

	handler.wait ();
	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE程序员指南 P213 用互斥体保证只有一个线程可以访问资源
#include "ace/Task.h"

class HA_Device_Repository
{
public:
	HA_Device_Repository ()
	{ }

	void update_device (int device_id)
	{
		mutex_.acquire ();
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) Updating device %d\n"),
			device_id));
		ACE_OS::sleep (1);
		mutex_.release ();
	}
private:
	ACE_Thread_Mutex mutex_;
};

class HA_CommandHandler : public ACE_Task_Base
{
public:
	enum {NUM_USES = 10};

	HA_CommandHandler (HA_Device_Repository& rep) : rep_(rep)
	{ }

	virtual int svc (void)
	{
		ACE_DEBUG
			((LM_DEBUG, ACE_TEXT ("(%t) Handler Thread running\n")));
		for (int i=0; i < NUM_USES; i++)
			this->rep_.update_device (i);
		return 0;
	}

private:
	HA_Device_Repository & rep_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	HA_Device_Repository rep;
	HA_CommandHandler handler1 (rep);
	HA_CommandHandler handler2 (rep);
	handler1.activate ();
	handler2.activate ();

	handler1.wait ();
	handler2.wait ();
	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE程序员指南 P220 消息块 从ACE_Task继承
//用copy成员函数可以不用手工移动wr_ptr
ACE_Message_Block *mb;
ACE_NEW_RETURN (mb, ACE_Message_Block (128), -1);
const char *deviceAddr= "Dev#12";
mb->copy (deviceAddr, ACE_OS::strlen (deviceAddr)+1);

//用sprintf要手工移动wr_ptr
ACE_Message_Block *mb;
ACE_NEW_RETURN (mb, ACE_Message_Block (128), -1);
const char *commandSeq= "CommandSeq#14";
ACE_OS::sprintf (mb->wr_ptr (), commandSeq);
// Move the wr_ptr() forward in the buffer by the
// amount of data we just put in.
mb->wr_ptr (ACE_OS::strlen (commandSeq) +1);

//读消息块
ACE_DEBUG((LM_DEBUG,
           ACE_TEXT ("Command Sequence --> %s\n"),
           mb->rd_ptr ()));
mb->rd_ptr (ACE_OS::strlen (mb->rd_ptr ())+1);
mb->release ();

//设置消息类型
// Send a hangup notification to the receiver.
ACE_NEW_RETURN
  (mb, ACE_Message_Block (128, ACE_Message_Block::MB_HANGUP), -1);//ACE_NEW_RETURN (mb, ACE_Message_Block (ACE::strlen("This is message 1\n"), ACE_Message_Block::MB_HANGUP), -1);
// Send an error notification to the receiver.
mb->msg_type (ACE_Message_Block::MB_ERROR);

//中篇：ACE程序员教程P136
//消息队列
ACE_Message_Queue<ACE_NULL_SYNCH> *mq_;//这是未加锁模板的消息队列
//消息块进队列
if (mq_->enqueue_prio(mb) == -1)
{
	//could not enqueue
}
//消息块出列队
mq_->dequeue_head(mb)//这里的出队列操作并没有前移rd_ptr，直接release()了，不知道会不会有问题？

//中篇：ACE程序员教程P134
9.1.2 在消息块中插入和操作数据
除了构造器，ACE_Message_Block还提供若干方法来直接在消息块中插入数据。另外还有一些方法可用来操作已经在消息块中的数据。
每个ACE_Message_Block都有两个底层指针：rd_ptr和wr_ptr，用于在消息块中读写数据。它们可以通过调用rd_ptr()和wr_ptr()方法来直接访问。rd_ptr指向下一次读取数据的位置，而wr_ptr指向下一次写入数据的位置。程序员必须小心地管理这些指针，以保证它们总是指向正确的位置。在使用这些指针读写数据时，程序员必须自己来增加它们的值，它们不会魔法般地自动更新。大多数内部的消息块方法也使用这两个指针，从而使它们能够在你调用消息块方法时改变指针状态。程序员必须保证自己了解这些指针的变化。

9.1.2.1 拷贝与复制（Copying and Duplicating）
可以使用ACE_Message_Block的copy()方法来将数据拷贝进消息块。
int copy(const char *buf, size_t n);
copy方法需要两个参数，其一是指向要拷贝进消息块的缓冲区的指针，其二是要拷贝的数据的大小。该方法从wr_pt指向的位置开始往前写，直到它到达参数n所指示的数据缓冲区的末尾。copy()还会保证wr_ptr的更新，使其指向缓冲区的新末尾处。注意该方法将实际地执行物理拷贝，因而应该小心使用。
base()和length()方法可以联合使用，以将消息块中的整个数据缓冲区拷贝出来。base()返回指向数据块的第一个数据条目的指针，而length()返回队中数据的总大小。将base和length相加，可以得到指向数据块末尾的指针。合起来使用这些方法，你就可以写一个例程来从消息块中取得数据，并做一次外部拷贝。
duplicate()和clone()方法用于制作消息块的“副本”。如它的名字所暗示的，clone()方法实际地创建整个消息块的新副本，包括它的数据块和附加部分；也就是说，这是一次“深度复制”。而另一方面，duplicate()方法使用的是ACE_Message_Block的引用计数机制。它返回指向要被复制的消息块的指针，并在内部增加内部引用计数。

9.1.2.2 释放消息块
一旦使用完消息块，程序员可以调用它的release()方法来释放它。如果消息数据内存是由该消息块分配的，调用release()方法就也会释放此内存。如果消息块是引用计数的，release()就会减少计数，直到到达０为止；之后消息块和与它相关联的数据块才从内存中被移除。
//------------------------------------------------------------------------------------------------
//线程安全的栈类（.h文件和.c文件没分出来）
#include <iostream>
#include <stack>
#include <sstream>
#include <string>
#include "ace/Task.h"
#include "ace/Thread_Mutex.h"
#include "ace/RW_Thread_Mutex.h"
#include "ace/Guard_T.h"

ACE_Thread_Mutex outputMutex;

void printOutput(std::stringstream& ss)
{
	ACE_Guard<ACE_Thread_Mutex> outputGuard(outputMutex);
	std::cout << ss.str() << std::endl;
}

template<typename T>
class ThreadSafeStack
{
public:
	ThreadSafeStack(): stack_(), rwMutex_() 
	{ }

	ThreadSafeStack(const ThreadSafeStack<T>& threadSafeStack): 
	stack_(threadSafeStack.stack_), rwMutex_(threadSafeStack.rwMutex_)//感觉有问题，如何保证被拷贝对象threadSafeStack在拷贝时不会被操作？另外，rwMutex_是否被复制有关系吗？
	{ }

	ThreadSafeStack& operator=(const ThreadSafeStack<T>& threadSafeStack)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> copyConstructGuard(rwMutex_);
		stack_ = threadSafeStack.stack_;
		rwMutex_ = threadSafeStack.rwMutex_;
	}

	void pushIntoStack(const T& x)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> pushGuard(rwMutex_);
		stack_.push(x);
	}

	T popOutOfStack()
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> popGuard(rwMutex_);
		ifStackIsEmpty();
		T tmp = stack_.top();
		stack_.pop();
		return tmp;
	}

	T readTop()
	{
		ACE_Read_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);
		ifStackIsEmpty();
		return stack_.top();
	}

private:
	void ifStackIsEmpty()
	{
		if (stack_.empty())
		{
			throw std::string("empty!");
		}
	}
	std::stack<T> stack_; 
	ACE_RW_Thread_Mutex rwMutex_;
};

template<typename T>
class PushThread : public ACE_Task_Base
{
public:
	enum {NumOfPush = 10};

	PushThread (ThreadSafeStack<T>& threadSafeStack, const T& content, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), content_(content), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		for (int i = 1; i <= NumOfPush; ++i)
		{
			threadSafeStack_.pushIntoStack(content_);
			std::stringstream ss;			
			ss << "PushThread " << nthThread_ << " pushes " << content_ << " at the " << i << " time.";
			printOutput(ss);
			//ACE_OS::sleep(ACE_Time_Value(1));
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const T content_;
	const unsigned int nthThread_;
};

template<typename T>
class PopThread : public ACE_Task_Base
{
public:
	enum {NumOfPop = 10};

	PopThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		for (int i = 1; i <= NumOfPop; ++i)
		{
			try
			{
				T tmp = threadSafeStack_.popOutOfStack();
				std::stringstream ss;				
				ss << "PopThread " << nthThread_ << " pops " << tmp  << " at the " << i << " time.";
				printOutput(ss);
				//ACE_OS::sleep(1);
			}
			catch(std::string& e)
			{
				std::stringstream ss(e);
				printOutput(ss);
				return -1;
			}					
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
};

template<typename T>
class ReadThread : public ACE_Task_Base
{
public:
	enum {NumOfRead = 10};

	ReadThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		for (int i = 1; i <= NumOfRead; ++i)
		{
			try
			{
				T tmp = threadSafeStack_.readTop();
				std::stringstream ss;				
				ss << "ReadThread " << nthThread_ << " reads " << tmp  << " at the " << i << " time.";
				printOutput(ss);
				//ACE_OS::sleep(1);
			}
			catch(std::string& e)
			{
				std::stringstream ss(e);
				printOutput(ss);
				return -1;
			}					
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ThreadSafeStack<std::string> threadSafeStack;

	PushThread<std::string> pushThread1(threadSafeStack, "a", 1);
	PushThread<std::string> pushThread2(threadSafeStack, "b", 2);
	PopThread<std::string> popThread1(threadSafeStack, 1);
	ReadThread<std::string> readThread1(threadSafeStack, 1);
	
	readThread1.activate();
	pushThread1.activate();
	popThread1.activate();
	pushThread2.activate();
	//ACE_OS::sleep(4);
	

	pushThread1.wait();
	pushThread2.wait();
	popThread1.wait();
	readThread1.wait();
	return 0;
}
//--加入条件变量
#include <iostream>
#include <stack>
#include <sstream>
#include <string>
#include "ace/Task.h"
#include "ace/Thread_Mutex.h"
#include "ace/RW_Thread_Mutex.h"
#include "ace/Condition_T.h"
#include "ace/Guard_T.h"

ACE_Thread_Mutex outputMutex;

void printOutput(std::stringstream& ss)
{
	ACE_Guard<ACE_Thread_Mutex> outputGuard(outputMutex);
	std::cout << ss.str() << std::endl;
}

template<typename T>
class ThreadSafeStack
{
public:
	enum {maxStackSize = 2};
	ThreadSafeStack(): stack_(), rwMutex_(), conditionForPush_(rwMutex_), conditionForPop_(rwMutex_), conditionForRead_(rwMutex_), exitStatus_(false) 
	{ }

	ThreadSafeStack(const ThreadSafeStack<T>& threadSafeStack): 
	stack_(threadSafeStack.stack_), rwMutex_(threadSafeStack.rwMutex_), conditionForPush_(rwMutex_), conditionForPop_(rwMutex_), conditionForRead_(rwMutex_) 
	{ }

	//我的理解是：这里如果加上条件变量，则无法实现赋值操作了，条件变量的成员锁是&，必须在构造时创建好，没有办法为引用赋值，
	//所以这里无法写出赋值操作，不知道是否有什么好办法？
	/*ThreadSafeStack& operator=(const ThreadSafeStack<T>& threadSafeStack)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> copyConstructGuard(rwMutex_);
		stack_ = threadSafeStack.stack_;
		rwMutex_ = threadSafeStack.rwMutex_;
	}*/

	void pushIntoStack(const T& x)
	{
		ACE_Guard<ACE_Thread_Mutex> pushGuard(rwMutex_);
		while (maxStackSize == stack_.size() && !exitStatus_)
		{
			conditionForPush_.wait();
		}
		if (!exitStatus_)
		{
			stack_.push(x);
			conditionForPop_.broadcast();
			conditionForRead_.broadcast();
		}
	}

	T popOutOfStack()
	{
		ACE_Guard<ACE_Thread_Mutex> popGuard(rwMutex_);
		while (stack_.empty() && !exitStatus_)
		{
			conditionForPop_.wait();
		}
		T tmp = T();
		if (!exitStatus_)
		{
			tmp = stack_.top();
			stack_.pop();
			conditionForPush_.broadcast();
		}
		return tmp;
	}

	T readTop()
	{
		ACE_Guard<ACE_Thread_Mutex> readGuard(rwMutex_);
		T tmp = T();
		while (stack_.empty() && !exitStatus_)
		{
			conditionForRead_.wait();
		}
		if (!exitStatus_)
		{
			tmp = stack_.top();
		}
		return tmp;
	}

	void setExitStatus()
	{
		exitStatus_ = true;
	}

	bool getExitStatus()
	{
		return exitStatus_;
	}

	void broadcastOfPushCondition()
	{
		conditionForPush_.broadcast();
	}

	void broadcastOfPopCondition()
	{
		conditionForPop_.broadcast();
	}

	void broadcastOfReadCondition()
	{
		conditionForRead_.broadcast();
	}

private:
	//对于这个成员变量的类型应该是std::stack<T>，std::stack<T*>，std::stack<T>*还是std::stack<T*>*，我没有什么太好的判断，
	//感觉std::stack<T*>*应该是最好的，可以降低编译依赖性和减小类的大小，应该这样理解吗？
	std::stack<T> stack_;

	//要用条件变量时，原来的读写锁没有ACE_RW_Thread_Mutex::lock()成员函数，
	//所以ACE_Condition或ACE_Thread_Condition的wait()函数无法编译通过，只能换成ACE_Thread_Mutex，
	//这也使得读线程也不允许其它读线程同时读取资源了，有什么解决方法吗？
	ACE_Thread_Mutex rwMutex_;
	ACE_Thread_Condition<ACE_Thread_Mutex> conditionForPush_, conditionForPop_, conditionForRead_;
	bool exitStatus_;
};

template<typename T>
class PushThread : public ACE_Task_Base
{
public:
	PushThread (ThreadSafeStack<T>& threadSafeStack, const T& content, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), content_(content), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (!threadSafeStack_.getExitStatus())
		{
			threadSafeStack_.pushIntoStack(content_);
			std::stringstream ss;			
			ss << "PushThread " << nthThread_ << " pushes " << content_ << " at the " << i++ << " time.";
			printOutput(ss);
			ACE_OS::sleep(ACE_Time_Value(1));
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const T content_;
	const unsigned int nthThread_;
};

template<typename T>
class PopThread : public ACE_Task_Base
{
public:
	PopThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (!threadSafeStack_.getExitStatus())
		{
			T tmp = threadSafeStack_.popOutOfStack();
			std::stringstream ss;				
			ss << "PopThread " << nthThread_ << " pops " << tmp  << " at the " << i++ << " time.";
			printOutput(ss);
			ACE_OS::sleep(1);
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
};

template<typename T>
class ReadThread : public ACE_Task_Base
{
public:
	ReadThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (!threadSafeStack_.getExitStatus())
		{
			T tmp = threadSafeStack_.readTop();
			std::stringstream ss;				
			ss << "ReadThread " << nthThread_ << " reads " << tmp  << " at the " << i++ << " time.";
			printOutput(ss);
			ACE_OS::sleep(1);	
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
};

template<typename T>
class QuitThread: public ACE_Task_Base
{
public:
	QuitThread (ThreadSafeStack<T>& threadSafeStack): threadSafeStack_(threadSafeStack)
	{ }
	
	virtual int svc (void)
	{
		std::string s;
		while ("exit" != s)
		{
			std::cin >> s;
			if ("exit" == s)
			{
				threadSafeStack_.setExitStatus();
				threadSafeStack_.broadcastOfPushCondition();
				threadSafeStack_.broadcastOfPopCondition();
				threadSafeStack_.broadcastOfReadCondition();
			}
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ThreadSafeStack<std::string> threadSafeStack;

	PushThread<std::string> pushThread1(threadSafeStack, "a", 1);
	PushThread<std::string> pushThread2(threadSafeStack, "b", 2);
	PopThread<std::string> popThread1(threadSafeStack, 1);
	//ReadThread<std::string> readThread1(threadSafeStack, 1);
	QuitThread<std::string> quitThread(threadSafeStack);
	
	//readThread1.activate();
	pushThread1.activate();
	popThread1.activate();
	pushThread2.activate();

	quitThread.activate();	

	pushThread1.wait();
	pushThread2.wait();
	popThread1.wait();
	//readThread1.wait();
	quitThread.wait();

	return 0;

}
//--分开结束各类线程
#include <iostream>
#include <stack>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include "ace/Task.h"
#include "ace/Thread_Mutex.h"
#include "ace/Condition_T.h"
#include "ace/Thread_Manager.h"
#include "ace/Guard_T.h"
#include "boost/shared_ptr.hpp"

ACE_Thread_Mutex outputMutex;

void printOutput(std::stringstream& ss)
{
	ACE_Guard<ACE_Thread_Mutex> outputGuard(outputMutex);
	std::cout << ss.str() << std::endl;
}

template<typename T>
class ThreadSafeStack
{
public:
	enum {maxStackSize = 5};
	ThreadSafeStack(): stack_(), rwMutex_(), conditionForPush_(rwMutex_), conditionForPop_(rwMutex_), conditionForRead_(rwMutex_), 
		activeStatus_(true), activePushStatus_(true), activePopStatus_(true), activeReadStatus_(true)
	{ }

	ThreadSafeStack(const ThreadSafeStack<T>& threadSafeStack): 
	stack_(threadSafeStack.stack_), rwMutex_(), conditionForPush_(rwMutex_), conditionForPop_(rwMutex_), conditionForRead_(rwMutex_), 
		activeStatus_(true), activePushStatus_(true), activePopStatus_(true), activeReadStatus_(true)
	{ }

	//我的理解是：这里如果加上条件变量，则无法实现赋值操作了，条件变量的成员锁是&，必须在构造时创建好，没有办法为引用赋值，
	//所以这里无法写出赋值操作，不知道是否有什么好办法？
	/*ThreadSafeStack& operator=(const ThreadSafeStack<T>& threadSafeStack)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> copyConstructGuard(rwMutex_);
		stack_ = threadSafeStack.stack_;
		rwMutex_ = threadSafeStack.rwMutex_;
	}*/

	bool pushIntoStack(const T& x)
	{
		ACE_Guard<ACE_Thread_Mutex> pushGuard(rwMutex_);
		while (isFull() && activeStatus_ && (!isFull() || activePopStatus_) && activePushStatus_)
		{
			//ACE_Time_Value wakeUpTime = ACE_OS::gettimeofday() + ACE_Time_Value(5);			
			conditionForPush_.wait();
		}
		bool pushSuccessfulFlag = false;
		if (activeStatus_ && (!isFull() || activePopStatus_) && activePushStatus_)
		{
			stack_.push(x);
			conditionForPop_.broadcast();
			conditionForRead_.broadcast();
			pushSuccessfulFlag = true;
		}
		return pushSuccessfulFlag;
	}

	bool popOutOfStack(T& popValue)
	{
		ACE_Guard<ACE_Thread_Mutex> popGuard(rwMutex_);
		while (stack_.empty() && activeStatus_ && activePopStatus_ && (!stack_.empty() || activePushStatus_))
		{
			conditionForPop_.wait();
		}
		bool popSuccessfulFlag = false;
		if (activeStatus_ && activePopStatus_ && (!stack_.empty() || activePushStatus_))
		{
			popValue = stack_.top();
			stack_.pop();
			conditionForPush_.broadcast();
			if (stack_.empty())
			{
				conditionForRead_.broadcast();
			}
			popSuccessfulFlag = true;
		}
		return popSuccessfulFlag;
	}

	bool readTop(T& readValue)
	{
		ACE_Guard<ACE_Thread_Mutex> readGuard(rwMutex_);		
		while (stack_.empty() && activeStatus_ && activeReadStatus_ && (!stack_.empty() || activePushStatus_))
		{
			conditionForRead_.wait();
		}
		bool readSuccessfulFlag = false;
		if (activeStatus_ && activeReadStatus_ && (!stack_.empty() || activePushStatus_))
		{
			readValue = stack_.top();
			readSuccessfulFlag = true;
		}
		return readSuccessfulFlag;
	}

	void resetActiveStatus()
	{
		activeStatus_ = false;
	}

	bool getActiveStatus()
	{
		return activeStatus_;
	}
	
	void resetActivePushStatus()
	{
		activePushStatus_ = false;
	}

	bool getActivePushStatus()
	{
		return activePushStatus_;
	}

	void resetActivePopStatus()
	{
		activePopStatus_ = false;
	}

	bool getActivePopStatus()
	{
		return activePopStatus_;
	}

	void resetActiveReadStatus()
	{
		activeReadStatus_ = false;
	}

	bool getActiveReadStatus()
	{
		return activeReadStatus_;
	}

	void broadcastOfPushCondition()
	{
		conditionForPush_.broadcast();
	}

	void broadcastOfPopCondition()
	{
		conditionForPop_.broadcast();
	}

	void broadcastOfReadCondition()
	{
		conditionForRead_.broadcast();
	}

	bool isFull()
	{
		return maxStackSize == stack_.size();
	}

	bool isEmpty()
	{
		return stack_.empty();
	}

	size_t getStackSize()
	{
		return stack_.size();
	}

private:
	//对于这个成员变量的类型应该是std::stack<T>，std::stack<T*>，std::stack<T>*还是std::stack<T*>*，我没有什么太好的判断，
	//感觉std::stack<T*>*应该是最好的，可以降低编译依赖性和减小类的大小，是这样理解吗？
	std::stack<T> stack_;

	//要用条件变量时，原来的读写锁没有ACE_RW_Thread_Mutex::lock()成员函数，
	//所以ACE_Condition或ACE_Thread_Condition的wait()函数无法编译通过，只能换成ACE_Thread_Mutex，
	//这也使得读线程也不允许其它读线程同时读取资源了，有什么解决方法吗？
	ACE_Thread_Mutex rwMutex_;
	ACE_Thread_Condition<ACE_Thread_Mutex> conditionForPush_, conditionForPop_, conditionForRead_;
	bool activeStatus_, activePushStatus_, activePopStatus_, activeReadStatus_;
};

template<typename T>
class PushThread : public ACE_Task_Base
{
public:
	PushThread (ThreadSafeStack<T>& threadSafeStack, const T& content, const unsigned int nthThread, const ACE_Time_Value& pushInterval = ACE_Time_Value(2)): 
	threadSafeStack_(threadSafeStack), content_(content), nthThread_(nthThread), pushInterval_(pushInterval)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (threadSafeStack_.getActiveStatus() && (!threadSafeStack_.isFull() || threadSafeStack_.getActivePopStatus()) && threadSafeStack_.getActivePushStatus())
		{
			if (threadSafeStack_.pushIntoStack(content_))
			{
				std::stringstream ss;			
				ss << "PushThread " << nthThread_ << " pushes " << content_ << " at the " << i++ << " time.";
				printOutput(ss);
				//ACE_DEBUG((LM_DEBUG, ACE_TEXT("PushThread id: %t\n")));
				ACE_OS::sleep(pushInterval_);
			}			
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const T content_;
	const unsigned int nthThread_;
	ACE_Time_Value pushInterval_;
};

template<typename T>
class PopThread : public ACE_Task_Base
{
public:
	PopThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread, const ACE_Time_Value& popInterval = ACE_Time_Value(2)) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread), popInterval_(popInterval)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (threadSafeStack_.getActiveStatus() && threadSafeStack_.getActivePopStatus() && (!threadSafeStack_.isEmpty() || threadSafeStack_.getActivePushStatus()))
		{
			T popValue;
			if (threadSafeStack_.popOutOfStack(popValue))
			{
				std::stringstream ss;				
				ss << "PopThread " << nthThread_ << " pops " << popValue  << " at the " << i++ << " time.";
				printOutput(ss);
				ACE_OS::sleep(popInterval_);
			}	
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
	ACE_Time_Value popInterval_;
};

template<typename T>
class ReadThread : public ACE_Task_Base
{
public:
	ReadThread (ThreadSafeStack<T>& threadSafeStack, const unsigned int nthThread, const ACE_Time_Value& readInterval = ACE_Time_Value(2, 500000)) : 
	threadSafeStack_(threadSafeStack), nthThread_(nthThread), readInterval_(readInterval)
	{ }

	virtual int svc (void)
	{
		unsigned int i = 1;
		while (threadSafeStack_.getActiveStatus() && threadSafeStack_.getActiveReadStatus() && (!threadSafeStack_.isEmpty() || threadSafeStack_.getActivePushStatus()))
		{
			T readValue;
			if (threadSafeStack_.readTop(readValue))
			{
				std::stringstream ss;				
				ss << "ReadThread " << nthThread_ << " reads " << readValue  << " at the " << i++ << " time.";
				printOutput(ss);
				ACE_OS::sleep(readInterval_);	
			}		
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
	const unsigned int nthThread_;
	ACE_Time_Value readInterval_;
};

template<typename T>
class ControlThread: public ACE_Task_Base
{
public:
	ControlThread (ThreadSafeStack<T>& threadSafeStack): threadSafeStack_(threadSafeStack)
	{ }
	
	virtual int svc (void)
	{
		std::string s;
		while ("quit" != s)
		{
			std::cin >> s;
			if ("stop" == s || "quit" == s)//stop all threads
			{
				threadSafeStack_.resetActiveStatus();
				threadSafeStack_.broadcastOfPushCondition();
				threadSafeStack_.broadcastOfPopCondition();
				threadSafeStack_.broadcastOfReadCondition();
			}
			else if ("spu" == s)//stop push thread(s)
			{
				threadSafeStack_.resetActivePushStatus();
				threadSafeStack_.broadcastOfPushCondition();				
			}
			else if ("spo" == s)//stop pop thread(s)
			{
				threadSafeStack_.resetActivePopStatus();
				threadSafeStack_.broadcastOfPopCondition();
			}			
			else if ("sre" == s)//stop read thread(s)
			{
				threadSafeStack_.resetActiveReadStatus();
				threadSafeStack_.broadcastOfReadCondition();
			}
			else if ("size" == s)
			{
				std::stringstream ss;
				ss << threadSafeStack_.getStackSize();
				printOutput(ss);
			}
		}
		return 0;
	}

private:
	ThreadSafeStack<T>& threadSafeStack_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ThreadSafeStack<std::string> threadSafeStack;

	std::vector<boost::shared_ptr<PushThread<std::string> > > pushThreadVector;
	std::vector<boost::shared_ptr<PopThread<std::string> > > popThreadVector;
	std::vector<boost::shared_ptr<ReadThread<std::string> > > readThreadVector;

	unsigned int numOfPushThread = 2;
	unsigned int numOfPopThread = 3;
	unsigned int numOfReadThread = 1;

	ControlThread<std::string> controlThread(threadSafeStack);
	controlThread.activate();	
	for (unsigned int i = 1; i <= numOfPushThread; ++i)
	{
		boost::shared_ptr<PushThread<std::string> > p(new PushThread<std::string>(threadSafeStack, "hello", i));
		p->activate();
		pushThreadVector.push_back(p);
	}
	for (unsigned int i = 1; i <= numOfPopThread; ++i)
	{
		boost::shared_ptr<PopThread<std::string> > p(new PopThread<std::string>(threadSafeStack, i));
		p->activate();		
		popThreadVector.push_back(p);
	}
	for (unsigned int i = 1; i <= numOfReadThread; ++i)
	{
		boost::shared_ptr<ReadThread<std::string> > p(new ReadThread<std::string>(threadSafeStack, i));
		p->activate();	
		readThreadVector.push_back(p);
	}
	
	ACE_Thread_Manager::instance()->wait();

	return 0;
}
有四个问题，请帮忙解答一下，谢谢：
(1)如何保证被拷贝和赋值的对象在给另一对象拷贝和赋值时不会被其他线程改变呢？就是说如果在拷贝和赋值期间，有其他的线程操作了被拷贝对象，拷贝过来的对象不就不是最初想要拷贝的内容了吗？
(2)在类中用了条件变量之后，如何实现类的赋值操作呢？条件变量中的mutex对象是引用&，所以在第一次构造好之后就无法赋值操作吧？只能把条件变量声明为指针对象，在赋值操作函数里先delete掉，再new出来吗？
(3)在类中用了条件变量之后，能用ACE_RW_Thread_Mutex构造条件变量吗？条件变量的wait方法用到了mutex对象的lock()成员函数，但是ACE_RW_Thread_Mutex好像没有lock成员函数。
(4)如何在成员变量的类型std::stack<T>，std::stack<T*>，std::stack<T>*还是std::stack<T*>*中做选择？我感觉std::stack<T*>*应该是最好的，可以降低编译依赖性和减小类的大小并且减少的拷贝构造次数，是这样理解吗？
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P232 用ACE_Thread_Manager登记退出函数，在线程退出时被自动调用，这些退出函数可以用于进行“最后一秒”的清理，或是通知其他编程，某个线程的结束已经临近。退出处理器的一个优点是，它们总是会被调用，即使线程因为调用了低级的ACE_Thread::exit()方法而突然退出（这个方法会使线程退出），也同样如此。
//要设置退出函数，要创建ACE_At_Thread_Exit的一个子类，实现apply()方法，然后ACE_Thread_Manager登记这个类的一个实例。
#include "ace/Task.h"
#include "ace/Log_Msg.h"

class ExitHandler : public ACE_At_Thread_Exit
{
public:
	virtual void apply (void)
	{
		ACE_DEBUG ((LM_INFO, ACE_TEXT ("(%t) is exiting \n")));

		// Shut down all devices.
	}
};

class HA_CommandHandler : public ACE_Task_Base
{
public:
	HA_CommandHandler(ExitHandler& eh) : eh_(eh)
	{ }
	virtual int svc (void)
	{
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) starting up \n")));

		this->thr_mgr ()->at_exit (eh_);

		// Do something.

		// Forcefully exit.
		ACE_Thread::exit ();

		// NOT REACHED
		return 0;
	}
private:
	ExitHandler& eh_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
  ExitHandler eh;

  HA_CommandHandler handler (eh);
  handler.activate ();

  ACE_Thread_Manager::instance ()->wait ();//这里没有使用ACE_Task_Base::wait()方法，而是使用了ACE_Thread_Manager的wait()方法来等待处理器线程退出。线程管理器等待所有的子线程退出，不管与它们相关联的是哪个任务。当有不止一个正在执行的任务时，这个特性将会证明很方便。
  return 0;
}

////注意，这里把线程管理器当作单体对象使用：其原因是，在默认情况下，ACE会通过这个单体来管理所有线程。尽管在大多数情况下，会发现默认行为已经足够，仍可以创建并使用不止一个线程管理器
int ACE_TMAIN (int, ACE_TCHAR *[])
{
  ExitHandler eh;
  ACE_Thread_Manager tm;

  HA_CommandHandler handler (eh);
  handler.thr_mgr (&tm);
  handler.activate ();

  tm.wait();
  return 0;
}
//------------------------------------------------------------------------------------------------
//向线程发信息 ACE_程序员指南 P234
#include <iostream>
#include "ace/Task.h"
#include "ace/Thread_Manager.h"
#include "ace/Sig_Handler.h"

class SignalableTask : public ACE_Task<ACE_MT_SYNCH>
{
public:
	virtual int handle_signal (int signum,
		siginfo_t *  = 0,
		ucontext_t * = 0)
	{
		if (signum == SIGUSR1)
		{

			ACE_DEBUG ((LM_DEBUG,
				ACE_TEXT ("(%t) received a %S signal\n"),
				signum));
			handle_alert ();
		}
		return 0;
	}

	virtual int svc (void)
	{
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) Starting thread\n")));

		while (1)
		{
			ACE_Message_Block* mb;
			ACE_Time_Value tv (0, 1000);
			//tv += ACE_OS::time (0);
			int result = this->getq (mb, &tv);
			if (result == -1 && errno == EWOULDBLOCK)
				continue;
			else
				process_message (mb);
		}

		return 0;
	}

	void handle_alert () 
	{
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("handle_alert\n")));
	}
	void process_message (ACE_Message_Block *mb) 
	{
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("process_message\n")));
	}
};


int ACE_TMAIN (int, ACE_TCHAR *[])
{
	SignalableTask handler;
	handler.activate (THR_NEW_LWP | THR_JOINABLE , 5);

	ACE_Sig_Handler sh;
	sh.register_handler (SIGUSR1, &handler);

	ACE_OS::sleep (1);

	ACE_Thread_Manager::instance () ->
		kill_grp (handler.grp_id (), SIGUSR1);
	handler.wait ();
	return 0;
}

//但是运行起来5个线程并没有收到信号，查了下kill_grp，win32系统不支持信号
/*Send @a signum to a group of threads, not supported on platforms
that do not have advanced signal support, such as Win32.*/
int kill_grp (int grp_id, int signum);

进程与线程
概念
　　进程（Process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。
　　线程（Thread）是进程的一个实体，是CPU调度和分派的基本单位。线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
二者关系
　　线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。
操作系统分类
　　根据进程与线程的设置，操作系统大致分为如下类型：
　　（1）单进程、单线程，MS-DOS就是这种操作系统；
　　（2）多进程、单线程，多数UNIX（及类UNIX的LINUX）是这种操作系统；
　　（3）多进程、多线程，Win32（Windows NT/2000/XP等）、Solaris 2.x和OS/2都是这种操作系统；
　　（4）单进程、多线程，VxWorks是这种操作系统。
引入线程的好处
　　在操作系统中引入线程带来的主要好处有：
　　（1）通过进程来创建、终止线程比单独地通过应用程序来创建、终止线程要快；
　　（2）同一进程内的线程间切换比进程间的切换要快，尤其是用户级线程间的切换。另外，线程的出现还有以下几个原因：
　　①并发程序的并发执行，在多处理环境下更为有效。一个并发程序可以建立一个进程,而这个并发程序中的若干并发程序段就可以分别建立若干线程,使这些线程在不同的处理机上执行。
　　②每个进程具有独立的地址空间，而该进程内的所有线程共享该地址空间。这样可以解决父子进程模型中，子进程必须复制父进程地址空间的问题。
　　③线程对解决客户/服务器模型非常有效。
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P239 协作式取消
#include <iostream>
#include "ace/Task.h"
#include "ace/Thread_Manager.h"

class CanceledTask : public ACE_Task<ACE_MT_SYNCH>
{
public:

	virtual int svc (void)
	{
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) starting up \n")));
		// Cache our ACE_Thread_Manager pointer.
		ACE_Thread_Manager *mgr = this->thr_mgr ();
		while (1)
		{
			if (mgr->testcancel (mgr->thr_self ()))//取消点是代码中明确定义的点，在这个点上，线程或是已经阻塞（比如阻塞在某个I/O调用上），或是用ACE_Thread_Manager::testcancel()方法编写了显式的取消
				return 0;

			ACE_Message_Block *mb;
			ACE_Time_Value tv (0, 1000);
			//tv += ACE_OS::time (0);
			int result = this->getq (mb, &tv);
			if (result == -1 && errno == EWOULDBLOCK)
				continue;
			else
			{
				// Do real work.
			}
		}
		return 0;
	}
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	CanceledTask task;
	task.activate ();

	ACE_OS::sleep (1);

	ACE_Thread_Manager::instance ()->cancel_task (&task);
	task.wait ();
	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P245 原子运算包装
#include <iostream>
#include "ace/Task.h"
#include "ace/Atomic_Op_T.h"

typedef ACE_Atomic_Op<ACE_Thread_Mutex, unsigned int> SafeUInt;
typedef ACE_Atomic_Op<ACE_Thread_Mutex, int> SafeInt;

unsigned int MAX_PROD = 100;
unsigned int Q_SIZE = 10;

class Producer : public ACE_Task_Base
{
public:
	Producer (int *buf, SafeUInt &in, SafeUInt &out)
		: buf_(buf), in_(in), out_(out)
	{ }

	int svc (void)
	{
		SafeInt itemNo = 0;
		while (1)
		{
			// Busy wait.
			do
			{ }
			while (in_.value () - out_.value () == Q_SIZE);

			itemNo++;
			buf_[in_.value () % Q_SIZE] = itemNo.value ();
			in_++;

			ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Produced %d \n"),
				itemNo.value ()));

			if (check_termination (itemNo.value ()))
				break;
		}

		return 0;
	}

	int check_termination (int item)
	{
		return (item == MAX_PROD);
	}

private:
	int * buf_;
	SafeUInt& in_;
	SafeUInt& out_;
};

class Consumer : public ACE_Task_Base
{
public:
	Consumer (int *buf, SafeUInt &in, SafeUInt& out)
		: buf_(buf), in_(in), out_(out)
	{ }

	int svc (void)
	{
		while (1)
		{
			int item;

			// Busy wait.
			do
			{ }
			while (in_.value () - out_.value () == 0);

			item = buf_[out_.value () % Q_SIZE];
			out_++;

			ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("Consumed %d\n"),
				item));

			if (check_termination (item))
				break;
		}

		return 0;
	}

	int check_termination (int item)
	{
		return (item == MAX_PROD);
	}

private:
	int * buf_;
	SafeUInt& in_;
	SafeUInt& out_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	//int shared_buf[Q_SIZE];
	int shared_buf[10];
	SafeUInt in = 0;
	SafeUInt out = 0;

	Producer producer (shared_buf, in, out);
	Consumer consumer (shared_buf, in, out);

	producer.activate();
	consumer.activate();
	producer.wait();
	consumer.wait();

	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P252 使用信号量，信息队列中实际有高低水位成员虚函数，这里用信号量只是为了演示如何使用
#include <iostream>
#include "ace/Task.h"
#include "ace/Semaphore.h"

class Consumer : public ACE_Task<ACE_MT_SYNCH>
{
public:
	enum { N_THREADS = 5 };

	Consumer (ACE_Semaphore& psema, ACE_Semaphore& csema)
		: psema_(psema), csema_(csema), exit_condition_(0)
	{ }

	int svc (void)
	{
		while (!is_closed ())
			consume_item ();
		return 0;
	}

	void consume_item ()
	{
		csema_.acquire ();
		if (!is_closed ())
		{
			ACE_Message_Block *mb;
			this->getq (mb);
			if (mb->msg_type () == ACE_Message_Block::MB_HANGUP)
			{
				shutdown ();
				mb->release ();
				return;
			}
			else
			{
				ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) Consumed %d\n"),	*(reinterpret_cast<int*>(mb->rd_ptr ()))));
				//mb->rd_ptr (sizeof(int));//这句话可有可无，没有影响？
				mb->release();
			}
			psema_.release ();
		}
	}

	void shutdown (void)
	{
		exit_condition_ = 1;
		this->msg_queue ()->deactivate ();
		csema_.release (N_THREADS);
	}

	int is_closed (void)
	{
		return exit_condition_;
	}

private:
	ACE_Semaphore& psema_;
	ACE_Semaphore& csema_;
	int exit_condition_;
};

class Producer : public ACE_Task_Base
{
public:
	enum { MAX_PROD = 128 };

	Producer (ACE_Semaphore& psema, ACE_Semaphore& csema,
		Consumer &consumer)
		: psema_(psema), csema_(csema), consumer_(consumer)
	{ }

	int svc (void)
	{
		for (int i = 0; i <= MAX_PROD; i++)
			produce_item (i);
		hang_up ();
		return 0;
	}

	void produce_item (int item)
	{
		psema_.acquire ();

		//ACE_Message_Block *mb;
		//ACE_NEW_NORETURN (mb, ACE_Message_Block (sizeof(int), ACE_Message_Block::MB_DATA));//这个宏定义有三种形式，ACE_NEW_RETURN（return第三个参数;）、ACE_NEW（return;）和ACE_NEW_NORETURN（没有返回值）
		ACE_Message_Block *mb = new ACE_Message_Block (sizeof (int),	ACE_Message_Block::MB_DATA);
		
		//mb->copy (&item, sizeof(int));//copy参数类型const char*
		//ACE_OS::sprintf (mb->wr_ptr (), &item);//sprintf两个参数是char*，const char*，这两个函数都是操作字符串的，这里都无法使用
		ACE_OS::memcpy (mb->wr_ptr (), &item, sizeof(item));
		mb->wr_ptr (sizeof (int));
		this->consumer_.putq (mb);

		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) Produced %d\n"), item));
		csema_.release();
	}

	void hang_up ()
	{
		psema_.acquire ();
		ACE_Message_Block *mb =
			new ACE_Message_Block (0, ACE_Message_Block::MB_HANGUP);
		this->consumer_.putq (mb);
		csema_.release ();
	}

private:
	ACE_Semaphore& psema_;
	ACE_Semaphore& csema_;
	Consumer& consumer_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ACE_Semaphore psem (5);
	ACE_Semaphore csem (0);

	Consumer consumer (psem, csem);
	Producer producer (psem, csem, consumer);

	producer.activate ();
	consumer.activate (THR_NEW_LWP | THR_JOINABLE,
		Consumer::N_THREADS);

	producer.wait ();
	consumer.wait ();

	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P256 使用栅栏
#include <iostream>
#include "ace/Task.h"
#include "ace/Barrier.h"

class HA_CommandHandler : public ACE_Task<ACE_MT_SYNCH>
{
public:
	enum { N_THREADS = 5 };

	HA_CommandHandler (ACE_Barrier& startup_barrier,
		ACE_Barrier &shutdown_barrier)
		: startup_barrier_(startup_barrier),
		shutdown_barrier_(shutdown_barrier)
	{ }
	void initialize_handler (void)
	{
		//ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("initialize_handler\n")));
	}
	int handle_command_requests (void)
	{
		//ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("handle_command_requests")));
		return -1;
	}

	int svc (void)
	{
		initialize_handler ();
		startup_barrier_.wait ();
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t: %D) Started\n")));

		while (handle_command_requests () > 0)
			;

		shutdown_barrier_.wait ();
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t: %D) Ended\n")));

		return 0;
	}

private:
	ACE_Barrier& startup_barrier_;
	ACE_Barrier& shutdown_barrier_;
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	ACE_Barrier startup_barrier (HA_CommandHandler::N_THREADS);
	ACE_Barrier shutdown_barrier (HA_CommandHandler::N_THREADS);

	HA_CommandHandler handler (startup_barrier, shutdown_barrier);
	handler.activate (THR_NEW_LWP | THR_JOINABLE,
		HA_CommandHandler::N_THREADS);
	handler.wait ();
	return 0;
}
//------------------------------------------------------------------------------------------------
//ACE_程序员指南 P258 线程专有存储
#include <iostream>
#include <map>
#include "ace/Task.h"

class ClientContext
{
public:
	void* get_attribute (const char *name)
	{
		return attributeMap_[name];
	}
	void set_attribute (const char *name, void *val)
	{
		attributeMap_[name] = val;
	}

private:
	std::map<const char*, void*> attributeMap_;
};

class HA_CommandHandler : public ACE_Task<ACE_MT_SYNCH>
{
public:
	enum {N_THREADS = 5};
	virtual int svc (void)
	{
		ACE_thread_t tid = this->thr_mgr ()->thr_self ();
		// Set our identifier in TSS.
		this->tss_ctx_->set_attribute ("thread_id", &tid);

		while (handle_requests () > 0)
			;

		return 0;
	}

	int handle_requests (void)
	{
		ACE_thread_t* tid = static_cast<ACE_thread_t*>(this->tss_ctx_->get_attribute ("thread_id"));
		ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("(%t) TSS TID: %d \n"), *tid));

		// do work.
		return -1;
	}

private:
	ACE_TSS<ClientContext> tss_ctx_;//使用ACE_TSS类模板，只需要把想要存储在TSS中的数据作为模板参数传给它，然后用operator->()方法在需要时对数据进行访问就可以了。operator->()会在首次被调用时在TSS中创建并在存储数据。ACE_TSS的析构器会确保TSS数据被适当移除和销毁。
};

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	HA_CommandHandler handler;
	handler.activate(THR_NEW_LWP | THR_JOINABLE,	HA_CommandHandler::N_THREADS);
	handler.wait();
	return 0;
}
//------------------------------------------------------------------------------------------------
////ACE_程序员指南 P369 主动定时器
#include "ace/Task.h"
#include "ace/Timer_Queue_Adapters.h"
#include "ace/Timer_Heap.h"

typedef ACE_Thread_Timer_Queue_Adapter<ACE_Timer_Heap> ActiveTimer;

class CB : public ACE_Event_Handler
{
public:
	CB (int id) : id_(id) { }

	virtual int handle_timeout (const ACE_Time_Value &tv,
		const void *arg)
	{
		ACE_TRACE (ACE_TEXT ("CB::handle_timeout"));

		//const int *val = ACE_static_cast (const int*, arg);
		//ACE_ASSERT((*val) == id_);
		ACE_DEBUG ((LM_DEBUG,
			ACE_TEXT ("Expiry handled by thread %t\n")));
		return 0;
	}
private:
	int id_;
};

int ACE_TMAIN (int argc, ACE_TCHAR *argv[])
{
	ACE_DEBUG ((LM_DEBUG,
		ACE_TEXT ("the main thread %t has started \n")));

	// Create an "active" timer and start its thread.
	ActiveTimer atimer;
	atimer.activate ();

	CB cb1 (1);
	CB cb2 (2);
	int arg1 = 1;
	int arg2 = 2;

	// Schedule timers to go off 3 & 4 seconds from now
	// and then with an interval of 1.1 seconds.
	const ACE_Time_Value curr_tv = ACE_OS::gettimeofday ();
	ACE_Time_Value interval = ACE_Time_Value (1, 1000);

	long tid1 = atimer.schedule (&cb1,
		&arg1,
		curr_tv + ACE_Time_Value (3L),
		interval);
	long tid2 = atimer.schedule (&cb2,
		&arg2,
		curr_tv + ACE_Time_Value (4L),
		interval);
	ACE_Thread_Manager::instance ()->wait ();  // Wait forever.

	return 0;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 第1章 简单工厂模式 P34 面向对象可以使代码：可维护（可以很容易修改，并且不影响其他功能，不需要其他功能也同时编译）、可扩展（增加新功能）和复用（方便用到别处，逻辑与业务分离，一个类或者一个函数实现一个独立功能），灵活性高
//参照第1章内容所编写代码
#include <iostream>
#include <memory>
using namespace std;

//interface class
template<typename T>
class Operation
{
public:
	//Operation(T& numberA, T& numberB): numberA_(numberA_), numberB_(numberB) { }
	virtual T getOperationResult() const = 0;
	virtual ~Operation() {};
	void setNumberA(T numberA)
	{
		numberA_ = numberA;
	}
	void setNumberB(T numberB)
	{
		numberB_ = numberB;
	}
protected:
	T numberA_;
	T numberB_;
};

//add
template<typename T>
class AddOperation: public Operation<T>
{
public:
	//AddOperation(T& numberA, T& numberB): Operation(numberA, numberB) { }
	virtual T getOperationResult() const
	{
		return (numberA_ + numberB_);
	}
};

//divide
template<typename T>
class DivideOperation: public Operation<T>
{
public:
	//DivideOperation(T& numberA, T& numberB): Operation(numberA, numberB) {}
	virtual T getOperationResult() const
	{
		if (0 == numberB_)
		{
			cout << "Error" << endl;
			return -1;
		}
		else
		{
			return numberA_ / numberB_;
		}
	}
};

template<typename T>
class OperationFactory
{
public:
	static auto_ptr<Operation<T> > createNewOperation(char operation)
	{
		switch (operation)
		{
		default:
		case '+':
			return auto_ptr<Operation<T> >(new AddOperation<T>);
		case '/':
			return auto_ptr<Operation<T> >(new DivideOperation<T>);
		}
	}
};

int main()
{
	auto_ptr<Operation<double> > pAdd(OperationFactory<double>::createNewOperation('/'));
	pAdd->setNumberA(3);
	//pAdd->setNumberB(5);
	cout << pAdd->getOperationResult() << endl;
}
//------------------------------------------------------------------------------------------------
//大话设计模式P40 第2章 策略模式 
//简单工厂模式只是解决对象的创建问题，面对算法的时常变动，应该有更好的方法-策略模式
//简单工厂模式说白了就是根据不同的传入参数创建不同的类，这个工厂不一定非要是个工厂类，也可以就是一个switch分支判断，并且与其他类相结合
//面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类
策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
策略模式说白了就是设计一个策略管理类A，类A有一个数据成员，该成员类型是一个抽象基类B，通过调用A的对外公有接口函数（接口函数实现中调用类B的虚函数），从而得到B的派生类各种算法实现。可以与简单工厂模式结合，根据传入参数的不同得到指向不同派生类对象的基类指针
策略模式解析：定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各自算法类与使用算法类之间的耦合
优点：
(1)策略模式的Strategy类（指抽象基类B）层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能
(2)简化了单元测试，每个算法都有自己的类，可以通过自己的接口单独测试
当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为（就是说很可能需要条件语句来选择合适的行为）。将这些行为封装在一个个独立的Stragety类中，可以在使用这些行为的类中消除条件语句。
策略模式封装了变化。策略模式就是用来封装算法的，在实践中，发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
在基本和策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象（策略管理类A）。
而在策略与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了客户端的职责。
但是依然不够完美，在Context里用到了switch，也就是说，如果需要增加一种算法，就必须要更改Context中的switch代码，这总还是让人不爽。更好的办法是反射技术。（在抽象工厂模式章节有对反射的讲解）
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class CashSuper
{
public:
	virtual ~CashSuper() { }
	virtual double acceptCash(unsigned quantity, double unitPrice) const = 0;
protected:
	double originalMoney(unsigned quantity, double unitPrice) const 
	{
		return quantity * unitPrice;
	}
};

class CashNormal: public CashSuper
{
public:
	virtual double acceptCash(unsigned quantity, double unitPrice) const
	{
		return originalMoney(quantity, unitPrice);
	}
};

class CashRebate: public CashSuper
{
public:
	CashRebate(const double moneyRebate): moneyRebate_(moneyRebate) { }
	virtual double acceptCash(unsigned quantity, double unitPrice) const
	{
		return originalMoney(quantity, unitPrice) * moneyRebate_;
	}
private:
	double moneyRebate_;
};

class CashReturn: public CashSuper
{
public:
	CashReturn(const double moneyCondition, const double moneyReturn): 
	  moneyCondition_(moneyCondition), moneyReturn_(moneyReturn) 
	{ }
	virtual double acceptCash(unsigned quantity, double unitPrice) const
	{
		double oM = originalMoney(quantity, unitPrice);
		return (oM - static_cast<int>(oM / moneyCondition_) * moneyReturn_);
	}
private:
	double moneyCondition_;
	double moneyReturn_;
};

class CashContext
{
public:
	enum AcceptType {TypeNormal, TypeRebate, TypeReturn};
	CashContext(AcceptType type)//这里是策略模式和简单工厂模式的结合，如果只是策略模式的话，则构造函数参数类型为CashSuper，传进来的参数为new出来的派生类对象，并用内部私有成员指针指向传入参数
	{
		switch (type)//switch类型只能是枚举值或整数
		{
		case TypeNormal:
			pCS_.reset(new CashNormal);
			break;//switch判断一定要有break或return，否则就会一直往下走到最后一个分支
		case TypeRebate:
			pCS_.reset(new CashRebate(0.8));
			break;
		case TypeReturn:
			pCS_.reset(new CashReturn(300, 100));
			break;
		default:
			break;//默认情况下，就不reset指针了，默认构造空的智能指针
		}
	}
	double getResult(unsigned quantity, double unitPrice)
	{
		return pCS_->acceptCash(quantity, unitPrice);
	}
private:
	auto_ptr<CashSuper> pCS_;
};

void main()
{
	//对比简单工厂模式auto_ptr<Shape> pShape(ShapeFactory::CreateNewShape(ShapeFactory::ShapeCircle))，让客户认识到两个类，Shape类和ShapeFactory类
	CashContext cashContextObj(CashContext::TypeReturn);//用了策略模式之后让客户只认识到一个Context类
	cout << cashContextObj.getResult(100, 7) << endl;
}
//------------------------------------------------------------------------------------------------
//大话设计模式P51 第3章 单一职责原则
软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。
//------------------------------------------------------------------------------------------------
//大话设计模式P52 第4章 开放-封闭原则 不能修改，但可以扩展的思想The Open-Closed Principle，OCP，或叫开-闭原则
开放-封闭原则：是说软件实体（尖模块、函数等等）应该可以扩展，但是不可修改。
两个特征，对于扩展是开放的，对于更改是封闭的。
软件设计要容易维护又不容易出问题的最好办法，就是多扩展，少修改
在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
面对需要，对程序的改动是通过增加新代码进行的，而不是量多改现有的代码。这就“开放-封闭原则”的精神所在。
我们希望的是在开发工作那该久就知道可能发生的变化。查明可能发生的变化所等待的时候越长，要创建正确的抽象就越困难。
开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可利用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。
//------------------------------------------------------------------------------------------------
//大话设计模式P57 第5章 依赖倒转原则
A.高层模块不应该依赖低层模块。两个都应该依赖抽象。（抽象应该理解为接口？细节理解为实现？）
B.抽象不应该依赖细节，细节应该依赖抽象。说白了，就是要针对接口编程，不要对实现编程。
里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。翻译过来就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被利用，而子类也能够在父类的基础上增加新的行为。
依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中的所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了。
//------------------------------------------------------------------------------------------------
//大话设计模式P68 装饰模式
Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但是对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。
每个装饰对象的实现和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不是需要关心如何被添加到对象链当中。
装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能时，新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。
优点：把类中的装饰功能从类中搬移去除，可以简化原有的类，有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。
装饰模式除了采用组合的方式取得了比采用继承方式更好的效果，还给设计带来了一种“即用即付”的方式来添加职责。在OO设计和分析经常有这样一种情况：为了多态，通过父类指针指向其具体子类，但是这就带来另外一个问题，当具体子类要添加新的职责，就必须向其父类添加一个这个职责的抽象接口，否则是通过父类指针是调用不到这个方法了。这样处于高层的父类就承载了太多的特征（方法），并且继承自这个父类的所有子类都不可避免继承了父类的这些接口，但是可能这并不是这个具体子类所需要的。而在Decorator模式提供了一种较好的解决方法，当需要添加一个操作的时候就可以通过Decorator模式来解决，你可以一步步添加新的职责。
//在类图中，Component和Decorator都是抽象基类，如果想对多种派生的具体对象ConcreteCompent装饰，则必须要从Component派生出ConcreteCompent和Decorator，否则只想对一个具体对象装饰，则不需要抽象基类Component，如例子中所示；如果只用给Component类加一种装饰，则不需要抽象基类Decorator，否则需要。
//抽象基类就是为了多态，从而可以处理不同的派生具体对象，如果只有一个具体对象，则完全没必要抽象出一个基类来
#include <iostream>
#include <string>
using namespace std;

class Person
{
public:
	Person() { }
	Person(const string& name): name_(name) { }
	~Person() { }
	virtual void show()
	{
		cout << name_ << " will do: " << endl;
	}
private:
	string name_;
};

class DoThings: public Person//Decorator
{
public:
	DoThings(Person* pToPerson): pToPerson_(pToPerson)	{ }//这里没有构造基类，所以必须要默认构造基类，必须要有基类的默认构造函数，否则编译不过，说Person没有合适的默认构造函数
	virtual ~DoThings() { }
	virtual void show()
	{
		if(!pToPerson_)
		{
			pToPerson_->show();
		}
	}
protected:
	Person* pToPerson_;
};

class ReadBook: public DoThings
{
public:
	ReadBook(Person* pToDoThings): DoThings(pToDoThings) { } 
	virtual void show()
	{
		pToPerson_->show();
		cout << "read book" << endl;
		//s = "abc";//这里可以增加这个装饰类独有的操作
	}
//private:
	//string s;
};

class DrawMoney: public DoThings
{
public:
	DrawMoney(Person* pToDoThings): DoThings(pToDoThings) { }
	virtual void show()
	{
		pToPerson_->show();
		cout << "draw money" << endl;
		//addBehavior();//这里可以增加这个装饰类独有的操作
	}
//private:
	//void addBehavior() {}
};

int main()
{
	Person* p = new Person("Ben");
	DoThings *pDT1 = new ReadBook(p);
	DoThings *pDT2 = new DrawMoney(pDT1);
	pDT2->show();//这个show()动态绑定到DrawMoney::show()，所以会执行DrawMoney::show()中的两句语句；但是第一句又是pToPerosn_->show()，会找到DrawMoney::pToPerosn_，指向的是pDT1，所以会动态绑定到ReadBook::show()中的两句；但是第一句pToPerosn_->show()，又会找到ReadBook::pToPerson_，指向的是p，所以会调用Person::show()，最终会先后输出"Ben will do: read book draw money"，理解起来有些类似递归实现一样。

	delete p;
	delete pDT1;
	delete pDT2;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P82 代理模式  为其他对象提供一种代理以控制对这个对象的访问
Subject类，定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。
RealSubject类，定义Proxy所代表的真实实体。
Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。
四种应用：远程代理，虚拟代理，安全代理，智能指引
但是在《C++ 设计模式23种设计模式》中，代理类Proxy并没有继承Subject？最大好处就是实现了逻辑和实现的彻底解耦。
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class SchoolGirl
{
public:
	SchoolGirl(const string& name): name_(name) { }
	const string& getName() const
	{
		return name_;
	}
private:
	string name_;
};

class GiveGift
{
public:
	virtual void giveDolls() = 0;
	virtual void giveFlowers() = 0;
	virtual void giveChocolate() = 0;
};

class Pursuit: public GiveGift
{
public:
	Pursuit(SchoolGirl* pmm): pmm_(pmm) { }
	virtual void giveDolls()
	{
		cout << pmm_->getName() << " give you dolls." << endl;
	}
	virtual void giveFlowers()
	{
		cout << pmm_->getName() << " give you flowers." << endl;
	}
	virtual void giveChocolate()
	{
		cout << pmm_->getName() << " give you chocolate." << endl;
	}
private:
	SchoolGirl* pmm_;
};

class Proxy: public GiveGift
{
public:
	Proxy(SchoolGirl* pmm)
	{
		pgg_ = new Pursuit(pmm);
	}
	~Proxy()
	{
		delete pgg_;
	}
	virtual void giveDolls()
	{
		pgg_->giveDolls();
	}
	virtual void giveFlowers()
	{
		pgg_->giveFlowers();
	}
	virtual void giveChocolate()
	{
		pgg_->giveChocolate();
	}
private:
	Pursuit* pgg_;
};

int main()
{
	SchoolGirl* p = new SchoolGirl("jiaojiao");
	auto_ptr<GiveGift> pToProxy(new Proxy(p));
	pToProxy->giveDolls();
	pToProxy->giveFlowers();
	pToProxy->giveChocolate();
	delete p;
}
//------------------------------------------------------------------------------------------------
//大话设计模式P89 第8章 工厂方法模式
简单工厂模式的最大优点在工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
但问题也在这里，如果要新增一个功能，一定需要给简单工厂类的方法里增加判断分支的。修改原有的类，这不是好办法，这等于说，我们不但对扩展开放了，对修改也开放了，违背了开放-封闭原则。
工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
当新增加功能时，就不需要修改原有的工厂类了，只需要增加此功能的运算类和相应的工厂类就可以了。
工厂方法模式实现时，客户商需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来就是改工厂类的，而现在是修改客户端。
工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。并且要更换对象时，不需要做大的改动就可以实现，降低了客户程序与产品对象的耦合。工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。但缺点是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。（利用“反射”可以解决避免分支判断的问题。）
仍以之前写的简单工厂ShapeFactory为例，如果创建了多个Circle对象，如果要修改Circle成其他对象，就需要每个Circle都做修改，而如果用工厂方法模式，只需要把工厂的子类换一下即可
//简单工厂模式
class ShapeFactory
{
public:
	enum ShapeType {ShapeRectangle, ShapeSquare, ShapeCircle};
	static auto_ptr<Shape> CreateNewShape(ShapeType shapeType)
	{
		switch  (shapeType)
		{
		case  ShapeRectangle:
			return auto_ptr<Shape>(new Rectangle);
		case ShapeSquare:
			return auto_ptr<Shape>(new Square);
		case ShapeCircle:
			return auto_ptr<Shape>(new Circle);
		default :
			return auto_ptr<Shape>();//默认返回空的智能指针
		}
	}
};

int main()
{
	auto_ptr<Shape> pShape1(ShapeFactory::CreateNewShape(ShapeFactory::ShapeCircle));//如果想换成ShapeRectangle，就要三个都修改
	auto_ptr<Shape> pShape2(ShapeFactory::CreateNewShape(ShapeFactory::ShapeCircle));
	auto_ptr<Shape> pShape3(ShapeFactory::CreateNewShape(ShapeFactory::ShapeCircle));
	pShape1->showShapeInfomation();
	pShape1->setParameter();
	pShape1->showShapeInfomation();
	cout << pShape1->getArea() << endl;
}
//工厂方法模式
class Factory
{
public:
	virtual ~Factory() { }
	virtual auto_ptr<Shape> createNewShape() = 0;
};

template<typename T>
class ShapeFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape()
	{
		return auto_ptr<Shape>(new T);
	}
};

int main()
{
	auto_ptr<Factory> pFactory(new ShapeFactory<Circle>);//这里只需要把Circle换成Rectangle即可把三个对象全部换过去
	auto_ptr<Shape> pShape1(pFactory->createNewShape());
	auto_ptr<Shape> pShape2(pFactory->createNewShape());
	auto_ptr<Shape> pShape3(pFactory->createNewShape());	
	pShape1->showShapeInfomation();
	pShape1->setParameter();
	pShape1->showShapeInfomation();
	cout << pShape1->getArea() << endl;
}
//原例子是写成这种结构的
class Factory
{
public:
	virtual ~Factory() { }
	virtual auto_ptr<Shape> createNewShape() = 0;
};

class RectangleFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape()
	{
		return auto_ptr<Shape>(new Rectangle);
	}
};

class SquareFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape()
	{
		return auto_ptr<Shape>(new Square);
	}
};

class CircleFactory: public Factory
{
public:
	virtual auto_ptr<Shape> createNewShape()
	{
		return auto_ptr<Shape>(new Circle);
	}
};
//------------------------------------------------------------------------------------------------
//大话设计模式P95 第9章 原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
最主要的一个成员函数就是virtual object* clone() {}，实现是通过拷贝构造函数创建一个新指针对象（深拷贝），因此要正确实现拷贝构造函数（注意深拷贝和浅拷贝）
Prototype模式通过复制原型（Prototype）而获得新对象创建的功能，这里Prototype本身就是“对象工厂”（因为能够生产对象），实际上Prototype模式和Builder模式、AbstractFactory模式都是通过一个类（对象实例）来专门负责对象的创建工作（工厂对象），它们之间的区别是：Builder模式重在复杂对象的一步步创建（并不直接返回对象），AbstractFactory模式重在产生多个相互依赖类的对象，而Prototype模式重在从自身复制自己创建新类。
//------------------------------------------------------------------------------------------------
//大话设计模式P112 第10章 模板方法模式
既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复
当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理
模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
AbstactClass是抽象类，也就是一个抽象模板，定义并实现了一个模板方法，这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。
ConcreteClass，实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有任意多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。
模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。提供了一个很好的代码利用平台。
当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。

可以看到Strategy模式和Template模式解决了类似的问题，也正如在Template模式中分析的，Strategy模式和Template模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。要实现一个抽象接口，继承是一种方式：我们将抽象接口声明在基类中，将具体的实现放在具体子类中。组合（委托）是另外一种方式：我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。这两种方式各有优缺点，先列出来：
1 继承：
优点
1）易于修改和扩展那些被复用的实现。
缺点
1）破坏了封装性，继承中父类的实现细节暴露给子类了；
2）“白盒”复用，原因在1）中；
3）当父类的实现更改时，其所有子类将不得不随之改变
4）从父类继承而来的实现在运行期间不能改变（编译期间就已经确定了）。

2 组合
优点
1）“黑盒”复用，因为被包含对象的内部细节对外是不可见的；
2）封装性好，原因为1）；
3）实现和抽象的依赖性很小（组合对象和被组合对象之间的依赖性小）；
4）可以在运行期间动态定义实现（通过一个指向相同类型的指针，典型的是抽象基类的指针）。
缺点
1）系统中对象过多。
从上面对比中我们可以看出，组合相比继承可以取得更好的效果，因此在面向对象的设计中的有一条很重要的原则就是：优先使用（对象）组合，而非（类）继承（Favor Composition Over Inheritance）。
#include <iostream>
#include <memory>
using namespace std;

class TestPaper
{
public:
	~TestPaper() { }
	void answerQuestions()
	{
		questionOne();
		answerOne();

		questionTwo();
		answerTwo();
	}
protected://这里用private也没有问题，动态类型是什么对象，就调该对象的相应函数，与是什么继承没有关系
	void questionOne()
	{
		cout << "1 + 1 = " << '\n'
			<< "A.2 B.3 C.4 D.5" << endl;
	}
	void questionTwo()
	{
		cout << "2 * 3 = " << '\n'
			<< "A.5 B.6 C.7 D.8" << endl;
	}
	virtual void answerOne() = 0;
	virtual void answerTwo() = 0;
};

class TestPaperA: public TestPaper
{
protected://这里用private也没有问题
	virtual void answerOne()
	{
		cout << "choose A" << endl;
	}
	virtual void answerTwo()
	{
		cout << "choose B" << endl;
	}
};

class TestPaperB: public TestPaper
{
protected://这里用private也没有问题
	virtual void answerOne()
	{
		cout << "choose D" << endl;
	}
	virtual void answerTwo()
	{
		cout << "choose C" << endl;
	}
};

int main()
{
	auto_ptr<TestPaper> pToTestPaperA(new TestPaperA);
	pToTestPaperA->answerQuestions();
	auto_ptr<TestPaper> pToTestPaperB(new TestPaperB);
	pToTestPaperB->answerQuestions();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P120 迪米特法则
迪米特法则，也叫最少知识原则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用 。
首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
其根本思想是，强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。
//------------------------------------------------------------------------------------------------
//大话设计模式 P121 外观模式
外观模式，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
外观模式的使用：
首先，在设计初期阶段，应该要有意识的将不同的两个层分离，在层与层之间建立外观Facade，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。
其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade，可以提供一个简单的接口，减少它们之间的依赖。
第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需要开发必须要依赖于它，可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

 讨论
Facade模式在高层提供了一个统一的接口，解耦了系统。设计模式中还有另一种模式Mediator也和Facade有类似的地方。但是Mediator主要目的是对象间的访问的解耦（通讯时候的协议），具体请参见Mediator文档。
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class Stock
{
public:
	void buy()
	{
		cout << "buy stock" << endl;
	}
	void sell()
	{
		cout << "sell stock" << endl;
	}
};

class NationalDebt
{
public:
	void buy()
	{
		cout << "buy national debt" << endl;
	}
	void sell()
	{
		cout << "sell national debt" << endl;
	}
};

class Realty
{
public:
	void buy()
	{
		cout << "buy realty" << endl;
	}
	void sell()
	{
		cout << "sell realty" << endl;
	}
};

class Fund
{
public:
	void buyFund()
	{
		stock_.buy();
		nationalDebt_.buy();
	}
	void sellFund()
	{
		nationalDebt_.sell();
	}
private:
	Stock stock_;
	NationalDebt nationalDebt_;
	Realty realty_;
};

int main()
{
	auto_ptr<Fund> fund(new Fund);
	fund->buyFund();
	fund->sellFund();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P133 建造者模式
如果需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，需要应用于“建造者模式”，又叫生成器模式。如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了
它主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。
建造者模式的好处就是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了
建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。

GoF在《设计模式》一书中给出的关于Builder模式的意图是非常容易理解、间接的：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示（在示例代码中可以通过传入不同的参数实现这一点）。
Builder模式和AbstractFactory模式在功能上很相似，因为都是用来创建大的复杂的对象，它们的区别是：Builder模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结果对象，一般来说Builder模式中对象不是直接返回的。而在AbstractFactory模式中对象是直接返回的，AbstractFactory模式强调的是为创建多个相互依赖的对象提供一个同一的接口。
#include <iostream>
#include <string>
#include <memory>
#include <list>
#include <algorithm>
#include <iterator>
using namespace std;

class Product
{
public:
	void addPart(const string& s)
	{
		stringList_.push_back(s);
	}
	void show()
	{
		cout << "Manufacture a product: " << endl;
		copy(stringList_.begin(), stringList_.end(), ostream_iterator<string>(cout, " "));
		cout << endl;
	}
private:
	list<string> stringList_;
};

class Builder
{
public:
	virtual void buildPartA() = 0;
	virtual void buildPartB() = 0;
	virtual Product getProduct() = 0;
};

class ConcreteBuilder1: public Builder
{
public:
	virtual void buildPartA()
	{
		product_.addPart("part A");
	}
	virtual void buildPartB()
	{
		product_.addPart("part B");
	}
	virtual Product getProduct()
	{
		return product_;
	}
private:
	Product product_;
};

class ConcreteBuilder2: public Builder
{
public:
	virtual void buildPartA()
	{
		product_.addPart("part X");
	}
	virtual void buildPartB()
	{
		product_.addPart("part Y");
	}
	virtual Product getProduct()
	{
		return product_;
	}
private:
	Product product_;
};

//这里还可以抽取出一个基类Director，如果派生出不同的ConcreteDirector则可以创建出结构不一样的对象
class Director
{
public:
	void contruct(auto_ptr<Builder>& builder)
	{
		builder->buildPartA();
		builder->buildPartB();
	}
};

int main()
{
	Director director;
	
	auto_ptr<Builder> builder1(new ConcreteBuilder1);//这里builder表示要建一个具体对象1
	director.contruct(builder1);//然后用指导类去建一个具体对象
	Product product1(builder1->getProduct());//建好之后返回一个具体对象，用户就拿着这个创建好的对象去做后续操作。整个过程用户不需要知道创建对象的细节，只要按着这个过程来操作就可以了
	product1.show();

	auto_ptr<Builder> builder2(new ConcreteBuilder2);
	director.contruct(builder2);
	Product product2(builder2->getProduct());
	product2.show();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P149 观察者模式
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
Subject类，可翻译为主题或抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个，可以增加和删除观察者对象。
Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update()方法，这个方法叫做更新方法。
ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。
ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。
用观察都模式的动机是：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使名类紧密耦合，这样会给维护、扩展和重用都带来不便。而观察者模式的关键对象是主题Subject和观察者Observer，一个Sub可以有任意数目的依赖它的Observer，一旦Subject的状态发生了改变，所有的Observer都可以得到通知。Subject发出通知时并不需要知道谁是它的观察者，也就是说，具体观察者是谁，它根本不需要知道。而任何一个具体观察者不知道也不需要知道其他观察者的存在。
什么时候使用：当一个对象的改变需要同时改变其他对象的时候；而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式；一个抽象模型有两个方面，其中一方面依赖于另一个方面，这时用观察者模式可以将这两者封闭在独立的对象中使它们各自独立地改变和复用。总的来说，观察者模式所做的工作其实就是在解除耦合。耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。
//P154讲到了事件委托的实现

//Subject.h
#ifndef __SUBJECT__
#define  __SUBJECT__
#include <list>

class Observer;

class Subject
{
public:
	virtual ~Subject() { }
	virtual void attachObserver(Observer* obv);
	virtual void detachObserver(Observer* obv);
	virtual void notifyObserver();
	virtual void setState(const std::string& s) = 0;
	virtual std::string getState() = 0;
protected:
	std::list<Observer*> observerList_;
	
};

class ConcreteSubject: public Subject
{
public:
	virtual void setState(const std::string& s);
	virtual std::string getState();
private:
	std::string state_;
};

#endif

//Subject.cpp
#include "Subject.h"
#include "Observer.h"

void Subject::attachObserver( Observer* obv )
{
	observerList_.push_back(obv);
}

void Subject::detachObserver( Observer* obv )
{
	observerList_.remove(obv);
}

void Subject::notifyObserver()
{
	for (std::list<Observer*>::iterator iter = observerList_.begin(); iter != observerList_.end(); ++iter)
	{
		(*iter)->update();
	}
}

void ConcreteSubject::setState( const std::string& s )
{
	state_ = s;
}

std::string ConcreteSubject::getState()
{
	return state_;
}

//Observer.h
#ifndef __OBSERVER__
#define  __OBSERVER__

#include "Subject.h"

class Observer
{
public:
	virtual ~Observer() { };
	virtual void update() = 0;
protected:
	Subject* sub_;
	std::string state_;
	std::string name_;
};

class StockObserver: public Observer
{
public:
	StockObserver(const std::string& name, Subject* sub);
	virtual void update();
private:
	void printInfo();
};

class NBAObserver: public Observer
{
public:
	NBAObserver(const std::string& name, Subject* sub);
	virtual void update();
private:
	void printInfo();
};

#endif

//Observer.cpp
#include <iostream>
#include <string>
#include "Observer.h"
#include "Subject.h"

StockObserver::StockObserver(const std::string& name, Subject* sub )//感觉这里应该修改，调用一个基类的构造函数
{
	name_ = name;
	sub_ = sub;
}

void StockObserver::update()
{
	state_ = sub_->getState();
	printInfo();
}

void StockObserver::printInfo()
{
	std::cout << name_ << ", " << state_ << ", don't watch stock, please go to work." << std::endl;
}

NBAObserver::NBAObserver(const std::string& name, Subject* sub )
{
	name_ = name;
	sub_ = sub;
}

void NBAObserver::update()
{
	state_ = sub_->getState();
	printInfo();
}

void NBAObserver::printInfo()
{
	std::cout << name_ << ", " << state_ << ", don't watch NBA, please go to work." << std::endl;
}

//main.cpp
#include <iostream>
#include <string>
#include "Subject.h"
#include "Observer.h"
using namespace std;

int main()
{
	Subject* subject = new ConcreteSubject;
	Observer* observer1 = new StockObserver("Bob", subject);
	Observer* observer2 = new NBAObserver("Green", subject);
	subject->attachObserver(observer1);//可以把这个注册过程放入observer中构造过程中，即把subject传入时，直接在构造函数中调用subject->attachObserver()（head first P59，同时取消注册也由observer来完成，而不是直接由subject来调用，这也更合理一些。）
	subject->attachObserver(observer2);
	subject->setState("Boss Lee is back");
	subject->notifyObserver();

	subject->setState("Boss John is back");
	subject->notifyObserver();

	delete subject;
	delete observer1;
	delete observer2;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P167 抽象工厂模式
抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 。
AbstractProductA和AbstractProductB是两个抽象产品，之所以抽象，是因为它们都有可能有两种不同的实现，就文中所举例子来说就是User和Department，而ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类的实现，比如ProductA1可以理解为是SqlserverUser，ProductA2可以理解为AccessUser，ProductB1理解为SqlserverDepartment，ProductsB2理解为AccessDepartment。
IFactory是一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法，而ConcreteFactory1和ConcreteFactory2就是具体的工厂了，就像是SqlserverFactory和AccessFactory一样。通常是在运行时刻再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。
抽象工厂模式最大的好处便是易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。第二大好处是，它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。

AbstractFactory模式和Factory模式的区别是初学（使用）设计模式时候的一个容易引起困惑的地方。实际上，AbstractFactory模式是为创建一组（有多类）相关或依赖的对象提供创建接口，而Factory模式正如我在相应的文档中分析的是为一类对象提供创建接口或延迟对象的创建到子类中实现。并且可以看到，AbstractFactory模式通常都是使用Factory模式实现（ConcreteFactory1）。

#include <iostream>
#include <string>
#include <memory>
using namespace std;

class IUser
{
public:
	virtual ~IUser() { };
	virtual void insertUser(const string& s) = 0;
	virtual string getUser(int id) = 0;		
};

class SqlserverUser: public IUser
{
public:
	virtual void insertUser(const string& s)
	{
		cout << "Insert a user " << s << " into Sqlserver User table." << endl;
	}
	virtual string getUser(int id)
	{
		cout << "Get a user from Sqlserver User table according to ID " << id << " .\n";
		return string("");
	}
};

class AccessUser: public IUser
{
public:
	virtual void insertUser(const string& s)
	{
		cout << "Insert a user " << s << " into Access User table." << endl;
	}
	virtual string getUser(int id)
	{
		cout << "Get a user from Access User table according to ID " << id << " .\n";
		return string("");
	}
};

class IDepartment
{
public:
	virtual ~IDepartment() { };
	virtual void insertDepartment(const string& s) = 0;
	virtual string getDepartment(int id) = 0;		
};

class SqlserverDepartment: public IDepartment
{
public:
	virtual void insertDepartment(const string& s)
	{
		cout << "Insert a user " << s << " into Sqlserver Department table." << endl;
	}
	virtual string getDepartment(int id)
	{
		cout << "Get a user from Sqlserver Department table according to ID " << id << " .\n";
		return string("");
	}
};

class AccessDepartment: public IDepartment
{
public:
	virtual void insertDepartment(const string& s)
	{
		cout << "Insert a department " << s << " into Access Department table." << endl;
	}
	virtual string getDepartment(int id)
	{
		cout << "Get a department from Access Department table according to ID " << id << " .\n";
		return string("");
	}
};

class IFactory
{
public:
	virtual auto_ptr<IUser> createNewUser() = 0;
	virtual auto_ptr<IDepartment> createNewDepartment() = 0;
};

class SqlserverFactory: public IFactory
{
public:
	virtual auto_ptr<IUser> createNewUser()
	{
		return auto_ptr<IUser>(new SqlserverUser);
	}
	virtual auto_ptr<IDepartment> createNewDepartment()
	{
		return auto_ptr<IDepartment>(new SqlserverDepartment);
	}
};

class AccessFactory: public IFactory
{
public:
	virtual auto_ptr<IUser> createNewUser()
	{
		return auto_ptr<IUser>(new AccessUser);
	}
	virtual auto_ptr<IDepartment> createNewDepartment()
	{
		return auto_ptr<IDepartment>(new AccessDepartment);
	}
};

int main()
{
	auto_ptr<IFactory> pToFactory(new AccessFactory);
	auto_ptr<IUser> pToUser(pToFactory->createNewUser());
	pToUser->insertUser("John");
	pToUser->getUser(3);
	auto_ptr<IDepartment> pToDepartment(pToFactory->createNewDepartment());
	pToDepartment->insertDepartment("Human Resource");
	pToDepartment->getDepartment(5);
}

//简单工厂模式实现，简单工厂模式只是说根据一个判断条件生成相应对象，也可以有多个生成函数生成多个不同类的对象
class IFactory
{
public:
	enum DataBass{Sqlserver, Access};

	static auto_ptr<IUser> createNewUser(DataBass dataBase)
	{
		switch (dataBase)
		{
		case Sqlserver:
			return auto_ptr<IUser>(new SqlserverUser);
		case Access:
			return auto_ptr<IUser>(new AccessUser);
		default:
			return auto_ptr<IUser>();
		}
	}

	static auto_ptr<IDepartment> createNewDepartment(DataBass dataBase)
	{
		switch (dataBase)
		{
		case Sqlserver:
			return auto_ptr<IDepartment>(new SqlserverDepartment);
		case Access:
			return auto_ptr<IDepartment>(new AccessDepartment);
		default:
			return auto_ptr<IDepartment>();
		}
	}
};

int main()
{
	auto_ptr<IUser> pToUser(IFactory::createNewUser(IFactory::Sqlserver));
	pToUser->insertUser("John");
	pToUser->getUser(3);
	auto_ptr<IDepartment> pToDepartment(IFactory::createNewDepartment(IFactory::Sqlserver));
	pToDepartment->insertDepartment("Human Resource");
	pToDepartment->getDepartment(5);
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P181 状态模式
MartinFowler在《重构》中写过一个很重要的代码坏味道，叫做“Long Method”，方法如果过长其实极有可能是有坏味道了。一个函数方法很长，而且有很多的判断分支，这也就意味着它的责任过大了，无论在任何状态，都需要通过它来改变，这实际上是很糟糕的，违背了“单一职责原则”。同时，任何需求的改动或者增加，都需要去更改这个方法，所以要满足需求就得更改这个方法，而过长的函数就要对整个方法做改动，维护出错的风险很大，违背了“开放-封装原则”。
面向对象设计其实就是希望做到代码的责任分解。
状态模式，当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当然，如果这个状态判断很简单，那就没必要用“状态模式”了。
状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。说白了，目的就是为了消除庞大的条件分支语句，大的分支判断会使得它们难以修改和扩展。状态模式通过把各种状态转换逻辑分布到State的子类之间，来减少相互间的依赖，好比把整个版面改成了一个又一个的活字，此时就容易维护和扩展了。
当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。另外如果业务需要某项业务有多个状态，通常都是一些枚举常量，状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑将每一种业务状态定义为一个State的子类。这样这些对象就可以不依赖于其他对象而独立变化了，某一天客户需要更改需求，增加或减少业务状态或改变状态流程，对你来说都不是困难的事。
讨论：
State模式的应用也非常广泛，从最高层逻辑用户接口GUI到最底层的通讯协议（例如GoF在《设计模式》中就利用State模式模拟实现一个TCP连接的类。）都有其用武之地。
State模式和Strategy模式又很大程度上的相似：它们都有一个Context类，都是通过委托（组合）给一个具有多个派生类的多态基类实现Context的算法逻辑。两者最大的差别就是State模式中派生类持有指向Context对象的引用，并通过这个引用调用Context中的方法，但在Strategy模式中就没有这种情况。因此可以说一个State实例同样是Strategy模式的一个实例，反之却不成立。实际上State模式和Strategy模式的区别还在于它们所关注的点不尽相同：State模式主要是要适应对象对于状态改变时的不同处理策略的实现，而Strategy则主要是具体算法和实现接口的解耦（coupling），Strategy模式中并没有状态的概念（虽然很多时候有可以被看作是状态的概念），并且更加不关心状态的改变了。
State模式很好地实现了对象的状态逻辑和动作实现的分离，状态逻辑分布在State的派生类中实现，而动作实现则可以放在Context类中实现（这也是为什么State派生类需要拥有一个指向Context的指针）。这使得两者的变化相互独立，改变State的状态逻辑可以很容易复用Context的动作，也可以在不影响State派生类的前提下创建Context的子类来更改或替换动作实现。
State模式问题主要是逻辑分散化，状态逻辑分布到了很多的State的子类中，很难看到整个的状态逻辑图，这也带来了代码的维护问题。
//state.h
#ifndef __STATE_H__
#define  __STATE_H__
class Context;

class State
{
public:
	virtual ~State();
	virtual void operationInterface(Context*) = 0;
	virtual void operationChangeState(Context*) = 0;
protected:
	bool changeState(Context*, State*);
};

class ConcreteStateA: public State
{
public:
	virtual void operationInterface(Context*);
	virtual void operationChangeState(Context*);
};

class ConcreteStateB: public State
{
public:
	virtual void operationInterface(Context*);
	virtual void operationChangeState(Context*);
};
#endif

//context.h
#ifndef __CONTEXT_H__
#define  __CONTEXT_H__
class State;

class Context
{
	friend class State;//基类为友元函数，State的派生类仍然不是友元函数，为了使派生类可以访问，必须将派生类也声明为友元函数，但这里不可能知道派生类是什么，也没有必要将派生类声明为友元函数
public:
	Context(State*);
	~Context();
	void operationInterface();
	void operationChangeState();
private:
	bool changeState(State*);
	State* state_;
};
#endif

//state.cpp
#include "state.h"
#include "context.h"
#include <iostream>
using namespace std;

bool State::changeState(Context* context, State* state)
{
	context->changeState(state);//这是声明友元类State的作用所在，为了访问Context私有成员函数
	return true;
}

State::~State()
{

}
void ConcreteStateA::operationInterface(Context* )
{
	cout << "ConcreteStateA::perationInterface......" << endl;
}

void ConcreteStateA::operationChangeState(Context* context)
{
	operationInterface(context);//在当前状态下context应做的相应操作
	changeState(context, new ConcreteStateB());//之后改变其状态
}

void ConcreteStateB::operationInterface(Context*)
{
	cout << "ConcreteStateB::operationInterface......" << endl;
}

void ConcreteStateB::operationChangeState(Context* context)
{
	operationInterface(context);
	changeState(context, new ConcreteStateA());
}

//context.cpp
#include "context.h"
#include "state.h"

Context::Context(State* state): state_(state)
{
}

Context::~Context()
{
	delete state_;//删除最后一次的状态
}

void Context::operationInterface()//Context在当前状态下应做的操作，在此例中没有用到这个函数，下下例中会用到
{
	state_->operationInterface(this);
}

void Context::operationChangeState()//在当前的状态下去改变状态，此时Context并不知道下一个状态是什么，所以不可能由Context调用自己的Context::changeState()函数，而只能由当前的状态state_去处理相应的状态变化
{
	state_->operationChangeState(this);
}

bool Context::changeState(State* state)
{
	delete state_;//在改变新的状态前应当删除之前new出来旧状态
	state_ = state;
	return true;
}

//main.cpp
#include <iostream>
#include "context.h"
#include "state.h"
using namespace std;

int main()
{
	State* state = new ConcreteStateA();
	Context* context = new Context(state);
	context->operationChangeState();//state在这里已经就被删掉了
	context->operationChangeState();
	context->operationChangeState();
	delete context;
	state = 0;
	context = 0;
}

//上述指针new，delete操作很难看，用智能指针重新实现
//state.h
#ifndef __STATE_H__
#define  __STATE_H__
#include <memory>
class Context;

class State
{
public:
	virtual ~State();
	virtual void operationInterface(Context*) = 0;
	virtual void operationChangeState(Context*) = 0;
protected:
	bool changeState(Context*, std::auto_ptr<State>);
};

class ConcreteStateA: public State
{
public:
	virtual void operationInterface(Context*);
	virtual void operationChangeState(Context*);
};

class ConcreteStateB: public State
{
public:
	virtual void operationInterface(Context*);
	virtual void operationChangeState(Context*);
};
#endif

//context.h
#ifndef __CONTEXT_H__
#define  __CONTEXT_H__
#include <memory>
class State;

class Context
{
	friend class State;
public:
	Context(std::auto_ptr<State>);
	void operationInterface();
	void operationChangeState();
private:
	bool changeState(std::auto_ptr<State>);
	std::auto_ptr<State> state_;
};
#endif

//state.cpp
#include "state.h"
#include "context.h"
#include <iostream>

State::~State()
{
	
}

bool State::changeState(Context* context, std::auto_ptr<State> state)
{
	context->changeState(state);
	return true;
}

void ConcreteStateA::operationInterface(Context*)
{
	std::cout << "ConcreteStateA::perationInterface......" << std::endl;
}

void ConcreteStateA::operationChangeState(Context* context)
{
	operationInterface(context);
	changeState(context, std::auto_ptr<State>(new ConcreteStateB()));
}

void ConcreteStateB::operationInterface(Context*)
{
	std::cout << "ConcreteStateB::operationInterface......" << std::endl;
}

void ConcreteStateB::operationChangeState(Context* context)
{
	operationInterface(context);
	changeState(context, std::auto_ptr<State>(new ConcreteStateA()));
}

//context.cpp
#include "context.h"
#include "state.h"

Context::Context(std::auto_ptr<State> state): state_(state)
{
}

void Context::operationInterface()
{
	state_->operationInterface(this);
}

void Context::operationChangeState()
{
	state_->operationChangeState(this);
}

bool Context::changeState(std::auto_ptr<State> state)
{
	state_ = state;
	return true;
}

//main.cpp
#include <iostream>
#include <memory>
#include "context.h"
#include "state.h"
using namespace std;

int main()
{
	auto_ptr<State> state(new ConcreteStateA());
	auto_ptr<Context> context(new Context(state));
	context->operationChangeState();
	context->operationChangeState();
	context->operationChangeState();
}

//仿照大话设计模式写的状态转换程序
//state.h
#ifndef __STATE_H__
#define  __STATE_H__
#include <memory>
class Context;

class State
{
public:
	virtual ~State();
	virtual void writeProgram(Context*) = 0;
protected:
	bool changeState(Context*, std::auto_ptr<State>);
};

class ForenoonState: public State
{
public:
	virtual void writeProgram(Context*);
};

class AfternoonState: public State
{
public:
	virtual void writeProgram(Context*);
};

class EveningState: public State
{
public:
	virtual void writeProgram(Context*);
};

class SleepingState: public State
{
public:
	virtual void writeProgram(Context*);
};
#endif

//context.h
#ifndef __CONTEXT_H__
#define  __CONTEXT_H__
#include <memory>
class State;

class Context
{
	friend class State;//感觉这里设友元比原文的public成员函数setState()好，减少了对外访问接口
public:
	Context(std::auto_ptr<State> state, unsigned time = 8);
	void writeProgram();//这个函数就对应于第一例中的void Context::operationInterface()，在当前状态下应该做什么，而这例中没有上上例中的自己改变状态的函数void Context::operationChangeState()
	void setTime(unsigned);
	unsigned getTime();
private:
	bool changeState(std::auto_ptr<State>);
	std::auto_ptr<State> state_;
	unsigned time_;
};
#endif

//state.cpp
#include "state.h"
#include "context.h"
#include <iostream>

bool State::changeState(Context* context, std::auto_ptr<State> state)
{
	context->changeState(state);
	return true;
}

State::~State()
{

}

void ForenoonState::writeProgram(Context* context)
{
	unsigned time = context->getTime();
	if (time <= 12)
	{
		std::cout << "Current time: " << time << ", good spirit!" << std::endl;
		changeState(context, std::auto_ptr<State>(new ForenoonState()));//新增加的语句，以便每次判断完都可以回到初始状态
	}
	else
	{
		changeState(context, std::auto_ptr<State>(new AfternoonState()));
		context->writeProgram();
	}
}

void AfternoonState::writeProgram(Context* context)
{
	unsigned time = context->getTime();
	if (time <= 17)
	{
		std::cout << "Current time: " << time << ", low spirit!" << std::endl;
		changeState(context, std::auto_ptr<State>(new ForenoonState()));
	}
	else
	{
		changeState(context, std::auto_ptr<State>(new EveningState()));
		context->writeProgram();
	}
}

void EveningState::writeProgram(Context* context)
{
	unsigned time = context->getTime();
	if (time <= 21)
	{
		std::cout << "Current time: " << time << ", very low spirit!" << std::endl;
		changeState(context, std::auto_ptr<State>(new ForenoonState()));
	}
	else
	{
		changeState(context, std::auto_ptr<State>(new SleepingState()));
		context->writeProgram();
	}
}

void SleepingState::writeProgram(Context* context)
{
	unsigned time = context->getTime();
	std::cout << "Current time: " << time << ", sleeping!" << std::endl;
	changeState(context, std::auto_ptr<State>(new ForenoonState()));
}

//context.cpp
#include "context.h"
#include "state.h"

Context::Context(std::auto_ptr<State> state, unsigned time): state_(state), time_(time)
{
}

void Context::writeProgram()
{
	state_->writeProgram(this);
}

bool Context::changeState(std::auto_ptr<State> state)
{
	state_ = state;
	return true;
}

unsigned Context::getTime()
{
	return time_;
}

void Context::setTime(unsigned time)
{
	time_ = time;
}

//main.cpp
#include <iostream>
#include <memory>
#include "context.h"
#include "state.h"
using namespace std;

int main()
{
	Context context(auto_ptr<State>(new ForenoonState()));
	context.writeProgram();
	context.setTime(14);
	context.writeProgram();
	context.setTime(20);
	context.writeProgram();
	context.setTime(22);
	context.writeProgram();
}

//上例中的默认值构造函数没写成功，这里补上一个小测试例子
//Test.h
#ifndef __TEST_H__
#define __TEST_H__
#include <memory>

class Test
{
public:
	Test(std::auto_ptr<int> pInt = std::auto_ptr<int>(new int(-1)), int i = -2);//这里正犯了在函数中构造auto_ptr的错误！！！
	void show();	
private:
	std::auto_ptr<int> pInt_;
	int i_;
};

#endif

//Test.cpp
#include "Test.h"
#include <iostream>

Test::Test( std::auto_ptr<int> pInt /*= auto_ptr<int>(new int(-1))*/, int i /*= -2*/ ): pInt_(pInt), i_(i) 
{

}

void Test::show()
{
	std::cout << *pInt_ << std::endl;
	std::cout << i_ << std::endl;
}

//main.cpp
#include <iostream>
#include <memory>
#include "Test.h"
using namespace std;

int main()
{
	Test t;
	t.show();
};
//------------------------------------------------------------------------------------------------
//大话设计模式 P190 适配器模式
适配器模式，将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
在软件开发中，也就是系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。
在GoF的设计模式中，讲了两种类型，类适配器模式和对象适配器模式。类模式的Adapter采用继承的方式复用Adaptee的接口，而在对象模式的Adapter中我们则采用组合的方式实现Adaptee的复用。类模式实际是私有继承Adapee，与对象模式（组合Adaptee）功能一样。
Target（客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口）
Adapee（需要适配的类）
Adapter（通过在内部包装一个Adaptee对象，把源接口转换成目标接口）
就是用Adapter继承Target，并且在Adapter内声明一个Adaptee对象，将Target接口用Adaptee的接口来实现即可。
何时使用：在想使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。两个类所做的事情相同或类似，但是具有不同的接口时要使用它，而且由于类都共享同一接口，使得客户代码可以统一调用同一接口，这样可以更简单、更直接、更紧凑。
通常是在软件开发后期或维护期再考虑使用它，如果在设计阶段，公司内部，类和方法的命名应该有规范，最好前期就设计好，然后如果真的有接口不相同时，首先不应该考虑用适配器，而是应该考虑通过重构统一接口，就是要在双方都不太容易修改的时候再使用适配器模式适配，而不是一有不同时就使用它。当然也有设计之初就需要用适配器模式的时候，比如公司设计一系统时考虑使用第三方开发组件，而这个组件的接口与我们自己的系统接口是不相同的，而我们也完全没有必要为了迎合它而改动自己的接口，此时尽管是在开发的设计阶段，也是可以考虑用适配器模式来解决接口不同的问题。

Adapter模式实现上比较简单，要说明的是在类模式Adapter中，我们通过private继承Adaptee获得实现继承的效果，而通过public继承Target获得接口继承的效果（有关实现继承和接口继承参见讨论部分）。
在Adapter模式的两种模式中，有一个很重要的概念就是接口继承和实现继承的区别和联系。接口继承和实现继承是面向对象领域的两个重要的概念，接口继承指的是通过继承，子类获得了父类的接口，而实现继承指的是通过继承子类获得了父类的实现（并不统共接口）。在C++中的public继承既是接口继承又是实现继承，因为子类在继承了父类后既可以对外提供父类中的接口操作，又可以获得父类的接口实现。当然我们可以通过一定的方式和技术模拟单独的接口继承和实现继承，例如我们可以通过private继承获得实现继承的效果（private继承后，父类中的接口都变为private，当然只能是实现继承了。），通过纯抽象基类模拟接口继承的效果，但是在C++中pure virtual function也可以提供默认实现，因此这是不纯正的接口继承，但是在Java中我们可以interface来获得真正的接口继承了。

//对象适配器模式
//apdater.h
#ifndef __ADAPTER_H__
#define  __ADAPTER_H__
#include <string>

class Player
{
public:
	Player(const std::string& name);
	~Player();
	virtual void attack() const = 0;
	virtual void defense() const = 0;
protected:
	const std::string name_;
};

class Forwards: public Player
{
public:
	Forwards(const std::string& name);
	virtual void attack() const;
	virtual void defense() const;
};

class ForeignCenter//adaptee
{
public:
	ForeignCenter(const std::string& name);
	void attackInChinese() const;
	void defenseInChinese() const;
private:
	const std::string name_;
};

class Translator: public Player//adapter
{
public:
	Translator(const std::string& name);
	virtual void attack() const;
	virtual void defense() const;
private:
	const ForeignCenter foreignCenter_;
};
#endif

//apdator.cpp
#include "adapter.h"
#include <iostream>

Player::Player(const std::string& name): name_(name)
{

}

Player::~Player()
{

}

Forwards::Forwards(const std::string& name): Player(name)
{

}

void Forwards::attack() const
{
	std::cout << "Forward " << name_ << ", attack!" << std::endl;
}

void Forwards::defense() const
{
	std::cout << "Forward " << name_ << ", defense!" << std::endl;
}

ForeignCenter::ForeignCenter( const std::string& name ): name_(name)
{

}

void ForeignCenter::attackInChinese() const
{
	std::cout << "Foreign Center " << name_ << ", attack!" << std::endl;
}

void ForeignCenter::defenseInChinese() const
{
	std::cout << "Foreign Center " << name_ << ", defense!" << std::endl;
}

Translator::Translator( const std::string& name ): Player(name), foreignCenter_(name)
{

}

void Translator::attack() const
{
	foreignCenter_.attackInChinese();
}

void Translator::defense() const
{
	foreignCenter_.defenseInChinese();
}

//main.cpp
#include <iostream>
#include <memory>
#include "adapter.h"
using namespace std;

int main()
{
	auto_ptr<Player> pPlayerMG(new Forwards("Mcgrady"));
	pPlayerMG->attack();
	pPlayerMG->defense();
	auto_ptr<Player> pPlayYM(new Translator("YaoMing"));
	pPlayYM->attack();
	pPlayYM->defense();
}

//类适配器模式，只有Translator类有不同，通过多重继承实现
//apdator.h
class Translator: public Player, private ForeignCenter
{
public:
	Translator(const std::string& name);
	virtual void attack() const;
	virtual void defense() const;
};

//apdator.cpp
Translator::Translator(const std::string& name): Player(name), ForeignCenter(name)
{

}

void Translator::attack() const
{
	attackInChinese();
}

void Translator::defense() const
{
	defenseInChinese();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P201 备忘录模式
备忘录模式：在不破坏封闭性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
Originator（发起人）：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。
Memento（备忘录）：负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象或接收一个备忘录对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。
Caretaker（管理者）：负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。
在备忘录模式中，把要保存的细节给封闭在了Memento中了，哪天要更改保存的细节也不用影响客户端了。
应用场景：Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态；如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态；有时一些对象的内部信息必须保存在对象以外的地方，但是必须由对象自己读取，这时，使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界；最大的作用还是在当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。
备忘录模式也是有缺点的，角色状态需要完整存储到备忘录对象中，如果状态数据很大很多，那么在资源消耗上，备忘录对象会非常耗内存。

代码说明
Memento模式的关键就是friend class Originator;我们可以看到，Memento的接口都声明为private，而将Originator声明为Memento的友元类。我们将Originator的状态保存在Memento类中，而将Memento接口private起来，也就达到了封装的功效。
在Originator类中我们提供了方法让用户后悔：RestoreToMemento(Memento* mt)；我们可以通过这个接口让用户后悔。在测试程序中，我们演示了这一点：Originator的状态由old变为new最后又回到了old。
讨论
在Command模式中，Memento模式经常被用来维护可以撤销（Undo）操作的状态。这一点将在Command模式具体说明。

说白了，就是用另一个备忘录类保存发起者类的部分或全部状态，而后在需要恢复时将备忘录类保存的状态再还原回来。或者用第三个管理类来实现备忘录类的创建恢复接口，或者直接用备忘录类提供创建和恢复接口
//memento.h
#ifndef __MEMENTO_H__
#define __MEMENTO_H__
#include <memory>
class RoleStateMemento;
class GameRole
{
public:
	GameRole();
	std::auto_ptr<RoleStateMemento> saveState();
	void recoveryState(const std::auto_ptr<RoleStateMemento>& pRoleStateMemento);
	void stateAfterFight();
	void showState();
private:
	int vitality_;
	int attack_;
	int defense_;
};

class RoleStateMemento
{
	friend class GameRole;
public:
	RoleStateMemento(int vit, int atk, int def);
private:
	int vitality_;
	int attack_;
	int defense_;
};

class RoleStateCaretaker
{
public:
	RoleStateCaretaker(std::auto_ptr<RoleStateMemento> pRoleStateMemento);
	const std::auto_ptr<RoleStateMemento>& obtainRoleStateMemento();
private:
	std::auto_ptr<RoleStateMemento> pRoleStateMemento_;
};
#endif

//memento.cpp
#include "memento.h"
#include <iostream>
#include <ctime>
GameRole::GameRole(): vitality_(80), attack_(80), defense_(80)
{
}

std::auto_ptr<RoleStateMemento> GameRole::saveState()
{
	return std::auto_ptr<RoleStateMemento>(new RoleStateMemento(vitality_, attack_, defense_));
}

void GameRole::recoveryState( const std::auto_ptr<RoleStateMemento>& pRoleStateMemento )
{
	vitality_ = pRoleStateMemento->vitality_;
	attack_ = pRoleStateMemento->attack_;
	defense_ = pRoleStateMemento->defense_;
}

void GameRole::stateAfterFight()
{
	srand (static_cast<unsigned>(time(NULL)));
	vitality_ = rand() % 100;
	attack_ = rand() % 100;
	defense_ = rand() % 100;
}

void GameRole::showState()
{
	std::cout << "The present state of the hero: vitality_" << vitality_ 
		<< ", attack_" << attack_ << ", defense_" << defense_ << "." << std::endl;
}

RoleStateMemento::RoleStateMemento( int vit, int atk, int def ): vitality_(vit), attack_(atk), defense_(def)
{
}

RoleStateCaretaker::RoleStateCaretaker( std::auto_ptr<RoleStateMemento> pRoleStateMemento )
	: pRoleStateMemento_(pRoleStateMemento)
{
}

const std::auto_ptr<RoleStateMemento>& RoleStateCaretaker::obtainRoleStateMemento()
{
	return pRoleStateMemento_;
}

//main.cpp
#include <iostream>
#include <memory>
#include "memento.h"
using namespace std;

int main()
{
	auto_ptr<GameRole> dingben(new GameRole);
	dingben->showState();
	auto_ptr<RoleStateCaretaker> saveState(new RoleStateCaretaker(dingben->saveState()));
	dingben->stateAfterFight();
	dingben->showState();

	dingben->recoveryState(saveState->obtainRoleStateMemento());
	dingben->showState();

	dingben->stateAfterFight();
	dingben->showState();

	dingben->recoveryState(saveState->obtainRoleStateMemento());
	dingben->showState();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P208 组合模式
组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
Component是组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。
Leaf在组合中表示叶节点对象，叶节点没有子节点。
Composite定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，如增加Add和删除Remove。
客户端代码，能通过Component接口操作组合部件的对象。
Leaf类当中也有Add和Remove，这种方式叫透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。
如果不希望做这样的无用功，就是Leaf类当中不用Add和Remove访求，这就是安全方式，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做就不会出现上述问题，不过由于不够透明，所以树叶和树枝类将不具有相同的的接口，客户端的调用需要做相应的判断，带来了不便。
两者有各好处，需要视情况而定。
什么地方用组合模式：当发现需求中体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式。
组合模式定义了包含了基本对象和类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了；用户是不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合而写一些判断语句了；组合模式让客户可以一致地使用组合结构和单个对象。

代码说明
Composite模式在实现中有一个问题就是要提供对于子节点（Leaf）的管理策略，这里使用的是STL 中的vector，可以提供其他的实现方式，如数组、链表、Hash表等。
讨论
Composite模式通过和Decorator模式有着类似的结构图，但是Composite模式旨在构造类，而Decorator模式重在不生成子类即可给对象添加职责。Decorator模式重在修饰，而Composite模式重在表示。

#include <iostream>
#include <string>
#include <list>
#include "boost/shared_ptr.hpp"
using namespace std;

class Company
{
public:
	Company(const string& name): name_(name){ }
	virtual ~Company() {}
	virtual void add(boost::shared_ptr<Company> c) = 0;
	virtual void remove(boost::shared_ptr<Company> c) = 0;
	virtual void display(int depth) = 0;
	virtual void lineOfDudy() = 0;
protected:
	string name_;
};

class ConcreteCompany: public Company
{
public:
	ConcreteCompany(const string& name): Company(name){}
	virtual void add(boost::shared_ptr<Company> c)
	{
		list_.push_back(c);
	}
	virtual void remove(boost::shared_ptr<Company> c)
	{
		list_.remove(c);
	}
	virtual void display(int depth)
	{
		cout << string(depth, '-') << name_ << endl;
		for (list<boost::shared_ptr<Company> >::iterator iter = list_.begin(); iter != list_.end(); ++iter)
		{
			(*iter)->display(depth + 2);
		}
	}
	virtual void lineOfDudy()
	{
		for (list<boost::shared_ptr<Company> >::iterator iter = list_.begin(); iter != list_.end(); ++iter)
		{
			(*iter)->lineOfDudy();
		}
	}
private:
	list<boost::shared_ptr<Company> > list_;
};

class HRDepartment: public Company
{
public:
	HRDepartment(const string& name): Company(name){}
	virtual void add(boost::shared_ptr<Company> c)
	{		
	}
	virtual void remove(boost::shared_ptr<Company> c)
	{	
	}
	virtual void display(int depth)
	{
		cout << string(depth, '-') << name_ << endl;
	}
	virtual void lineOfDudy()
	{
		cout << name_ << ": employees management." << endl; 
	}
};

class FinanceDepartment: public Company
{
public:
	FinanceDepartment(const string& name): Company(name){}
	virtual void add(boost::shared_ptr<Company> c)
	{		
	}
	virtual void remove(boost::shared_ptr<Company> c)
	{	
	}
	virtual void display(int depth)
	{
		cout << string(depth, '-') << name_ << endl;
	}
	virtual void lineOfDudy()
	{
		cout << name_ << ": finance management." << endl; 
	}
};

int main()
{
	boost::shared_ptr<Company> root(new ConcreteCompany("Bei Jing Head Company"));
	root->add(boost::shared_ptr<Company>(new HRDepartment("Head Company HR Department")));
	root->add(boost::shared_ptr<Company>(new FinanceDepartment("Head Company Finance Department")));

	boost::shared_ptr<Company> comp(new ConcreteCompany("Shang Hai East China Branch Company"));
	comp->add(boost::shared_ptr<Company>(new HRDepartment("East China Branch Company HR Department")));
	comp->add(boost::shared_ptr<Company>(new FinanceDepartment("East China Branch Company Finance Department")));
	root->add(comp);

	boost::shared_ptr<Company> comp1(new ConcreteCompany("Nan Jing Agency"));
	comp1->add(boost::shared_ptr<Company>(new HRDepartment("Nan Jing Agency HR Department")));
	comp1->add(boost::shared_ptr<Company>(new FinanceDepartment("Nan Jing Agency Finance Department")));
	comp->add(comp1);

	boost::shared_ptr<Company> comp2(new ConcreteCompany("Hang Zhou Agency"));
	comp2->add(boost::shared_ptr<Company>(new HRDepartment("Hang Zhou Agency HR Department")));
	comp2->add(boost::shared_ptr<Company>(new FinanceDepartment("Hang Zhou Agency Finance Department")));
	comp->add(comp2);

	//comp->remove(comp2);

	cout << "Structure Figure:" << endl;
	root->display(1);

	cout << "Duty Figure:" << endl;
	root->lineOfDudy();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P219 迭代器模式
迭代器模式，提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式；你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。为遍历的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。
用具体的迭代器来实现抽象的Iterator，是当需要对聚集有多种方式遍历时，可以考虑用迭代器这个好处，可以从尾到头遍历或任意遍历方式。
总地来说，迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
Iterator模式的实现代码很简单，实际上为了更好地保护Aggregate的状态，我们可以尽量减小Aggregate的public接口，而通过将Iterator对象声明位Aggregate的友元来给予Iterator一些特权，获得访问Aggregate私有数据和方法的机会。
讨论
Iterator模式的应用很常见，我们在开发中就经常会用到STL中预定义好的Iterator来对STL类进行遍历（Vector、Set等）。

迭代器模式，实际就是将聚集对象封装在抽象Aggregate类的派生类ConcreteAggregate类中，然后用ConcreteAggregate对象去构造一个抽象Iterator类的派生类ConcreteIterator类
，并通过Iterator提供的First(), Next(), IsDone(), CurrentItem()等接口访问ConcreteAggregate中的聚集对象。
//------------------------------------------------------------------------------------------------
//大话设计模式 P231 单例模式
所有类都在构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。
单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。
通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。
单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

//原来写的线程安全的单例代码
Singleton* Singleton::getInstance()
{
	if (0 == instance_)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> readGuard(rwMutex_);//这样写是有问题的，如果两个线程同时进来了，会创建了两个对象！
		instance_ = new Singleton();
	}
	return instance_;
}
//应该改成如下（每次都不管三七二十一都加锁，开销大和效率低）：
Singleton* Singleton::getInstance()
{
	ACE_Write_Guard<ACE_RW_Thread_Mutex> writeGuard(rwMutex_);
	if (0 == instance_)
	{
		instance_ = new Singleton();
	}
	return instance_;
}
//或，双重锁定：
Singleton* Singleton::getInstance()
{
	if (0 == instance_)
	{
		ACE_Write_Guard<ACE_RW_Thread_Mutex> writeGuard(rwMutex_);//这解决了HeadFirst中提到的只有第一次初始化单例对象时才需要锁的问题。当创建好了该对象后，即if (0 == instance_)判定为false后，根本就不再需要锁了，可以提高效率，避免创建不必要的锁对象
		if (0 == instance_)
		{
			instance_ = new Singleton();
		}
	}
	return instance_;
}

在实际应用中，C#与公共语言运行库也提供了一种“静态初始化”方法（即HeadFirst中所提到的声明静态数据成员的方法，该成员为Singleton的唯一实例），这种方法不需要开发人员显式地编写线程安全代码，即可解决多线程环境下它是不安全的问题。
应该阻止派生，而派生可能会增加实例。（个人感觉可以将构造函数或析构函数声明为私有？没有试验）
静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为饿汉式单例类，原先的new出来的处理方式要在第一次被引用时，才会被自己实例化，所以就被称为懒汉式单例类。
由于饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。然而懒汉式，又会面临着多线程访问的安全问题，需要做双重锁定这样的处理才可以保证安全。所以到底使用哪一种方式，取决于实际的需要。从C#语言角度来讲，饿汉式的单例类已经足够满足我们的需求了。C++呢？
//------------------------------------------------------------------------------------------------
//大话设计模式 P243 桥接模式
对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。
在面向对象设计中，还有一个很重要的设计原则，就是合成/聚合复用原则，即优先使用对象合成/聚合，而不是类继承。
合成/聚合复用原则，尽量使用合成/聚合，尽量不要使用类继承。
聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。如大雁，翅膀和雁群的关系。
优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。
继承是一种强耦合的结构，父类变，子类就必须要变，所以在使用继承时，一定要是“is-a”的关系时再考虑使用，而不是任何时间都去使用。
桥接模式，将抽象部分与它的实现部分分离，使它们都可以独立地变化。
抽象与它的实现分离，并不是说抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。由于实现的方式有多种，桥接模式的核心意图就是把这些实现独立出来，让它们各自地变化。这就使得每种实现的变化不会影响到其他实现，从而达到应对变化的目的。
将抽象部分与它的实现部分分离，就是实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。也就是说，在发现我们需要多角度去分类实现对象，只用继承会造成大量的类增加，不能满足开放-封闭原则时，就应该要考虑用桥接模式了。
只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了。

总结面向对象实际上就两句话：一是松耦合（Coupling），二是高内聚（Cohesion）。面向对象系统追求的目标就是尽可能地提高系统模块内部的内聚（Cohesion）、尽可能降低模块间的耦合（Coupling）。
在Bridge模式的结构图中可以看到，系统被分为两个相对独立的部分，左边是抽象部分，右边是实现部分，这两个部分可以互相独立地进行修改：例如上面问题中的客户需求变化，当用户需求需要从Abstraction派生一个具体子类时候，并不需要像上面通过继承方式实现时候需要添加子类A1和A2了。另外当上面问题中由于算法添加也只用改变右边实现（添加一个具体化子类），而右边不用在变化，也不用添加具体子类了。
代码说明
Bridge模式将抽象和实现分别独立实现，在代码中就是Abstraction类和AbstractionImp
类。
讨论
Bridge是设计模式中比较复杂和难理解的模式之一，也是OO开发与设计中经常会用到的模式之一。使用组合（委托）的方式将抽象和实现彻底地解耦，这样的好处是抽象和实现可以分别独立地变化，系统的耦合性也得到了很好的降低。
GoF在说明Bridge模式时，在意图中指出Bridge模式“将抽象部分与它的实现部分分离，使得它们可以独立地变化”。这句话很简单，但是也很复杂，连Bruce Eckel在他的大作《Thinking in Patterns》中说“Bridge模式是GoF所讲述得最不好（Poorly－described）的模式”，个人觉得也正是如此。原因就在于GoF的那句话中的“实现”该怎么去理解：“实现”特别是和“抽象”放在一起的时候我们“默认”的理解是“实现”就是“抽象”的具体子类的实现，但是这里GoF所谓的“实现”的含义不是指抽象基类的具体子类对抽象基类中虚函数（接口）的实现，是和继承结合在一起的。而这里的“实现”的含义指的是怎么去实现用户的需求，并且指的是通过组合（委托）的方式实现的，因此这里的实现不是指的继承基类、实现基类接口，而是指的是通过对象组合实现用户的需求。理解了这一点也就理解了Bridge模式，理解了Bridge模式，你的设计就会更加Elegant了。
实际上上面使用Bridge模式和使用带来问题方式的解决方案的根本区别在于是通过继承还是通过组合的方式去实现一个功能需求。因此面向对象分析和设计中有一个原则就是：Favor Composition Over Inheritance。其原因也正在这里。

感觉和策略模式有些像啊。。。可以从多角度实现，为了减少耦合，将抽象和实现分离

//handsetBrand.h
#ifndef __HANDSETBRAND_H__
#define  __HANDSETBRAND_H__
#include <memory>
class HandsetSoft;

class HandsetBrand
{
public:
	virtual ~HandsetBrand();
	void setHandsetSoft(std::auto_ptr<HandsetSoft> phandsetBrand);
	virtual void run() = 0;
protected:
	std::auto_ptr<HandsetSoft> pHandsetBrand_;
};

class HandsetBrandNokia: public HandsetBrand
{
public:
	virtual void run();
};

class HandsetBrandApple: public HandsetBrand
{
public:
	virtual void run();
};
#endif

//handsetSoft.h
#ifndef __HANDSETSOFT_H__
#define  __HANDSETSOFT_H__
class HandsetSoft
{
public:
	virtual void run() = 0;
	virtual ~HandsetSoft();
};

class HandsetGame: public HandsetSoft
{
public:
	virtual void run();
};

class HandsetAddressList: public HandsetSoft
{
public:
	virtual void run();
};
#endif

//handsetBrand.cpp
#include "handsetBrand.h"
#include "handsetSoft.h"
#include <iostream>

HandsetBrand::~HandsetBrand()
{

}

void HandsetBrand::setHandsetSoft( std::auto_ptr<HandsetSoft> phandsetBrand )
{
	pHandsetBrand_ = phandsetBrand;
}

void HandsetBrandNokia::run()
{
	std::cout << "Handset brand Nokia:" << std::endl;
	pHandsetBrand_->run();
}

void HandsetBrandApple::run()
{
	std::cout << "Handset brand Apple:" << std::endl;
	pHandsetBrand_->run();
}

//handsetSoft.cpp
#include "handsetSoft.h"
#include <iostream>

HandsetSoft::~HandsetSoft()
{

}

void HandsetGame::run()
{
	std::cout << "Run games." << std::endl;
}

void HandsetAddressList::run()
{
	std::cout << "Run address list." << std::endl;
}

//main.cpp
#include <iostream>
#include <memory>
#include "handsetBrand.h"
#include "handsetSoft.h"
using namespace std;

int main()
{
	auto_ptr<HandsetBrand> nokia(new HandsetBrandNokia());
	nokia->setHandsetSoft(auto_ptr<HandsetSoft>(new HandsetGame()));
	nokia->run();
	nokia->setHandsetSoft(auto_ptr<HandsetSoft>(new HandsetAddressList()));
	nokia->run();

	auto_ptr<HandsetBrand> apple(new HandsetBrandApple());
	apple->setHandsetSoft(auto_ptr<HandsetSoft>(new HandsetGame()));
	apple->run();
	apple->setHandsetSoft(auto_ptr<HandsetSoft>(new HandsetAddressList()));
	apple->run();
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P253 命令模式
烤肉摊，“行为请求者”和“行为实现者”的紧耦合，对请求排除或记录请求日志，以及支持可撤销的操作行为时，“行为请求者”与“行为实现者”的紧耦合是不太合适的。
让编程融入生活。
命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
Command类，用来声明执行操作的接口。
ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。
Invoker类，要求该命令执行这个请求。
Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。
命令模式的优点：
第一，它能较容易地设计一个命令队列；第二，在需要的情况下，可以较容易地将命令记入日志；第三，允许接收请求的一方决定是否要否决请求；第四，可以容易地实现对请求的撤销和重做；第五，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易；第六，最关键就是，命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。
敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。

代码说明
Command模式在实现的实现和思想都很简单，其关键就是将一个请求封装到一个类中（Command），再提供处理对象（Receiver），最后Command命令由Invoker激活。另外，我们可以将请求接收者的处理抽象出来作为参数传给Command对象，实际也就是回调的机制（Callback）来实现这一点，也就是说将处理操作方法地址（在对象内部）通过参数传递给Command对象，Command对象在适当的时候（Invoke激活的时候）再调用该函数。
template <class Reciever>
class SimpleCommand: public Command
{
public:
	typedef void (Reciever::* Action)();
	SimpleCommand(Reciever* rev,Action act)
	{
		_rev=rev;
		_act= act;
	}
	virtual void Excute()
	{
		(_rev->*_act)();
	}
	~SimpleCommand()
	{
		delete _rev;
	}
protected:
private:
	Reciever* _rev;
	Action _act;
};
#endif //~_COMMAND_H_

//main.cpp
#include "Command.h"
#include "Reciever.h"
#include <iostream>
using namespace std;
int main(int arc,char* argv[])
{
	Reciever* rev = new Reciever();
	Command* cmd = new SimpleCommand<Reciever>(rev,&Reciever::Action);//就是将Receiver类的成员函数指针与Receiver类一起传给Command类构造，并且在Command调用Excute()时调用Receiver类对象的成员函数
	cmd->Excute();
	return 0;
}

讨论
Command模式的思想非常简单，但是Command模式也十分常见，并且威力不小。实际上，Command模式关键就是提供一个抽象的Command类，并将执行操作封装到Command类接口中，Command类中一般就是只是一些接口的集合，并不包含任何的数据属性（当然在示例代码中，我们的Command类有一个处理操作的Receiver类的引用，但是其作用也仅仅就是为了实现这个Command的Excute接口）。这种方式在是纯正的面向对象设计者最为鄙视的设计方式，就像OO设计新手做系统设计的时候，仅仅将Class作为一个关键字，将C中的全局函数找一个类封装起来就以为是完成了面向对象的设计。
但是世界上的事情不是绝对的，上面提到的方式在OO设计种绝大部分的时候可能是一个不成熟的体现，但是在Command模式中却是起到了很好的效果。主要体现在：
1） Command模式将调用操作的对象和知道如何实现该操作的对象解耦。在上面Command的结构图中，Invoker对象根本就不知道具体的是那个对象在处理Excute操作（当然要知道是Command类别的对象，也仅此而已）。
2） 在Command要增加新的处理操作对象很容易，我们可以通过创建新的继承自Command的子类来实现这一点。
3） Command模式可以和Memento模式结合起来，支持取消的操作。

//receiver.h
#ifndef __RECEIVER_H__
#define __RECEIVER_H__
class Barbecuer
{
public:
	void bakeMutton();
	void bakeChickenWing();
};
#endif

//receiver.cpp
#include "receiver.h"
#include <iostream>

void Barbecuer::bakeMutton()
{
	std::cout << "Bake mutton!" << std::endl;
}

void Barbecuer::bakeChickenWing()
{
	std::cout << "Bake chicken wing!" << std::endl;
}

//command.h
#ifndef __COMMAND_H__
#define  __COMMAND_H__
#include "boost/shared_ptr.hpp"
class Barbecuer;

class Command
{
public:
	Command(boost::shared_ptr<Barbecuer> barbecuer);
	virtual ~Command();
	virtual void excuteCommand() = 0;
protected:
	boost::shared_ptr<Barbecuer> barbecuer_;
};

class BakeMuttonCommand: public Command
{
public:
	BakeMuttonCommand(boost::shared_ptr<Barbecuer> barbecuer);
	virtual void excuteCommand();
};

class BakeChickenWingCommand: public Command
{
public:
	BakeChickenWingCommand(boost::shared_ptr<Barbecuer> barbecuer);
	virtual void excuteCommand();
};
#endif

//command.cpp
#include "command.h"
#include "receiver.h"

Command::Command( boost::shared_ptr<Barbecuer> barbecuer ): barbecuer_(barbecuer)
{

}

Command::~Command()
{

}

BakeMuttonCommand::BakeMuttonCommand( boost::shared_ptr<Barbecuer> barbecuer ): Command(barbecuer)
{

}

void BakeMuttonCommand::excuteCommand()
{
	barbecuer_->bakeMutton();
}

BakeChickenWingCommand::BakeChickenWingCommand( boost::shared_ptr<Barbecuer> barbecuer ): Command(barbecuer)
{

}

void BakeChickenWingCommand::excuteCommand()
{
	barbecuer_->bakeChickenWing();
}

//waiter.h
#ifndef __WAITER_H__
#define  __WAITER_H__
#include "boost/shared_ptr.hpp"
#include <list>
class Command;

class Waiter
{
public:
	void setOrder(boost::shared_ptr<Command> order);
	void cancelOrder(boost::shared_ptr<Command> order);
	void notify();
private:
	std::list<boost::shared_ptr<Command> > orders_;
};

#endif

//waiter.cpp
#include "waiter.h"
#include "command.h"
#include <iostream>
#include <ctime>

void Waiter::setOrder( boost::shared_ptr<Command> order )
{
	orders_.push_back(order);
}

void Waiter::cancelOrder( boost::shared_ptr<Command> order )
{
	orders_.remove(order);
}

void Waiter::notify()
{
	time_t now = time(0);
	tm* localTime = localtime(&now);
	std::cout << "--Order time: " << asctime(localTime);
	for (std::list<boost::shared_ptr<Command> >::iterator iter = orders_.begin(); iter != orders_.end(); ++iter)
	{
		(*iter)->excuteCommand();
	}
}

//main.cpp
#include <iostream>
#include "command.h"
#include "receiver.h"
#include "waiter.h"
#include "boost/shared_ptr.hpp"
#include "ace/Task.h"
using namespace std;

int ACE_TMAIN (int, ACE_TCHAR *[])
{
	boost::shared_ptr<Barbecuer> barbecuer;
	boost::shared_ptr<Command> bakeMuttonCommand1(new BakeMuttonCommand(barbecuer));
	boost::shared_ptr<Command> bakeMuttonCommand2(new BakeMuttonCommand(barbecuer));
	boost::shared_ptr<Command> bakeChickenWingCommand(new BakeChickenWingCommand(barbecuer));

	Waiter waiterGirl;
	waiterGirl.setOrder(bakeMuttonCommand1);
	waiterGirl.setOrder(bakeMuttonCommand2);
	waiterGirl.setOrder(bakeChickenWingCommand);
	waiterGirl.notify();

	ACE_OS::sleep (4);

	waiterGirl.cancelOrder(bakeMuttonCommand2);
	waiterGirl.notify();
	return 0;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P267 职责链模式
职责链模式，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
Handler类，定义一个处理请求的接口。
ConcreteHandler类，具体处理者类，处理它所负责的请求，可访问它的后续者，如果可处理该请求，就处理之，否则就将该请求转发给它的后续者。
这当时最关键的是当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。这样做的好处是请求者不用管哪个对象来处理，反正该请求会被处理。使得接收者和发送者都没有对方的明确信息，且链中的对象自己也不并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后续者的引用，而不需要保持它所有的候选接受者的引用，大大降低了耦合度。可以随时地增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。但是一个请求极有可能到了末端都得不到处理，或者因为没有正确配置而得不到处理，这就很糟糕了，需要事先考虑全面。

讨论
Chain of Responsibility模式的最大的一个有点就是给系统降低了耦合性，请求的发送者完全不必知道该请求会被哪个应答对象处理，极大地降低了系统的耦合性。

//request.h
#ifndef __REQUEST_H__
#define __REQUEST_H__
#include <string>
class Request
{
public:
	Request(const std::string& requestType, const std::string& requestContent, int requestNumber);
	const std::string getRequestType() const;
	const std::string getRequestContent() const;
	int getRequestNumber() const;
private:
	std::string requestType_;
	std::string requestContent_;
	int requestNumber_;
};
#endif

//request.cpp
#include "request.h"

Request::Request( const std::string& requestType, const std::string& requestContent, int requestNumber )
	: requestType_(requestType), requestContent_(requestContent), requestNumber_(requestNumber)
{

}

const std::string Request::getRequestType() const
{
	return requestType_;
}

const std::string Request::getRequestContent() const
{
	return requestContent_;
}

int Request::getRequestNumber() const
{
	return requestNumber_;
}

//manager.h
#ifndef __MANAGER_H__
#define __MANAGER_H__
#include "boost/shared_ptr.hpp"
#include <string>
class Request;

class Manager
{
public:
	Manager(const std::string& name);
	Manager(const std::string& name, boost::shared_ptr<Manager>& superior);
	virtual ~Manager();
	void setSuperior(boost::shared_ptr<Manager>& superior);
	virtual void handleRequest(const Request& request) = 0;
protected:
	void approveRequest(const Request& request);
	void rejectRequest(const Request& request);
	void waitForSuperiorApprove();
	std::string name_;
	boost::shared_ptr<Manager> superior_;
};

class CommonManager: public Manager
{
public:
	CommonManager(const std::string& name);
	CommonManager(const std::string& name, boost::shared_ptr<Manager>& superior);
	virtual void handleRequest(const Request& request);
};

class Majordomo: public Manager
{
public:
	Majordomo(const std::string& name);
	Majordomo(const std::string& name, boost::shared_ptr<Manager>& superior);
	virtual void handleRequest(const Request& request);
};

class GeneralManager: public Manager
{
public:
	GeneralManager(const std::string& name);
	GeneralManager(const std::string& name, boost::shared_ptr<Manager>& superior);
	virtual void handleRequest(const Request& request);
};
#endif

//manager.cpp
#include <iostream>
#include "manager.h"
#include "request.h"

Manager::Manager( const std::string& name ): name_(name)
{

}

Manager::Manager( const std::string& name, boost::shared_ptr<Manager>& superior ): name_(name), superior_(superior)
{

}

Manager::~Manager()
{

}

void Manager::setSuperior( boost::shared_ptr<Manager>& superior )
{
	superior_ = superior;
}

void Manager::approveRequest( const Request& request )
{
	std::cout << name_ << ": " << request.getRequestContent() << " " << request.getRequestNumber() << " is approved." << std::endl;
}

void Manager::rejectRequest( const Request& request )
{
	std::cout << name_ << ": " << request.getRequestContent() << " " << request.getRequestNumber() << " is rejected." << std::endl;
}

void Manager::waitForSuperiorApprove()
{
	std::cout << name_ << ": I cannot approve the request. Please wait for superior's approval." << std::endl;
}

CommonManager::CommonManager( const std::string& name ): Manager(name)
{

}

CommonManager::CommonManager( const std::string& name, boost::shared_ptr<Manager>& superior ): Manager(name, superior)
{

}

void CommonManager::handleRequest( const Request& request )
{
	if (request.getRequestType() == "AskForLeave" && request.getRequestNumber() < 3)
	{
		approveRequest(request);
	}
	else if (superior_.get() != 0)
	{
		superior_->handleRequest(request);
	}
	else
	{
		waitForSuperiorApprove();
	}
}

Majordomo::Majordomo( const std::string& name ): Manager(name)
{

}

Majordomo::Majordomo( const std::string& name, boost::shared_ptr<Manager>& superior ): Manager(name, superior)
{

}

void Majordomo::handleRequest( const Request& request )
{
	if (request.getRequestType() == "AskForLeave" && request.getRequestNumber() < 6)
	{
		approveRequest(request);
	}
	else if (superior_.get() != 0)
	{
		superior_->handleRequest(request);
	}
	else
	{
		waitForSuperiorApprove();
	}
}

GeneralManager::GeneralManager( const std::string& name ): Manager(name)
{

}

GeneralManager::GeneralManager( const std::string& name, boost::shared_ptr<Manager>& superior ): Manager(name, superior)
{

}

void GeneralManager::handleRequest( const Request& request )
{
	if (request.getRequestType() == "AskForLeave" && request.getRequestNumber() < 11)
	{
		approveRequest(request);
	}
	else if (request.getRequestType() == "AskForSalaryIncrease" && request.getRequestNumber() <= 500)
	{
		approveRequest(request);
	}
	else
	{
		rejectRequest(request);
	}
}

//main.cpp
#include <iostream>
#include "manager.h"
#include "request.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main()
{
	boost::shared_ptr<Manager> jinLi(new CommonManager("Jin Li"));
	boost::shared_ptr<Manager> zongJian(new Majordomo("Zong Jian"));
	boost::shared_ptr<Manager> zhongJingLi(new GeneralManager("Zhong Jing Li"));
	jinLi->setSuperior(zongJian);
	zongJian->setSuperior(zhongJingLi);
	Request request1("AskForLeave", "Xiao Cai asks for leave of", 11);
	jinLi->handleRequest(request1);
	Request request2("AskForSalaryIncrease", "Xiao Cai asks for salary increase of", 501);
	jinLi->handleRequest(request2);
	return 0;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P276 中介者模式
尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性，大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。
中介者模式，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
中介者模式优缺点：中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了“多对多”交互复杂的对象群时，不要急于使用中介都模式，而要先反思你的系统在设计上是不是合理。
首先是Mediator的出现减少了各个Colleague耦合，使得可以独立地改变和复用各个Colleague类和Mediator，任何国家的改变不会影响到其他国家，而只是与安理会发生变化。其次，由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的 交互上来，也就是站在一个更宏观的角度去看待系统。
缺点，由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性 ，这就使得中介者会变得比任何一个ConcreteColleague都复杂。
中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。

在面向对象系统的设计和开发过程中，对象之间的交互和通信是最为常见的情况，因为对象间的交互本身就是一种通信。在系统比较小的时候，可能对象间的通信不是很多、对象也比较少，我们可以直接硬编码到各个对象的方法中。但是当系统规模变大，对象的量变引起系统复杂度的急剧增加，对象间的通信也变得越来越复杂，这时候我们就要提供一个专门处理对象间交互和通信的类，这个中介者就是Mediator模式。Mediator模式提供将对象间的交互和通讯封装在一个类中，各个对象间的通信不必显势去声明和引用，大大降低了系统的复杂性能（了解一个对象总比深入熟悉n个对象要好）。另外Mediator模式还带来了系统对象间的松耦合，这些将在讨论中详细给出。
代码说明
Mediator模式的实现关键就是将对象Colleague之间的通信封装到一个类种单独处理，为了模拟Mediator模式的功能，这里给每个Colleague对象一个string型别以记录其状态，并通过状态改变来演示对象之间的交互和通信。这里主要就Mediator的示例运行结果给出分析：
1）将ConcreteColleageA对象设置状态“old”，ConcreteColleageB也设置状态“old”；
2）ConcreteColleageA对象改变状态，并在Action中和ConcreteColleageB对象进行通信，并改变ConcreteColleageB对象的状态为“new”；
3）ConcreteColleageB对象改变状态，并在Action中和ConcreteColleageA对象进行通信，并改变ConcreteColleageA对象的状态为“new”；
注意到，两个Colleague对象并不知道它交互的对象，并且也不是显示地处理交互过程，这一切都是通过Mediator对象完成的，示例程序运行的结果也正是证明了这一点。
讨论
Mediator模式是一种很有用并且很常用的模式，它通过将对象间的通信封装到一个类中，将多对多的通信转化为一对多的通信，降低了系统的复杂性。Mediator还获得系统解耦的特性，通过Mediator，各个Colleague就不必维护各自通信的对象和通信协议，降低了系统的耦合性，Mediator和各个Colleague就可以相互独立地修改了。
Mediator模式还有一个很显著额特点就是将控制集中，集中的优点就是便于管理，也正式符合了OO设计中的每个类的职责要单一和集中的原则。

//Mediator.h
#ifndef __MEDIATOR_H__
#define  __MEDIATOR_H__
#include <string>
#include "boost/shared_ptr.hpp"
class Country;

class UnitedNations
{
public:
	virtual ~UnitedNations();
	virtual void declare(const std::string& message, const Country& country) = 0;//C++设计模式中这个方法，并没有用到typeid，而是声明了两个函数doActionFromAToB()以及doActionFromBToA()，在两个Colleague子类中的action()函数中分别调用Mediator的一个函数实现通信的
};

class UnitedNationsSecurityConcil: public UnitedNations
{
public:
	//UnitedNationsSecurityConcil(const boost::shared_ptr<Country>& pUsa, const boost::shared_ptr<Country>& pIraq);
	void setCountry(const boost::shared_ptr<Country>& pUsa, const boost::shared_ptr<Country>& pIraq);
	virtual void declare(const std::string& message, const Country& country);
private:
	boost::shared_ptr<Country> pUsa_;
	boost::shared_ptr<Country> pIraq_;
};
#endif

//Colleague.h
#ifndef __COLLEAGUE_H__
#define  __COLLEAGUE_H__
#include <string>
#include "boost/shared_ptr.hpp"
class UnitedNations;

class Country
{
public:
	Country(const boost::shared_ptr<UnitedNations>& pUnitedNations);
	virtual ~Country();
	virtual void declare(const std::string& message) = 0;
	virtual void getMessage(const std::string& message) = 0;
protected:
	boost::shared_ptr<UnitedNations> pUnitedNations_;
};

class Usa: public Country
{
public:
	Usa(const boost::shared_ptr<UnitedNations>& pUnitedNations);
	virtual void declare(const std::string& message);
	virtual void getMessage(const std::string& message);
};

class Iraq: public Country
{
public:
	Iraq(const boost::shared_ptr<UnitedNations>& pUnitedNations);
	virtual void declare(const std::string& message);
	virtual void getMessage(const std::string& message);
};
#endif

//Mediator.cpp
#include <typeinfo>
#include "Mediator.h"
#include "Colleague.h"

UnitedNations::~UnitedNations()
{

}

void UnitedNationsSecurityConcil::setCountry( const boost::shared_ptr<Country>& pUsa, const boost::shared_ptr<Country>& pIraq )
{
	pUsa_ = pUsa;
	pIraq_ = pIraq;
}

void UnitedNationsSecurityConcil::declare( const std::string& message, const Country& country )
{
	if (typeid(country) == typeid(Usa))
	{
		pIraq_->getMessage(message);
	}
	else
	{
		pUsa_->getMessage(message);
	}
}

//Colleague.cpp
#include <iostream>
#include "Colleague.h"
#include "Mediator.h"

Country::Country( const boost::shared_ptr<UnitedNations>& pUnitedNations ): pUnitedNations_(pUnitedNations)
{

}

Country::~Country()
{

}

Usa::Usa( const boost::shared_ptr<UnitedNations>& pUnitedNations ): Country(pUnitedNations)
{

}

void Usa::declare( const std::string& message )
{
	pUnitedNations_->declare(message, *this);
}

void Usa::getMessage( const std::string& message )
{
	std::cout << "USA gets message: " << message << std::endl;
}

Iraq::Iraq( const boost::shared_ptr<UnitedNations>& pUnitedNations ): Country(pUnitedNations)
{

}

void Iraq::declare( const std::string& message )
{
	pUnitedNations_->declare(message, *this);
}

void Iraq::getMessage( const std::string& message )
{
	std::cout << "Iraq gets message: " << message << std::endl;
}

//main.cpp
#include <iostream>
#include "Mediator.h"
#include "Colleague.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main()
{
	boost::shared_ptr<UnitedNationsSecurityConcil> pUnitedNationsSecurityConcil(new UnitedNationsSecurityConcil());//这里必须用派生类指针，否则调不到setCountry()函数，而且也不能在UnitedNations类中声明setCountry()函数，因为它不知道要处理哪些国家
	//又或者在UnitedNations类中声明setCountry()函数也可以，它是知道它要协调哪些国家的，继承它的教科文组织类，世界卫生组织类，世界贸易协会组织类等都是协调这些国家
	boost::shared_ptr<Country> pUsa(new Usa(pUnitedNationsSecurityConcil));
	boost::shared_ptr<Country> pIraq(new Iraq(pUnitedNationsSecurityConcil));
	pUnitedNationsSecurityConcil->setCountry(pUsa, pIraq);
	pUsa->declare("If you have nuclear weapons, we will declare war on you!");
	pIraq->declare("We have no nuclear weapons, and we are not afraid of war!");
	return 0;
}
//------------------------------------------------------------------------------------------------
//大话设计模式 P287 享元模式
享元模式，运用共享技术有效地支持大量细粒度的对象。
在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。也就是说，享元模式Flyweight执行时所需的状态是有内部的也可能有外部的，内部状态存储于ConcreteFlyweight对象之中，而外部对象则应该考虑由客户端对象存储或计算，当调用Flyweight对象的操作时，将该状态传递给它。
如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑合用 还有就是对象的大多数状态是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。
在实际使用中，因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享的对象越多，存储节约也就越多，节约量随着共享共享状态的增多而增大。
在某些情况下，对象的数量可能会太多，从而导致了运行时的资源与性能损耗。那么如何去避免大量细粒度的对象，同时又不影响客户程序，是一个值得去思考的问题，享元模式，可以运用共享技术有效地支持大量细粒度的对象。不过，使用享元模式需要维护一个记录了系统已有的所有享元的列表，而这本身需要耗费资源，另外享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。因此，应当在有足够多的对象实例可供共享时才值得使用享元模式。

问题
在面向对象系统的设计何实现中，创建对象是最为常见的操作。这里面就有一个问题：如果一个应用程序使用了太多的对象，就会造成很大的存储开销。特别是对于大量轻量级（细粒度）的对象，比如在文档编辑器的设计过程中，我们如果为每一个字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。例如一个字母“a”在文档中出现了100000次，而实际上我们可以让这一万个字母“a”共享一个对象，当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象作为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。
Flyweight模式中有一个类似Factory模式的对象构造工厂FlyweightFactory，当客户程序员（Client）需要一个对象时候就会向FlyweightFactory发出请求对象的消息GetFlyweight（）消息，FlyweightFactory拥有一个管理、存储对象的“仓库”（或者叫对象池，vector实现），GetFlyweight（）消息会遍历对象池中的对象，如果已经存在则直接返回给Client，否则创建一个新的对象返回给Client。当然可能也有不想被共享的对象（例如结构图中的UnshareConcreteFlyweight），但不在本模式的讲解范围，故在实现中不给出。
代码说明
Flyweight模式在实现过程中主要是要为共享对象提供一个存放的“仓库”（对象池），这里是通过C++STL中Vector容器，当然就牵涉到STL编程的一些问题（Iterator使用等）。另外应该注意的就是对对象“仓库”（对象池）的管理策略（查找、插入等），这里是通过直接的顺序遍历实现的，当然我们可以使用其他更加有效的索引策略，例如Hash表的管理策略，当然这些细节已经不是Flyweight模式本身要处理的了。
讨论
我们在State模式和Strategy模式中会产生很多的对象，因此我们可以通过Flyweight模式来解决这个问题。

//User.h
#ifndef __USER_H__
#define  __USER_H__
#include <string>
class User
{
public:
	User(const std::string& name);
	const std::string getName() const;
private:
	std::string name_;
};
#endif

//User.cpp
#include "User.h"

User::User( const std::string& name ): name_(name)
{

}

const std::string User::getName() const
{
	return name_;
}

//WebSite.h
#ifndef __WEBSITE_H__
#define __WEBSITE_H__
#include <string>
#include "boost/shared_ptr.hpp"
class User;

class WebSite
{
public:
	WebSite(const std::string& name);
	virtual ~WebSite();
	virtual void use(const User& user) = 0;
	const std::string getName() const;
protected:
	std::string name_;
};

class ConcreteWebSite: public WebSite
{
public:
	ConcreteWebSite(const std::string& name);
	virtual void use(const User& user);
};

class JudgeWebSiteCategory: public std::unary_function<boost::shared_ptr<WebSite>, bool>//这里要加std::命名空间，感觉这个仿函数类应该由WebSiteFactory.h提供
{
public:
	JudgeWebSiteCategory(const std::string& name);
	bool operator()(boost::shared_ptr<WebSite> pWebSite) const;
private:
	std::string name_;
};
#endif

//WebSite.cpp
#include <iostream>
#include "WebSite.h"
#include "User.h"

WebSite::WebSite( const std::string& name ): name_(name)
{

}

WebSite::~WebSite()
{

}

const std::string WebSite::getName() const
{
	return name_;
}

ConcreteWebSite::ConcreteWebSite( const std::string& name ): WebSite(name)
{

}

void ConcreteWebSite::use( const User& user )
{
	std::cout << "WebSite type: " << name_ << "--User: " << user.getName() << std::endl;
}

JudgeWebSiteCategory::JudgeWebSiteCategory( const std::string& name ): name_(name)
{

}

bool JudgeWebSiteCategory::operator()( boost::shared_ptr<WebSite> pWebSite ) const
{
	return pWebSite->getName() == name_;
}

//WebSiteFactory.h
#ifndef __WEBSITEFACTORY_H__
#define __WEBSITEFACTORY_H__
#include <string>
#include <vector>
#include "boost/shared_ptr.hpp"

class WebSite;

class WebSiteFactory
{
public:	
	boost::shared_ptr<WebSite> getWebSiteCategory(const std::string& name);
	int getWebSiteCount() const;
private:
	std::vector<boost::shared_ptr<WebSite> > pWebSiteVec_;
};
#endif

//WebSiteFactory.cpp
#include <algorithm>
#include "WebSiteFactory.h"
#include "WebSite.h"

boost::shared_ptr<WebSite> WebSiteFactory::getWebSiteCategory( const std::string& name )
{
	std::vector<boost::shared_ptr<WebSite> >::iterator iter(find_if(pWebSiteVec_.begin(), pWebSiteVec_.end(), JudgeWebSiteCategory(name)));
	if (iter != pWebSiteVec_.end())
	{
		return *iter;
	}
	else
	{
		boost::shared_ptr<WebSite> pWebSite(new ConcreteWebSite(name));
		pWebSiteVec_.push_back(pWebSite);
		return pWebSite;
	}
}

int WebSiteFactory::getWebSiteCount() const
{
	return pWebSiteVec_.size();
}

//main.cpp
#include <iostream>
#include <string>
#include "boost/shared_ptr.hpp"
#include "User.h"
#include "WebSite.h"
#include "WebSiteFactory.h"
using namespace std;

int main()
{
	User user1("DingBen");
	User user2("LiLei");
	User user3("John");
	WebSiteFactory webSiteFactory;

	boost::shared_ptr<WebSite> webSite1(webSiteFactory.getWebSiteCategory("Blog"));
	webSite1->use(user1);
	boost::shared_ptr<WebSite> webSite2(webSiteFactory.getWebSiteCategory("Blog"));
	webSite2->use(user2);
	boost::shared_ptr<WebSite> webSite3(webSiteFactory.getWebSiteCategory("Blog"));
	webSite3->use(user3);
	cout << webSiteFactory.getWebSiteCount() << endl;

	boost::shared_ptr<WebSite> webSite4(webSiteFactory.getWebSiteCategory("Product show"));
	webSite4->use(user1);
	boost::shared_ptr<WebSite> webSite5(webSiteFactory.getWebSiteCategory("Product show"));
	webSite5->use(user2);
	boost::shared_ptr<WebSite> webSite6(webSiteFactory.getWebSiteCategory("Product show"));
	webSite6->use(user3);
	cout << webSiteFactory.getWebSiteCount() << endl;
	return 0;
}
//------------------------------------------------------------------------------------------------
//上例中的问题
//要加std::
1>d:\program files\vc projects\acetest\acetest\test.h(4): error C2504: “unary_function”: 未定义基类
1>d:\program files\vc projects\acetest\acetest\test.h(4): error C2143: 语法错误 : 缺少“,”(在“<”的前面)
//test.h
#ifndef __TEST_H__
#define __TEST_H__

class MyCompare2: public std::unary_function<int, bool>
{
public:
	MyCompare2(int i): i_(i){}
	bool operator()(int i) const
	{
		return i == i_ ;
	}
private:
	int i_;
};
#endif

//main.cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include "boost/shared_ptr.hpp"
#include "test.h"
using namespace std;

class MyCompare: public unary_function<int, bool>
{
public:
	MyCompare(int i): i_(i){}
	bool operator()(int i) const
	{
		return i == i_ ;
	}
private:
	int i_;
};

int main()
{
	vector<int> intVec;
	intVec.push_back(1);
	intVec.push_back(2);
	vector<int>::iterator iter = find_if(intVec.begin(), intVec.end(), not1(MyCompare(2)));
	cout << *iter << endl;
};
//------------------------------------------------------------------------------------------------
//大话设计模式 P298 解释器模式
解释器模式，给定一个语言，定义它的方法的一种表示，并定义一个解释器，这个解释器使用该表示表解释语言中的句子。
解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
何时使用：通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
好处：可以很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。除了像正则表达式、浏览器等应用，只要是可以用语言来描述的地方，都可以应用。
说白了，解释器模式就是将这样的一句话，转变成实际的命令程序执行而已。而不用解释器模式本来也可以分析，但通过继承抽象表达式的方式，由于依赖倒转原则，使得对文法的扩展和维护都带来了方法。
解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。
反复提到一个简单工厂加反射？

代码说明
Interpreter模式的示例代码很简单，只是为了说明模式的组织和使用，实际的解释Interpret逻辑没有实际提供。
讨论
XML格式的数据解析是一个在应用开发中很常见并且有时候是很难处理的事情，虽然目前很多的开发平台、语言都提供了对XML格式数据的解析，但是例如到了移动终端设备上，由于处理速度、计算能力、存储容量的原因解析XML格式的数据却是很复杂的一件事情，最近也提出了很多的移动设备的XML格式解析器，但是总体上在项目开发时候还是需要自己去设计和实现这一个过程（笔者就有过这个方面的痛苦经历）。
Interpreter模式则提供了一种很好的组织和设计这种解析器的架构。
Interpreter模式中使用类来表示文法规则，因此可以很容易实现文法的扩展。另外对于终结符我们可以使用Flyweight模式来实现终结符的共享。

这个模式就是根据Context的内容，来生成不同的表达式类，并调用表达式类的::interpret(Context& context)，以达到不同的解释效果。其中终端解释器直接解释context，非终端解释器调用其私有指针变量“终端解释器_”的::interpret(Context& context)。
//------------------------------------------------------------------------------------------------
//大话设计模式 P318 访问者模式
访问者模式，表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。
访问者模式的目的是要把处理从数据结构分离出来，很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。反之，如果这样的系统的数据结构对象易于变化，经常要有新的数据对象增加进来，就不适合使用访问者模式。
访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。
访问者模式的缺点其实也就是使增加新的数据结构变得困难了。大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。事实上，我们很难找到数据结构不变化的情况，所以用访问者模式的机会也就不太多了。
访问者模式基本代码：
Visitor类，为该对象结构中ConcreteElement的每一个类声明一个Visit操作。
ConcreteVisitor1和ConcreteVisitor2类，具体访问者，实现每个由Visitor声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。
Element类，定义一个Accept操作，它以一个访问者为参数。
ConcreteElementA和ConcreteElementB类，具体元素，实现Accept操作。充分复用双分派技术，实现处理与数据结构的分离。
ObjectStructure类，能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。
访问者模式的能力和复杂性是把双刃剑，只有当你真正需要它的时候，才考虑使用它。

问题
在面向对象系统的开发和设计过程，经常会遇到一种情况就是需求变更（Requirement Changing），经常我们做好的一个设计、实现了一个系统原型，咱们的客户又会有了新的需求。我们又因此不得不去修改已有的设计，最常见就是解决方案就是给已经设计、实现好的类添加新的方法去实现客户新的需求，这样就陷入了设计变更的梦魇：不停地打补丁，其带来的后果就是设计根本就不可能封闭、编译永远都是整个系统代码。
Visitor模式则提供了一种解决方案：将更新（变更）封装到一个类中（访问操作），并由待更改类提供一个接收接口，则可达到效果。
Visitor模式在不破坏类的前提下，为类提供增加新的新操作。Visitor模式的关键是双分派（Double-Dispatch）的技术。C++语言支持的是单分派。
在Visitor模式中Accept（）操作是一个双分派的操作。具体调用哪一个具体的Accept（）操作，有两个决定因素：1）Element的类型。因为Accept（）是多态的操作，需要具体的Element类型的子类才可以决定到底调用哪一个Accept（）实现；2）Visitor的类型。Accept（）操作有一个参数（Visitor* vis），要决定了实际传进来的Visitor的实际类别才可以决定具体是调用哪个VisitConcrete（）实现。
【注释1】：双分派意味着执行的操作将取决于请求的种类和接收者的类型。
代码说明
Visitor模式的实现过程中有以下的地方要注意：
1） Visitor类中的Visit（）操作的实现。
-这里我们可以向Element类仅仅提供一个接口Visit（），而在Accept（）实现中具体调用哪一个Visit（）操作则通过函数重载（overload）的方式实现：我们提供Visit（）的两个重载版本a）Visit（ConcreteElementA* elmA），b）Visit（ConcreteElementB* elmB）。
-在C++中我们还可以通过RTTI（运行时类型识别：Runtime type identification）来实现，即我们只提供一个Visit（）函数体，传入的参数为Element*型别参数，然后用RTTI决定具体是哪一类的ConcreteElement参数，再决定具体要对哪个具体类施加什么样的具体操作。【注释2】RTTI给接口带来了简单一致性，但是付出的代价是时间（RTTI的实现）和代码的Hard编码（要进行强制转换）。
讨论
有时候我们需要为Element提供更多的修改，这样我们就可以通过为Element提供一系列的
Visitor模式可以使得Element在不修改自己的同时增加新的操作，但是这也带来了至少以下的两个显著问题：
1） 破坏了封装性。Visitor模式要求Visitor可以从外部修改Element对象的状态，这一般通过两个方式来实现：a）Element提供足够的public接口，使得Visitor可以通过调用这些接口达到修改Element状态的目的；b）Element暴露更多的细节给Visitor，或者让Element提供public的实现给Visitor（当然也给了系统中其他的对象），或者将Visitor声明为Element的friend类，仅将细节暴露给Visitor。但是无论那种情况，特别是后者都将是破坏了封装性原则（实际上就是C++的friend机制得到了很多的面向对象专家的诟病）。
2） ConcreteElement的扩展很困难：每增加一个Element的子类，就要修改Visitor的
接口，使得可以提供给这个新增加的子类的访问机制。从上面我们可以看到，或者增加一个用于处理新增类的Visit（）接口，或者重载一个处理新增类的Visit（）操作，或者要修改RTTI方式实现的Visit（）实现。无论那种方式都给扩展新的Element子类带来了困难。 

//Person.h
#ifndef __PERSON_H__
#define __PERSON_H__
#include "boost/shared_ptr.hpp"
class Action;

class Person
{
public:
	virtual ~Person();
	virtual void accept(const boost::shared_ptr<Action> action) = 0;
};

class Man: public Person
{
public:
	virtual void accept(const boost::shared_ptr<Action> action);
};

class Woman: public Person
{
public:
	virtual void accept(const boost::shared_ptr<Action> action);
};
#endif

//Person.cpp
#include "Person.h"
#include "Action.h"
//#include <iostream>

Person::~Person()
{

}

void Man::accept(boost::shared_ptr<Action> action )
{
	action->getManConclusion(this);
	//std::cout << typeid(*this).name() << std::endl;
}

void Woman::accept(boost::shared_ptr<Action> action )
{
	action->getWomanConclusion(this);
}

//Action.h
#ifndef __ACTION_H__
#define __ACTION_H__
class Person;

class Action
{
public:
	virtual ~Action();
	virtual void getManConclusion(Person* man) = 0;
	virtual void getWomanConclusion(Person* woman) = 0;
};

class Success: public Action
{
public:
	virtual void getManConclusion(Person* man);
	virtual void getWomanConclusion(Person* woman);
};

class Fail: public Action
{
public:
	virtual void getManConclusion(Person* man);
	virtual void getWomanConclusion(Person* woman);
};

class Amativeness: public Action
{
public:
	virtual void getManConclusion(Person* man);
	virtual void getWomanConclusion(Person* woman);
};
#endif

//Action.cpp
#include <iostream>
#include <typeinfo>
#include "Action.h"


Action::~Action()
{

}

void Success::getManConclusion( Person* man )
{
	std::cout << typeid(*man).name() << " " << typeid(*this).name() << ": low profile." << std::endl;//这里有问题啊，为什么没有动态识别出类型呢？
}

void Success::getWomanConclusion( Person* woman )
{
	std::cout << typeid(*woman).name() << " " << typeid(*this).name() << ": high profile." << std::endl;
}

void Fail::getManConclusion( Person* man )
{
	std::cout << typeid(*man).name() << " " << typeid(*this).name() << ": calm." << std::endl;
}

void Fail::getWomanConclusion(Person* woman)
{
	std::cout << typeid(*woman).name() << " " << typeid(*this).name() << ": sad." << std::endl;
}

void Amativeness::getManConclusion( Person* man )
{
	std::cout << typeid(*man).name() << " " << typeid(*this).name() << ": know everything." << std::endl;
}

void Amativeness::getWomanConclusion(Person* woman)
{
	std::cout << typeid(*woman).name() << " " << typeid(*this).name() << ": know nothing." << std::endl;
}

//main.cpp
#include <iostream>
#include "Person.h"
#include "Action.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main()
{
	boost::shared_ptr<Action> pSuccess(new Success());
	boost::shared_ptr<Person> pMan(new Man());
	pMan->accept(pSuccess);
	boost::shared_ptr<Person> pWoman(new Woman());
	pWoman->accept(pSuccess);
};
//------------------------------------------------------------------------------------------------
//大话设计模式 P330 总结
创建型模式：
抽象工厂模式：创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。
原型模式：当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例更方便一些。
建造者模式：内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就松耦合。建造者模式将一个复杂对象的构建与它的表示分离，这就可以很容易地改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，它无需关心产品的创建过程，而只告诉建造者模式需要什么，就能用同样的构建过程创建不同的产品给客户。
单例模式：对一些类来说，一个实例是很重要的。一个全局变量可以使得一个对象被访问，但它不能防止客户实例化多个对象。单例的优势就是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且还提供了一个访问该实例的方法。这样就使得对唯一的实例可以严格地控制客户怎样以及何时访问它。
工厂方法模式：创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。另外几种创建型模式都可能设计出比工厂模式更加灵活的代码，但它们的实现也相对就更加复杂。通常设计应该是从工厂方法模式开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。

结构型模式：
适配器模式：面向对象的精神就是更好地应对需要的变化，而现实中往往会有下面这些情况，想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。正如所倡导地对修改关闭，对扩展开放的原则，适配器模式可以做到让这些接口不同的类通过适配后，协同工作。适配器模式主要是为了解决两个已有接口之间不匹配的问题，不需要考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。适配器这种方式不需要对两个独立设计的类中任一个进行重新设计，就能使它们协同工作。
桥接模式：继承是好东西，但往往会过度地使用，继承会导致类的结构过于复杂，关系太多，难以维护，而更糟糕的是扩展性非常差。而仔细研究如果能发现继承体系中，有两个甚至多个方向的变化，那么就解耦这些不同方向的变化，通过对象组合的方式，把两个间的继承关系改为了组合的关系，从而使这两者可以应对各自独立的变化，事实上这也就是合成聚合复用所提倡的原则，总之，面对变化桥接模式主张“找出变化并封装之”。和适配器具有一些共同的特征，就是给另一对象提供一定程度的间接性，这样可以有利于系统的灵活性。通常在设计之初就要想好应该如何做来避免问题的发生，在设计之初，就对抽象接口与它的实现部分进行桥接，让抽象与实现两者可以独立演化。
装饰模式：面对变化，如果采用生成子类的方法进行扩充，为支持每一种扩展的组合，会产生大量的子类，使得子类数目呈爆炸性增长。这也是桥接提到的继承带来的灾难，而事实上，这些子类多半只是为某个对象增加一些职责，此时通过装饰的方式，可以更加灵活、以动态、透明的方式给单个对象添加职责，并在不需要时，撤销相应的职责。
组合模式：组合模式希望用户忽略组合对象与单个对象的不同，用户将可以统一地使用组合结构中的所有对象。用户使用组合类接口与组合结构中的对象进行交互，如果接收者一个叶节点，则直接处理请求，如果接收者是组合对象，通常将请求发送给它的子部件，并在转发请求之前或之后可能执行一些辅助操作。组合模式的效果是客户可以一致地使用组合结构和单个对象。任何用到基本对象的地方都可以使用组合对象。
外观模式：信息的隐藏促进了软件的复用。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障。通常企业软件的三层或N层架构，层与层之间地分离其实就是外观模式的体现。桥接和适配器是被用于软件生命周期的不同阶段，针对的是不同的问题，谈不上孰优孰劣。外观械和适配器有些近似，都是对现存系统的封装，有人说外观模式其实就是另外一组对象的适配器，这种说法是不准确的，因为外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现在系统提供一个更为方便的访问接口。如果硬要说外观模式是适配，那么适配器是用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。
享元模式：对象使得内存占用过多，而且如果都是大量重复的对象，那就是资源的极大浪费。
代理模式：代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统；代理的客户对象无法直接访问目标对象，由代理提供对象单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对系统各元件功能的简化的共同层次的调用接口。而代理模式与适配器模式，其实都是属于一种衔接性质的功能。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构出一个代表者，只需要为就会特定使用目的，将原来的类进行一些组合。

行为型模式：
观察者模式：对象间，尤其是具体对象间，相互知道的越少越好，这样发生改变时才不至于互相影响。对于观察者模式来说，目标和观察者不是紧密耦合的，它们可以属于一个系统中的不同抽象层次，目标所知道的仅仅是它有一系统的观察者，每个观察者实现Observer的简单接口，观察者属于哪一个具体类，目标是不知道的。
模板方法：代码重复是编程中最觉、最糟糕的“坏味道”， 如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设计将它们合而为一，程序会变得更好。但是完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中，这使得我们一定要小心处理。继承的一个非常大的好处就是你能免费地从基类获取一些东西，当你继承一个类时，派生类马上就可以获得基类中所有的功能，你还可以在它的基础上任意增加新的功能。模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法，这样就使得，所有可重复的代码都提炼到抽象为中了，这就实现了代码的重用。
命令模式：将请求发送者与具体实现者分离，即将调用操作的对象与知道如何实现该操作的对象解耦，而这就意味着可以在这两两者之间处理很多事，比如完全可以发送者发送请求就完事了，具体怎么做是命令模式的事情，可以在不同的时刻指定、排列和执行请求。再比如命令模式可以在实施操作前将状态存储起来，以便支持取消/重做的操作。还可以记录整个操作的日志，以便以后可以在系统出问题时查找原因或恢复重做。当然这也就意味着命令模式可在支持事务，要么所有的命令全部执行成功，要么恢复到什么也没执行的状态。总之，如果有类似的需要时，利用命令模式分离请求者和实现者，是最明智的选择。
职责链模式：我们时常会碰到这种情况，就是有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，此时，最好的办法就是让请求发送者与具体处理者分离，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。这就不需要请求发送者了解所有处理者才能处理问题了。
状态模式：如果条件分支语句没有涉及重要的商务逻辑或者不会随着时间的变化而变化，也不会有任何的可扩展性，换句话说，它几乎不会变化，此时条件分支是应该使用的。但是注意这里用到了很多前提，这些前提往往都是不成立的，事实上不会变化的需要很少，不需要扩展的软件也很少，那么如果把这样的分支语句进行分解并封装成多个子类，利用多态来提高其可维护、可扩展的需要，是非常重要的。状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换。

MVC是包括三类对象，Model就应用对象，View是它在屏幕上的表示，Controller定义用户界面对用户输入的响应方式。如果不使用MVC，则用户界面设计往往将这些对象混在一起，而MVC则是将它们分离以提高灵活性和复用性。MVC是多种模式的综合应用，应该算是一种架构模式。

解释器模式：在编程世界里，实现目标都是通过编写语言并执行来实现的，从最低级的机器语言到人能很容易读懂机器也可以执行的高级语言，但是高级语言编写起一起问题可能还是比较复杂。如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题。比如正则表达式就是描述字符串模式的一种标准语言，与其为每一个字符串模式都构造一个特定的算法，不如使用一种通用的搜索算法来解释执行一个正规表达式，该正则表达式定义了待匹配字符器的集合。
中介者模式：面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有很多连接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难。中介者模式提倡将集体行为封装一个单独的中介者对象来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对象不再相互显式引用。这些对象仅知道中介者，从而减少了相互连接的数目。中介者就起到了在朋友间牵线搭桥的作用，也正是迪米特法则提倡的最少知识原则，也就是如何减少耦合的问题，类之间的耦合越弱，越有利于复用。
访问者模式：访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。
策略模式：继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，使它易于切换、易于理解、易于扩展。这里显然使用对象组合要优于类继承。
备忘录模式：通常原对象A都有很多状态属性，保存对象的内部状态，其实也就是将这些状态属性的值可以记录到A对象外部的另一个对象B，但是，如果记录的过程是对外透明的，那就意味着保存过程耦合了对象状态细节。使用备忘录就不会出现这个问题，它可以避免暴露一些只应由对象A管理却又必须存储在对象之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。
迭代器模式：迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。

只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果希望遵循开放-封装原则、依赖倒转原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪一个特选的对象。此时就需要“对象管理者”工厂来负责此事。另外，在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更加复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。总之，在面向对象开发过程中，为了避免耦合，都多多少少会应用工厂方法来帮助管理创建对象的工作。工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂。

说到底，面向对象设计模式体现的就是抽象的思想，类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。不管是什么，其实都是在不同层次、不同角度进行抽象的结果，它们的共性就是抽象。
//------------------------------------------------------------------------------------------------
//附录A P353 面向对象基础
对象是一个自包含的实体，用一组可识别的特性和行为来标识。面向对象编程，其实就是针对对象来进行编程的意思。
类是具有相同的属性和功能的对象的抽象和集合。

面向对象的三大特性之一“封装”：每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己操作。封装有很多好处，第一、良好的封装能够减少耦合，第二、类内部的实现可以自由地修改，第三、类具有清晰的对外接口。

面向对象的第二大特性“继承”：对象的继承代表了一种“is-a”的关系，如果两个对象A和B，可以描述为“B是A”，则表明B可以继承A。实际上，继承者还可以理解为是对被继承者的特殊化，因为它除了具备被继承者的特性外，还具备自己独有的个性。因而，在继承关系中，继承者可以完全替换被继承者，反之则不成立。继承定义了类如何相互关联，共享特性。继承的工作方式是，定义父类和子类，或叫做基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。
学习继承最好记住三句话，如果子类继承于父类，第一、子类拥有父类非private的属性和功能，第二、子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能，第三、子类还可以以自己的方式实现父类的功能（方法重写）。protected表示继承时子类可以对基类有完全访问权。
不用继承的话，如果要修改功能，就必须在所有重复的方法中修改，代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另，继承可使得修改或扩展继承而来的实现都较为容易。
继承是有缺点的，那就是父类变，则子类不得不变。另外，继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性。耦合性，简单理解就是耦断丝连，两个类尽管分开，但如果关系密切，一方的变化都会影响到另一方，这就是耦合性高的表现，继承显然是一种类与类之间强耦合的关系。
合理使用继承：当两个类之间具备“is-a”的关系时，就可以考虑用继承了。而当两个类之间是“has-a”的关系时，表示某个角色具有某一项责任，此时不合适用继承。

面向对象的第三大特性“多态”：多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。
第一、子类以父类的身份出现，第二、子类在工作时以自己的方式来实现，第三、子类以父类的身份出现时，子类特有的属性和方法不可以使用。
多态的原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用，也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。

抽象类：第一，抽象类不能实例化，第二，抽象方法是必须被子类重写的方法，第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。
抽象类拥有尽可能多的共同代码，拥有尽可能少的数据。？
抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类。
抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现，一个类能继承一个抽象类，但可实现多个接口等。
有三点能帮助区分抽象类和接口的：第一，类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象。接口是对类的局部（行为）进行的抽象，而抽象类是对类整体（字段、属性、方法）的抽象。如果只关注行为抽象，那么也可以认为接口就是抽象类。总之，不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，它们的共性就是抽象。第二、如果行为跨越不同类的对象，可使用接口，对于一些相似的类对象，用继承抽象类。第三，从设计角度讲，抽象类是从子类中发现了公共的东西，活化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。
敏捷开发的思想，通过重构改善既有代码的设计。抽象类可以理解为自底而上抽象出来，而接口则是自顶向下设计出来的。

在继承类中同时组合基类的模式有：组合模式、装饰模式、职责链模式、解释器模式
//------------------------------------------------------------------------------------------------
//protected继承的作用 C++ FAQs 百度文库
某些只有数据成员类A，如果要被派生类B继承，并且这些数据要被类B列为protected以便类B的派生类C使用，则类B可以protected A。
//------------------------------------------------------------------------------------------------
//在类继承时不写access-label时继承方式，class默认是private继承，struct默认是public继承
class Base{};
struct Derived1: Base//同struct Derived: public Base
{};
class Derived2: Base//同class Derived: private Base
{};
//------------------------------------------------------------------------------------------------
//C++ FAQs 百度文库 P25 限制模板的参数
//如下例，想保证Container中的对象是Shape*对象，或可以转化成Shape*的对象。
让我们来看这段代码  
template< class Container>   
void draw_all(Container& c)  
{
    for_each(c.begin(),c.end(),mem_fun(&Shape::draw));  
} 
如果c不符合constraints出现了类型错误ツ敲创砦蠼发生在相当复杂的for_each解析之中。比如说ゲ问化的类型被要求实例化int型ツ敲次颐俏薹ㄎ之调用Shape::draw()。而我们从编译器中得到的错误信息是含糊而令人迷惑的――因为它和标准库中复杂的for_each纠缠不清。

为了早点捕捉到这个错误ノ颐强梢哉庋写代码 
 template< class Container>   
 void draw_all(Container& c)  
 {    
	Shape*  p =  c.front( ) ; // accept only containers of Shape* s    
	for_each(c.begin(),c.end(),mem_fun(&Shape::draw));  
}
我们注意到デ懊婕恿艘恍Shape * p的定义＞」芫统绦虮旧矶言p是无用的ぁＨ绻不可将c.front()赋给Shape * pツ敲淳痛蠖嗍现代编译器而言ノ颐嵌伎梢缘玫揭惶鹾义清晰的出错信息。这样的技巧在所有语言中都很常见ザ且对于所有“不同寻常的构造”都不得不如此。

不过这样做不是最好。如果要我来写实际代码ノ乙残砘嵴庋写：
template< class Container>   
void draw_all(Container& c)  
{
	typedef typename Container::value_type T;   
	Can_copy<T, Shape*> (); // accept containers of only Shape* s    
	for_each(c.begin(),c.end(),mem_fun(&Shape::draw)); 
}
这就使代码通用且明显地体现出我的意图――我在使用断言[译注：即明确断言typename Container是draw_all()所接受的容器类型ザ不是令人迷惑地定义了一个Shape *指针，也不知道会不会在后面哪里用到]。Can_copy()模板可被这样定义：
template< class T1, class T2>  
struct Can_copy 
{    
	static void constraints(T1 a, T2 b)//这个静态成员函数如果不调用，就不会到作用，下面在构造函数中定义一个函数指针p，并将constraints赋给p，正是调用静态成员函数，把参数T1和T2传给contraints并同时检验T1是否可以赋给T2
	{  
		T2 c =  a; 
		b = a; 
	}
	Can_copy() 
	{
		void(* p)(T1,T2) =  constraints;
	}
};

Can_copy在编译期间检查确认T1可被赋于T2。Can_copy< T,Shape* >检查确认T是一个Shape*类型セ蛘呤且桓鲋赶Shape的公有继承类的指针セ蛘呤怯没ё远ㄒ宓目杀蛔型为Shape *的类型。注意フ饫Can_copy()的实现已经基本上是最优化的了σ恍写码用来指明需要检查的constraints[译注χ傅1行代码constraints为T2]ズ鸵对其做这个检查的类型[译注σ作检查的类型为T1] б恍写码用来精确列出所要检查是否满足的constraints，constraints()函数[译注：第2行之所以要有2个子句并不是重复，而是有原因的。如果T1、T2均是用户自定义的类ツ敲T2 c =  a; 检测能否缺省构造，b =  a; 检测能否拷贝构造]一行代码用来提供执行这些检查的机会 [译注：指第3行。Can_copy是一个模板类，constraints是其成员函数，第2行只是定义而未执行] 。   
[译注：这里constraints实现的关键是依赖C++强大的类型系统，特别是类的多态机制。第2行代码中T2 c =  a; b =  a; 能够正常通过编译的条件是：T1实现了T2的接口。具体而言，可能是以下4种情况：(1) T1、T2 同类型 (2) 重载operator =  (3) 提供了 cast operator(类型转换运算符)(4)派生类对象赋给基类指针。说到这里：记起我曾在以前的一篇文章中说到，C+ +的genericity实作――template不支持constrained genericity，而Eiffel则从语法级别支持constrained genericity，即提供类似于template < typename T as Com parable>  xxx 这样的语法――其中Comparable即为一个constraint。曾有读者指出我这样说是错误的，认为C+ +  template也支持constrained genericity。现在这部分译文给出了通过使用一些技巧，将OOP和GP的方法结合，从而在C+ +中巧妙实现constrained genericity的方法。对于爱好C+ +的读者，这种技巧是值得细细品味的。不过也不要因为太执著于各种细枝末节的代码技巧而丧失了全局眼光。有时语言支持方面的欠缺可以在设计层面，而非代码层面，更优雅地弥补。另外，这能不能算“C+ +的template支持constrained genericity”，我保留意见。正如，用C通过一些技巧也可以OOP，但我们不说C语言支持OOP。]

请大家再注意ハ衷谖颐堑亩ㄒ寰弑噶苏庑┪颐切枰的特性
1)你可以不通过定义/拷贝变量就表达出constraints[译注κ翟蚨ㄒ/拷贝变量的工作被封装在Can_copy模板中了] ゴ佣可以不必作任何“那个类型是这样被初始化”之类假设ヒ膊挥萌ス芏韵竽芊癖豢奖础⑾毁３非这正是constraints所在ぁ[译注即――除非constraints正是“可拷贝”、“可销毁”。如果用易理解的伪码描述ゾ褪template < typename T as Copy_Enabled>  xxxtemplate < typename T as Destructible>  xxx 。]  
2)如果使用现代编译器constraints不会带来任何额外代码  
3)定义或者使用constraints均不需使用宏定义  
4)如果constraints没有被满足ケ嘁肫鞲出的错误消息是容易理解的。事实上ジ出的错误消息包括了单词“constraints” (这样ケ嗦胝呔湍艽又械玫教崾)、constraints的名称、具体的出错原因(比如“cannot initialize Shape*  by double* ")

还可以写很多类似功能的模板类
template< class T, class B>  
struct Derived_from 
{
	static void constraints(T*  p) 
	{
		B*  pb =  p; 
	}    
	Derived_from() 
	{
		void(* p)(T* ) =  constraints; 
	}   
};

template< class T1, class T2>  
struct Can_copy 
{   
	static void constraints(T1 a, T2 b) 
	{  
		T2 c =  a; 
		b = a; 
	}    
	Can_copy()
	{
		void(* p)(T1,T2) =  constraints; 
	}
};

template< class T1, class T2 = T1> 
struct Can_compare 
{
	static void constraints(T1 a, T2 b) 
	{
		a == b; 
		a != b; 
		a< b;
	}
	Can_compare()
	{
		void(* p)(T1,T2) =  constraints; 
	}
}; 

template< class T1, class T2, class T3 = T1>  
struct Can_multiply 
{
	static void constraints(T1 a, T2 b, T3 c) 
	{
		c =  a* b; 
	}
	Can_multiply()
	{
		void(* p)(T1,T2,T3) = constraints; 
	}
};

struct B {  };
struct D: B {  };
struct DD: D {  };
struct X {  };
int main()
{
	Derived_from< D,B> ();
	Derived_from< DD,B> ();   
	Derived_from< X,B> ();   
	Derived_from<int,B> ();
	Derived_from< X,int> ();    
	
	Can_compare<int,float> ();   
	Can_compare< X,B> ();   
	
	Can_multiply<int,float>();   
	Can_multiply<int,float,double>();   
	Can_multiply< B,X> ();    
	
	Can_copy< D* ,B* > ();   
	Can_copy< D,B* > ();   
	Can_copy< int,B* > ();  
} 
事实上Derived_from并不检查继承性ざ是检查可转换性。不过Derive_from常常是一个更好的名字――有时给constraints起个好名字也是件需细细考量的活儿
//------------------------------------------------------------------------------------------------
//C++ FAQs 百度文库 P47 只有静态常量整型数据成员才可以在类中初始化
#include <iostream>
using namespace std;

class Test
{
public:
	static int a;
	static const int b = 8;
};

int Test::a;

int main()
{
	const int* p1 = &Test::a;
	const int* p2 = &Test::b;
	cout << p1 << '\t' << p2 << endl;
}
//------------------------------------------------------------------------------------------------
//C++ FAQs 百度文库 P48 为何delete操作不把指针置零
(1)delete的对象不一定为左值，如delete p + 1; delete f(x);
(2)T*  p = new T;  T*  q = p;  delete p;  delete q;//这种情况仍然无法避免
如果你觉得释放内存时把指针置零很重要，那么不妨写这样一个destroy函数：
template< class T>  
inline void destroy(T* & p)
{
	delete p; 
	p = 0; 
}
不妨把delete带来的麻烦看作“尽量少用new/delete，多用标准库中的容器”之另一条理由吧
请注意，把指针作为引用传递，以便delete可以把指针置零会带来额外的效益――防止右值被传递给destroy()。只有const 引用才可以接受临时变量
//------------------------------------------------------------------------------------------------
//C++ FAQs 百度文库 P55 指针风格的声明和书写，尽量把*写在与类型挨在一起
#include <iostream>
using namespace std;

int main()
{
	int* p1, p2;//p1为int*，p2为int
	int a = 3;
	p1 = &a;
	p2 = 4;
	cout << *p1 << '\t' << p2 << endl;
}
坚持一次只声明一个指针并在声明时顺便初始化，困扰我们已久的混淆之源就会随风逝去！
//------------------------------------------------------------------------------------------------
//静态函数可以像普通成员函数一样被类对象调用，也可以直接类名::调用
#include <iostream>
using namespace std;

class Car {
public:
	Car();
	~Car();
	Car(const Car& c);
	static int num();                                
protected:
	static int num_;                              
};
Car::Car()
{
	++num_;
}

Car::~Car()
{
	--num_;
}

int Car::num()
{
	return num_;
}

int Car::num_ = 0;   

int main()
{
	Car a;
	cout << Car::num() << endl;
	cout << a.num() << endl;
}
//------------------------------------------------------------------------------------------------
//C++编程惯用法 P16 
一个经过详细考虑并记录下来的抽象模型对于程序设计的重要性：
1. 它有助于帮助他人来理解如何使用你所设计的类
2. 抽象模型是你与你的用户之间的一个协议
3. 在记录抽象模型的过程中，我们常常可以发现设计中的重要缺陷
4. 清晰的抽象模型文档有助于其他人重新构造出你的类的新版本
5. 一旦理解了抽象模型，我们就可以避免“以实现来驱动设计”的情况出现。设计抽象模型和设计实现方案应该是两个独立的行为，但尽管如此，这并不意味着我们需要用不同的人手来分开处理这两部分，重要的是，开发人员必须知道自己在某个特定的时间时，自己到底是在负责抽象还是在负责实现。
仅仅考虑抽象（而不是实现），我们有几种常用的方法。在抽象的过程中决定“什么应该有，什么不应该有”是面向对象设计者的一个关键技巧。

如何开始抽象模型的设计：
第一步：用一句话来描述该对象是用来干什么的（注意，不是“是什么”）。这种描述方式应该尽可能的抽象，尽量不要涉及到对象的内部结构。这种“官面总结”应该尽可能的简单，简单到即便是行政人员也可以轻而易举地理解它。
“当从呼叫电话拨号后，电话号码就是决定可能连接到的被呼电话的关键。”
没有出现在抽象模型中的东西和存在于模型中的一样重要。在保持实用性的前提下，我们通过尽可能地将该模型最小以使其尽可能通用化。我们提高了它应付今后未知变化的能力，以避免频繁地修改我们的抽象模型（但实现细节可能有所改变）。
如果存在疑问，暂不考虑。在吃不准某个特殊的概念是否应该包含于抽象模型中时，通常的安全做法是不去考虑它，而只是把它包含入我们的抽象模型中去。这是因为，由于缺少造成的错误通常都可以用一种向上兼容的方法进行修复――一般来说我们只需在类中新增一个成员函数就可以了。扩展接口总是比缩减接口要容易得多。从另一方面来说，从类中去除掉一个成员函数通常很难做到与现有代码兼容，因为可能已经有的用户代码中调用了这个被去除的函数。
作为初始设计过程的部分，设计人员应该仔细地考虑抽象模型与其他模型间的交互，问自己一系列相关的问题。问自己这些问题还有着另外一个重要的好处。当在设计时问自己这些问题时，最好在那些能够很容易就得到答案的问题上停下来，并更加深入地对它们进行思索。这个（显而易见）的答案是不是对的？试图去设想一个可以证明它是错误的场景。只要你能够在这种思索过程中找到哪怕只是一个错误场景，你都有可能会因此避免一个将来会给你带来高昂代价的设计错误。
is-a， has-a，use-a（电话和连接）三种关系。

小结：
1. 设计抽象模型和设计实现细节应该是两个独立且相关的行为。
2. 没有出现在抽象模型中的东西和出现在其中的东西一样重要。
3. 如果存在疑问，先不要去考虑它。添加新的功能通常都不会有兼容性的问题，但是去除一个已有的功能则可能会导致代码失效。
4. 彻底地检测和记录下设计中的关键点。
5. 设计是一个迭代的过程。
6. 请考虑边界条件。
7. 在设计的初始阶段使用CRC卡片。
//------------------------------------------------------------------------------------------------
//C++编程惯用法 第2章 P30 
对于缺省复制构造，并没有一个通用的规则。一种从经验中得到的方法就是：对那些包含指针的类要“另眼相待”。如果被指向的对象“属于”该产生的对象，那么缺省的复制构造函数就有可能是错误的，因为它只是简单地复制了指针而不是指针所指向的对象。

避免公有数据成员的出现。公有成员将使得我们很难去更改类的实现（如改变信息的存储格式或者存储位置）；它也无法保证表示不变量的长期有效性（如有理数分母0的判断，如果不用类成员函数判断，则需要每次赋值都进行手动判断）。

隐式转换
例：
class Rational
{
public:
	Rational(long num = 0, long denom = 1);
};

int operator==(const Rational&, const Rational&);

int nonzero(const Rational& r)
{
	return r == 0;
}
该例中，0在被隐式转换成一个Rational（在Rational的构造函数中，第二个参数有着一个缺省的值1）。在这个代码中，比较==操作看起来要比它实际上的显式操作要显得更高效一些。它的显示版本如下：
int nonzero(const Rational& r)
{
	return r == Rational(0, 1);
}
上面的代码就可以给我们一个更好的关于该函数的实际性能如何的描述，并且它还可以向我们暗示出如下的优化：
int nonzero(const Rational& r)
{
	static const Rational zero(0, 1);
	return r == zero;
}
这使得我们可以节省下每次都创建和摧毁一个新的Rational对象zero所产生的开销。只有那些精明的程序员才可以从函数的最初版本中发现这种优化。

操作符重载为成员或非成员函数：P46
一元操作符：声明为非成员函数可以使参数隐式转换，声明为成员函数无法进行隐式转换。隐式转换的代码难以被维护和理解。出于这个原因，建议：在可能的情况下，最好将一元操作符实现为成员函数。
=，[]，()和->：按照C++语言定义来说，这四种操作符必须被实现为成员函数，任何将它们中的某个实现为非成员的尝试都会造成一个编译错误。
其他二元操作符：赋值类操作符最好定义为成员函数（可以防止隐式转换，如Complex c; c += 5; 如果发生了隐式转换为其他东西，则运行后c的值将不会变，令人迷惑）；非赋值类操作符，最好将该操作符定义为非成员函数，这可以确保在有隐式转换的条件下，这两个操作数都可以以同样的方式进行操作。

P50 Const
记住一点：将某件事物声明为const（或者是指向const的指针或者引用）会引起额外的编译期检测，但它并不会导致编译器产生额外的代码。

#include <iostream>
using namespace std;

void doCallback(const int* ip, void(*callback)())
{
	cout << *ip << endl;
	//(*ip) = 8;
	(*callback)();
	cout << *ip << endl;
}

int i = 5;
void bump()
{
	++i;
}

int main()
{
	doCallback(&i, bump);
}
声明一个指向常量的指针关注的该指针，而不是该指针所指向的空间，编译器不确保被指向的数据不会被改变，能确保的是，数据不会是通过该指针被改变的。
调用回调函数时，先对函数指针进行解引用，再调用该函数：(*callback)();然而，直接通过()操作符来“调用”该函数，将得到和前面一样的结果：callback();
这两种方式得到的代码将完全一样。但并不推荐这么做。当使用第一种形式时，我们可以很清楚地知道函数是通过函数指针来调用的；如果我们使用第二种形式，我们必须了解“函数”的类型实际上也就是“函数指针”的类型。相比而言，少输入几个字符所得来的好处不值得我们去为它而生成难以理解的代码。

可以在未命名的临时对象上调用一个非常量成员函数：P53
class String
{
public:
	void capitalize();//非常量成员函数
};

String makeUpName();
makeUpName().capitalize();//可以但是不应该这么调用
这种做法凸显了C++语言定义的一个失误。不管如何，我们都不应该使用这种用法。如果我们希望从对象来调用一个非常量的成员函数，我们必须明确地定义这个对象并给它一个名字：
String name(makeUpName());
name.capitalize();//稍好的做法。按照这个说法，之前的for_each(stringVec.begin(), stringVec.end(), MyFunc()).show();的写法也是不好的？
这将保证该名字所代表的对象在程序离开当前定义它的语句块前都不会被摧毁。

常量成员函数P53
通过在函数的声明体和定义体的参数列表后面添加关键字const，我们可以把一个成员函数声明为一个常量成员函数：
//String.h中
class String
{
public:
	int length() const;
	void capitalize();
};
我们只能对常量对象调用常量成员函数：
const String("hello");
int len = s.length();//OK
s.capitalize();//编译期错误：对常量对象调用非常量成员函数

String t("world");
len = t.length();//OK
t.capitalize();//OK
在常量成员函数的定义体中，对象的所有数据成员都是常量，“this”指针也是一个“指向常量对象的常量指针”，而不是“指向对象的常量指针”。

P55 修改常量成员函数中的成员数据值
为了在一个常量成员函数中对数据成员进行修改，我们必须使用类型转换来去除该成员的常量性。在C++中，这种做法不但合法，而且只在类中带有一个构造函数，它的行为就将正确无误。（如果类中没有构造函数，那么我们用来去除常量性的类型转换将得到未定义的结果；之所以有这样的规则是因为我们希望编译器能够将类似于const int这样的事物旋转到ROM中去。）
#include <iostream>
using namespace std;

class Test
{
public:
	Test(): i_(0) { }
	int get() const
	{
		if (0 == i_)
		{
			const_cast<int&>(i_) = 1;//(int&)(i_) = 1;这种写法是C形式的转换
		}
		return i_;
	}
private:
	int i_;//如果不用转型方式的话，可以把i_声明成mutable int i_;就可以在常量成员函数中修改其值了
};

int main()
{
	Test t;
	cout << t.get() << endl;
}

P56 静态对象
C++编译系统确保：所有的静态对象在它们被使用之前都会被初始化。很多的编译器实现的做法是将所有静态对象放到main函数被调用之前进行初始化，但C++语言规则中也允许我们在（动态的）链接时期用动态的链接器来初始化编译单元中的所有对象。
如果不能将这两个静态对象放在同一个文件中（这样我们就可以得到它们的初始化的确切顺序），就不得不将这些初始化操作延迟到main函数被执行时才执行它们（或Effective C++ P62 条款4中放入函数中的local static对象单例方法）：
extern String defaultName;//另一个文件中字符串
String* defaultSrcFile = 0;
static void initNames()
{
	defaultSrcFile = new String(defaultName + ".c");
}

int main()
{
	initName();//这时候defaultName优先defaultSrcFile被使用了，所以肯定会优先初始化
}

如果我们的代码来自于一个函数库，在那里并没有我们所期望的main()函数，那么我们还可以在每个使用了具有依赖关系的静态对象的函数中对该对象进行检测，看看它是否已经被初始化了：
extern String defaultName;//另一个文件中字符串
String* defaultSrcFile = 0;
void routineThatUsesName()
{
	if (defaultSrcFile == 0)
	{
		defaultSrcFile = new String(defaultName + ".c");
	}
}

P57 我们应该避免在一个给定的头文件中初始化对象，因为它会造成每个包含该头文件的编译单元都拥有这份初始化代码。模板特性的一个副作用就是：它会增加给定程序中编译单元的个数（因为每个模板对会被实例化一个单独的编译单元）。当使用模板时，我们很容易就能得到上百个编译单元的程序。对于这样的程序来说，要求同一个初始化在每个编译单元中都有着冗余的运行时开销的方式会显得太昂贵了。

小结：
1. 判断缺省的复制构造函数和赋值操作符的行为是否符合我们的期望，必要时重新实现它们。
2. 避免使用赋值操作来初始化成员：使用构造函数初始化语法来完成初始化操作。
3. 当编写赋值操作符时，请检测s = s这种情况。
4. 避免出现公有成员数据。
5. 尽可能少地声明和使用隐式类型转换。避免在同一个类中出现两个（或多个）转换操作符。
6. 一元操作符、赋值类操作、()、[]、以及->应该被定义为成员函数，其他操作符应该被定义为非成员函数。
7. 使用缺省值来为同一个函数提供不同的调用方式，使用函数重载来为同一个抽象操作提供多种实现。
8. 除非被调用函数需要它自己的对象拷贝，否则请使用传递常量引用的方式来调用函数。
9. 在可能的情况下，将指针参数声明为指向常量的指针，将引用参数声明为指向常量的引用。
10. 在可能的情况下，将成员函数声明为const。
11. 不同文件中的静态数据的初始化顺序没有被明确定义。
//------------------------------------------------------------------------------------------------
//C++编程惯用法 第3章 句柄 P60
从概念上来说，句柄是一个指向某种C++对象的指针，它通常也就是一个普通的C++指针。我们使用术语“句柄”的原因是：句柄本身也可以是某种C++对象，它可以用来提供和指针一致的功能。
句柄可以给我们带来如下的好处：
1. 我们可以在实现中用尺寸大小固定的对象来表示尺寸大小不定的值。
2. 我们可以在实现中用运行时绑定而不是编译时绑定的方式来处理对象。
3. 对于实现的改变通常只会引起一次重新链接，而不是重新编译。
4. 我们可以对他人隐藏对象的实现。
不过有利必有弊，句柄的实现通常需要我们编写更多的代码，并且它还会带来一些运行时的开销。
P63 句柄在String类中的应用，char*和嵌套计数类
//------------------------------------------------------------------------------------------------
//C++编程惯用法 第4章 继承
P78 私有、保护和公有继承
一个类可以向外给出两个接口：一个面向用户（类的公有部分）；另外一个则面向派生类的实现（类的公用部分以及保护部分）。继承也同样如此：如果继承方式是公有的，它就是面向对象的接口的一部分，用户也就可以以此编写依赖于该继承关系的代码。如果继承方式是保护型的，那么它只是面向派生类实现的接口的一部分。如果继承方式是私有的，它将不属于任何的接口，只有类的实现本身（以及其友元）才可以使用这种继承关系。
公有继承，基类中的公有成员也就同时成为了派生类中的公有成员，它里面的保护成员也成为了派生类中的保护成员；一个指向派生类的指针可以被隐式地转化为一个指向公有基类的指针。
私有继承，基类中的公有成员以及保护成员都变成派生类别的私有成员，我们可以通过派生类别的成员和友元来访问它们，但是用户就不行了。用户不能隐式地将一个指向派生类的指针转化为指向私有基类的指针。
保护继承，基类中的保护和公有成员都将成为派生类别的保护成员。派生类可以调用保护基类中的成员函数，并且也可以隐式将一个指向派生类的指针转化为一个指向保护基类的指针。
通过使用存取声明指令using，私有或保护基类中的公有对象也可以变成派生类别的公有成员。
P81私有继承使用的一个特例：在派生类中需要重写基类中的虚函数，但又不希望对基类的使用暴露于公有接口中。如果被重写的函数是析构函数时，最简单（也是惟一）的做法就是使用私有继承。（P82的例子，如何调用，根本指不上私有继承派生类啊？）
当继承是面向派生类而不是面向用户的接口中的一部分时，我们就选择使用保护继承。一个保护型的基类和一个能够被所有派生类所访问的私有基类差不多：
class String {};
class Telephone_number: protected String {};
class Local_number: public Telephone_number {};
在类Local_number中的成员函数都可以访问它们的String部分的公有和保护成员。
作者从来没有使用过保护型 继承，也没有听说有人在哪个项目中使用过它。除了会得到一个保护基类之外，那些用来阻止使用私有继承的原因同样也适用于保护继承，而且我们也可以很容易就得到一个保护成员：
class String {};
class Telephone_number 
{
protected:
	String s;
};
class Local_number: public Telephone_number {};
上面的代码大大简化了继承架构，并用它还没有改变代码的运行效率，Local_number中的成员函数仍然可以访问到对象中的String部分（此时惟一的改动就是我们必须通过s来访问它们）。
我们并不是说保护继承没有用――如果派生类别的成员需要重写（保护型）基类中的虚函数，我们就可以使用保护型继承了。但如果可以使用组合，我们就应该使用组合：因为使用语言中的晦涩特性（如保护继承）会增大理解程序的难度。
当继承被使用时，有着一个严格的限制：派生类别的成员函数必须和基类的抽象模型相一致。虽然实现可能会不一样，但所有派生自Vehicle的对象都应该“像Vehicle那样加速”。这种语义上的限制并没有出现在C++的语法规则中，也没有C++编译器能够检测出它们来。这样才能保证通过基类调用派生类对象时行为一致。
析构函数不能为纯虚函数：派生类肯定会调用基类的析构函数，所以必须有定义，声明了纯虚没有任意意义。
P87 没有被继承的东西
当我们使用继承时，我们必须时刻牢记，下面的这些东西没有从基类中被继承：
1. 构造函数（包括复制构造函数）。如果我们没有声明复制构造函数，那么编译器将会自动为我们创建一个。在这个被创建的复制构造函数中，它会调用类中所有非静态的数据成员以及基类的复制构造函数。
2. 析构函数。如果烦躁的某个基类的析构函数是虚函数，那么编译器为我们合成的析构函数也将是虚函数。
3. 赋值操作符。
4. 被隐藏的成员函数。如果不希望隐藏基类中的函数，则要么用using引入到派生类中，要么定义一个完全相同的函数，并且在实现中调用基类的这个函数。

P89 不要在构造函数和析构函数中调用虚函数
#include <iostream>
using namespace std;

class Base
{
public:
	Base()
	{
		debugPrint();
	}
	virtual ~Base()
	{
		debugPrint();
	}
	virtual void debugPrint()
	{
		cout << "base" << endl;
	}	
};

class Derived: public Base
{
public:
	virtual void debugPrint()
	{
		cout << "derived" << endl;
	}
};

int main()
{
	//Base b;
	Derived d;
}
输出：
base
base
请按任意键继续. . .
记住：只有在构造和析构的过程中调用虚函数才会导致这种特殊的行为出现。在其他情况下（即使是我们在构造函数或析构函数中调用它时），虚函数的行为都是正常的。

小结：
1. 继承描述的是is-a关系：派生类所实现的对象应该是基类所实现的对象集中的一个子集。
2. 当继承是接口的一部分时，请使用公有继承。只有当继承被用来隐藏实现细节时，我们才需要使用私有和保护继承。
3. 对于私有继承的大部分使用，我们都可以用组合来替代；只有当派生类需要重写（私有）基类中的虚函数时，我们才不能那样做。
4.	在派生类中被重写的虚函数应该和基类中的抽象模型相一致。
5.	构造函数、析构函数以及赋值操作符不能被继承。
//------------------------------------------------------------------------------------------------
//C++编程惯用法 第5章 多重继承
P97 多重继承描述的是对象间的交集，而交不是合集。当我们这样写时：
class D: public B1, public B2{};
我们就已经断定在B1所描述的对象和B2所描述的对象间存在着一个非空的交集，而D就是这个交集。我们可以在D上面调用所有B1和B2的公有成员函数；因此D不但是B1，同时也是B2。
如果B1和B2之前没有交集的话，我们就不能使用多重继承。特别地，并非D要么是B1，要么是B2，而恰好同时既是B1，也是B2。

小结：
1. 只有在派生类包括多个基类，并且这多个基类间没有继承关系时，我们才应该使用多重继承。
2. 使用虚基类来避免在同一对象中出现多份基类子对象。
3. 基类对象的构造顺序和它们在类声明中（而不是构造函数的定义中）的顺序一样。
4. 为每个基类明确地指定存取类型。
//------------------------------------------------------------------------------------------------
//C++ 编程惯用法 第6章 考虑继承的设计
P111 将函数声明为虚函数同时也会因为该函数不能内联而导致一定的开销。如果在编译时编译器断定应该执行的代码究竟是哪部分代码，那么它就不能将成员函数扩展为内联函数。
相比“非内联函数”和“虚函数”之间的差别来说，“内联函数”和“非内联函数”的差别总是要大一些。动态绑定的最大开销并不在于运行时分发所带来的执行时间，而是来自于“被动态绑定的函数不能被内联”这个事实。对大多数现实中的程序来说，“虚函数和虚基类只会带来矢量的性能损耗”这个结论总是正确的。
保护型数据会使得派生类得以了解到我们类的部分实现。虽然出于性能上的考虑这样做可能是必要的，但我们至少还是应该尽量通过提供保护型存取函数来避免使用保护型数据。
再次重申，在此讨论的是：如何设计可能会被其他人继承的类。如果我们拥有所有的派生类，那么使用保护型数据将是一种很完美的解决方法。但如果我们设计的是要给其他人从中派生的类，保护型数据就不再适合了。
P113 抽象基类的定义以及<<的重载
P115 为派生类提供服务的类：管理计数器的基类。只是被用来对派生类的调用提供服务。基类同样也可以用来主动调用定义在派生类中的（虚）函数。一个关于基类的主动调用的例子就是：修改计数类，使得当计数器被清0时它会知道摧毁掉已有的对象。if (--count_d == 0){delete this;}
让基类来为派生类提供服务只是“一个类为另外一个类提供服务”中的一个特例而已。除此之外，它（“一个类为另外一个类提供服务”）还包括：
1. 一个类是另外一个类的成员（has-a关系）：例如，如果Car拥有Engine，那么Engine就可以用来为Car提供服务。
2. 一个类可以调用另外一个类的成员函数（use-a关系）。如果我们需要访问一条特定的职员记录，我们可以调用Directory中的一个成员函数来实现这一点。
//------------------------------------------------------------------------------------------------
//C++编程惯用法 第7章 模板
P122 我们可能会设想模板Tuple可以用来接受任意个类型参数，可惜的是，模板类不能被重载，对于一个特定的名字来说，程序中只可以用它来定义一个模板：
template<class L, class R>
class Tuple{};
template<class L, class M, class R>
class Tuple{};//编译期错误：Tuple被重复定义，我们可以使用递归的方式来使得Tuple接受任意个模板参数变为可行的，具体的做法可以参考boost库中Tuple库
P122 一些有关模板的细节
模板类的两个不同实例间的关系必须被明确地区分开来。pair<int, int>和pair<double, double>是两个完全不同的类：它们之间既不存在继承关系，也不存在友元关系。实际上，我们根本没有办法让同一个模板类所产生的实例类相互成为友类，我们可以这么声明：
friend class stack<int>;
但不能这么做（或者其他类似的行为）：
friend template<class T> class stack;
我们可以设法让一个特定的类成为一个指定的模板类的所有实例的友元：
template<class T>
class stack
{
	friend class stackImpl;
};
也可以让模板类的所有实例类都拥有一个共同的基类：
template<class T>
class stack: public stackBase{};

P132 只有当类比较小且我们对性能要求很高时，我们才会在模板中使用表达式参数。把表达式作为模板参数会使得某些实现变快，在内嵌函数中使用这些参数时这种变化显得尤为明显。
在实际中，这种通过使用模板的表达式参数而获得的性能上的提升和由此受到的语义限制（尤其是“表达式必须是一个编译期的常量表达式”这个限制）相比并不合算。
//------------------------------------------------------------------------------------------------
//C++ 编程惯用法 P174 Linton法则
函数中不应该将指向其引用参数的指针保存在函数返回后还可以访问到的变量中。如果需要这么做的话，我们就应该使用指针参数。
P199 Tiemann法则
如果它从来没有被重用过，那它就不能被称为可重用的。
//------------------------------------------------------------------------------------------------
//C++编程规范101 
P25 第6条 应该使用命名变量，而不要使用临时变量，作为构造函数的参数。这能够避免可能的声明二义性。这还经常能使代码的意图更加清晰，从而更容易维护，而且经常也更安全。（见第13条和第31条）
//------------------------------------------------------------------------------------------------
//C++编程规范101 
P27 第7条
要尽可能优先使用线性（或者更好的）算法。尽可能合理地避免使用比线性算法差的多项式算法。竭尽全力避免使用指数算法。
//------------------------------------------------------------------------------------------------
//C++编程规范101
P40 第14条
运行时检查取决于控制流和数据的具体情况，这意味着很难知道检查是否彻底。相比而言，编译时检查与控制流和数据无关，一般情况下能够获得更高的可信度。
//------------------------------------------------------------------------------------------------
//C++编程规范101
P51 第21条
Singleton单例本质上也是全局变量――披着羊皮的“狼”，它会因为相互依赖或者循环依赖而被破坏（同样，零初始化只会使情况更复杂？？？）。
//------------------------------------------------------------------------------------------------
//C++编程规范101
P52 第22条
不要过分依赖：如果用前向声明（forward declaration）能够实现，那么就不要包含（#include）定义。
如
#include <iosfwd>
class Base;
不要互相依赖：循环依赖是指两个模块直接或者间接地互相依赖。
讨论：
除非确实需要类型定义，否则应该优先使用前向声明。主要在两种情形下需要某个类比如C的完整定义：
1. 需要知道C对象的大小时：例如，在栈中分配一个C，或者作为另一个类型直接具有的成员分配一个C。
2. 需要命名或者调用C的成员时：例如，调用成员函数时。

依赖倒置原则（Dependency Inversion Principle）：不要让高层模块依赖于低层模块；相反，应该让两者都依赖于抽象。如果能够为Parents或Child定义独立的抽象类，那么就能够打破循环了，否则，就必须保证它们属于同一模块。

类之间的依赖循环并不一定都是坏事――只要类被认为属于同一模块，一起测试，一起发布。诸如Command（感觉说得不太对啊，命令模式并没有这种循环依赖啊？？？）和Visitor等设计模式的原始实现就会产生天生相互依赖的接口。这种相互依赖可以被打破，但是需要进行的设计才行。
//------------------------------------------------------------------------------------------------
//C++编程规范101
P58 第25条
如果函数需要其参数的副本，则可以考虑通过值传递代替通过引用传递。这在概念上等同于通过const引用传递加上一次复制，能够帮助编译器更好地优化掉临时变量。
在Effective C++ P86 条款11中的处理自我赋值讲到copy and swap技术进行异常安全的赋值提到：
Widget& Widget::operator=(const Widget& rhs)
{
	Widget temp(rhs);
	swap(temp);
	return *this;
}
这个主题的另一个变奏乃利用以下事实：（1）某class的copy assignment操作符可能被声明为“以by value方式接受实参”；（2）以by value方式传递东西会造成一份复件/副本：
Widget& Widget::operator=(Widget rhs)
{
	swap(rhs);
	return *this;
}
作者个人比较忧虑这个做法，认为它为了伶俐巧妙的修补而牺牲了清晰性。然后“copying动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码。

再如重载二元操作符@，应该定义其赋值形式，使a@=b和a=a@b具有相同的含义（只不过第一种形式可能更高效，它只计算一次a）。实现这一目标的标准方法就是用@=来定义@：
T& T::operator=(const T&)
{
	//...具体实现代码
	return *this;
}

T operator@(const T& lhs, const T& rhs)
{
	T temp(lhs);
	return temp @= rhs;
}

非成员函数的operator@=（不过不推荐，赋值操作符最好为成员函数）和上述所讲变体，使operator@通过值接受其第一个参数。这样，可以安排编译器自己隐式地进行复制，这能够在应用优化上给编译器以更多的灵活性：
T& operator@=(T& lhs, const T& rhs)
{
	//...具体的实现代码
	return lhs;
}

T operator@(T lhs, const T& rhs)
{
	return lhs @= rhs;
}

另一种变体是让operator@返回一个const值。这种技术的优势在于，它禁止了a+b=c一类的废话式的代码，但是这样也要付出一定的代价：它禁止了一些可能有用的结构，比如a = (b + c).replace(pos, n, d)――这是很有表达力的代码，一个式子就合并了字符串b和c，替换了一些字符（但是因为加了const，该临时变量不可被改变，所以也无法替换了），然后将最后结果赋值给a，可谓一石三鸟。
Effective C++ P48 条款3尽可能使用const又说最好让operator@返回一个const值，所以视情况而定吧

示例：
一个用于字符串的+=的实现。实现字符串时，预先知道长度是很有用的，这样只分配一次内存就可以了
String operator+=(const String& lhs, const String& rhs)
{
	String temp;//初始时是空的
	temp.Reserve(lhs.size() + rhs.size());//分配足够内存
	return (temp += lhs) += rhs;//追加字符串然后返回
}
例外情况
在一些情况（比如操作于复数的operator*=），操作符可能要显著地改变其左参数，此时用operator*实现operator*=可能会比反过来更有利。
//------------------------------------------------------------------------------------------------
//C++编程101
P65 第30条 避免重载&&、||或,（逗号）
内置版本的&&、||和,（逗号）的特殊之处在于：从左到右求值，而&&和||还使用短路求值。
重载之后遵循以下规则：对所有参数进行求值（,逗号总是要对两个表达式都求值）， 函数参数的求值顺序是不确定的。
//------------------------------------------------------------------------------------------------
//C++编程规范101
P66 第31条 不要编写依赖于函数参数求值顺序的代码
函数参数的求值顺序是不确定的，因此不要依赖具体的顺序。
void transmogrify(int, int);
int count = 5;
Transmogrify(++count, ++count);//求值顺序未知
我们惟一能够确定的就是运行一旦进入Transmogrify的函数体，count的值就会变为7――但是我们不知道它的参数哪个是6，哪个是7。
这种问题解决起来其实很简单――使用命名对象控制求值顺序（第13条 P37）：
int bumped = ++count;
Transmogrify(bumped, ++count);//OK
又如第13条所述（Effective C++ 条款17也讲了同样的原则）：
void Fun(shared_ptr<Widget>, shared_ptr<Widget>);
Fun(shared_ptr<Widget>(new Widget), shared_ptr<Widget>(new Widget));
这种代码是不安全的，因为如果其中一个构造函数调用抛出异常的话，另一个对象的内存就永远也没有办法释放了。这种微妙的问题有一个简单的解决办法：遵循建议，绝对不要在一条语句中分配一个以上的资源，应该在自己的代码语句中执行显式的资源分配（比如new），而且每次都应该马上将分配的资源赋予管理对象（比如shared_ptr）。例如：
shared_ptr<Widget> sp1(new Widget), sp2(new Widget);
Fun(sp1, sp2);
//------------------------------------------------------------------------------------------------
//C++编程规范101
P72 第35条 
要添加行为，应该添加非成员函数而不是成员函数。要添加状态，应该使用组合而不是继承。要避免从具体的基类中继承。
从独立类中继承将使代码面临大量问题，而且其中很少有编译器能够发出警告或者报错。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P74 第36条优先提供抽象接口
应该定义和继承抽象接口。抽象接口是完全由（纯）虚拟函数构成的抽象类，没有状态（成员数据），通常也没有成员函数实现。请注意，在抽象接口中避免使用状态能够简化整个层次结构的设计。
应该遵守依赖倒置原则（Dependency Inversion Principle, DIP），表述如下：
1. 高层模块不应该依赖于低层模块。相反，两者都应该依赖抽象。
2. 抽象不应该依赖于细节。相反，细节应该依赖抽象。
遵守DIP意味着层次结构应该以抽象类而不是具体类为根。抽象基类必须负责定义功能，而不是实现功能。换言之，策略应该上推，而实现应该下入。
与此相关的二次机会定律陈述如下：需要保证正确的最重要的东西是接口。其他所有东西以后都可以修改。如果接口弄错了，可能再也不允许修改了。
通常，应该选择公用虚拟函数以允许多态删除，除非使用了诸如COM或CORBA这样的对象代理，它们使用的是另一种内存管理机制。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P76 第37条 公有继承即可替换性
公用继承所建模的必须总是“是一个（is-a）”【即可精确的“其行为像一个（works-like-a）”】关系：所有基类约定必须满足这一点，因此如果要成功地满足基类的约定，所有虚拟成员函数的改写版本就必须不多于其基类版本，其承诺也必须不少于其基类版本。
当人们使用公用继承进行不相关的现实类比时，其实就已经误解了公用继承中“是一个”这种描述的意义：从数学上说，一个正文形的确“是一个”矩形，但是在行为上一个Square并不是一个Rectangle。因此，我们不使用“是一个”，而喜欢说“其行为像一个”（或者，如果愿意的话，说“可以用作一个”也行），这样可以避免描述易于误解。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P78 第38条 实施安全的改写
保持基类中函数的前后条件。
虽然派生类通常会增加更多状态（即数据成员），但它们所建模的是其基类的子集而非超集。在正确的继承关系中，派生类所建模的是更一般的基础概念的一个特例（见第37条）。
这对正确改写有直接的影响：因为包含关系隐含着可替换性――适用于整个集合的操作也应该适用于其任何子集。在基类保证了操作的前后条件后，任何派生类都必须遵守这些保证。改写函数可以要求更少而提供更多，但绝不能要求更多而承诺更少，因为这将违反已向调用代码保证过的约定。
定义一个可能失败（比如抛出异常，见第70条）的派生改写函数，只是在基类没有声明操作总是成功的时候，这个定义才是正确的。
谨防不小心在基类中隐藏了重载函数。如果基类的重载函数应该可见，那就写一条using声明语句，在派生类中重新声明。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P80 第39条 考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的
在面向对象层次结构中进行修改尤其昂贵，所以应该实施完整的抽象：将公用函数设为非虚拟的，将虚拟函数设为私有的（或者设为保护的，如果派生类需要调用基类的话）。这就是所谓的非虚拟接口（Nonvirtual Interface, NVI）模式（最好上网查一下这个模式？）。【NVI与其他模式，特别是模板方法（Template Methods）很类似，但是动机和意图不同】
公用虚拟函数本质上有两种不同而且互相竞争的职责，针对的是两种不同而且互相竞争的目标：
1. 它指定了接口：作为公用函数，这是类向外界提供的接口的一部分。
2. 它指定了实现细节：作为虚拟函数，它为派生类替换函数的基类实现（如果有的话）提供了一个钩子，它是一个自定义点。
这两种职责的动机和目标都不同，所以它们可能会（而且经常会）发生冲突，因而从定义上来讲一个函数无法很好地履行两种职责。公用虚拟函数本身有两种明显不同的职责和两种互相竞争的目标，这是没有很好地将问题关注点分离的标志（本质上违反了第5条和第11条），也说明我们应该考虑采用其它方法了。
通过将公用函数与虚拟函数分离，可以获得如下明显的好处：
1. 每个接口都能自然成形
2. 基类拥有控制权
3. 基类能够健壮地适应变化
//------------------------------------------------------------------------------------------------
//C++编程规范101 P82 第40条 要避免提供隐式转换
隐式转换有两个主要问题：会在最意料不到的地方抛异常，并不总是能与语言的其他元素有效地配合
隐式转换构造函数与重载机制配合得很糟糕，而且会使不可见的临时对象到处出现。定义成operator T（其中T是一个类型）的形式的成员函数的转换也好不到哪里去――它们与隐式构造函数的配合很糟，而且会允许各种荒谬的代码通过编译。
C++中，一个转换序列最多只能包含一个用户定义的转换。可是，如果这其中加入了内置转换，结果就会变得极为混乱。解决方案很简单：
1. 默认时，为单参数构造函数加上explicit（另见第54条，其中有explicit复制构造函数的讨论）（包括提供了默认参数的情况）
2. 使用提供转换的命名函数代替转换操作符：
class String
{
	const char* as_char_pointer() const;//遵循c_str的伟大传统，标准库中的c_str函数是std::string的一个函数，功能是将string对象的值以C风格字符串的形式（在最后加上一个0作为结束符）返回。其原型为const char* string::c_str() const
};

例外情况
只要谨慎地保守使用隐式转换，就可以编写出简洁直观的代码。标准std::string定义了一个参数类型为const char*的隐式构造函数。它工作良好，因为设计者已经采取了预防了措施：
1. 没有目标为const char*的自动转换，这种转换是通过两个命名函数c_str()和data()提供的。
2. 对所有为std::string定义的比较操作符（如==，!=，<）都进行了重载，从而能够以任意顺序比较const char*和std::string（见第29条）。这样就避免了创建隐藏的临时变量。
即使如此，重载函数仍然有些古怪：
void display(int);
void display(std::string);
display(null);//调用display(int)
这一结果可能还是有些令人惊奇。（顺便说一句，如果调用的确实是display(std::string)，则代码将表现出未定义的行为，因为从空指针构造一个std::string是非法的，但是此处并没有要求构造函数检查指针是否为空。）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第41条 将数据成员设为私有
请考虑使用Pimpl惯用法来隐藏类的私有成员。
get/set函数很有用，但是主要由get/set组成的类可能是一种设计不良的表现。遇到这种情况，应该决定一下，它是要提供抽象还是要成为一个struct。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第42条 不要公开内部数据
Effective C++中讲到相同的主题
例外情况
有时由于兼容的原因，比如与遗留代码或者其他系统进行接口，类必须提供访问其内部句柄的方式。如，std::string通过成员函数data和c_str提供了访问其内部句柄的方式，以兼容要接受C语言形式指针为参数的函数――但应该不会存储指针或者通过它们写入数据！这种后门访问函数很讨厌但又无法避免，应该小心并尽可能少地使用，而且，必须在文档中仔细记载什么情况下句柄仍然有效。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第43条 明智地使用Pimpl
抑制语言的分离欲望：C++将私有成员指定为不可访问的，但并没有指定为不可见的。虽然这样自有其好处，但是可以考虑通过Pimpl惯用法使私有成员真正不可见，从而实现编译器防火墙，并提高信息隐藏度（见第11条和第41条）。
如果创建“编译器防火墙”将调用代码与类的私有部分完全隔离是明智的，就应该使用Pimpl惯用法：将私有部分隐藏在一个不透明的指针（即指向已经声明但是尚未定义的类的指针，最好是选择合适的智能指针）后面。例如：
class Map
{
private:
	struct Impl;
	shared_ptr<Impl> pImpl_;
};
应该用Pimpl来存储所有的私有成员，包括成员数据和私有成员函数。这使我们能够随意改变类的私有实现细节，而不用重新编译调用代码――独立和自由正是这个惯用法的标记性特点。
请注意：一定要如上所示使用两个声明来声明Pimpl。将两行合并成一条语句，在一句中前置声明类型和指针，即采用struct Impl* pImpl_;这种形式的，也是合法的，但是意义就不同了，此时Impl处于外围名字空间中（即Impl类的声明与定义空间是与Map类相同的，而不是属于Map类的嵌套类），而不是类中的嵌套类型。
使用Pimpl的理由至少有三个：
1. 潜在更长的构建时间，需要处理不必要的类型定义。对于通过值保存的私有数据成员以及通过值接受的或者用于可见函数实现的私有成员函数中的参数，必须定义它们的类型，即使在此编译单元中根本不需要。这会导致更长的构建时间。
2. 会给试图调用函数的代码带来二义性和名字隐藏。即使私有成员函数不能从类外及其友元调用，它们也会参加查找和重载解析，因此会使调用无效或者存在二义性。C++在可访问性检查之前执行名字查找，然后重载解析。这是可见性具有优先级的原因。在这些调用问题中，有些是可以用Pimpl惯用法以外的办法解决的，例如，永远不写成员函数的私有重载，但是并非所有Pimpl能解决的问题都能有这样的替代方案。
3. 是对错误处理和错误安全的影响。例如，类的值成员数据如果赋值失败则无法提供异常基本保证，但是用（智能）指针则可以先将对象保存起来，为防错赋值提供最基本的保证，而且只要所需的T1和T2（值得注意的有构造和析构）没有副作用，通常还能够提供较强的保证：通过指针而不是值来保存成员对象，将它们都放在一个Pimpl指针之后更好。

例外情况
只有在弄清楚了增加间接层次确实有好处之后，才能添加复杂性，Pimpl也是一样（见第6条和第8条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第45条 总是一起提供new和delete
重载void* operator new(parms)必须伴有与其对应的重载void operator delete(void*, parms)，因为编译器自己要调用它们
定位操作符operator new(in-place)形式：
void* T::operator new(size_t, void* p) {return p;}
并不需要对应的operator delete，因为没有真正的分配。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第46条 如果提供类专门的new，应该提供所有的标准形式（普通、就地和不抛出）
如果类定义了operator new的重载，则应该提供operator new所有三种形式――普通（plain），就地（in-place）和不抛出（nothrow）的重载。不然，类的用户就无法看到和使用它们。（查一下三种具体怎么使用？）
class C
{
	//...
	static void* operator new(size_t, MemeoryPool&);//隐藏三种常规形式
};
声明接受一个MemoryPool为参数的C::operator new重载，将隐藏所有其他重载，包括我们都熟知而且受用的内置全局版本，也就是：
void* operator new(std::size_t);
void* operator new(std::size_t, std::nothrow_t) throw();
void* operator new(std::size_t, void*);
或者，类也可能为以上三种operator new之一提供自己专用的版本。在此情况下，如果声明了其中之一，默认时类将屏蔽其他两个：
class C
{
	//...
	static void* operator new(size_t, void*);//隐藏其他两种常规形式
};
应该让类C在作用域中显式地声明operator new的所有三种标准变体。通常，所有三种形式都有相同的可见性。（各个形式还可以将可见性设为private，比如要显式地禁用普通或者不抛出operator new，但是本条款的目的是提醒读者记住不要因为疏忽而隐藏它们。）
请注意，应该总是避免隐藏就地new，因为它在STL容器中有广泛的使用。（查一下如果使用？）
最后一个技巧是：在两种不同的环境下，公开已隐藏的operator new需要采用两种不同的方式。如果类的基类也定义了operator new，那么要公开operator new所需要做的就是：
class C: public B
{
public:
	using B::operator new;
};
否则，如果没有基类版本或者基类没有定义operator new，就需要写一些矮小的转送函数（因为无法通过using从全局名字空间中导入名字）：
class C
{
public:
	static void* operator new(std::size_t s)
	{
		return ::operator new(s);
	}
	static void* operator new(std::size_t s, std::nothrow_t nt) throw()
	{
		return ::operator new(s, nt);
	}
	static void* operator new(std::size_t s, void* p)
	{
		return ::operator new(s, p);
	}
};
上面的建议也适用于数组形式的operator new[]和operator delete[]。
避免在客户代码中调用new (nothrow)版本，但是仍然要为客户提供，以免客户一旦要用到时感到奇怪。
//------------------------------------------------------------------------------------------------
//百度文库 C++中new的用法大全 wenku.baidu.com/view/110ceda3284ac850ad0242cb.html###
当我们使用关键字new在堆上动态创建一个对象时，它实际上做了三件事：获得一块内存空间、调用构造函数、返回正确的指针。当然，如果我们创建的是简单类型的变量，那么第二步会被省略。
们定义了如下一个类A： 
class A 
{    
	int i; 
public:    
	A(int _i): i(_i*_i) {}    
	void Say()  
	{ 
		printf("i=%dn", i); 
	} 
}; //调用new： 
A* pa = new A(3); 
那么上述动态创建一个对象的过程大致相当于以下三句话（只是大致上）： 
A* pa = (A*)malloc(sizeof(A)); 
pa->A::A(3); 
return pa;
虽然从效果上看，这三句话也得到了一个有效的指向堆上的A对象的指针pa，但区别在于，当malloc失败时，它不会调用分配内存失败处理程序new_handler，而使用new的话会的。因此我们还是要尽可能的使用new，除非有一些特殊的需求。
new的三种形态 
到目前为止，本文所提到的new都是指的“new operator”或称为“new expression”，但事实上在C++中一提到new，至少可能代表以下三种含义：new operator、operator new、placement new。 
new operator就是我们平时所使用的new，其行为就是前面所说的三个步骤，我们不能更改它。但具体到某一步骤中的行为，如果它不满足我们的具体要求时，我们是有可能更改它的。三个步骤中最后一步只是简单的做一个指针的类型转换，没什么可说的，并且在编译出的代码中也并不需要这种转换，只是人为的认识罢了。但前两步就有些内容了。
new operator的第一步分配内存实际上是通过调用operator new来完成的，这里的new实际上是像加减乘除一样的操作符，因此也是可以重载的。operator new默认情况下首先调用分配内存的代码，尝试得到一段堆上的空间，如果成功就返回，如果失败，则转而去调用一个new_hander，然后继续重复前面过程。如果我们对这个过程不满意，就可以重载operator new，来设置我们希望的行为。例如：
#include <iostream>
using namespace std;

class TestOperatorNew
{
public:
	static void* operator new(size_t size)
	{
		cout << "called operator new in class TestOperatorNew" << endl;
		return ::operator new(size);
	}
};

int main()
{
	TestOperatorNew* p(new TestOperatorNew);
	delete p;
}
这里通过::operator new调用了原有的全局的new，实现了在分配内存之前输出一句话。全局的operator new也是可以重载的，但这样一来就不能再递归的使用new来分配内存，而只能使用malloc了：
#include <iostream>
using namespace std;

void* operator new(size_t size)
{
	cout << "global operator new" << endl;
	return malloc(size);
}

class TestOperatorNew
{
public:
	static void* operator new(size_t size)
	{
		cout << "called operator new in class TestOperatorNew" << endl;
		return ::operator new(size);
	}
};

int main()
{
	TestOperatorNew* p(new TestOperatorNew);
	delete p;
}
相应的，delete也有delete operator和operator delete之分，后者也是可以重载的。并且，如果重载了operator new，就应该也相应的重载operator delete，这是良好的编程习惯。
（按照上述说法补充的类中的operator delete和全局的operator delete，不知道是否正确？）
#include <iostream>
using namespace std;

void* operator new(size_t size)
{
	cout << "global operator new" << endl;
	return malloc(size);
}

void operator delete(void* p)
{
	cout << "global operator delete" << endl;
	free(p);
	p = 0;
}

class TestOperatorNew
{
public:
	static void* operator new(size_t size)
	{
		cout << "called operator new in class TestOperatorNew" << endl;
		return ::operator new(size);
	}
	static void operator delete(void* p)
	{
		cout << "called operator delete in class TestOperatorNew" << endl;
		::operator delete(p);
	}
};

int main()
{
	TestOperatorNew* p(new TestOperatorNew);
	delete p;
}
new的第三种形态――placement new是用来实现定位构造的，因此可以实现new operator三步操作中的第二步，也就是在取得了一块可以容纳指定类型对象的内存后，在这块内存上构造一个对象，这有点类似于前面代码中的“p->A::A(3);”这句话，但这并不是一个标准的写法，正确的写法是使用placement new：
#include <iostream>
#include <new>
using namespace std;

class TestOperatorNew
{
public:
	TestOperatorNew(int i = 0): i_(i) { }
	~TestOperatorNew()
	{
		cout << "destructor of TestOperatorNew" << endl;
	}
	void show()
	{
		cout << i_ << endl;
	}
	//static void* operator new(size_t size)
	//{
	//	cout << "called operator new in class TestOperatorNew" << endl;
	//	return ::operator new(size);
	//}
	//static void operator delete(void* p)
	//{
	//	cout << "called operator delete in class TestOperatorNew" << endl;
	//	::operator delete(p);
	//}
private:
	int i_;
};

int main()
{
	char s[sizeof(TestOperatorNew)];
	TestOperatorNew* p = reinterpret_cast<TestOperatorNew*>(s);
	new(p) TestOperatorNew(5);
	p->show();
	p->~TestOperatorNew();//如果这里没有这句话，析构函数是不会自己调用的
}
对头文件<new>或<new.h>的引用是必须的，这样才可以使用placement new。这里“new(p) A(3)”这种奇怪的写法便是placement new了，它实现了在指定内存地址上用指定类型的构造函数来构造一个对象的功能，后面A(3)就是对构造函数的显式调用。这里不难发现，这块指定的地址既可以是栈，又可以是堆，placement对此不加区分。但是，除非特别必要，不要直接使用placement new ，这毕竟不是用来构造对象的正式写法，只不过是new operator的一个步骤而已。使用new operator地编译器会自动生成对placement new的调用的代码，因此也会相应的生成使用delete时调用析构函数的代码。如果是像上面那样在栈上使用了placement new，则必须手工调用析构函数，这也是显式调用析构函数的唯一情况：
p->~TestOperatorNew();
当我们觉得默认的new operator对内存的管理不能满足我们的需要，而希望自己手工的管理内存时，placement new就有用了。STL中的allocator就使用了这种方式，借助placement new来实现更灵活有效的内存管理。
正如前面所说，operator new的默认行为是请求分配内存，如果成功则返回此内存地址，如果失败则调用一个new_handler，然后再重复此过程。于是，想要从operator new的执行过程中返回，则必然需要满足下列条件之一：
1. 分配内存成功 
2. new_handler中抛出bad_alloc异常
3. new_handler中调用exit()或类似的函数，使程序结束 
于是，我们可以假设默认情况下operator new的行为是这样的： 
void* operator new(size_t size) 
{
    void* p = null;
    while(!(p = malloc(size)))  
	{
		if(null == new_handler)   
        throw bad_alloc();
        try   
		{   
			new_handler();
		}        
		catch(bad_alloc& e)  
		{    
			throw e;   
		}    
		catch(…)    
		{}    
	} 
	return p; 
}
在默认情况下，new_handler的行为是抛出一个bad_alloc异常，因此上述循环只会执行一次。但如果我们不希望使用默认行为，可以自定义一个new_handler，并使用std::set_new_handler函数使其生效。在自定义的new_handler中，我们可以抛出异常，可以结束程序，也可以运行一些代码使得有可能有内存被空闲出来，从而下一次分配时也许会成功，也可以通过set_new_handler来安装另一个可能更有效的new_handler。例如： void MyNewHandler() {    printf(“New handler called!n”);    throw std::bad_alloc(); }  std::set_new_handler(MyNewHandler); 这里new_handler程序在抛出异常之前会输出一句话。应该注意，在new_handler的代码里应该注意避免再嵌套有对new的调用，因为如果这里调用new再失败的话，可能会再导致对new_handler的调用，从而导致无限递归调用。――这是我猜的，并没有尝试过。
在编程时我们应该注意到对new的调用是有可能有异常被抛出的，因此在new的代码周围应该注意保持其事务性，即不能因为调用new失败抛出异常来导致不正确的程序逻辑或数据结构的出现。

STL的内存分配与traits技巧 
在《STL原码剖析》一书中详细分析了SGI STL的内存分配器的行为。与直接使用new operator不同的是，SGI STL并不依赖C++默认的内存分配方式，而是使用一套自行实现的方案。首先SGI STL将可用内存整块的分配，使之成为当前进程可用的内存，当程序中确实需要分配内存时，先从这些已请求好的大内存块中尝试取得内存，如果失败的话再尝试整块的分配大内存。这种做法有效的避免了大量内存碎片的出现，提高了内存管理效率。 
为了实现这种方式，STL使用了placement new，通过在自己管理的内存空间上使用placement new来构造对象，以达到原有new operator所具有的功能。
template <class T1, class T2> 
inline void construct(T1* p, const T2& value)
{
	new(p) T1(value); 
}
此函数接收一个已构造的对象，通过拷贝构造的方式在给定的内存地址p上构造一个新对象，代码中后半截T1(value)便是placement new语法中调用构造函数的写法，如果传入的对象value正是所要求的类型T1，那么这里就相当于调用拷贝构造函数。类似的，因使用了placement new，编译器不会自动产生调用析构函数的代码，需要手工的实现： 
template <class T> 
inline void destory(T* pointer) 
{
	pointer->~T(); 
}
与此同时，STL中还有一个接收两个迭代器的destory版本，可将某容器上指定范围内的对象全部销毁。典型的实现方式就是通过一个循环来对此范围内的对象逐一调用析构函数。如果所传入的对象是非简单类型，这样做是必要的，但如果传入的是简单类型，或者根本没有必要调用析构函数的自定义类型（例如只包含数个int成员的结构体），那么再逐一调用析构函数是没有必要的，也浪费了时间。为此，STL使用了一种称为“type traits”的技巧，在编译器就判断出所传入的类型是否需要调用析构函数： 
template <class ForwardIterator>
inline void destory(ForwardIterator first, ForwardIterator last) 
{
    __destory(first, last, value_type(first));
	//感觉这里这样写是不是更好？
	//typedef typename first::value_type value_type;
	//__destory(first, last, value_type);
}
其中value_type()用于取出迭代器所指向的对象的类型信息，于是：
template<class ForwardIterator, class T> 
inline void __destory(ForwardIterator first, ForwardIterator last, T*) 
{
    typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;//这里的trivial_destructor为__true_type或__false_type
	__destory_aux(first, last, trivial_destructor()); 
}
//如果需要调用析构函数： 
template<class ForwardIterator> 
inline void __destory_aux(ForwardIterator first, ForwardIterator last, __false_type) 
{
    for(; first < last; ++first)        
	destory(&*first); //因first是迭代器，*first取出其真正内容，然后再用&取地址 
}
//如果不需要，就什么也不做： 
tempalte<class ForwardIterator> 
inline void __destory_aux(ForwardIterator first, ForwardIterator last, __true_type) 
{} 
因上述函数全都是inline的，所以多层的函数调用并不会对性能造成影响，最终编译的结果根据具体的类型就只是一个for循环或者什么都没有。这里的关键在于__type_traits<T>这个模板类上，它根据不同的T类型定义出不同的has_trivial_destructor的结果，如果T是简单类型，就定义为__true_type类型，否则就定义为__false_type类型。其中__true_type、__false_type只不过是两个没有任何内容的类，对程序的执行结果没有什么意义，但在编译器看来它对模板如何特化就具有非常重要的指导意义了，正如上面代码所示的那样。__type_traits<T>也是特化了的一系列模板类（这个模板方法真是牛！）：
struct __true_type {}; 
struct __false_type {}; 
template <class T> 
struct __type_traits 
{ 
public:    
	typedef __false_type has_trivial_destructor;    
	//…… 
};
template<> //模板特化 
struct __type_traits<int>    //int的特化版本 
{
public:    
	typedef __true_type has_trivial_destructor;    
	//…… 
};
//…… //其他简单类型的特化版本 
如果要把一个自定义的类型MyClass也定义为不调用析构函数，只需要相应的定义__type_traits<T>的一个特化版本即可： 
template<> 
struct __type_traits<MyClass> 
{
public:
    typedef __true_type has_trivial_destructor;    
	//…… 
};
模板是比较高级的C++编程技巧，模板特化、模板偏特化就更是技巧性很强的东西，STL中的type_traits充分借助模板特化的功能，实现了在程序编译期通过编译器来决定为每一处调用使用哪个特化版本，于是在不增加编程复杂性的前提下大大提高了程序的运行效率。更详细的内容可参考《STL源码剖析》第二、三章中的相关内容。

带有“[]”的new和delete 
我们经常会通过new来动态创建一个数组，例如： 
char* s = new char[100];
//…… 
delete s; 
严格的说，上述代码是不正确的，因为我们在分配内存时使用的是new[]，而并不是简单的new，但释放内存时却用的是delete。正确的写法是使用delete[]： 
delete[] s; 
但是，上述错误的代码似乎也能编译执行，并不会带来什么错误。事实上，new与new[]、delete与delete[]是有区别的，特别是当用来操作复杂类型时。假如针对一个我们自定义的类MyClass使用new[]： 
MyClass* p = new MyClass[10]; 上述代码的结果是在堆上分配了10个连续的MyClass实例，并且已经对它们依次调用了构造函数，于是我们得到了10个可用的对象，这一点与Java、C#有区别的，Java、C#中这样的结果只是得到了10个null。换句话说，使用这种写法时MyClass必须拥有不带参数的构造函数，否则会发现编译期错误，因为编译器无法调用有参数的构造函数。 当这样构造成功后，我们可以再将其释放，释放时使用delete[]： 
delete[] p; 
当我们对动态分配的数组调用delete[]时，其行为根据所申请的变量类型会有所不同。如果p指向简单类型，如int、char等，其结果只不过是这块内存被回收，此时使用delete[]与delete没有区别，但如果p指向的是复杂类型，delete[]会针对动态分配得到的每个对象调用析构函数，然后再释放内存。因此，如果我们对上述分配得到的p指针直接使用delete来回收，虽然编译期不报什么错误（因为编译器根本看不出来这个指针p是如何分配的），但在运行时（DEBUG情况下）会给出一个Debug assertion failed提示。 
到这里，我们很容易提出一个问题――delete[]是如何知道要为多少个对象调用析构函数的？要回答这个问题，我们可以首先看一看new[]的重载。
#include <iostream>
#include <new>
using namespace std;

class MyClass
{
public:
	MyClass()
	{
		cout << "constructor" << endl;
	}
	~MyClass()
	{
		cout << "destructor" << endl;
	}
private:
	int i_;
};

void* operator new[](size_t sz)//这个sz已经是经过计算需要分配的字节数的大小了，而不是单纯的“2”
{
	void* p = operator new(sz);
	cout << "address of pointer in operator new is: " << p << '\n'
		<< "calling new[] with size = " << sz << endl;	
	return p;
}

int main()
{
	MyClass* p = new MyClass[3];
	cout << "address of pointer in main is: " << p << '\n'
		<< "sizeof MyClass is: " << sizeof(MyClass) << '\n'
		<< "sizeof 3 MyClasses is: " << 3*sizeof(MyClass) << endl;
	delete [] p;
}
运行结果：
address of pointer in operator new is: 00473410
calling new[] with size = 16
constructor
constructor
constructor
address of pointer in main is: 00473414
sizeof MyClass is: 4
sizeof 3 MyClasses is: 12
destructor
destructor
destructor
请按任意键继续. . .
查看内存：0x00473410  03 00 00 00 0d f0 ad ba 0d f0 ad ba 0d f0 ad ba
虽然对构造函数和析构函数的调用结果都在预料之中，但所申请的内存空间大小以及地址的数值却出现了问题。我们的类MyClass的大小显然是4个字节，并且申请的数组中有3个元素，那么应该一共申请12个字节才对，但事实上系统却为我们申请了16字节，并且在operator new[]返后我们得到的内存地址是实际申请得到的内存地址值加4的结果。也就是说，当为复杂类型动态分配数组时，系统自动在最终得到的内存地址前空出了4个字节，我们有理由相信这4个字节的内容与动态分配数组的长度有关。通过单步跟踪，很容易发现这4个字节对应的int值为0x00000003，也就是说记录的是我们分配的对象的个数。改变一下分配的个数然后再次观察的结果证实了我的想法。于是，我们也有理由认为new[] operator的行为相当于下面的伪代码：
template <class T> 
T* New[](int count) 
{    
	int size = sizeof(T) * count + 4;    
	void* p = T::operator new[](size);   
	*(int*)p = count;    
	T* pt = (T*)((int)p + 4);    
	for(int i = 0; i < count; i++)        
		new(&pt[i]) T();    
	return pt; 
}
上述示意性的代码省略了异常处理的部分，只是展示当我们对一个复杂类型使用new[]来动态分配数组时其真正的行为是什么，从中可以看到它分配了比预期多4个字节的内存并用它来保存对象的个数，然后对于后面每一块空间使用placement new来调用无参构造函数，这也就解释了为什么这种情况下类必须有无参构造函数，最后再将首地址返回。类似的，我们很容易写出相应的delete[]的实现代码：
template <class T> 
void Delete[](T* pt) 
{    
	int count = ((int*)pt)[-1];    
	for(int i = 0; i < count; i++)        
		pt[i].~T();    
	void* p = (void*)((int)pt C 4);    
	T::operator delete[](p); 
}
由此可见，在默认情况下operator new[]与operator new的行为是相同的，operator delete[]与operator delete也是，不同的是new operator与new[] operator、delete operator与delete[] operator。当然，我们可以根据不同的需要来选择重载带有和不带有“[]”的operator new和delete，以满足不同的具体需求。
把前面类MyClass的代码稍做修改――注释掉析构函数，然后再来看看程序的输出：
address of pointer in operator new is: 004D6FC8
calling new[] with size = 12
constructor
constructor
constructor
address of pointer in main is: 004D6FC8
sizeof MyClass is: 4
sizeof 3 MyClasses is: 12
请按任意键继续. . .

这一次，new[]老老实实的申请了12个字节的内存，并且申请的结果与new[] operator返回的结果也是相同的，看来，是否在前面添加4个字节，只取决于这个类有没有析构函数，当然，这么说并不确切，正确的说法是这个类是否需要调用析构函数，因为如下两种情况下虽然这个类没声明析构函数，但还是多申请了4个字节：一是这个类中拥有需要调用析构函数的成员（如声明了一个string类型的数据成员），二是这个类继承自需要调用析构函数的类。于是，我们可以递归的定义“需要调用析构函数的类”为以下三种情况之一： 
1. 显式的声明了析构函数的 
2. 拥有需要调用析构函数的类的成员的 
3. 继承自需要调用析构函数的类的 
类似的，动态申请简单类型的数组时，也不会多申请4个字节。于是在这两种情况下，释放内存时使用delete或delete[]都可以，但为养成良好的习惯，我们还是应该注意只要是动态分配的数组，释放时就使用delete[]。

释放内存时如何知道长度 
但这同时又带来了新问题，既然申请无需调用析构函数的类或简单类型的数组时并没有记录个数信息，那么operator delete，或更直接的说free()是如何来回收这块内存的呢？这就要研究malloc()返回的内存的结构了。与new[]类似的是，实际上在malloc()申请内存时也多申请了数个字节的内容，只不过这与所申请的变量的类型没有任何关系，我们从调用malloc时所传入的参数也可以理解这一点――它只接收了要申请的内存的长度，并不关系这块内存用来保存什么类型。下面运行这样一段代码做个实验：
#include <iostream>
using namespace std;

int main()
{
	char *p = 0; 
	for(int i = 0; i < 40; i += 4)
	{   
		char* s = new char[i];    
		printf("alloc %2d bytes, address=%p distance=%d\n", i, s, s - p);    
		p = s; 
	}
}
输出如下：
alloc  0 bytes, address=00491370 distance=4789104
alloc  4 bytes, address=00491380 distance=16
alloc  8 bytes, address=00491390 distance=16
alloc 12 bytes, address=004913A0 distance=16
alloc 16 bytes, address=004913B8 distance=24
alloc 20 bytes, address=004913D0 distance=24
alloc 24 bytes, address=004913F0 distance=32
alloc 28 bytes, address=00491410 distance=32
alloc 32 bytes, address=00491438 distance=40
alloc 36 bytes, address=00491460 distance=40
请按任意键继续. . .
我们直接来看VC2005下Release版本的运行结果，DEBUG版因包含了较多的调试信息，这里就不分析了（从下是原文的输出）：
alloc   0 bytes, address=003A36F0 distance=3815152 
alloc   4 bytes, address=003A3700 distance=16 
alloc   8 bytes, address=003A3710 distance=16 
alloc 12 bytes, address=003A3720 distance=16 
alloc 16 bytes, address=003A3738 distance=24 
alloc 20 bytes, address=003A84C0 distance=19848 
alloc 24 bytes, address=003A84E0 distance=32 
alloc 28 bytes, address=003A8500 distance=32 
alloc 32 bytes, address=003A8528 distance=40 
alloc 36 bytes, address=003A8550 distance=40
每一次分配的字节数都比上一次多4，distance值记录着与上一次分配的差值，第一个差值没有实际意义，中间有一个较大的差值，可能是这块内存已经被分配了，于是也忽略它。结果中最小的差值为16字节，直到我们申请16字节时，这个差值变成了24，后面也有类似的规律，那么我们可以认为申请所得的内存结构是如下这样的（参见图“内置类型内存存储结构1”）：
从图中不难看出，当我们要分配一段内存时，所得的内存地址和上一次的尾地址至少要相距8个字节（在DEBUG版中还要更多），那么我们可以猜想，这8个字节中应该记录着与这段所分配的内存有关的信息。观察这8个节内的内容，得到结果如下（参见图“内置类型内存存储结构2”）： 
图中右边为每次分配所得的地址之前8个字节的内容的16进制表示，从图中红线所表示可以看到，这8个字节中的第一个字节乘以8即得到相临两次分配时的距离，经过试验一次性分配更大的长度可知，第二个字节也是这个意义，并且代表高8位，也就说前面空的这8个字节中的前两个字节记录了一次分配内存的长度信息，后面的六个字节可能与空闲内存链表的信息有关，在翻译内存时用来提供必要的信息。这就解答了前面提出的问题，原来C/C++在分配内存时已经记录了足够充分的信息用于回收内存，只不过我们平常不关心它罢了。  
//------------------------------------------------------------------------------------------------
//C++编程规范101 第47条 以同样的顺序定义和初始化成员变量
C++语言之所以采取这样的设计，是因为要确保销毁成员的顺序是惟一的，否则，析构函数将以不同顺序销毁对象，具体顺序取决于构造对象的构造函数。为此带来的底层操作开销应该是不可接受的。
解决方案是，总是按成员声明的顺序编写成员初始始化语句。这样，任何非法依赖都会显而易见。当然，尽量不让一个成员的初始化依赖于其他成员更好。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第48条 在构造函数中用初始化代替赋值
有话直说最好：在初始化列表中初始化成员变量，代码表达意图更加明确，而且锦上添花的是，代码通常还会更小、更快。
这不是不成熟的优化，这是在避免不成熟的劣化。

例外情况
应该总是在构造函数体内而不是初始化列表中执行非托管资源获取，比如并不立即将结果传递智能指针构造函数的new表达式。当然，最好是一开始就没有这种不安全的无属主资源（见第13条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第49条 避免在构造函数和析构函数中调用虚拟函数
作为一条经验规则，请记住，在B的构造期间，没有办法说清到底B是一个独立对象还是其他派生对象的基类部分。虚拟行为的虚拟函数总是这样的。
从构造函数调用还完全没有定义的纯虚拟函数将是给伤口撒盐，这种情况下的行为是未定义的。这样的代码不仅会令人糊涂，而且维护时也会显得更加脆弱。
另一方面，有些设计方案需要“后构造”，即必须在构造了完整的对象之后立刻调用虚拟函数。下面列出其中的一部分选项列表：
1. 推卸责任：在文档中说明用户代码必须在构造了对象之后立刻调用后初始化（post-initialization）函数。
2. 延缓后初始化：在第一次成员函数调用时进行后初始化。基类中有一个布尔标志说明是否已经发生了后构造。
3. 使用虚拟基类语义：语言规则要求构造函数最底层的派生类决定调用哪个基类构造函数，使用这个语言规则会对我们有利。
4. 使用工厂函数：通过这种方式可以很容易地强制调用后构造函数（见本条示例）。
没有哪一种后构造技术是完美的。最差的技术是仅仅通过要求调用手工调用后构造函数来绕开整个问题。

示例
例 使用工厂函数插入后构造函数调用。考虑如下代码：
#include <iostream>
#include "boost/make_shared.hpp"
using namespace std;

class Base//层次结构的根
{
public:
	template<typename T>
	static boost::shared_ptr<T> create()//用于创建对象的接口
	{
		boost::shared_ptr<T> p(new T);
		p->postInitialize();
		return p;
	}
protected:
	Base() 
	{ }
	virtual void postInitialize()//在构造之后立刻调用
	{
		cout << "This is post initialization function." << endl;
	}
};

class Derived: public Base//某个派生类
{
public:
	virtual void postInitialize()//不知道加上这个函数是否仍符合要求？
	{
		cout << "This is derived post initialization function." << endl;
	}
};


int main()
{
	boost::shared_ptr<Base> pBase1(Base::create<Derived>());
	boost::shared_ptr<Base> pBase2(Derived::create<Derived>());
	boost::shared_ptr<Derived> pDerived1(Base::create<Derived>());
	boost::shared_ptr<Derived> pDerived2(Derived::create<Derived>());//创建一个D对象，这是原条款中的创建语句，另三种好像也没有问题
	Derived d;//这个是可以的，但是不符合下面所说的第1条，即创建D对象不会调用postInitialize()函数
}
这个非常脆弱的设计展现了如下折中：
1. 派生类比如D决不能公开公用构造函数。否则，D的用户无需要调用postInitialize就能够创建D对象。
2. 分配局限于operator new。但是B可以改写new（见第45条和第46条）。
3. D必须定义一个与B选择的参数相同的构造函数。但是定义几个Create的重载能够缓解这一问题：甚至可以根据参数类型将重载模板化。（不太懂？）
4. 如果能够满足以上的需求，设计就可以保证任何完整构造的B派生对象都调用了postInitialize。此时就不需要虚拟postInitialize了：但是它可以自由的调用虚拟函数。（不太懂，就是把postInitialize的virtual去掉，然后在该函数里面调用虚函数吗？）

感觉这个规则说白了就是在对象不完整的时候，虚函数无法正确调用，在对象完整创建之后，再怎么调用该对象的虚函数就都没有问题了！
//------------------------------------------------------------------------------------------------
//C++编程规范101 第50条 将基类析构函数设为公用且虚拟的，或者保护且非虚拟的
删除，还是不删除，这是个问题：如果允许通过指向基类Base的指针执行删除操作，则
Base的析构函数必须是公用且虚拟的。否则，就应该是保护且非虚拟的。
编写一个基类，就是定义一个抽象（见第35条到第37条）。对于参与抽象的每个成员函数，都需要决定：
1. 是否应该行为虚拟。
2. 是应该对所有使用了Base指针的调用者都公用，还是应该隐藏内部实现细节。
正如第39条中所述，对于常规的成员函数，要么允许通过Base*非虚拟的调用（但是如果调用的虚拟函数，还可能要虚拟的调用，比如在NVI或者Template Method模式中的情况），要么完全不允许。NVI模式是避免了公用虚拟函数的技术。
析构可以看成是另一个操作，虽然它的特殊语义会使非虚拟调用变得很危险，或者很容易出错。对于基类析构函数，要么允许通过Base*虚拟的调用，要么完全不允许；不能选择“非虚拟地”（调用）。因此，基类析构函数如果能够被调用（即是公用的），那么它就是虚拟的，否则就是非虚拟的。
请注意NVI模式不适用于析构函数，因为构造函数和析构函数不能进行深虚拟调用。（见第39条和第55条）（不懂？）
结论：问题为基类编写析构函数，因为隐含生成的析构函数是公用且非虚拟的。

示例
客户要么能够使用Base的指针多态删除，要么就不能。这两种选择都隐含着特定的设计：
例1 含有多态删除的基类。如果允许多态删除，则析构函数必须是公用的（否则调用代码就无法调用它），而且必须是虚拟的（否则调用它就会导致未定义行为）。
例2 不含多态删除的基类。如果不允许多态删除，则析构函数必须是非公用的（这样调用代码就不能调用它），而且应该是非虚拟的（因为不需要是虚拟的）。（要声明成保护，不能声明为私有的，因为此时虽然不会通过基类来删除派生类，但是派生类析构时还是需要调用基类的析构函数的，如果声明为私有的，则派生类无法正常调用基类的析构函数了）
特事特办类经常被用作基类（如Uncopyable），是出于方便考虑的，而不是出于多态行为考虑的。建议将它们析构函数设为保护且非虚拟的。

例外情况
有些组件架构（比如，COM和CORBA）没有使用标准的删除机制，而是重新编写了各种不同的对象清除协议。请遵循架构本身的模式和惯用法，并相应地调整本条款中的准则。
另外再考虑一个罕见的的情况：
1. B既是一个基类又是一个可以被自身实例化的具体类（因此要创建和销毁的B对象的析构函数必须是公用的）。
2. B既没有虚拟函数也不想被多态地使用（因此虽然析构函数是公用的，但不必是虚拟的）。
因此，即使析构函数必须是公用的，可能也有很大的压力要求不将其设为虚拟的，因为作为第一个虚拟函数，如果添加了根本就不需要的功能，将带来所有运行时的类型开销。
在这个罕见的例子中，可以将析构函数设为公用且非虚拟的，但是要在文档中明确地说明：进一步派生的对象要和B一样，不能被多态地使用。这正是std::unary_function的做法。
但，一般而言，要避免使用具体基类（见第35条）。例如，unary_function就是一组根本不需要单独实例化的类型祢。给它一个公用析构函数其实毫无意义；更好的设计应该遵循本条款的建议，给它一个保护的非虚拟析构函数。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第51条 析构函数、释放和交换绝对不能失败
它们的一切尝试都必须成功：决不允许析构函数、资源释放（dellocation）函数（如operator delete）或者交换函数报告错误。说得更具体一些，就是绝对不允许将那些析构函数可能会抛出异常的类型用于C++标准库。
析构函数很特殊，编译器可以在不同的上下文中自动调用它们。我们编写一个类，就称之为Nefarious类，如果它的析构函数有可能会失败的话（通常提供抛出异常，见第72条），那么会导致下列后果：
1. Nefarious对象很难安全地用在普通函数中
2. 含有Nefarious成员或者以Nefarious为基类的类也将很难安全地使用
3. 无法可靠地创建全局或者静态Nefarious对象：无法捕获它的析构函数有可能会抛出的任何异常。
4. 无法可靠地创建Nefarious数组
5. 无法将Nefarious对象用在标准容器中：无法在标准容器中存储Nefarious对象，或者将它们用于标准库的任何其他组件。标准库禁止所有与它一起使用的析构函数抛出异常。

释放函数，包括特殊一些的重载operator delete和operator delete[]，都属于同一范畴，因为它们通常也被用于清除期间，尤其是异常处理期间，来撤销需要取消的部分工作。

除了析构函数和释放函数之外，常见的错误安全技术还依赖于这种情况下的交换操作从来都不会失败，这不是因为它们要实现有保证的回滚，而是因为要实现有保证的提交。举个例子，下面采用常用的方式为类型T实现了一个operator=，类型T执行了复制构造，其后是一个不会失败的Swap调用：
T& T::operator=(const T& other)
{
	T temp(other);
	Swap(temp);
}
（另见第56条。）
在释放资源时，失败的作用域肯定会更小。如果使用了异常作为错误报告机制，请确保这些函数能够处理其内部处理可能生成的所有异常和其他错误。（对于异常而言，只需要将析构函数所做的一切敏感操作都包装在一个try/catch(...)块中即可。）这非常重要，因为析构函数可能会在危急情况下被调用，比如分配系统资源（比如，内存、文件、锁、端口、窗口或者其他系统对象）失败。
当使用异常作为错误处理机制时，建议用一个注释掉的空异常规范/*throw()*/来声明这些函数，通过这种方式说明这一行为（见第75条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P106 第52条 一致地进行复制和销毁
既要创建，也要清除：如果定义了复制构造函数、复制赋值操作符或者析构函数中的任何一个，那么可能也需要定义另一个或者另外两个。
如果需要定义这三个函数中的任何一个，就意味着我们需要函数默认行为之外的功能，而这三个函数是不对称相关的。
1. 如果编写或者禁用了复制构造函数或者复制赋值操作符，那么可能需要对另一个也如法炮制
2. 如果显式地编写了复制函数，那么可能也需要编写析构函数
3. 如果显式地编写了析构函数，那么可能也需要编写或者禁止复制：如果必须编写一个特殊的（nontrivial）析构函数，那么经常是因为需要手工释放对象持有的资源。如果真的如此，那么很可能那些资源需要小心复制，然后需要留意复制和赋值对象的方式，或者完全禁止复制。
在许多情况下，如果能通过RAII“拥有”对象的方式正确地持有封装起来的资源，我们就没有必要自己编写这些操作了（见第13条）。
要优先使用编译器所生成的特殊成员，只有它们能够归类为“普通的（trivial）”，而且至少已经有一个主要的STL开发商已经为含有“普通的”特殊成员的类进行了大幅优化。这很可能会成为普遍的实践。
例外情况
如果声明这三个特殊函数之一，只是为了将它们设为私有的或者虚拟的，而没有什么特殊语义的话，那么就意味着不需要其余两个函数。
在某些比较罕见的情况下，拥有一些奇怪类型（比如，引用，std::auto_ptr）成员的类是本条款的例外，因为它们的复制语义很奇特。在一个包含引用或者auto_ptr的类中，可能还需要编写复制构造函数和赋值操作符，但是默认析构函数已经能够正确工作了。（请注意使用引用或者auto_ptr成员几乎总是错误的？）
//------------------------------------------------------------------------------------------------
//C++编程规范101 P107 第53条 显式地启用或者禁止复制
清醒地进行复制：在下述三行为之间谨慎选择――使用编译器生成的复制构造函数和赋值操作符；编写自己的版本；如果不应请允许复制的话，显式的禁用前两者。
要确保类能够提供合理的复制，否则就根本不要提供。可能的选择如下：
1. 显式地禁止复制和赋值
2. 显式地编写复制和赋值
3. 使用编译器生成的版本，最好是加上一个明确的注释：如果复制有意义，而且默认行为也是正确的，那么就不用我们自己声明了，让编译器生成的版本来干吧。最好注释说明默认行为是正确的，这样代码的阅读者就能知道你并不是不小心忽略了其他两种选项。
请注意（禁止，是不是少写了这两个字？）复制和复制赋值意味着不能将T对象放入标准容器。这未必是一件坏事，很可能，你根本就不想在容器中存放这样的T对象。（通过智能指针保存这些对象，还是可以将它们放入容器的，见第79条。）
关键在于：应该对于这两种操作采取主动行为，因为编译器喜欢慷慨地替我们生成，而对非值型的类型而言，这种编译器所生成的版本默认情况下经常是不安全的（另见第32条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P108 避免切片。在基类中考虑用克隆代替复制
在基类中，如果客户需要进行多态（完整的、深度的）复制的话，那么请考虑禁止复制构造函数和复制赋值操作符，而改为提供虚拟的Clone成员函数。
如果B的开发者想要允许切片，但是又不想调用者很容易或者不小心地切片的话，那么可以这样选择：将B的复制构造函数设为explicit（explicit功能是必须明确显式调用此函数，而不能隐式调用）。（我们只是为了叙述完整而提到它，并不推荐将其用在需要移植的代码中。）这不仅有助于避免隐含的切片，而且也防止了所有通过值的传递（对于基类来说，这可能是一个不错的选择，因为基类无令如何也不会实例化，见第35条）：
#include <iostream>
using namespace std;
//将复制构造函数设为explicit（有副作用，需要改善）
class Base
{
public:
	Base() { }
	explicit Base(const Base& rhs) {	}
};

class Derived: public Base
{

};
//如果确实需要，调用代码仍然能够切片，但是必须明确表示：
void transmogrify(Base obj)//注意：现在不能调用
{

}

void transmogrify2(const Base& obj)//明确说明“我想通过值接受obj（即使有可能将其切片）”的一个惯用法
{
	Base b(obj);
}

int main()
{
	Base b;//基类不应该是具体的（见第35条），这里只是举个例子
	Derived d;
	//transmogrify(b);//现在是错误的
	//transmogrify2(b);//这样是OK的
	transmogrify2(d);//这样是OK的，但是在transmogrify2构造的b是切片的
}

还有一种更好的方法，不但能够可移植地达到防止切片的目的，而且还能够提供更多的好处。假设Transmogrify这样的函数确实想要在不知道所给对象的实际派生类型的情况下进行完整的深复制。更通用的惯用法解决方案是，将基类的复制构造函数设为protected（这样像Transmogrify这样的函数就不会偶然地调用它了），并改而依赖一个虚拟的Clone函数：（就是原型模式？）
//添加Clone（第一次尝试，有所改善，但还需继续改善）
class B
{
public:
	virtual B* clone() const = 0;
protected:
	B(const B&);
};

class D: public B
{
public:
	virtual D* clone() const 
	{
		return new D(*this);
	}
protected:
	D(const D& rhs): B(rhs)
	{}
};

现在再试图切片，将（有可能）会生成编译时错误，而且将clone设为纯虚拟函数会强制直接派生类对其进行改写。不幸的是，这种解决方案仍然有两个编译器无法检查出来的问题：层次结构中进一步派生的类还是会忘记实现clone，同时clone的改写的实现也可能会出错，从而使所得副本与原对象的类型并不一样。clone应该应该NVI模式（见第39条），这种模式将clone的public特性和virtual特性分开了，从而使我们得以插入一个重要的断言：
class B
{
public:
	B* clone() const//非虚拟的
	{
		B* p = doClone();
		assert(typeid(*p) == typeid(*this) && "doClone incorrectly overridden");//检查doClone的返回类型
		return p;
	}
protected:
	B(const B&);
private:
	virtual B* doClone() const = 0;
};
clone现在是所有调用代码使用的非虚拟接口。派生类只需要改写doClone即可。assert将对任何副本与原对象类型不一样的情况进行标记，从而发出这样的信号：某个派生类忘记了改写doClone函数；归根到底，assert就是用来报告这些编程错误的（见第68条和第70条）。

例外情况
有些设计可能会要求基类的复制构造函数保持为公有的（比如，在层次结构中有一部分是第三方程序库时）。在这种情况下，应该通过（智能）指针来传递，而不是通过引用来传递。正如第25条中说明的，通过指针来传递所导致的切片以及不希望出现的临时构造的机会要小得多。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P111 第55条 使用赋值的标准形式
赋值，在实现operator=时，应该使用标准形式――具有特定签名的非虚拟形式。
应该为具有如下签名的类型T声明复制赋值：
T& operator=(const T&);//传统的
T& operator=(T);//可能更方便的优化器（见第27条）
如果需要复制操作符内的参数，比如第56条中基于swap的惯用法，就采用第二个版本好了。（两种选择之前有过分析）
要避免将赋值操作符设为虚拟的（参阅【Meyers96】33和【Sutter04】19）。如果你认为自己确实需要赋值的虚拟行为，那么请首先重新阅读上述文献中的叙述。如果这还不能劝阻你，你仍然认为自己需要虚拟赋值，那么最好是改成提供一个命名函数（比如，virtual void assign(const T&);）。
不要返回const T&。虽然这有助于防止(a = b) = c这样的奇怪代码，但是它有负作用：你将不能把T对象放入标准库容器中；容器要求赋值返回一个普通的T&。
要始终保证赋值操作是错误安全的，最好是提供强有力的保证（见第71条）。
要确保赋值操作符对于自我赋值是安全的。要避免编写依赖于自我赋值检查才能正确工作的复制赋值操作符，因为那样做往往会暴露出措施的缺乏。如果swap惯用法（见第56条）编写复制赋值操作符，则操作符不仅会自动具有强大的防错功能，而且对于自我赋值也会是安全的；如果由于引用别名或者其他原因需要经常自我赋值，那么将检查自我赋值作为一种优化检查以避免不必要的工作是没有问题的。
要显式调用所有基类赋值操作符，并为所有数据成员赋值，注意，交换可以自动为我们处理好所有这一切。要返回*this。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P112 第56条 只要可行，就提供不会失败的swap（而且要正确地提供）
应该考虑提供一个swap函数，高效且绝对无误地交换两个对象。这样的函数实现便于实现许多惯用法，从流畅地将对象四处移动 以轻易地实现赋值，到提供一个有保证的、能够提供强大防错调用代码的提交函数（另见第51条）。
考虑使用swap以复制构造来实现复制赋值。下面列出的operator=实现提供了强大的保证（见第71条），虽然这需要以创建一个额外对象为代价，但是如果能更有效率地为T对象执行防错赋值的话，那么这样做就可能就是合适的：
T& T::operator=(const T& other)//很好：变体#1（传统的）
{
	T temp(other);
	swap(temp);
	return *this;
}
T& T::operator=(T temp)//很好：变体#2（见第27条），请注意：temp是通过值传递的
{
	swap(temp);
	return *this;
}
如果U没有实现不会失败的swap函数，就像许多遗留类一样，而你又仍然需要T支持swap函数，会怎么样呢？
1. 如果U的复制函数和复制赋值都没有失败（同样，就像遗留类那样），那么std::swap将在U对象上正常工作。
2. 如果U的复制构造函数有可能会失败的话，那么可以存储一个U的（智能）指针来代替直接成员。指针是很容易交换的。当然，这样做会产生额外的开销――一个额外的动态存储分配和一次额外的访问，但是如果在一个Pimpl对象中存储了所有成员，那么对于所有的私有成员来说，只需增加一次开销（见第43条）。
绝对不要使用这样的小花招：通过一个后跟定位new的显式析构函数，用复制构造来实现复制赋值，即使这种所谓的技巧经常出现在C++论坛中。（另见第99条。）也就是说，绝对不要这样编写：
T& T::operator=(const T& rhs)//糟糕：这是一个反惯用法，这种技巧真是作孽（参阅【Sutter00】41）
{
	if (this != &rhs)
	{
		this->~T();
		new (this) T(rhs);
	}
	return *this;
}
当用户定义类型的对象有办法比野蛮赋值更高效地交换值【比如它们有自己的swap或者等效的函数（见第57条）】时，应该在与用户定义类型相同的名字空间中提供一个非成员交换函数。此外，还可以考虑为自己的非模板类型特化std::swap（第65条和66条的情形除外）：
namespace std
{
	template<>
	void swap(MyType& lhs, MyType& rhs)
	{
		lhs.swap(rhs);//为MyType对象使用MyType::swap
	}
}
当MyType本身是一个模板类时，标准并不允许我们这么样做。幸运的是，这种特化只是一种锦上添花的事，主要的技术还是在与类型相同的名字空间中提供类型定制的非成员函数swap。

例外情况
对于有值语义的类来说，交换是很有用的。但对于基类来说往往就没那么有用了，因为我们总是在通过指针使用基类（见第32条和第54条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P116 第57条 将类型及其非成员函数接口置于同一名字空间中
非成员也是函数：如果要将非成员函数（特别是操作符和辅助函数）设计成类X的接口的一部分，那么就必须在与X相同的名字空间中定义它们，以便正确调用。
公有成员函数和非成员函数都是类的公有接口的组成部分。接口原则是这样表述的：对于一个类X而言，所有在同一个名字空间中“提及”X和“随X一起提供的”函数（包括非成员函数）逻辑上都是X的一部分，因为它们形成了X接口的组成部分。（见第44条）
参数依赖查找（argument dependent lookup，ADL，也称Koenig查找）
考虑定义于名字空间N中的类X：
class X
{
public:
	void f();
};

X operator+(const X&, const X&);
调用者通常想写这样的代码，其中x1、x2和x3是类型X的对象：
x3 = x1 + x2;
如果operator+是在与X相同的名字空间中被声明的，那么就没有问题，这样的代码问题能够正确地工作，因为所提供的operator+将使用ADL进行查找。
如果operator+不是在与X相同的名字空间中被声明的，那么调用者的代码将无法正确工作。调用者有两种变通方法使其工作。第一种方法是使用显式的限定：
x3 = N::operator+(x1, x2);
这既可悲又可耻，因为它要求用户放弃自然的操作符语法，而这正是操作符重载的第一要点。
另一种方法是编写一条using语句：
using N::operator+;//或者：using namespace N;
x3 = x1 + x2;
编写上面的using语句是完全可以接受的（见第59条），但是，如果X的作者正确地将X对象的operator+放入了与X相同的名字空间中，那么调用者也就不必经历这些磨难了。
这个问题的另一方面，见第58条。
//------------------------------------------------------------------------------------------------
//C++编程规范101 P118 第58条 应该将类型和函数分别置于不同的名字空间中，除非有意想让它们一起工作
协助防止名字查找问题：通过将类型（以及与其相关的非成员函数，见第57条）置于自己单独的名字空间中，可以使类型与无意的ADL（参数依赖查找，也称Koenig查找）隔离开来，促进有意的ADL。要避免将类型和模板化函数或者操作符放在相同的名字空间中。
ADL不正确地从其他名字空间中导入了名字，只是因为在附近使用了那些名字空间中的类型。
这个问题并不只是和标准库的使用有关。在C++中，使用任何与自己不特别相关的函数（特别是模板化函数，而最特别的只是操作符）在同一名字空间中定义的类型，都可能而且确实会出现这一。切莫为之。
归根结底：你应该不必知道这些东西。通常，避免此类问题的最简单的方法，就是：避免将不属于类型X的接口的非成员函数与X放在同一个名字空间中，尤其是绝对不要将模板化函数或者操作符与用户定义类型放在同一名字空间中。
注意：的确，C++标准库将一些算法和其他函数模板（比如copy和distance）以及大量类型（比如pair和vector）都放在了同一个名字空间中。它将所有东西都放进了一个名字空间。这是一件非常不幸的事情，这也正是产生此类微妙问题的原因。以史为鉴，切莫再为。
这个问题的另一个方面，见第57条。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第59条 不要在头文件中或者#include之前编写名字空间using
绝对不要编写using声明或者在#include之前编写using指令。
推论：在头文件中，不要编写名字空间级的using指令或者using声明，相反应该显式地用名字空间限定所有的名字。（第二条规则是第一条直接得出的，因为头文件无法知道以后其他头文件会出现什么样的#include。）
using声明和指令是为了编码方便而设的，不应该让它们的使用影响其他人的代码。具体地说，就是不要在任何后面可能跟有其他人代码的地方编写它们：尤其是不要在头文件（头文件都要被无数的实现文件所包含，当然不应该干扰其他代码的意义）中或者在#include之前（我们不希望干扰其他人头文件中代码的意义）使用它们。
如果using指令（比如，using namespace A;）毫无意识地影响了其后的代码，那么大多数人都能凭直觉理解为什么它会引起名字污染：因为它将一个名字空间整体地导入到了另一个名字空间中，包括那些还没有见过的名字，非常明显，它能轻易地改变其后代码的意义。
但这里有一个陷阱：许多人认为在名字空间一级进行using声明（例如，using N::Widget;）是安全的。其实不然，它们至少同样危险，而其难于理解和隐蔽的程序只有过之而无不及。考虑以下的代码：
#include <iostream>
using namespace std;

//代码片断1
namespace A
{
	void f(double d)
	{
		cout << "this is f(double)" << endl;
	}
}

//代码片断2
namespace B
{
	using A::f;//将调用f(double)
	//using namespace A;//将调用f(int)
	void g();
}

//代码片断3
namespace A
{
	void f(int i)
	{
		cout << "this is f(int)" << endl;
	}
}

//代码片断4
void B::g()
{
	f(1);
}

int main()
{
	B::g();
}
此处的危险在于，using声明将获取的是在遇到using声明之前所见到的名字空间A中的任何名为f的实体。因此，从B中来看，哪个重载可见将取决于这些代码片断处在哪里，是以什么顺序组合的。第二个重载，f(int)，能够更好地匹配调用f(1)，但是如果f(int)的声明在using声明之后的话，那么对B::g来说它将是不可见的。
考虑两种特殊情况。第一种情况中，假设代码片断1、2和3分别位于三个不同的头文件s1.h、s2.h和s3.h中，而代码片断4在实现文件s4.cpp中，该文件包含了那三个头文件以导入相关的声明。然后，我们就遇到了一个不幸的现象：B::g的语义将取决于s4.cpp中所包含的头文件的顺序！具体说就是：
1. 如果s3.h在s2.h之前，则B::g将调用A::f(int)。
2. 如果如果s1.h在s2.h之前，则B::g将调用A::f(double)。
3. 否则B::g就完全无法编译。
至少在前面的例子中，仍然有一个定义明确的顺序，而且答案将肯定是所列出的三种选择之一。
另一种情况更糟：假设代码片断1、2、3和4分别在4个不同的头文件s1.h、s2.h、s3.h和s4.h中。情况更加糟糕了：B::g的语义将取决于这些头文件被包含的顺序，不仅在s4.h中，而且在任何包含s4.h的代码中！说得更具体一些，就是实现文件client_code.cpp可能会尝试以任意顺序包含这些头文件：
1. 如果s3.h在s2.h之前，则B::g将调用A::f(int)。
2. 如果如果s1.h在s2.h之前，则B::g将调用A::f(double)。
3. 否则B::g就完全无法编译。
这比第一种情况还糟糕，因为两个实现文件可能会以不同的顺序包含这些头文件。如果client_code_1.cpp以这样的顺序包含：s1.h、s2.h和s4.h，但client_code_2.cpp以这样的顺序包含：s3.h、s2.h和s4.h，此时，B::g将违反一次定义规则（One Definition Rule，ODR），因为它有两个既不一致，也不兼容的实现，这两个实现不可能同时正确――一个试图调用A::f(int)，而一个试图调用A::f(double)。
因此，不要在头文件中或者在实现文件的#include指令之前编写名字空间级的using声明或者using指令。这样要么会导致名字空间污染，要么会获取想要导入的名字的不完整的瞬间快照，还有可能两者兼而有之，从而很有可能会影响到以后代码的意义。（请注意这里的限定词“名字空间级的using声明或者using指令”。这一建议并不适用于编写类成员级的using声明以导入需要的基类成员名字的情况。）
在所有头文件中，以及所有最后一个#include之前的实现文件中，问题明确在用名字空间限定所有名字。在所有#include之后的实现文件中，可以而且应该不受限制地编写名字空间级的using声明和指令。这是协调代码简洁性和模块性的正确之道。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第60条 要避免在不同的模块中分配和释放内存
确保删除由合适的函数进行，一个很好的方式是使用shared_ptr设施。shared_ptr是一个引用计数的智能指针，可以在构造时捕获其“删除器（deleter）”。删除器是一个执行释放的函数对象（或者是一个直接的函数指针）。因为这个函数对象或者函数指针是shared_ptr对象状态的一部分，所以分配对象的模块能够同时指定释放函数，而且该函数即使在释放点在另一个模块中的时候，也能够被正确调用――而且是以公认的低代价（正确性是值得用这一代价交换的；另见第5条、第6条和第8条）。当然，原模块必须仍保留在内存中。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第61条 不要在头文件中定义具有链接的实体
重复会导致膨胀：具有链接的实例（entity with linkage），包括名字空间级的变量或函数，都需要分配内存。在头文件中定义这样的实体将导致连接时错误或者内存的浪费。请将所有具有链接的实体放入实现文件。
在开始使用C++时，我们都会很快地知道，这样的头文件：
//要避免在头文件中定义具有外部链接的实体
int fudgeFactor;
string hello("hello");
void foo() {/*...*/}
只要被一个以上的源文件所包含，就很容易导致连接时错误，编译器会报告存在重复符号错误。原因很简单：每个源文件中，都会定义fudgeFactor、hello和foo的函数体，并全本空间。当要将它们都链接起来的时候，连接器将面对多个具有相同名字而且互相在竞争可见性的符号。
解决之道非常简单――只在头文件中放置声明即可：
extern int fudgeFactor;
extern string hello;
void foo();//“extern”对函数声明而言是可有可无的
而实际的定义则放在一个单独的实现文件中：
int fudgeFactor;
string hello("hello");
void foo() {/*...*/}
同样，不要在头文件中定义名字空间级的static 实体。例如：
//要避免在头文件中定义具有静态链接的实体
static int fudgeFactor;
static string hello("hello");
static void foo() {/*...*/}
这种对static的错误使用比在头文件中只定义全局实体还要危险。对于全局实体，至少连接器可能会立即发现重复。但是静态数据和函数的重复是合法的，因为编译器会认为你想在每个源文件中都有一个私有的副本。因此，如果在某个头文件中定义了静态数据和静态函数，而该头文件又要被50个文件包含，那么函数体和数据所占用的空间会在最终的可执行文件中重复50次（除非有些现在连接能够在安全的前提下，将相同的函数体和const数据合并）。当然，全局数据（比如静态的fudgeFactor）也并不真正是全局的，因为每个源文件最终还是要操纵自己的副本，独立于程序中所有其他副本。
要不试图通过在头文件中（滥）用未命名的名字空间来绕开此问题，因为其结果仍然是无法令人满意的。
//在一个头文件中，这和static一样糟糕
namespace
{
	static int fudgeFactor;
	static string hello("hello");
	static void foo() {/*...*/}
}

例外情况
以下具有外部链接的实体可以放入头文件中：
1. 内联函数
2. 函数模板
3. 类模板的静态数据成员
此外，一种称为“Schwarz计数器”或者“灵巧计数器（nifty counter）”的全局数据初始化技术要求在头文件中放入静态的（或未命名名字空间中的）数据。

批注
1. 按照C++标准3.5 节（程序与链接）第2段中定义，所谓具有链接的名字，是指它可能与另一作用域中某个声明所引用的名字表示同一实体（对象、引用、函数、类型、模板、名字空间或值）。链接有三种情况：外部链接、内部链接和无链接。内外链接的区别，在于是否能从另一编译单元中引用。无链接指名字所表示的实体不能从作用域之外引用。判断链接的有无规则比较繁琐。但是，名字空间级的实体肯定具有内部或者外部链接，在局部作用域声明的名字肯定没有链接。
2. 标准中并没有定义静态链接这一术语，显式声明为static的实体具有内部链接。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第62条 不要允许异常跨越模块边界传播
C++异常处理没有普遍通用的二进制标准。不要在两段代码之间传播异常，除非能够控制用来构建两段代码的编译器和编译选择；否则模块可能无法支持可兼容地实现异常传播。这通常可以一言以蔽之：不要允许异常跨越模块或子系统边界传播。
应用程序必须通过保护所有主要模块的边界来防止异常处理的不兼容性，这意味着对于这些模块的每个编译单元，开发人员都要确保一致地使用相同的编译器和编译选项。
最低限度，应用程序必须在以下位置有捕获所有异常的catch(...)兜底语句，其中大多数都直接适用于模块。
1. 在main函数的附近：捕获并用日志记录任何将使程序不正常终止而其他地方又没有捕获的异常。
2. 在从无法控制的代码中执行回调附近：操作系统和程序库会提供一些框架，可以传递一个指向以后才会调用（例如，发生异步事件时）的函数的指针。不要让异常传播到回调函数之外，因为调用回调函数的代码很有可能使用不同的异常处理机制。其实，调用代码甚至有可能不是用C++编写的。
3. 在线程边界的附近：线程是在操作系统的内部创建的。要确保线程的mainline函数不会向系统传播异常，否则将出乎系统的意料。
4. 在模块接口边界的附近：子系统会公开一些公用接口供外部使用。如果子系统要封装为一个库，那么应该使异常仅限于内部，并使用传统的平凡但是可靠的错误代码向外界报告错误（见第72条）。
5. 在析构函数内部：析构函数不能抛出异常（见第51条）。如果析构函数要调用可能会抛出的异常的函数，就需要自我保护好，防止这些异常向外泄漏。
在本条款所提到的位置之外使用catch(...)，经常是一种不良设计的征兆，因为这意味着你想要捕获所有异常，却未必具备处理它们的专门知识（见第74条）。好的程序不应该有很多捕获全部异常的catch(...)，实际上，连try/catch语句都不多；理想情况下，错误可以在模块内部到处顺畅地传播，在跨越模块边界时转换（不得不付出的代码），在按策略设置的边界上进行处理。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第63条 在模块的接口中使用具有良好可移植性的类型
不要让类型出现在模块的外部接口中，除非能够确保所有的客户代码都能正确地理解该类型。应该使用代码能够理解的最高层抽象。
一般而言，如果能够控制用来构建模块和所有客户代码的编译器和编译选项，就可以使用任何类型；如果不能，就只能使用平台所提供的类型和C++的内置类型（尽管如此，对于后一种情况还是应该记录所希望的大小和表示形式）。具体到模块接口，不应该在其中使用标准库类型，除非使用该模块的所有其他模块是与它同时编译的，而且使用的是完全相同的标准库源码映像。
在使用并非所有客户都能正确理解的类型，和使用低层抽象之间，需要进行权衡。抽象当然重要，但是如果有些客户代码只能理解低层类型，而且必须使用这些类型的话，还可以考虑提供使用高级类型的替换操作。
即使选择在模块的外部接口中使用较低层的抽象，也还是应该始终在内部使用最高层的抽象，并在模块的边界处将其转换为低层抽象。例如，如果有非C++语言的客户代码的话，那么可以使用指向客户代码的、不透明的void*或int句柄（此处名模为引用），而内部依然使用对象，并且只在模块接口中转换类型，以实现内外之间的相互转换。
例：
在模块接口中使用std::string。假设一个模块需要提供下面的API：
std::string tranlate(const std::string&);
对于在一个团队或者一个公司内部使用的程序库，这样通常就行了。但是如果需要将此模块与含有不同std::string实现（内存布局不同）的调用代码动态链接起来，就会发生奇怪的事情，因为客户代码和模块都不能理解对方的string。
解决方案之一是用可移植的（可能是内置的）类型，要么在接受string参数的函数之外再增加一个新参数类型的函数，要么干脆取而代之。例如：
void translate(const char* src, char* dest, sizt_t destSize);
使用的抽象层次越低，可移植性就越好，但复杂性也越高；例如在本例中，如果缓冲区不够大，则调用代码和被调用代码都必须显式地处理可能出现的字符串截断。（请注意，这个版本使用了调用代码分配的缓冲区，这样能避免在不同的模块中分别分配和释放内存的缺陷，见第60条。）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第64条 理智地结合静态多态性和动态多态性
动态多态性是以某些类的形式出现的，这些类含有虚拟函数和（通过指针或者引用）间接操作的实例。静态多态性则与模板类和模板函数有关。
多态性意味着一个给定值能够有一种以上的类型，而给定函数能够接受类型与其形参不符的实参。“多态性是无需放弃静态类型检查之利，而能得动态类型检查之便的一种方式。”
多态性的优势在于，同一段代码能够操作于不同类型，甚至可以是在编写代码时不知道的类型。这种“假性因果的适用”是多态性的基础，因为它大大增加了代码的可用性和可重用性（见第37条）。（请与刻板的只能操作于设计意图所要处理的具体类型的那些巨型代码进行比较。）
通过公用继承实现的动态多态性能够使值具有一种以上的类型。动态多态性还称为包含多态性，因为Base所建模的集合，包含Derived所建模的特化。
由于具有这样的特性，在C++中动态多态性最擅长于以下几个方面：
1. 基于超集/子集关系的统一操作：具有超集/子集（基/派生）关系的不同类可以被统一处理。操作于Employee对象的函数也能够操作于Secretary对象。
2. 静态类型检查：C++中所有类型都是被静态检查的。
3. 动态绑定和分别编译：使用层次结构中类的代码与整个层次结构的代码是分别编译的。正是指针（为对象和函数）提供的间接性，使之成为可能。
4. 二进制接口：既可静态链接模块，也可以动态链接模块，只要所链接模块的虚拟表布局方式相同。
通过模板实现的静态多态性也能够使值具有一种以上的类型。在template<class T> void f(T t) {/*...*/}中，可以在f中替换t的类型，使其具有编译代码所需的类型。这称为“隐式接口”，与基类的显式接口对应。这同样实现了多态性的目的，即编写能够在多个类型上操作的代码，只不过方式迥异而已。
静态多态性最擅长于以下几个方面：
1. 基于语法和语义接口的统一操作：可以对奠定一个语法和语义接口的类型进行统一处理。接口是遵守语法的、隐式的（而不是基于签名的、显式的），因此允许使用任何符合给定语法的类型替换。
2. 静态类型检查：所有类型都是被静态检查的。
3. 静态绑定（防止分别编译）：所有类型都是被静态绑定的。
4. 效率：编译时估值和静态绑定能够带来动态绑定所不具备的优化和效率。
应该根据各种因素的轻重缓急，充分发挥两种多态性的长处。
应该结合两种多态性，取长补短，同时尽量趋利避害：
1. 用静态多态性辅助动态多态性：使用静态多态性实现动态多态的接口。例如，假设有一个抽象基类Command，则可以将各种实现定义为template</*...*/> class ConcreteCommand: public Command。实现Command（命令）和Visitor（访问者）设计模式是这种方案的具体实例。
2. 用动态多态性辅助静态多态性：提供一个泛型、易用而且静态绑定的接口，但是内部又是动态分派的，这样就可以提供统一的对象布局。这种方案的优秀实例是可辨识联合（discriminated union）的实现和tr1::shared_ptr的Deleter参数。
3. 任何其他的结合：那种取二者之弊的蹩脚结合比单独使用其一还要糟糕，而得二者之利的漂亮结合则肯定胜过只用其一。例如，不要将虚拟函数放入类模板中，除非需要所有虚拟函数每次都实例化（这与模板类型的非虚拟函数简直是大相径庭）。这种情况下，代码的内存占用可能是天文数字，而且会实例化从不需要的功能，也是对泛型类型的一种过度限制。标准中一些方面的缺陷铸成了这个错误。不要再重蹈覆辙。
//------------------------------------------------------------------------------------------------
//C++编程规范101 有意地进行显式自定义
有意胜过无意，显式强似隐式：在编写模板时，应该有意地、正确地提供自定义点，并清晰地记入文档。在使用模板时，应该了解模板想要你如何进行自定义以将其用于你的类型，并且正确地自定义。（不太懂？）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第66条 不要特化函数模板
只有在能够正确实施的时候，特化才能直到好作用：在扩展其他人的函数模板（包括std::swap）时，要避免尝试编写特化代码；相反，要编写函数模板的重载，将其放在重载所用的类型的名字空间中（见第56条和第57条）。编写自己的函数模板时，要避免鼓励其他人直接特化函数模板本身（替代方法参见第65条）。
特化函数模板很不直观。 这有两个基本原因：
1. 不可能部分地特化函数模板，只能完全特化：看似部分特化的代码实际上只是重载而已。
2. 函数模板特化决不能参与重载：所以，所编写的任何特化对使用哪个模板都将毫无影响，而这将与大多数人的自然预期背道而驰。毕竟，如果编写一个签名完全相同的非模板函数，而不是函数模板特化的话，所选中的将总是非模板函数，因为与模板相比，它始终被认为是更佳的选择。
如果要编写一个函数模板，应该将它编写成一个永远都不会被特化或者被重载的函数模板，并使用一个类模板来实现函数模板。这增加了一个著名的间接层，能够指导你很好地避开函数模板使用上的局限和死角。这样使用模板的程序员就能够随心所欲地部分特化和显式特化类模板，而不会影响函数模板期望的操作了。这很好地避免了函数模板无法被部分特化的限制以及有时候函数模板特化无法重载所导致的意外情况。问题由此迎刃而解。
如果正在使用其他人编写的没有使用以上技术的普通旧式函数模板（即没有使用类模板实现的函数模板），而且你想编写自己的应该参与重载的特殊版本，那么请不要将其编写成特化，要将其编写为重载非模板函数（另见第57条和第58条）。
示例
例 std::swap。基本的swap模板通过创建a的一个temp（临时）副本，将b赋值给a，并将temp赋值给b来实现两个值a和b的交换。怎样为你自己的类型扩展它呢？例如，在你自己的名字空间N中有一个自定义的类型Widget：
namespace N
{
	class Widget {/*...*/};
}
假定有更有效的方法交换两个Widget对象。要使其能够用于标准库，应该提供一个swap的重载（在Widget所在的名字空间中，见第57条）呢，还是直接特化std::swap呢？标准对此并没明确规定，而且现有的做法之间差异也很大（见第65条）。如今，实践中在一些编译器上，正确的解决方式是在Widget所在的名字空间中提供一个重载版本。对于上面非模板的Widget，可以
namespace N
{
	void swap(Widget&, Widget&);
}
但请注意如果Widget是一个模板：
namespace N
{
	template<typename T>class Widget {/*...*/};
}
则特化std::swap是根本不可能的，因为没有函数模板部分特化这样的东西。我们所能做的最多是添加重载版本：
namespace ???
{
	template<typename T> void swap(Widget<T>&, Widget<T>&);
}
但是这是有问题的，因为，如果将其放入Widget所在的名字空间中，则许多编译器都将无法找到它（这与Effective C++条款25说得不一致，后者提倡这么做？），但是标准又禁止将其放在std名字空间中。这真是一个“第22条军规”。如果标准规定了类型的名字空间中能够找到重载，或者允许在std中添加重载，或者（回到本条款的要点）规定swap要用能够部分特化的类模板实现，这个问题就不存在了。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第67条 不要无意地编写不通用的代码
依赖抽象而非细节：使用最通用、最抽象的方法来实现一个功能。
与此相反，毫无道理地依赖细节的代码将是僵化而脆弱的：
1. 使用!=代替<对迭代器进行比较
2. 使用迭代代替索引访问
3. 使用empty()代替size() == 0
4. 使用层次结构中最高层的类提供需要的功能：使用动态多态的类编程时，不要依赖于不需要的、绑定到具体派生类的细节。
5. 编写常量正确的代码（见第15条）：以const&为参数对调用代码的限制最小，因为const&同样适用常量和非常量对象。

例外情况
在某些情况下，使用索引而不是迭代器能够使编译器更好地进行优化。但是在这样做之前，请确认是否真地需要这种优化，以及编译器是否真地能够做到（见第8条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第68条 广泛地使用断言记录内部假设和不变式
使用断言，广泛地使用assert或者等价物记录模块内部（也就是说，调用代码和被调用代码由同一个人或者小组维护）的各种假设，这些假设是必须成立的，否则就说明存在编程错误（例如，函数的调用代码检查到函数的后条件不成立）。（另见第70条。）当然，要确保断言不会产生任何副作用。
刻意寻找代码中的错误时，错误都很难发现；如果已经认为代码没有错误了，那么错误就更难发现了。  
断言一般只会在调调试模式下生成代码（在NDEBUG宏没有被定义时），因此在发行版本中它们是不存在的。所以尽管进行检查好了。但是千万不要在assert语句中编写具有副作用的表达式，在发行模式下，如果定义了NDEBUG，则assert根本不会生成任何代码。
按照信息论的原理，一个事件中所含的信息量与该事件发生的概率是成反比的。因此，如果assert触发的可能性越低，它触发时所提供的信息量就越大。
要避免使用assert(false)，应该使用assert(!"informational message")。大多数编译器会在错误输出设备上发送这个字符串，这一点很有用。还可以老邪在更复杂的断言中加入&&"informational message"，尤其是这样可以取代注释。
#include <iostream>
#include <cassert>
using namespace std;

int main()
{
	int a = 3;
	assert(a == 0 && "a is not equal 0!");
	cout << a << endl;
}
输出：
Assertion failed: a == 0 && "a is not equal 0!", file d:\program files\vc projec
ts\learningtest\learningtest\main.cpp, line 8
请按任意键继续. . .
总而言之：我们知道有些错误是可能会发生的（见第69条到第75条）。对于其他不应该发生的错误，如果发生了，就是程序员的过错，此时就该使用assert了。

例 对基本假设应该使用assert。我们都曾有过与“不可能触发”却触发了的断言有关的痛苦经历。每次都有人说：“这个值肯定是正的！”“那个指针显然不会为空！”。但请反复检查重言式（tautology）：软件开发是复杂的，变化乃是常事，而在一个变化着的程序里什么事情都有可能发生。断言能够验证你现在确信“显然为真”的事情确实为真。对类型系统无法强制实施的重言式，应该使用assert：
string Data::DayOfWeek() const 
{
	assert(day_ > 0 && day_ <= 31);//不变式检查
	assert(month_ > 0 && month_ <= 12);
	//......
}
//------------------------------------------------------------------------------------------------
//C++编程规范101 第69条 建立合理的错误处理策略，并严格遵守
错误处理机制应该只在模块边界改变（见第62条和第63条）。每个模板都应该在其内部一致地使用一种错误处理策略和机制（例如，用C++编写的模块应该在内部使用异常；见第72条），并在接口中一致地使用一种（可能是不同于内部所用的另一种）错误处理策略和机制（例如，模块可能会提供普通的C语言的API，从而允许用各种编程语言编写调用代码，或者也可能会提供能够支持COM异常的COM封装）。
如果模块内外所使用的策略不同，则所有模块入口函数都要在直接负责由内到外的策略转换。例如，在一个内部使用C++异常，但是提供C语言的API边界的模块中，所有C语言的API必须catch(...)捕获所有异常并将其转换为错误代码。
特别要注意，按定义回调函数和线程主线函数是（或者可能是）位于模块边界。每个回调函数主体和线程主线函数主体都应该将内部错误机制转换为合适的接口错误策略（见第62条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第70条 区别错误与非错误
根据对函数的影响，而清楚地区别错误和非错误是非常关键的，对定义安全保证（见第71条）而言尤其如此。本条款中的关键词是前条件（precondition）、后条件（postcondition）和不变式（invariant）。
无论是用结构化的风格、面向对象风格还是泛型风格进行C++编程，函数都是基本的工作单元。函数对其起始状态进行了假设（此假设将被记录在前条件中，调用代码负责满足而被调用代码负责验证），并执行了一个或者多个操作（以其结果或者后条件的形式记录，作为被调用代码的函数负责满足后条件）。函数应该承担维持一个或者多个不变式的职责。特别是，一个非私有的会改变状态的函数按其定义是其对象的一个工作单元，而且必须将对象从一个有效的维持不变的状态转变成另一个有效的维持不变的状态；在该成员函数体中，对象的不变式可能会（而且几乎总是肯定会）被破坏，但这没有什么关系，只要在成员函数的最后它们能够被重新建立就行了。高层的函数通过组合多个低层的函数能够形成更大的工作单元。
错误就是组上函数成功操作的任何失败。有三种类型：
1. 违反或者无法满足前条件：函数检测出自己的一个前条件（比如一个参数或者状态约束）被违反，或者遇到一种情况，阻碍了它满足另一个必须调用的关键函数的前条件。
2. 无法满足后条件：函数遇到了一种阻碍它建立自己的一个后条件的情况。如果函数有一个返回值的话，生成一个有效的返回值对象就是一个后条件。
3. 无法重新建立不变式：函数遇到一种阻碍它重新建立自己负责维持的不变式的情况。这是一种特殊的后条件，尤其适用于成员函数；每个非私有成员函数都必不可少的后条件是它必须重新建立其类的不变式。
任何其他情况都不是错误，因此不应该报告为错误（见示例）。
可能产生错误的代码应该负责检查和报告错误。具体说来，调用代码在无法满足所调用的函数的前条件（尤其是被调用代码在文档中记载了它将不检查的前条件，比如vector::operator[]就不承诺对其参数进行范围检查）时，应该检查和报告。因为被调用函数不能依赖调用代码来保证行为正常，但是被调用函数仍然应该验证其前条件，并通过发送一个错误来报告，如果函数处于模块内部（即只能从模块内部调用），则任何前条件的违反按定义都是模块的编程错误，此时可以通过断言来报告（见第68条）。这就是所谓的防御性编程（defensive programming）。
关于指定函数的前条件有一个警告要说：当且仅当有正当理由让所有调用代码在调用函数f之前检查和验证条件的有效性时，这个条件才应该是函数f的前条件。例如，函数这样表述前条件是错误的：只能通过进行函数自己的具体操作或者访问私有信息才能检查；这种工作仍然应该在函数中进行，而不应该在调用代码中重复。
接受一个含有文件名的string作为参数的函数通常不能将文件的存在作为前条件，因为在调用代码没有对文件加锁的情况下，无法确保该文件一定存在（如果它们只检查文件是否存在而不对文件加锁的话，则在调用代码进行检查和被调用代码试图打开文件之间，另一个用户或者进程可能会删除或者重命名这个文件）。将文件的存在作为前条件的正确方法是，要求调用代码打开文件，将将函数的参数设为一个ifstream或者等价物（这也会更加安全，因为它工作在更高的抽象层上，见第63条。明白了，调用代码调用ifstream f("input.txt");并将f传给被调用函数）而不是被更强的类型化所替代，这将把原来的运行时错误变成编译时错误（见第14条）。
示例
例1 std::string::insert（前条件错误）。试图将一个新字符插入到一个string的某个特定位置pos时，调用代码应该检查pos是否是违反了在文档中所记载的参数需求的一个无效值；例如，pos > size()。如果没有有效的起点，insert函数就无法成功地执行操作。
如果超出范围，抛异常
#include <iostream>
#include <string>
#include <exception>

using namespace std;

int main()
{
	string s("hello");
	try
	{
		s.insert(6, 1, 'a');
	}
	catch(exception& e)
	{
		cerr << e.what() << endl;
	}
	cout << s << endl;
}
例2 std::string::append（后条件错误）。在string中追加字符时，如果现有的缓冲区已满，而又没胡成功地分配新的缓冲区，那么将阻止操作成功地执行其在文档中所记载的函数并满足其在文档中所记载的后条件，因此这是一个错误。
例3 无法生成返回值（后条件错误）。对于要返回值的函数，生成一个有效的返回值对象就是后条件。如果返回值不能被正确的创建（比如，函数返回一个double，但是结果所要求的数学属性并没有double值），那么这就一个错误。
例4 std::string::find_first_of（在string的上下文中不错误）。在string中查找字符时，找不到该字符是一种合理的结果，而不是错误。至少，对于通用string类而言这不是一个错误，但是，如果给定的string属主认为该字符应该存在，但实际不存在，那么根据更市场的不变式可知，这是一个错误，此时，高层调用代码应该正确地报告一个关于其不变式的错误。
例5 同一函数中的不同错误情况。如今尽管硬盘的可靠性在不断的提高，但是传统上写硬盘的操作还是会出现预期错误的。如果要设计一个File类，在同一个函数File::Write(const char* buffer, size_t size)中，要求buffer非空，并以写方式打开文件，那么可能会决定做以下工作：
1. 如果buffer为NULL：报告一个有关违反前条件的错误。
2. 如果File是只读的：报告一个有关违反前条件的错误。
3. 如果写入不成功：报告一个有关违反后条件的错误，因为函数无法实现承诺要完成的操作。
例6 同一情况的不同状况。同样的情况，对于一个函数来说可能是有效地前条件，但对另一个来说可能就不然了；选择取决于函数的作者，因为他指定了接口的语义。比如，std::vector提供了两种执行索引访问的方法：不进行边界检查的operator[]，和进行边界检查的at。这两种方法都要求参数不能越界这一前条件。因为并不要求operator[]验证其参数，也不要求使用无效参数能够安全调用，因此必须在文档中记录，调用代码需要单独负责确保参数在有效范围之内；
因此，operator[]这个函数并不安全。另一方法，文档中已经说明，即使存在无效参数，at也会安全行事，而且，如果发现参数超出了范围，at也会报告一个错误（通过抛出std::out_of_range）。（可以用try/catch捕捉at异常，但是operator[]会在debug模式直接弹“Debug assert failed”）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第71条 设计和编写错误安全代码
在所有函数中，都应该提供最强的安全保证，而且不应惩罚不需要这种保证的调用代码。至少要提供基本保证。
确保出现错误时程序会处于有效状态。这是所谓的基本保证（basic guarantee）。要小心会破坏不变式的错误（包括但是不限于泄漏），它们肯定都是bug。
应该进一步保证最终状态要么是最初状态（如果有错误，则回滚操作），要么是所希望的目标状态（如果没有错误，则提交操作）。这就是所谓的强保证（strong guarantee）。
应该进一步保证操作永远不会失败。虽然这对于大多数函数来说是不可能的，但是对于析构函数和释放函数这样的函数来说则是必须的。这就是所谓的不会失败保证（no-fail guarantee）。
基本保证、强保证和不会失败（也称为不抛出）保证适用于所有错误处理，无论使用什么具体方法，因此我们将使用它们一般性地叙述错误处理的安全性。不会失败保证是强保证的严格超集，而强保证是基本保证的严格超集。
一般而言，每个函数都应该尽可能地提供最强保证，而且不能无必要地惩罚不需要此保证的调用代码。只要可能，它应该进一步提供足够的功能以允许需要更强保证的调用代码获得这种保证（见“示例”中vector::insert一例）。
理想情况下，我们编写的是总能成功的函数，所有可以提供不会失败保证。有些函数必须始终提供不会失败保证，尤其是析构函数、释放函数和交换函数（见第51条）。
但是，大多数函数都会失败。当有可能出现错误时，最安全的方法就是确保函数支持事务性的行为：要么就完全成功，将程序从初始的有效状态转到期望的目标有效状态，要么就失败，让程序保持调用前的状态不变，即任何对象的可见状态在调用失败之前与调用失败之后都是一样的（比如，一个全局int的值不会从42变成43），在调用失败之前调用代码能够执行的任何操作，在调用失败之后仍然能够保持原有语义执行（比如，不会使任何容器的迭代器无效，对前面提到的全局int的值执行++操作仍然会得到43，而非44）。这就是强保证。
最后，如果提供强保证很困难或者过于昂贵，那就提供基本保证：要么函数完全成功，达到期望的目标状态，要么无法完全成功，让程序处于一个仍然有效（保持函数知道而且负责保持的不变式）但是不可预测（可能是初始状态，也可能不是，可能能满足所有后条件，也可能只能满足其中一些，还有可能完全不能满点；但是要注意提必须重新建立所有的不变式）的状态。应用程序的设计必须为正确地处理该状态做好准备。
就这些了，不存在更低的层次。如果无法满足最低的基本保证，那么就是一个程序bug。正确的程序中所有函数都至少要满足基本保证，甚至有少数特殊的正确程序设计会故意泄漏资源，尤其是在程序马上就要中止的情况下，这所以这么做是因为知道所泄漏的资源会被操作系统回收。除非错误非常严重，以至于只能选择正常终止或者非正常终止，否则应该总是合理地构造代码，即使在出现错误的情况下，程序也能正确地释放资源，数据也能处于一致的状态。
在决定应该支持哪种保证时，还要考虑版本问题：在未来的版本中加强保证问题很容易的，而以后要减弱保证则要将破坏要依赖于更强保证的调用代码。
请记住，“错误不安全”和“糟糕设计”是形影不离的：如果一段代码连基本保证都很难满足，那么这几乎就是说明设计很糟糕。例如，如果函数要承担多个互不相关的职责，那就很难做到错误安全的（见第5条）。
如果复制赋值操作符要依赖于自赋值检查才能正确运行，那么就要小心了。错误安全的复制赋值操作符对于自赋值自动就是安全的。使用自赋值检查作为一种优化以避免不需要的工作，是很好的（见第55条）。
示例
例1 在失败后重试
例2 皮肤。如果要编写一个可换皮肤的应用程序，不要在试图装载新的之前销毁原有的皮肤。否则如果装载新的失败，则应用程序可能会处于一个不可用的状态。
例3 std::vector::insert。因为vector<T>的内部存储是连续的，所以在中间插入一个元素需要将一些已有的值移动一个位置，为新元素腾出空间。这种移动是使用T::T(const T&)和T::operator=完成的，如果这两个操作之一可能会失败（通过抛出异常）的话，那么能够使insert提供强保证的惟一方法就是完整地复制容器，对副本执行操作：如果操作成功，则使用不会失败的vector<T>::swap交换原容器和副本的状态。
但是，如果每次都这些都由insert完成的话，那么vector::insert的所有调用代码都要承担完整复制容器所带来的空间与性能上的代码，无论是否需要强保证。这种高昂代价显然是不必要的。其实，需要强保证的那些调用代码能够自己完成这些任务，而且有充足的工作供它们使用。（最好的情况是，安排好容器中存放的类型，不让其复制构造函数或者复制赋值操作符抛出异常。最坏的情况是，完整复制，在副本中执行插入操作，然后在操作成功后将副本与原容器交换。）
例4 取消卫星发射。考虑函数f，它的功能之一是发射卫星，它所使用的LaunchSatellite函数提供强保证或者不会失败保证。如果f能够在发射卫星之前完成所有可能失败的任务，则可以将其编写成能够提供强保证的函数。但是，如果f在已经执行发射之后还必须执行其他可能失败的操作，那么它就无法提供强保证，因为它无法再将卫星拽回来。（无论如何，这样的f可能应该分成两个函数，因为一个函数可能不应该尝试完成多项这么重要的任务，见第5条。）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第72条 优先使用异常报告错误
出现问题时，就使用异常：应该使用异常而不是错误码来报告错误。但不能使用异常时，对于错误以及不是错误的情况，可以使用状态码（比如返回码，errno）（见第62条）来报告异常。当不可能从错误中恢复或者不需要恢复时，可以使用其他方法，比如正常终止或者非正常终止。
按定义粗略地说，异常就是为了报告正常处理的异常情况，也称为“错误”，第70条中定义为前条件、后条件和不变式的违反。与所有错误报告一样，异常不应该在正常的成功操作期间出现。
我们将使用“状态代码”这个术语涵盖通过代码报告状态的各种形式（包括返回码errno、GetLastError函数和其他返回或者获取代码的方法），而“错误码”则专门用于表示报告错误的状态代码。在C++中，和通过错误码报告相比，通过异常报告错误有许多明显的优势，这些优势都能够使代码更加健壮。
1. 异常不能不加修改地忽略：错误码最糟糕的弱点在于，它们默认时是被忽略的；而即使对错误码最低限度的处理，也需要显式地编写代码来接受错误并做出相应反应。程序员由于不注意或者偷懒而对错误码不加处理是非常常见的。这使代码审查更加困难。异常则不能被不加修改地忽略：要忽略异常，必须显式地捕获它（即使只是通过catch(...)），之后才能选择不对其进行操作。
2. 异常是自动传播的：错误码默认时不会跨越作用域传播，要上高层的调用函数知道低层的错误码，编写中间代码的程序员必须显式地手写代码传播错误。而异常则是自动跨作用域传播的，直到得到处理为止。（“试图使每个函数都成为防火墙并不是什么好主意。”）
3. 有了异常处理，就不必在控制流的主线中加入错误处理和恢复了：错误码的检查代码和处理代码（如果编写了），肯定会散布于（因此会弄乱）控制流的主线中。这会使主控制流和错误处理代码更加难于理解和维护。异常处理很自然地将错误检查和恢复都放进了独立的catch代码块：也就是说，它使错误处理变得清晰有形，不再是内嵌的大杂烩了。这能够使控制主线更加易于理解和维护，清晰地将正确的操作与错误检查和恢复分开，决不仅仅只是更加美观。
4. 对于从构造函数和操作符报告错误来说，异常处理要优于其他方案：复制构造函数和操作符的签名是预定义的，没有为返回码预留。特别是，构造函数根本就没返回类型（连void都没有），例如每个operator+操作都必须恰好有两个参数，并返回一个（指定类型的，见第26条）对象。对于操作符来说，使用错误码虽然不能令人满意，至少是可行的：它需要类似于errno的方法，或者采用一种更差的方法，如用对象将状态封装起来。对于构造函数，使用错误码是不可行的，因为C++语言将构造函数异常和构造函数失败紧紧地绑定在了一起，所以两者无疑是同义的。如果我们改而使用了一个类似于errno方法，比如：
SomeType anObject;//构造一个对象
if (SomeType::ConstructionWasOk())//测试构造是否行得通
{/*...*/}
那么所得到的结果不仅难看，容易出错，而且会产生无法真正满足其类型不变式的非法对象，因为这种方法根本就不会管多线程应用程序里调用SomeType::ConstructionWasOk时会自动产生的竞争条件。
异常处理潜在的主要缺点在于，它要求程序员必须熟悉一些会反复遇到的惯用法，这些惯用法来源于异常的特殊控制流。例如，析构函数和释放函数绝对不能失败（见第51条），而且在出现异常时必须保证中间代码是正确的（见第71条和本条参考文献）。为了满足后一个要求，一个常见的编程惯用法就是先执行所有可能安全地发出异常的工作，然后只在知道真正的工作成功后，才使用提供不会失败保证（见第51条）的操作提交和修改程序状态。但是使用错误码也有自己的惯用法，这些惯用法出现的时间更早，因此知道的人也更多，但是很不幸，人们通常还是会忽略它们。使用时千万当心。
性能通常不是异常处理的缺点。首先，请注意应该总是打开编译器的异常处理，即使默认是关闭的，否则就无法获得C++语言操作（比如operator new）和标准库操作（比如STL容器插入）的标准行为和错误报告（见本条例外情况）。
错误码使用过度的一个标志就是，应用程序需要不断地检查各种琐细的为真条件，或者（更糟糕地）不检查应该检查的错误码。
异常使用过度的一个标志就是，应用程序代码频繁地抛出和捕获异常，以致于try代码块成功与失败的次数是同一数量级的。这样的catch代码块要么没有处理真正的错误（违反了前条件、后条件和不变式的错误），要么说明程序存在严重问题。
示例
例1 构造函数（不变式错误）。如果构造函数无法成功创建其类型的对象，相当于它无法建立新对象的不变式，就应该抛出异常。反之，如果构造函数抛出异常，说明对象的构造失败了，对象的生命周期从未开始：这是C++语言强制实施的。
例2 成功的树递归查找。
例外情况
如果能够肯定以下两点为真，就可以考虑使用错误码：
1. 异常的优点不适用
2. 抛出异常与使用错误码的实测性能差异比较明显
//------------------------------------------------------------------------------------------------
//C++编程规范101 第73条 通过值抛出，通过引用捕获
抛出异常时，通过值抛出对象。
抛出指向栈分配的值是指针是不可行的，因为在指针到达调用处之前栈还没有展开。如果觉得确实必须抛出指针，那么可以考虑抛出一个类似值的智能指针，比如用shared_ptr<T>代替普通的T*。
通过值抛出，由编译器本身负责管理异常对象的内存这一复杂过程，我们要保证为异常类实现不抛出的复制构造函数（见第32条）。
除非要抛出的是智能指针（这已经增加了要保持多态的间接性），否则通过引用捕获异常。值捕获普通值将在捕获处引起切片问题（见第54条），会去除通常至关重要的异常对象的多态性。通过引用捕获则能够保持异常对象的多态性。
重新抛出异常e时，只写成throw;而不是throw e;，因为第一种形式总是能够保持重新抛出对象的多态性。
例 重新抛出一个修改过的异常。应该使用throw;重新抛出：
catch(MyException& e)//通过非常量的引用捕获
{
	e.AppendContext("Passed through here");//修改
	throw;//重新抛出修改过的对象
}
//------------------------------------------------------------------------------------------------
//C++编程规范101 第74条 正确地报告、处理和转换错误
在检查出并确认是错误时报告错误。在能够正确处理错误的最近一层处理或者转换每个错误。
只要函数检查出一个它自己无法解决而且会使函数无法继续执行的错误，就应该报告错误（比如编写throw）（见第70条）。
如果没有足以对错误做有用处理的上下文，代码就不应该接受错误。如果函数自己不准备处理（或者转换，或者谨慎地吸收）错误，那么它应该允许或者使错误向上传播到能够处理它的调用代码。
例外情况
接受并且再次发送（比如catch并重新抛出）同样的错误以添加测试代码有时候是有用的，虽然错误实际上并没有得到处理。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第75条 避免使用异常规范（不太懂？）
//------------------------------------------------------------------------------------------------
//C++编程规范101 第76条 默认时使用vector。否则，选择其他合适的容器
使用“正确的容器”才是正道：如果有充分的理由使用某个特定容器类型，那就用，我们心中有数：自己做出了正确的选择。
使用vector同样如此：如果没有充分理由，那就用vector，我们同样心中有数：自己做出了正确的选择。
1. 编程时正确、简单和清晰是第一位的（见第6条）
2. 只在必要时才考虑效率（见第8条）：如果证实查找速度是关键的考虑因素，那么优先使用基于散列（非标准的hash_...或者标准的unordered_...）的容器，然后考虑使用有序的vector，再后是set或map，一般依此顺序考虑。
3. 尽可能编写事务性的、强错误安全的代码（见第71条），而且不使用失效对象（见第99条）：如果插入和删除元素需要事务性的语义，或者需要尽量减少迭代器失效，则应该优先使用基于节点的容器（例如list、set和map）。
其他方面，应该遵循标准中的建议：默认情况下，应该使用的序列类型是vector。
示例
例 将vector用于小型列表 只是因为“对列表操作（比如在序列中间插入）显然应该使用list类型”就使用list，是一种常见的错误。将vector用于小型列表几乎总是优于使用list。即使在序列中间插入对vector而言是线性时间操作，而对list而言是常数时间操作，但当容器相对较小时，vector仍然总是优于list，因为它的常数因子更小，而list的算法复杂性上的优势在数据量更大时才能发挥出来。
这里，应该坚决使用vector，除非数据量决定了需要另一种选择（见第7条），或者因为强安全保证是必不可少的，而且所存放类型的复制构造函数和复制赋值操作可能会失败（list能够对这些类型集合的插入操作提供强安全保证，在此情况下，这一点有可能非常重要）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第77条 用vector和string代替数组
//------------------------------------------------------------------------------------------------
//C++编程规范101 第78条 使用vector（和string::c_str）与非C++ API交换数据
vector和string::c_str是与非C++ API通信的通道。但是不要将迭代器当作指针。要获取vector<T>::iterator iter所引用的元素地址，应该使用&*iter。
vector的存储区总是连续的，因此访问其第一个元素的地址将返回一个指向其内容的指针，可以使用&*v.begin()、&v[0]或&v.front()来获取v的第一个元素的指针。要获取指向vector第n个元素的指针，应该先做运算再取址（例如，&v.begin()[n]或&v[n]），而不要先获取头部的指针然后再进行指针运算（例如(&v.front())[n]）。这是因为，前一种情况下能够给带检查的标准库实现一个机会，验证没有越界访问v的元素（见第83条）。

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class MyIntGenerator
{
public:
	MyIntGenerator(int n): n_(n) {}
	int operator()()
	{
		return n_++;
	}
private:
	int n_;
};

int main()
{
	vector<int> intVec(10);
	generate(intVec.begin(), intVec.end(), MyIntGenerator(0));

	cout << intVec.begin()[5] << endl;
}

不要认为v.begin()返回的是指向第一个元素的指针，或者一般性地认为vector的迭代器都是指针。虽然有些STL实现确实将vector<T>::iterator定义为原始T*指针，但是迭代器可以是功能完整的类型，实际上也是越来越接近（见第83条）。
虽然大多数标准库实现中string都使用连续内存，但这是没有保证的，所以绝对不要认为获取了string中一个字符地址，它指向的就是连续内存。string::c_str总是返回一个空字符结束的C风格字符串。（string::data返回的也是指向连续内存的指针，但并不保证以空字符结束。）
一个设计良好的C语言的API会有这样的参数：对象的最大数量（最大为v.size()），或者指向结尾之后那个元素（past-the-end）的指针（&*v.begin() + v.size()）。
如果有一个除vector或string之外存放T对象的容器，想将其内容传递给一个非C++ API（或从该API中填充内容），而该API需要指向T对象数组的指针，那么应该将容器内容复制到一个vector<T>中（或将vector<T>内容复制到容器），通过后者直接与非C++ API通信。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第79条 在容器中只存储值和智能指针
在容器中存储值对象：容器假设它们所存放的是类似值的类型，包括值类型（直接存放）、智能指针和迭代器。
示例
例1 auto_ptr的对象并不类似于值，因为它们所有权转移的复制语义。用shared_ptr。
例2 异构容器。为了让容器存储和拥有不同但是相关联的类型（比如从一个公用基类Base派生的各种类型）的对象，应该使用container< shared_ptr<Base> >。另一选择是存储代理对象，该对象的非虚拟函数会将调用传递给相应的实际对象的虚拟函数。
例3 非值类型的容器。为了存放对象，即使它们是不可复制的，或者不是类似于值的（比如DatabaseLock和TcpConnection），也应该直接通过智能指针存入它们（比如container< shared_ptr<DatabaseLock> >和container< shared_ptr<TcpConnection> >）。
例4 可选值。如果需要map<Thing, Widget>，但是有些Thing没有相关联的Widget，就应该使用map<Thing, shared_ptr<Widget> >。
例5 索引容器。为了让主容器存放对象，然后在不重排主容器的情况下用不同的排列顺序访问它们，可以设置多个次容器“指向”主容器，然后用析值（dereference）比较谓词以不同的方式将次容器排序。但是应该用包含MainContainer::iterator（它是类似于值的）的容器而不是指针容器。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第80条 用push_back代替其他扩展序列的方式
尽可能使用push_back：如果不需要操心插入位置，就应该使用push_back在序列中添加元素。其他方法可能极慢而且不简明。
push_back是按指数扩大容量的，而不是按固定增量扩大的。因此重新分配和复制的次数将随大小的增长迅速减少。对于只用push_back调用添加元素的容器而言，无论容器最终大小是多少，每个元素平均只会复制一次。
resize和insert也可以采取相同的策略，但这与具体实现有关，只有push_back能够提供保证。
因为无法访问容器，所以标准算法不能直接调用push_back。但是可以通过使用back_inserter，要求算法使用push_back。
例外情况
如果知道要添加的范围，即使位于容器的末尾，也应该使用范围插入函数（见第81条）。
指数级增长需要分配大量内存。要对此增长微调，可以显式地调用reserve，因为如果有足够的空间，那么无论是push_back、resize，还是类似的函数，都永远不会触发重新分配。要为vector设定“正确大小”，可以使用shrink-to-fit惯用法（见第82条）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第81条 多用范围操作，少用单元素操作
//------------------------------------------------------------------------------------------------
//C++编程规范101 第82条 使用公认的惯用法真正地压缩容量，真正地删除元素
要真正地压缩容器的多余容量，应该使用“swap魔术”惯用法。要真正地删除容器中的元素，应该使用erase-remove惯用法。
有些容器（例如vector、string、deque）可能最后会具有不再需要的多余容量。虽然C++标准库容器没有提供一种保证可行的方法去除多余容量，但是下面的“swap魔术”惯用法确实可以去除类似container类型容器c的多余容量：
container<T>(c).swap(c);//去除多余容量的shrink-to-fit（压缩到合适）惯用法
或者，如果要将c完全清空，清除所有存放的元素并去除所有可能的容量，则惯用法为：
container<T>().swap(c);//去除全部内容和容量的惯用法
remove算法并不真正地从容器中删除元素。当然，它也不能；算法只操作于迭代器范围，不调用容器的成员函数（通常是erase），是不可能真正从容器中删除内容的。remove所做的就是移动值的位置，将不应该“删除”的元素移到范围的开始处，并返回一个迭代器指向最后一个不应删除元素的下一位置。要真正删除，需要在调用remove之后再调用erase――这就是所谓的“erase-remove”惯用法。例如，要删除容器c中所有等于value的元素，这样编程：
c.erase(remove(c.begin(), c.end(), value), c.end());
对于有remove或remove_if的容器，应该尽量使用这两个函数的成员版本。

例外情况
通常的shrink-to-fit惯用法对写时复制（copy-on-write）方式实现的std::string不适用。总是可行的方法是调用s.reserve(0)，或者通过编写string(s.begin(), s.end()).swap(s);，用迭代器范围构造函数来压缩string的多余容量。实际上，这些都可以去除多余容量。
#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s;
	cout << s.capacity() << endl;
	s.assign("hello");
	cout << s.capacity() << endl;
	s.reserve(20);
	cout << s << endl;
	cout << s.capacity() << endl;

	string(s.begin(), s.end()).swap(s);
	cout << s.capacity() << endl;
}
输出如下：
15
15
hello
31
15
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//C++编程规范101 第83条 使用带检查的STL实现
例1 
transform(data.begin(), data.end(), inserter(d, d.begin()), bind2nd(plus<double>(), 41));//从data复制元素到d的头部每个都加41
确实，bind2nd和plus很笨拙，原因也是它们有损可读性（见第6条）。
lambda函数可以为我们生成函数对象，这样就可以如下简单地编程了：
transform(data, data + max, insert(d, d.begin()), _1 + 41);
例2
查找处于x和y之间的第一个元素。思考这个原始循环，它通过计算指向被找到的元素或v.end()的迭代器，查找vector<int> v中x和y之间的第一个值：
vector<int>::iterator i = v.begin();
for(; i != v.end(); ++i)
{
	if (*i > x && *i < y) 
	{
		break;
	}
}
算法调用将大有问题。如果不使用lambda，那么就只有两种选择，即要么选择编写自定义的函数对象，要么使用标准绑定器。如果选择绑定器，就不能只使用标准绑定器，而是要用到非标准的（虽然广泛可用的）compose2适配器，不仅如果，所得到的代码将很难理解：
vector<int>::iterator iter = find_if(v.begin(), v.end(), 
																compose2(logical_and<bool>(), 
																					bind2nd(greater<int>(), x),
																					bind2nd(less<int>(), y)));
另一种选择，即编写自定义函数对象，是可行的。从调用点来看这种选择也很好，它的主要缺点在于必须编写类似于BetweenValues的函数对象，这使循环体的逻辑看上去远离了调用点。
template<typename T>
class BetweenValues: public unary_function<T, bool>
{
public:
	BetweenValues(const T& low, const T& high): low_(low), high_(high){}
	bool operaotr()(const T& val) const 
	{
		return val > low_ && val < high_;//远离了使用的调用点
	}
private:
	T low_, high_;
}
vector<int>::iterator iter = find_if(v.begin(), v.end(), BetweenValues<int>(x, y));
而lambda函数（上网查？）可以为我们生成函数对象，这样就可以如下简单地编程了：
vector<int>::iterator i = find_if(v.begin(), v.end(), _1 > x && _1 < y);

//没有找到lambda表达式和not1等的结合使用方法？？？

函数对象vsLambda
当你写代码时，你可能会使用函数指针和函数对象来解决问题和进行计算，尤其是当你使用 STL算法时 。 函数指针和函数对象有优点和缺点。例如，函数指针具有最低的语法开销，但不保留在范围内的状态，而函数对象能够维护状态，但需要类定义的语法开销。
lambda 将集合函数指针和函数对象的优点并避免其缺点。 像函数对象，lambda 是灵活，并且可以维护状态，但是，不同函数对象，其简洁语法不需要类定义。 使用lambda，相比等效的函数对象代码，您可以写出不太复杂并且不容易出错的代码。
下面的示例比较lambda和函数对象的使用。 第一个示例使用lambda打印到控制台在一个 vector 中的每个元素是偶数还是奇数。 第二个示例使用函数对象来完成相同任务。
lambda函数示例（MSDN上搜索到的）：
示例 1:使用 Lambda
这个示例使用lambda for_each 函数调用打印到控制台在一个 vector 中的每个元素是偶数还是奇数。
// even_lambda.cpp
// compile with: cl /EHsc /nologo /W4 /MTd
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main() 
{
	// Create a vector object that contains 10 elements.
	vector<int> v;
	for (int i = 0; i < 10; ++i) {
		v.push_back(i);
	}

	// Count the number of even numbers in the vector by 
	// using the for_each function and a lambda.
	int evenCount = 0;
	for_each(v.begin(), v.end(), [&evenCount] (int n) {
		cout << n;

		if (n % 2 == 0) {
			cout << " is even " << endl;
			++evenCount;
		} else {
			cout << " is odd " << endl;
		}
	});

	// Print the count of even numbers to the console.
	cout << "There are " << evenCount 
		<< " even numbers in the vector." << endl;
}
输出如下：
0 is even
1 is odd
2 is even
3 is odd
4 is even
5 is odd
6 is even
7 is odd
8 is even
9 is odd
There are 5 even numbers in the vector.

在此示例中，for_each 函数的第三个参数是一个lambda。 在 [&evenCount] 部分指定表达式的捕获从句，(int n) 指定的参数列表，剩余部分指定表达式的主体。

示例 2:使用函数对象
有时 lambda 比前面的示例在进一步扩展上有更大的困难。 下一个示例使用一个函数对象代替lambda，和 for_each 函数一起使用，以产生与例1相同的结果。 这两个例子都存储了在 vector 对象中偶数的个数。 为了维持计算的状态，FunctorClass 类存储了作为成员变量的 m_evenCount 变量。 为了执行此操作，FunctorClass 实现了函数调用操作符 operator()。 Visual C++ 编译器生成的代码与示例 1中的 lambda 代码的大小和性能的代码做比较。 对于像本文中的一个基本问题，更简单的 lambda 模型优于函数对象。 但是，如果您认为该功能在将来可能需要大量展开，那么使用函数对象模型，以便代码维护的简易性。

// even_functor.cpp
// compile with: /EHsc
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class FunctorClass
{
public:
    // The required constructor for this example.
    explicit FunctorClass(int& evenCount) 
        : m_evenCount(evenCount)
    {
    }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const
    {
        cout << n;

        if (n % 2 == 0) {
            cout << " is even " << endl;
            ++m_evenCount;
        } else {
            cout << " is odd " << endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    FunctorClass& operator=(const FunctorClass&);

    int& m_evenCount; // the number of even variables in the vector.
};


int main() 
{
    // Create a vector object that contains 10 elements.
    vector<int> v;
    for (int i = 0; i < 10; ++i) {
        v.push_back(i);
    }

    // Count the number of even numbers in the vector by 
    // using the for_each function and a function object.
    int evenCount = 0;
    for_each(v.begin(), v.end(), FunctorClass(evenCount));

    // Print the count of even numbers to the console.
    cout << "There are " << evenCount 
        << " even numbers in the vector." << endl;
}

//
Lambda 表达式语法

本主题介绍 lambda 表达式的语法。 它提供了一个示例，其中演示了 lambda 表达式的结构化元素以及这些元素如何与该示例相关。
下面的程序将在两个 STL 算法中使用 lambda 表达式： generate_n 和 for_each。 出现在 generate_n 函数调用中的 lambda 表达式将 vector 对象中的一个元素赋值为其前两个元素的和。 出现在对 for_each 函数的调用中的 lambda 表达式将相同的 vector 对象的元素打印到控制台。
// lambda_structure.cpp
// compile with: /EHsc
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

// The number of elements in the vector.
const int elementCount = 9;

int main() 
{
	// Create a vector object with each element set to 1.
	vector<int> v(elementCount, 1);

	// These variables hold the previous two elements of the vector.
	int x = 1;
	int y = 1;

	// Assign each element in the vector to the sum of the 
	// previous two elements.
	generate_n(v.begin() + 2, elementCount - 2, [=]() mutable throw() -> int {

		// Generate current value.
		int n = x + y;

		// Update previous two values.
		x = y;
		y = n;

		return n;
	});

	// Print the contents of the vector.
	for_each(v.begin(), v.end(), [](int n) { cout << n << " "; });
	cout << endl;

	// Print the local variables x and y.
	// The values of x and y hold their initial values because 
	// they are captured by value.
	cout << x << " " << y << endl;
}
//generate_n用法，第一个参数是起始迭代器，第二个参数是待生成元素个数，第三个是生成函数（对象）
template <class OutputIterator, class Size, class Generator>
void generate_n(OutputIterator first, Size n, Generator gen)
{
  for (; n>0; --n)  *first++ = gen();
}

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int GetNumber()
{
	return 0;
}

int main()
{
	vector<int> intVec(10);
	//generate_n(intVec.begin(), 10, GetNumber);
	generate_n(intVec.begin(), 10, [] () {return 1;});
	for_each(intVec.begin(), intVec.end(), [] (int i) {cout << i << " ";});
}

#include <iostream>
#include <functional>
using namespace std;

int main()
{
	// Assign the lambda expression that adds two numbers to an auto variable.
	auto f1 = [] (int x, int y) { return x + y; }; 

	// Assign the same lambda expression to a function object.
	function<int (int, int)> f2 = [] (int x, int y) { return x + y; };

	cout << f1(3, 4) << endl;
	cout << f2(3, 4) << endl;
}

// declaring_lambda_expressions2.cpp
// compile with: /EHsc
#include <iostream>
#include <functional>

int main()
{
	using namespace std;

	int i = 3;
	int j = 5;

	// The following lambda expression captures i by value and
	// j by reference.
	function<int (void)> f = [i, &j] { return i + j; };//[]里是在该时间点捕获值，此时i值是3，则函数实体中i就是3，j是引用捕获，所以外层j的改变，会影响里面的j值

	// Change the values of i and j.
	i = 22;
	j = 44;

	// Call f and print its result.
	cout << f() << endl;//47
}

// calling_lambda_expressions2.cpp
// compile with: /EHsc
#include <list>
#include <algorithm>
#include <iostream>

int main()
{
   using namespace std;

   // Create a list of integers with a few initial elements.
   list<int> numbers;
   numbers.push_back(13);
   numbers.push_back(17);
   numbers.push_back(42);
   numbers.push_back(46);
   numbers.push_back(99);

   // Use the find_if function and a lambda expression to find the 
   // first even number in the list.
   const list<int>::const_iterator result =
      find_if(numbers.begin(), numbers.end(),
         [](int n) { return (n % 2) == 0; });//迭代器中的值作为lambda函数的入参

   // Print the result.
   if (result != numbers.end())
   {
       cout << "The first even number in the list is " 
            << (*result) 
            << "." 
            << endl;
   }
   else
   {
       cout << "The list contains no even numbers." 
            << endl;
   }
}

//可以将 lambda 表达式用于类方法的主体中。 lambda 表达式可以访问该封闭方法可以访问的任何方法或数据成员。 您可以显式或隐式捕获 this 指针，以提供对封闭类的方法和数据成员的访问路径。
// method_lambda_expression.cpp
// compile with: /EHsc
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class Scale
{
public:
	// The constructor.
	explicit Scale(int scale)
		: _scale(scale)
	{
	}

	// Prints the product of each element in a vector object 
	// and the scale value to the console.
	void ApplyScale(const vector<int>& v) const
	{
		for_each(v.begin(), v.end(), 
			[this](int n) { cout << n * _scale << endl; });//[=],[&],[this]皆可；[&this]会提示编译错误：“this”始终按值捕获: 已忽略“&”
	}

private:
	int _scale;
};

int main()
{
	vector<int> values;
	values.push_back(3);
	values.push_back(6);
	values.push_back(9);

	// Create a Scale object that scales elements by 3 and apply
	// it to the vector object.
	Scale s(3);
	s.ApplyScale(values);
}

// template_lambda_expression.cpp
// compile with: /EHsc
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

// Negates each element in the vector object.
template <typename T> 
void negate_all(vector<T>& v)
{
    for_each(v.begin(), v.end(), [] (T& n) { n = -n; } );
}

// Prints to the console each element in the vector object.
template <typename T> 
void print_all(const vector<T>& v)
{
   for_each(v.begin(), v.end(), [] (const T& n) { cout << n << endl; } );
}

int main()
{
   // Create a vector of integers with a few initial elements.
   vector<int> v;
   v.push_back(34);
   v.push_back(-43);
   v.push_back(56);

   // Negate each element in the vector.
   negate_all(v);

   // Print each element in the vector.
   print_all(v);
}

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> intVec(10);
	int x = 0;
	generate(intVec.begin(), intVec.end(), [=] () mutable {return x++;});//如果需要在lambda函数中改变捕获参数，则需要加可变标识mutable；如果不加mutable，则需要用[&]引用方式捕获x

	for_each(intVec.begin(), intVec.end(), [] (int i) {cout << i << " ";});
	cout << "\n" << x << endl;
	
	copy(intVec.begin(), intVec.end(), ostream_iterator<int>(cout, " "));//输出效果同上，但是却比上个lambda语句复杂，需要多加一个库#include <iterator>
	cout << "\n" << x << endl;
}
//------------------------------------------------------------------------------------------------
//C++ 编程规范101 第85条 使用正确的STL查找算法
选择查找方式应“恰到好处”――正确的查找方式应该使用STL：本条款适用于在一个范围内查找某个特定值，或者查找某个值的位置（如果它处在范围内的话）。查找无序范围，应使用find/find_if或者count/count_if。查找有序范围，应使用lower_bound、upper_bound、equal_range或者（在少数情况下）binary_search（尽管binary_search有一个通行的名字，但是选择它通常并不一定正确）。
对有序范围来说，应该用以下4个二分查找算法：lower_bound、upper_bound、equal_range和binary_search都是对数时间。binary_search虽然有个好名字，但是几乎无用，它只能返回一个bool值表示是否找到了匹配。通常应该使用lower_bound、upper_bound和equal_range，equal_range能够找到lower_bound和upper_bound两种算法的结果（但开销却小于两倍）。
lower_bound将返回一个迭代器，指向第一个匹配（如果存在），或者指向匹配应该处于的位置（如果不存在）；如果要寻找正确位置，在有序序列中插入新值，那么后一种情况将非常有用。upper_bound将返回一个迭代器，指向最后一个匹配的下一个元素（如果存在），这也是添加下一个等价元素的位置；如果要寻找正确位置，在有序序列中插入新值，同时又能保持等价元素插入时的顺序，那么此算法将非常有用。
对于有序范围，应该将
p = equal_range(first, last, value);
distance(p.first, p.second);
当作count(first, last, value);的更快版本使用。
如果所查找的是一个关联容器，那么应该使用同名的成员函数，不要使用非成员算法。成员函数版本的效率通常更高，比如count的成员函数版本的执行时间是对数级的（因此无需像count的非成员函数版本那样，先调用equal_range，再调用distance）。
//------------------------------------------------------------------------------------------------
//C++编程规范101 条款86 使用正确的STL排序算法
理解每个排序算法的作用，选择能够实现所需而开销最低的算法。
并不总是需要进行完全排序。按开销从低到高的大致顺序，应该如下选择标准排序算法：partition, stable_partition, nth_element, partial_sort（以及其变体partial_sort_copy）, sort和stable_sort。应使用能够完成实际所需功能的开销最低的算法，使用更强的算法将是一种浪费。
partition, stable_partition和nth_element算法是线性时间的。
nth_element, partial_sort, sort和stable_sort需要随机访问迭代器。如果只有双向迭代器（例如list<T>::iterator），就无法使用它们。如果需要这些算法，又没有随机访问迭代器，那么可以考虑使用索引容器惯用法：创建一个支持随机访问迭代器的迭代器（例如vector），用其中的迭代器指向原范围，然后对此迭代器容器使用更强的算法，同时使用谓词的析值版本（在进行通常的比较之前析值迭代器）。
只有需要保留相等元素的相对顺序不变时才使用算法的stable_...版本。请注意partial_sort和nth_element都不稳定（也就是说它们无法保留相等元素排序前的相对顺序不变），而且没有标准化的稳定版本。如果想用这些算法然而又需要稳定性的话，可能应该用stable_sort。
如果不是非用不可，应该不用任何排序算法：如果使用的是标准的关联容器（set/multiset或map/multimap）或者priority_queue适配器，而且只需要一种排列顺序，那么其中的元素将总是有序的。
例外情况
由于要做的工作少，通常partial_sort都比完全的sort要快，但是如果需要对范围中大多数（或者全部）元素进行排序，则它会比完全的sort慢。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第87条 使谓词成为纯函数
谓词就是返回是或否（返回值通常为bool类型）的函数对象。从数学的意义上说，如果函数的结果只取决于其参数，则该函数就是一个纯函数（这里“纯”的用法与纯虚函数毫无关系）。
有状态谓词看似有用，但是对于C++标准库及其算法，它们显然并无大用，而且这是有意为之的。具体而言，只有在以下情况下，才可使用有状态谓词：
1. 谓词不会被复制
2. 谓词是按文献所记载的确定顺序使用的
通过编写一个轻型谓词，使用引用计数来共享其深层状态，是可以解决第一个问题的。这还解决了谓词复制的问题，因为这样谓词可以被安全地复制而不会在其应用于对象时改变语义。但是，解决第二个问题是不可能的。
应该问题将谓词类型的operator()声明为const成员函数，这样如果试图改变谓词类型可能具有的数据成员时，编译器就发出错误信息，帮助避免这种错误。这当然不能防止所有的误用行为（例如，它就无法在访问全局数据时报错），但是这至少有助于编译器帮我们避免最常见的错误。
删除某个特定元素的正确之道，是迭代至此元素，然后调用erase。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第88条 算法和比较器的参数应多用函数对象少用函数
对象的适配性比函数好：应该向算法传递函数对象，而非函数。关系容器的比较器必须是函数对象（函数也可以吧？参见标准库map示例）。函数对象的适配性好，而且与直觉相反，它们产生的代码一般比函数要快。
请注意：这并不是在鼓励不成熟的优化（见第8条），而是反对不成熟的劣化（见第9条）。如果已经有了一个函数，那么就继续传递该函数的指针好了（除非必须用ptr_fun或mem_fun将其封装）。但是，如果在编写要用算法参数的一段代码，那么应该多添加一些程序化代码，将编写成一个函数对象。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第89条 正确编写函数对象
函数对象模仿的就是函数指针。与函数指针一样，一般函数对象应该通过值来传递。所有标准算法都是通过值来传递对象的，我们自己的算法也应该如此。例：
template<class InputIter, class Func>
Function for_each(InputIter first, InputIter last, Function f);
因此，函数对象必须复制成本低廉的、单态的（不会切片，避免虚拟函数，见第54条）。但是大型的和/或多态的对象也有用，而且使用起来也有问题：只需用Pimpl惯用法（见第43条）将对象的大小和丰富的内容隐藏起来，使封装类成为复制成本低廉的、仍然能访问丰富状态的单态类型即可。封装类应该能够：
1. 可适配：从unary_function或binary_function继承
2. 具有Pimpl：存储一个指向大型/丰富对象实现的指针（例如shared_ptr）。
3. 具有函数调用操作符：将这些调用传递给实现对象。
除了可能需要提供非默认的构造函数、赋值操作符和/或析构函数版本之外，封装类中所需要的应该也就是这些了。
函数对象应该可适配。标准的绑定器和适配器依赖于一些typedef，当函数对象从unary_function或binary_function继承时，这些typedef能够最方便地自动提供。应该用与operator()相同的参数类型和返回类型实例化unary_function或binary_function，只是对于非指针类型，需要去掉所有顶层的const和&。
要避免提供多个operator()函数，因为这样会加大可适配的困难程序。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第90条 避免使用类型分支，多使用多态
避免通过对象类型分支来定制行为。使用模板和虚函数，让类型自己（是不是调用它们的代码）来决定行为。
编写出易于扩展而又不用修改的代码，根据抽象来编写代码以使用多态性（另见第36条），然后在添加功能时再为那些抽象添加各种实现。模板和虚拟函数调用在使用抽象的代码和实现抽象的代码之间构成了一个依赖性的隔离带（见第64条）。
这种管理依赖性要以找到正确的抽象为前提。抽象之所以称为“抽象”，就是因为它们应该比“细节”（即抽象的可能实现）稳定得多。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第91条 依赖类型，而非其表示方式
不要企图给对象拍X光片（见第96条）：不要对对象在内存中的准确表示方式做任何假设。相反，应该让类型决定如何在内存中读写其对象。
只要适当地定义类型，然后用这些类型来读写数据，就可以不用考虑位、字和地址。C++内存模型可以确保程序高效执行，无需程序员求诸于操作数据的表示方式。所以不要那么做。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第92条 避免使用reinterpret_cast
不要尝试使用reinterpret_cast强制编译器将某个类型对象的内存表示重新解释成另一种类型的对象。这违反了维护类型安全性的原则，尤其可怕的是，reinterpret_cast甚至不能保证是否能够达到这一目的，也无法保证其他功能。
例外情况
如果需要在不相关的指针类型之间强制转换，应该通过void*进行转换，不要直接用reinterpret_cast。也就是说，不要这样编写：
T1* p1 = ...;
T2* p2 = reinterpret_cast<T2*>(p1);
而应该写成：
T1* p1 = ...;
void *pv = p1;
T2* p2 = static_cast<T2*>(pv);
//------------------------------------------------------------------------------------------------
//C++编程规范101 第93条 避免对指针使用static_cast
不要对动态对象的指针使用static_cast：安全的替代方法有很多，包括使用dynamic_cast，重构，乃至重新设计。
应该考虑用功能更强的近亲操作符dynamic_cast代替static_cast，这样就不必操心static_cast什么时候安全，什么时候危险了。dynamic_cast效率稍微差一此，但它能检查非强制转换（不要忘了第8条的建议“不要进行不成熟的优化”）。
设计中应该消除向下强制：对代码进行重构或者重新设计，消除其必要性。
向下强制过多可能说明基类接口不太足。这会产生这样的设计：将过多功能定义在派生类中，而每次需要扩展类的接口时都要向下强制。比较好的一个解决方案是重新设计基类接口，提供更多的功能。
当且仅当dynamic_cast的开销确实成问题时（见第8条），才应该考虑自定义强制转换，在调试时使用dynamic_cast，而在“全程无保证”模式下使用static_cast。
template<class To, class From>
To checked_cast(From* from)
{
	assert(dynamic_cast<To>(from) == static_cast<To>(from) && "checked_cast failed");
	return static_cast<To>(from);//这里没有问题吗？从指针对象转换成普通对象
}

template<class To, class From>
To checked_cast(From& from)
{
	typedef tr1::remove_reference<To>::type* ToPtr;//利用leverage[C++TR104]
	assert(dynamic_cast<ToPtr>(&from) == static_cast<ToPtr>(&from) && "checked_cast failed");
	return static_cast<To>(from);
}
这一对函数（分别为指针和引用所需的）只是测评两个强制转换是否一致。根据自己的需要定制checked_cast，或者用某个库提供的函数实现。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第94条 避免强制转换const
强制转换const有时会导致未定义的行为，即使合法，也是不良编程风格的主要表现。
选择const之后，就（应该）永不回头。如果对象的最初定义为const，强制转换掉它的常量性，将使所有保护失效，程序完全处于未定义行为状态。例如，编译器可能会（而且确实会）将常量数据放在只读存储器（ROM）中或者写保护的随机访问存储（RAM）页中。对这种物理上的const对象，如果强制转换掉其常量性将是一种应该惩罚的不良操作，而且也经常会表面为内存故障。
即使这种转换不会导致程序崩溃，也破坏了承诺，不会如我们所预期的那样表现。例如，以下代码并不能分配一个可变大小的数组：
void foolish(unsigned int n)
{
	const unsigned int size = 1;
	const_cast<unsigned int&>(size) = n;//糟糕：别这么做
	char buffer[size];//大小将总是1
}
C++有一个隐式的const_cast，可以将字符串常量“起死回生”为char*：
char* weird = "trick or treat?";
编译器将不加提示地执行const_cast，将const char[16]强制转换为char*。之所以允许如此，是为了保持与C语言的API的兼容性，但这是C++类型系统的一个漏洞。字符串常量可以存放在ROM中，因此试图修改字符串很容易导致内存故障。
例如情况
在调用常量不正确的API（见第15条）时，强制转换掉const可能是必需的。如果一个函数必须接收和返回相同类型的引用，且该函数有const和非const的重载版本，而其中一个是通过调用另一个来实现的，那么也需要强制转换掉const：
const Object& f(const Object&);
Object& f(Object& obj)
{
	const Object& ref = obj;
	return const_cast<Object&>(f(ref));//必须强制转换掉返回类型的const
}
//------------------------------------------------------------------------------------------------
//C++编程规范101 第95条 不要使用C风格的强制转换
如果忘记了包含定义，那么即使代码能够没有报错地通过编译，也将莫名其妙地崩溃。避免这一问题可以这样编程：
extern void fun(Derived*);
void Gun(Base* pb)
{
	//如果我们明确知道pb实际指向的是Derived，那么可以用如下代码：
	Derived* pb = static_cast<Derived*>(pb);//很好：C++风格强制转换
	//或者用：= dynamic_cast<Derived*>(pb);//很好：C++风格强制转换
	fun(pb);
}
现在，如果编译器没有足够的、有关Base和Derived之间关系 的静态信息，那么它将报告一个错误，而不会自动执行按位（可能非常致命的）reinterpret_cast（见第92条）。
C++风格的强制转换可以很容易地使用grep这样的自动化工具进行查找。（但是没有什么grep正则表达式能够找到C风格强制转换的语法。）因为强制转换非常危险（尤其是针对指针的static_cast，以及reinterpret_cast：见第92条），所以使用自动化工具来掌握其情况总是不错的办法。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第96条 不要对非POD（见第91条注释）进行memcpy操作或者memcmp操作
不要用memcpy或memcmp来复制或比较任何对象，除非有什么对象的而已就是原始内存。
C++对象的要点就在于信息隐藏（这无疑是软件工程中最具有效果的原则：见第11条）：对象隐藏了数据（见第41条），并且通过构造函数和赋值操作符（见第52条至55条）设计了用于复制数据的精确抽象。使用memcpy严重违反信息隐藏的原则，而且经常会导致内存泄漏和资源泄漏、程序崩溃或者未定义的行为。
滥用memcpy可能会影响到对象类型和标识这样的基本方面。编译器经常会在多态对象中，嵌入一些隐藏数据（所谓的虚拟函数表指针，即vptr），为对象提供运行时标识。在多重继承情况下，对象中在不同偏移位置会有多个这种vptr共存，而使用虚拟继承时，大部分编译器实现都会添加更多内部指针。一般使用中，由编译器负责管理所有这些隐藏数据，而memcpy将只会为此带来灾难。
类似的，memcmp也不适合于比较任何比位更复杂的东西。有时，它的功能不够（如比较C风格的字符串与比较实现string的指针是不同的）。有时候它又做得过多（如，memcmp会毫无必要地比较并不属于对象状态的字节，包括编译器为了对齐而插入的填充字节）。无论哪种情况，结果都是错的。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第97条 不要使用联合重新解释表示方式
通过在union中定稿一个成员而读取另一个滥用方式可以获得“无需强制转换的强制转换”。这比起reinterpret_cast（见第92条）更阴险，也更难预测。
除最后写入的字段之外不要读取union中的其他字段。读取这样的字段会导致未定义的行为。错误使用union时，对内存表示的任何重新解释都不会产生编译时错误或者可靠的结果。
考虑如下代码，它目的是保存某类型（char*）的值，并以另一种类型（long）提取其内存表示：
union
{
	long intValue_;
	char* pointerValue_;
}
pointerValue_ = somePointer;
long int gotcha = intValue_;
这一代码有两个问题：
1. 假设太多：它假设sizeof(long)和sizeof(char*)相等，而且其内存表示完全一样。这种假设无法对所有编译器实现都成立（见第91条）。
2. 混淆了编写者的意图，对代码阅读者和编译器皆然：这样使用union，给编译器发现真正的类型错误增加了难度，给代码阅读者发现逻辑错误也增加了难度。

例外情况
如果两个POD struct是一个union的成员，而且均以相同的字段类型开始，那么对这种匹配的字段来说，写入其中一个而读取另一个是合法的。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第98条 不要使用可变长参数(...)
省略会导致崩溃：省略号（...）是来自C语言的危险遗产。要避免使用可变长参数，应改用高级的C++结构和库。
函数的参数数量可变具有很多优点，但是C语言风格的可变长参数却不是获得这种功能的好办法。可变长参数有很多严重的缺点：
1. 缺乏类型安全性：省略号本质上是告知编译器：“关闭所有检查。从此由我接管，启动reinterpret_cast”（见第92条）。
2. 调用者与被调用者之间存在紧密耦合，而且需要手动协调
3. 类类型对象的行为未定义
4. 参数的数量未知
有些类型安全的程序库通过其他方法支持可变长参数的功能，应该使用这些库。例如，boost的format库就使用了C++高级特性将类型安全与速度和使用方便很好地结合在了一起。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第99条 不要使用失效对象。不要使用不安全函数
失效对象主要有三种：
1. 已销毁对象
2. 语义失效对象
3. 从来都有效的对象
应该了解对象的生存期和有效性。决不要对失效的迭代器或指针进行析值操作（*）。不要假设delete会做什么，不会做什么。释放了的内存已经释放，此后任何情况下都不应再访问它。不要尝试通过手动调用析构函数（例如obj.~T()），然后再调用placement new，拿对象的生存期玩火（见第55条）。
不要使用不安全的C语言遗留函数：strcpy、strncpy、sprintf或其他要对不检查范围的缓冲区进行写入操作、不检查和不能正确处理越界错误的函数。C语言的strcpy不检查缓冲区的界限，strncpy虽然检查缓冲区界限，但是到达缓冲区界限时却不添加null，使用这两个函数迟早会使程序出现崩溃，它们都是安全隐患。请使用更现代、更安全也更灵活的结构和函数，比如C++标准库中的设施（见第77条）。虽然它们也并不问题百分之百安全（出于效率考虑），但是它们的出错概率小得多，能够更好地编写安全的代码。
//------------------------------------------------------------------------------------------------
//C++编程规范101 第100条 不要多态在处理数组
数组的可调整性很差：多态地处理数组是绝对的类型错误，而且编译器有可能不会做出任何提示。不要掉入这一陷阱。
指针可同时满足两种目的：一种是作为别名（对象的小标识符），一种是作为数组迭代器（可以用指针运算遍历对象数组）。用作别名时，将指向Derived的指针当作指向Base的指针处理是极有意义的。但是，如果用于数组迭代功能，这种替换就会出问题，因为Derived类型的数组与Base类型的数组是不同的。
这种错误是可替换性（规定指向派生类的指针可用作指向其基类的指针）和C语言遗留的指针运算（认为指针是的单态的，只使用静态信息计算跨距）之间糟糕的交互作用引起的。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款1 流
1. std::cin和std::cout的类型是什么？
简短回答，cin实际上是：
std::basic_istream<char, std::char_traits<char> >
cout实际上是：
std::basic_ostream<char, std::char_traits<char> >
下面是较详细的回答，它通过一些标准的typedef和模板向你展示答案的来龙去脉。首先，cin和cout具有的类型分别是std::istream和std::ostream。接着，这些类型是std::basic_istream<char>和std::basic_ostream<char>的typedef。最后，考虑到模板参数的默认值，到得上面的答案。
#include <iostream>
#include <string>

using namespace std;

int main(int argc, char* argv[])
{
	cout << "the bigger is " << (argv[1] > argv[2] ? argv[1] : argv[2]) << endl;
}
调用如下：LearningTest 1 2

#include <iostream>
#include <fstream>

using namespace std;

int main(int argc, char* argv[])
{
	//(argc > 2 ? ofstream(argv[2], ios::out | ios::binary) : cout) 
		//<< 
		//(argc > 1 ? ifstream(argv[1], ios::in	| ios::binary) : cin).rdbuf();
	//cout << cin.rdbuf();
	ofstream(argv[2], ios::out|ios::binary) << ifstream(argv[1], ios::in|ios::binary).rdbuf();
}
这个方案可行得益于两个相辅相成的条件：第一，basic_ios提供了一个方便的rdbuf()成员函数，这返回某个流对象所使用的streambuf，在本例中，这个流对象也就是cin或临时ifstream对象，二者都派生于basic_ios。第二，basic_ostream提供了一个operator<<()，它正好接受这样的basic_streambuf对象，将其作为输入，然后完全读取输入。
上例方案有两个主要缺点：首先，精简会带来晦涩，而且过度的精简不适合应用到产品代码中。
设计准则：尽量提高可读性。避免撰写精简代码（即，简洁但难以 理解和维护）。避免晦涩。

#include <iostream>
#include <fstream>

using namespace std;

int main(int argc, char* argv[])
{
	fstream ifs, ofs;//这里必须先声明，再在下面open，而不能在声明时直接open：如果想在声明时就打开文件，则不需要使用open成员函数，直接变量后接()就可直接打开；如果想要声明和打开分开，则必须用open()成员函数，即下面如果不用open成员函数则无法打开文件。在这里，由于不确定是否会传入文件名，所以这里必须将声明和打开分开写。将声明和打开操作分开还有一个好处是可以用is_open()判断是否成功打开，而在声明时直接打开文件，则不能很好的进行这种判断。
	if (argc > 1)
	{
		ifs.open(argv[1], ios::in | ios::binary);
	}
	if (argc > 2)
	{
		ofs.open(argv[2], ios::out | ios::binary);
	}
	process(ifs.is_open() ? ifs : cin, ofs.is_open() ? ofs : cout);
	ifs.close();
	ofs.close();
}
在C++中，主要有四种方法获得多态行为：虚函数、模板、重载和转换。其中，前两种方法可以用在这里，用以表达我们所需要那种多态。
方法A：模板（编译时多态）
第一种方法使用的是编译时多态，这需要借助于模板；它只需要被传递的对象有一个合适的接口（例如一个名为rdbuf()的成员函数）：
template<typename In, typename Out>
void process(In& inStream, Out& outStream)
{
	outStream << inStream.rdbuf();//执行某种更复杂的操作，或只是简单的“out << in.rdfuf();”
}
方法B：虚函数（运行时多态）
第二种方法使用的是运行时多态，它需要一个条件，即，存在一个具有合适接口的公共基类：
//第一次尝试，一定程序上可行
void process(basic_istream<char>& inStream, basic_ostream<char>& outStream)
{
	outStream << inStream.rdbuf();
}
注意，在上例中，参数类型不是basic_ios<char>&，因为那将不允许使用operator<<()。
上例中的方法具有依赖性，它要求输入和输出流必须分别从basic_istream<char>和basic_ostream<char>派生。这一点对我们的例子还不错，但并非所有的流都基于简单的char或者char_traits<char>。例如，宽字符流基于wchar_t，Exceptional C++的条款2和3也演示了一些具有不同行为特征的用户自定义traits（在那些例子中，ci_char_traits提供了大小写不分的行为特征），并展示了其潜在的用途。
因而，即使是采用方法B，我们也应该使用模板，让编译器去推导出合适的参数：
//更好的方案
template<typename T1,  typename T2>
void process(basic_istream<T1, T2>& inStream, basic_ostream<T1, T2>& outStream)
{
	outStream << inStream.rdbuf();
}
有效的工程设计原则
就其本身而言，以上所有答案都是“正确”的：但在目前场合下，作者个人倾向于选择方法A，其原因归结于两条很有价值的设计准则，第一条是：
设计准则：尽量提高可扩充性。
均衡的判断力是有经验的程序员所具有的一个特征。尤其是，在“编写专用代码，只解决当前问题”（短视，难以扩充）和“编写一个宏大的通用框架去解决本来应该很简单的问题”（追求过渡设计）之间，有经验的程序员懂得如何去获取最佳的平衡。
方法A整体复杂度与第一例基本相同，更易于理解、更具有可扩充性。与方法B 相比，既简单又更具灵活性：更能适应新的要求，因为它没有了束缚，不只是能和iostream体系打交道。
所以，如果存在两个选择，它们在设计和实现中需要的工作量相同，而且具有大致相当的清晰度和可维护性，那么，请尽量考虑可扩充性。这条建议是一条鼓励：如果稍微思考一下就可以发现，自己正在解决的问题实际上是某个更通用的问题的特例，你就应该多做一些工作，而不要仅仅满足于解决当前问题。这条建议十分正确，因为，在设计中提高了可扩充性，往往意味着同时提高了封装性。
设计准则：尽量提高封装性，将关系分离。
只要有可能，一段代码――函数或类――应该只知道并且只负责一件事。
方法A最出色的地方在于：它展示了关系之间最好的分离。它包括两部分代码，一部分代码知道输入/输出源（source）和目标（sink）中可能的区别，另一部分代码知道如何真正执行处理，这两部分代码被分离开来。这种分离也使得代码的用途更清晰，更易于他人阅读和理解。将关系进行分离是好的工程设计的另一个特征。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款2 Predicates、之一：remove()删除了什么？
remove()为什么要以这样的方式工作，其根本原因在于：remove()不是作用于容器身上，而在作用在迭代器区间（range）上，“从任何一种容器中删除迭代器所指元素”这样的代码器操作是不存在的。要想这样做，我们必须真正、直接地得到容器。

书上的第一个例子没有考虑first和last的距离，并且用for循环来递减迭代器first。
（1）正确的前提：要保证n<=distance(first, last)
（2）效率：假设我们想确保（并检查）“n对给定的区间有效”这一前提，将其作为解决第一个问题的方法。我们还是应该完全放弃那个迭代器递增循环，而只需简单地写一句advance(first, n)（这里应该有问题吧，n-1 ）。标准advance()算法是为迭代器设计的，可以分辨迭代器类型（iterator categories）：针对随机访问迭代器（random-access iterator），能自动进行优化。具体来说，对随机访问迭代器，只需要消耗常数级时间，对于其它迭代器，消耗线性级时间。
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cassert>
using namespace std;

struct myGenerate
{
	myGenerate(int i = 0): i_(i){}
	int operator()()
	{
		return ++i_;
	}
	int i_;
};

template<typename FwdIter>
FwdIter remove_nth(FwdIter first, FwdIter last, size_t n)
{
	assert(distance(first, last) >= n && n > 0 && "wrong input parameters");
	advance(first, n - 1);//在迭代区间内前进n-1
	if (first != last)
	{
		FwdIter dest = first;
		return copy(++first, last, dest);//将第n+1个迭代器对象之后的值移到第n个迭代器对象位置，并返回目标迭代区间的最后一个位置，这里即last-1的位置
	}
	return last;
}

template<typename Container>
void myPrint(Container& container)
{
	//typedef typename Container::value_type value_type;
	copy(container.begin(), container.end(), ostream_iterator<Container::value_type>(cout, " "));
	cout << endl;
}

int main(int argc, char* argv[])
{
	vector<int> intVec(10);
	generate(intVec.begin(), intVec.end(), myGenerate());
	myPrint(intVec);
	intVec.erase(remove_nth(intVec.begin(), intVec.end(), 8), intVec.end());//将第intVec.end()-1到intVec.end()区间内删除
	//intVec.erase(remove_nth(intVec.begin(), intVec.end() - 3, 5), intVec.end());//将第5个迭代对象移到第8个位置，并将第8个位置到end()删除，即结果：1 2 3 4 6 7
	myPrint(intVec);
}

而采用有状态的函数对象实现的remove_if方法
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cassert>
using namespace std;

struct myGenerate
{
	myGenerate(int i = 0): i_(i){}
	int operator()()
	{
		return ++i_;
	}
	int i_;
};

template<typename Container>
void myPrint(Container& container)
{
	//typedef typename Container::value_type value_type;
	copy(container.begin(), container.end(), ostream_iterator<Container::value_type>(cout, " "));
	cout << endl;
}

class FlagNth
{
public:
	FlagNth(size_t n): current_(0), n_(n) { }
	
	template<typename T>
	bool operator()(const T&)
	{
		return ++current_ == n_;
	}
private:
	size_t current_;
	const size_t n_;
};

int main(int argc, char* argv[])
{
	vector<int> intVec(10);
	generate(intVec.begin(), intVec.end(), myGenerate());
	myPrint(intVec);
	intVec.erase(remove_if(intVec.begin(), intVec.end(), FlagNth(3)), intVec.end());
	myPrint(intVec);
}
1 2 3 4 5 6 7 8 9 10
1 2 4 5 7 8 9 10
请按任意键继续. . .
可以看到3，6都被删除了，这也正是“C++编程规范101 第87条 使谓词成为纯函数”中所说的一般remove_if是通过find_if和remove_copy_if实现的，它会将谓词的一个副本传给这些函数，而在此之前可能它自己已经执行了某些会影响谓词状态的操作。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款3 Predicates、之二：状态带来的问题
predicate（谓词）是一个函数指针或一个函数对象（function object）（一个提供了函数调用运算符operator()的对象）：针对一个“关于对象的提问”，它作出“是”或“否”的回答。许多算法使用predicate，用以对它们所操作的每个元素进行某种判断。
pred应当返回一个值，而且这个值可以用true来作检测。注意，predicate只能通过“被解引用（dereferenced）的迭代器”来使用const函数。（这里的解引用是指在算法里会对函数指针或者函数对象进行解引用，而不是由用户显式的调用）
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>
using namespace std;

struct myGenerate
{
	myGenerate(int i = 0): i_(i){}
	int operator()()
	{
		return ++i_;
	}
	int i_;
};

class IsEven: public unary_function<int, bool>
{
public:
	bool operator()(int number) const//这里如果不加const，则无法使用适配器not1
	{
		return number % 2 == 0;
	}
};

template<typename Container>
void myPrint(Container& container)
{
	copy(container.begin(), container.end(), ostream_iterator<Container::value_type>(cout, " "));
	cout << endl;
}

int main(int argc, char* argv[])
{
	vector<int> intVec(10);
	generate(intVec.begin(), intVec.end(), myGenerate());
	myPrint(intVec);
	intVec.erase(remove_if(intVec.begin(), intVec.end(), not1(IsEven())), intVec.end());
	myPrint(intVec);
/* 	vector<int>::iterator iter(intVec.begin());//这里编译不过
	if (IsEven(*iter))
	{
		cout << "is even" << endl;
	} */
}
使用可以储值的predicate，可以获得可用性上的某些好处。

为了让状态性predicate正常工作，对算法有哪些必要求？
要让状态性predicate对算法真正有用，在如何使用predicate方面，算法一般得保证两点：
（a）算法绝对不能对predicate做复制（即，自始至终只能使用同一给定对象）。
（b）算法必须“以某个已知的顺序”将predicate作用到区间里的元素上。（通常是，从第1个元素到最后一个元素）
可惜的是，C++标准没有要求标准算法提供以上两个保证。虽然状态性predicate已经出现在一些书中，但是，在书和标准的决斗中，胜利者最终会是标准。对于标准算法，C++标准确实有很多其它规定，如性能复杂度、predicate被使用的次数等等，但对于所有算法，它恰恰没有规定上面（a）中的要求。
为了解决问题（a）中的predicate拷贝问题，有人写了运用引用计数技术的predicate。是的，你可以共享predicate状态，这样，在predicate被使用时，它就可以被安全的复制，而且其语义不会发生变化。P27
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "boost/shared_ptr.hpp"
using namespace std;

struct myGenerate
{
	myGenerate(int i = 0): i_(i){}
	int operator()()
	{
		return ++i_;
	}
	int i_;
};

template<typename Container>
void myPrint(Container& container)
{
	//typedef typename Container::value_type value_type;
	copy(container.begin(), container.end(), ostream_iterator<Container::value_type>(cout, " "));
	cout << endl;
}

class FlagNthImpl
{
	friend class FlagNth;
public:
	FlagNthImpl(size_t n):i_(0), n_(n) { }
private:
	size_t i_;
	const size_t n_;
};

class FlagNth
{
public:
	FlagNth(size_t n):pImpl_(new FlagNthImpl(n)) { }

	template<typename T>
	bool operator()(const T&)
	{
		return ++(pImpl_->i_) == pImpl_->n_;
	}
private:
	boost::shared_ptr<FlagNthImpl> pImpl_;
};

int main(int argc, char* argv[])
{
	vector<int> intVec(10);
	generate(intVec.begin(), intVec.end(), myGenerate());
	myPrint(intVec);
	intVec.erase(remove_if(intVec.begin(), intVec.end(), FlagNth(3)), intVec.end());
	myPrint(intVec);
}
输出如下：
1 2 3 4 5 6 7 8 9 10
1 2 4 5 6 7 8 9 10
请按任意键继续. . .
但这没有、也不可能解决前面问题（b）中的次序问题，也就是说，作为程序员，你必须完全依赖于算法使用predicate的次序。无法逃避这一点，即使运用高级的指针技术也无能为力，除非算法本身保证遍历的次序。
//------------------------------------------------------------------------------------------------
//条款4：可扩充的模板：使用继承还是traits？
一个traits类（特征类）是：一个封装了一组类型（types）与函数（functions）的类，以使模板类与模板函数可以操纵实例化类型的对象。（译注：“实例化类型”即模板实例化时使用的类型。为了中文表述上的方便，故简称之。）
特别概念是：traits类是模板实例，用于携带traits模板被实例化时类型的额外信息――特别是，可以被其它模板使用的信息。它所带来的好处是：在对某个类C不做任何修改的情况下，T<C>这个traits类能让我们记录C的（以上所说的那种）额外信息。

严格限定template类C中的类型对象T提供一个clone()函数，原型为T* T::clone() const。有以下做法：
template<typename T>
class C
{
public:
	//放在C的析构函数中（比放在每一个构造函数中要简单）：
	~C()
	{
		T* (T::*test) () const = &T::clone();//使用类成员函数指针！
		test;//禁止掉未使用的变量所造成的警告，这种未使用的变量可能会被编译器的优化程序完全消除掉
	}
};
或者，使代码更清晰并更具扩充性一点：
template<typename T>
class C
{
	bool validateRequirements() const
	{
		T* (T::*test) () const = &T::clone();//使用类成员函数指针！
		test;//禁止掉未使用的变量所造成的警告，这种未使用的变量可能会被编译器的优化程序完全消除掉
		//...
		return true;
	}
public:
	~C()
	{
		assert(validateRequirements());
	}
};
有了函数validateRequirements()，代码更具可扩充性，因为它为我们提供了一个非常干净的地方，便于将来增加任何“需求检查”功能。函数调用是在assert()中进行的，这进一步保证：针对“需求检查”的所有跟踪代码不会出现在发行版本中。

约束类（Constraints Classes）（参见“C++ FAQs 百度文库 P25 限制模板的参数”Can_Copy()类的实现）
约束类HasClone：
//HasClone要求T必须提供T* T::clone() const
template<typename T>
class HasClone
{
public:
	static void constraints()
	{
		T* (T::*test)() const = &T::clone;
		test;
	}
	HasClone()
	{
		void (*p)() = constraints;
	}
};
于是，我们有了一个非常“优雅”――我敢说“酷”吗？――的方法，以在编译时期实施约束：
template<typename T>
class C: HasClone<T>//私有继承
{
	//...
};
这个方案的设计思想很简单：每个C的构造函数必然调用HasClone<T>的缺省构造函数，此构造函数什么也没做，仅做约束检查。如果约束检查失败，大多数编译器会产生一条可读性极强的出错信息。HasClone<T>的派生关系就相当于一条断言（assertion），它以一种易于诊断的方式检查出T的某一特性。

对继承的需求，方式1：IsDerivedFrom1值辅助类（Value Helper）
某程序员想写一个模板，此模板可以要求（或者可以检测出）：它在实例化时所使用的类型具有 一个clone()成员函数。这个程序员采用的方案基于这样一个要求：
提供clone()的类必须派生于某个已有的Cloneable基类，演示如何写出下面模板：
template<typename T>
class X
{
	//...
};
a)此模板要求T派生于Cloneable。
两种方案，都可行。第一种需要一点技巧，稍微复杂一些；第二种简单精巧。两种方案都值得探讨，二者都展示了一些有趣设计技术。
第一种定义一个辅助模板，用来测试候选类型D是否派生于B。测试的方法是，检查一个指向D的指针能否被转换为一个指向B的指针。优点：可用于编译时期对值的检查；缺点：太复杂
//编译不过，没找到问题所在？
#include <iostream>
#include <cassert>
using namespace std;

class Cloneable { };

class Test1: public Cloneable { };

class Test2 { };

template<typename D, typename B>
class IsDerivedFrom1
{
public:
	enum {Is = (sizeof(test(static_cast<D*>(0))) == sizeof(Yes))};//对test函数调用，通过对“空指针进行合适的类型转换”来实现这一点。所做的一切是创建了一个类型化的表达式（typed expression）。现在，编译器知道D为何物，在编译期间重载解析时，编译器会根据D的类型来决定该选择test()的哪一个重载函数：如果D*可以被转换为B*，就选择test(B*)――返回值为Yes的那一个；否则，选择test(...)――返回值为No的那个。
private:
	class No { };
	class Yes
	{
		No no[2];
	};
	static Yes test(B*);//这是函数声明，未定义
	static No test(...);//函数声明，未定义
};

//使用IsDerivedFrom1辅助类，实施“从Cloneable派生”的约束
template<typename T1>
class X
{
public:
	~X()
	{
		assert(validateRequirements());
	}
private:
	bool validateRequirements() const
	{
		//需要一个typedef，否则，对assert来说，“,”会被解释为宏（macro）的参数分隔符
		typedef IsDerivedFrom1<T1, Cloneable> Y;
		
		//运行时检查，但不需要多少工作量就可以很容易地将其转化为编译时检查
		assert(Y::Is);
		return true;
	}
};

int main(int argc, char* argv[])
{
	X<Test1> x1;
}
上面花招倚仗以下三点：
（1）Yes和No的大小（size）不同。为保证这一点，让Yes包含一个数组，此数组保存的是No对象，且No的对象的数目大于1。
（2）重载函数的解析和sizeof值的确定是在编译时期完成的，而非运行时期。
（3）Enum的值在编译时期得出，并可以在编译时期使用。

对继承的需求，方式2：
IsDerivedFrom2约束基类（Constraints Base Class）
IsDerivedFrom2约束基类，优点：编译时期求值，易于直接使用；缺点不能直接应用于编译时期值的测试
template<typename D, typename B>
class IsDerivedFrom2
{
protected:
	IsDerivedFrom2()
	{
		void (*p)(D*) = constraints;
	}
private:
	static void constraints(D* p)
	{
		B* pb = p;
		pb = p//禁止掉未使用的变量所造成的警告
	}
};

//B为void的情况下，强制失败（类模板有偏特化，函数模板没有偏特化；B是一个类型，为什么会是void？）
template<typename D>
class IsDerivedFrom2<D, void>
{
	IsDerivedFrom2()
	{
		char* p = static_cast<int*>(0)//char* p = (int*)0;//错误
	}
};
现在，检测更简单了：
template<typename T>
class X: IsDerivedFrom2<T, Cloneable>
{
	//...
};

对继承的需求，方式3：
结合以上两种方案的IsDerivedFrom
IsDerivedFrom1主要优点在于：提借了一个enum值，这个值在编译时期产生，还可以在编译时期检测。对这里的类X示例来说，这一点不重要；但在下节中，这一点很重要，因为我们需要通过切换这样一个值来在编译时期选择不同的traits实现。另一方面，IsDerivedFrom2使用上有很大方便性。
将两种方案结合起来
//IsDerivedFrom约束基类，并具有测试值
template<typename D, typename B>
class IsDerivedFrom
{
public:
	enum {Is = (sizeof(test(static_cast<D*>(0))) == sizeof(Yes))};
	IsDerivedFrom()
	{
		void (*p)(D*) == constraints;
	}
private:
	class No { };
	class Yes {No no[2];};
	
	static Yes test(B*);
	static No test(...);
};

选择不同的实现
b)如果T派生于Cloneable，此模板提供一个可供选择的实现；否则，此模板工作于某种缺省模式
X将使用上例中的IsDerivedFrom，并使用这个辅助模板的部分特殊化（partial specialization）来完成在“Cloneable”实现和“非Cloneable”实现间的切换。（注意，这要求IsDerivedFrom1具有“在编译时期”可以检测的值，这个值也应该并入到IsDerivedFrom中，这样我们才有可供检测的东西，从而做到在不同的实现间切换。）
template<typename T, int>
class XImpl
{
	//一般情况：T没有从Cloneable派生
};

template<typename T>
class XImpl<T, 1>
{
	//T从Cloneable派生
};

template<typename T>
class X
{
	XImpl<T, IsDerivedFrom<T, Cloneable>::Is> impl_;
	//...委托给impl_;
};
T从Cloneable派生，则IsDerivedFrom<T, Cloneable>::Is为1，那么impl_类型为XImpl<T, 1>；否则impl_类型为XImpl<T, 0>，为非特殊化的XImpl。
干得很漂亮，一旦写完这些代码，一点都不难使用。从用户角度来看，复杂性被隐藏在X的内部。从X的设计者的角度来看，他只是直接复用（reuse）已经封装在IsDerivedFrom中的功能，而不必了解魔法如何动作。
这里只有XImpl<T, 0>和XImpl<T, 1>，虽然第二个参数理论可以取任何整数植，但我们作了处理，使得整数值只会是0或1。（用int而不用bool是为了扩充性：使用int没有坏处，相反，这样做的话，将来如果有需要，可以很容易地增加其它不同的实现――例如，假设我们以后又想对另一种继承层次结构提供支持，而这个继承层次结构具有一个和Cloneable相似但带有不同的接口的基类）

需求（Requirements）与Traits
4. 为了要求（检测）clone()存在，分析其它可能的方案。
问题3中方法很俏皮，但很多情况下更倾向于使用traits――它们往往很简单（有一种情况除外：对一个继承层次结构中的每个类，它们都必须进行特殊化的时候），而且如条款30和31所示，它们更具有可扩充性。
基本想法是创建一个traits模板，在当前情况下，此traits模板的唯一任务是实现clone()操作，这个traits模板看起来很XImpl，它有一个通用的非特殊化的版本，用来做一些通用的事情，还有可能有多个特殊化的版本，用来处理某些类， 这些类可能提供的是性能更好的clone操作，或者仅仅是不同方式的clone操作。
//使用traits而非IsDerivedFrom来使用，可能存在的Clone功能：若不存在，则做别的事情。需要为每个Cloneable类提供一个特殊化。
template<typename T>
class XTraits
{
public:
	//一般情况下，使用拷贝构造函数
	static T* clone(const T* p)
	{
		return new T(*p);
	}
};

template<>
class XTraits<MyCloneable>
{
public:
	//MyCloneable从Cloneable派生，所以使用clone()
	static MyCloneable* clone(const MyCloneable* p)
	{
		return p->clone();
	}
};

//...其它，针对Cloneable派生的每一个类
于是，X<T>会调用合适的的XTraits<T>::clone()，执行正确的操作。
Traits和上例中的那个普通的XImpl之间的区别主要是：有了traits，当用户定义了某个新类型的时候，如果想将这个新类型用于X，所要做的大部分工作都在X的外部――我们只用特殊化traits模板，为新类型“做正确的事”就可以了。这就比前面问题3有那个相对死板的方案更具有可扩充性，因为后者是在XImpl的实现中完成所有的选择工作，没有为了提高可扩充性而将其开放。Traits还请允许我使用其它clone方法，而不仅仅是特别命名为clone()的某个函数――而且这个函数还得从一个特别命名的基类继承而来，这也提供了另外的灵活性。

traits方案的主要缺点是：针对继承层次结构中的每一个类，它都需要单独的特殊化。有办法可以一次性为整个层次结构中的类提供traits，从而不必枯燥地写出大量的特殊化。请参见“Mappings Between Types and Values”，http://www.gotw.ca/publications/mxc++/aa_mappings.htm 。？

继承与Traits
对一个模板来说，就算知道它的一个模板参数从某个给定的基类继承，也不能让它获得“使用traits无法获得”的额外好处。使用traits仅有的一个真正缺点是：在一个庞大的继承体系中，为了处理大量的类，需要写大量的特殊化代码；不过，运用某些技术可以减轻或者消除这一缺点。

本条款的主要目的在于说明：与某些人的想法相反，“为了处理模板中的分类（categorization）而使用继承”不足以成为使用继承的理由。traits提供了更通用的机制：当用一个新类型――例如来自第三方程序库中的某个类型――来实例化一个现有模板的时候，此类型可能很难从某个预先确定的基类派生，此时，traits体现了更强的可扩充性。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款5：typename
template<typename T>
void f()
{
	T::A* pa;
}
T::A是一个有依赖性的名称（dependent name），因为它依赖于模板参数T。在此例中，程序员可能希望T::A是T中的嵌套类或typedef，因为如果是其它什么东西，例如静态成员变量或函数，则这段代码就无法通过编译，这里有一个问题，因为C++标准中有这样的叙述：
如果一个名称被使用模板声明或定义中并且依赖于模板参数，则这个名称不被认为是一个类型的名称，除非名称查找到了个合适的类型名称，或者这个名称用关键字typename修饰。

template<typename T>
class X_base
{
public:
	typedef T instantiated_type;
};

template<typename A, typename B>
class X: public X_base<B>
{
public:
	bool operator()(const instantiated_type& i) const
	{
		return i != instantiated_type();
	}
};
对有依赖性的名称使用typename
不幸的是，在编译器解析函数定义时，有依赖性的名称（即，依赖于模板参数的名称）是不可见的，所以编译器会发出抱怨，因为它不知道依赖性名称指的是什么。有依赖性的名称只会在后来可见，也就是模板被真正实例化的时候。
在上面未被特殊化的X_base模板中，X_base<T>::instantiated_type总会是T，但在特殊化的时候，我们无法阻止有人去改变它的含义，如：
template<>
class X_base<int>
{
public:
	typedef Y instantiated_type;
};
虽然这样做会导致typedef的名称有点让人误解，但它是合法的。或者，有人会这样做：
template<>
class X_base<double>
{
public:
	double instantiated_type;//成员变量
};
总而言之，编译器不可能知道如何解析X<A, B>::operator()()的定义，除非我们告诉它instantiated_type是什么――至少，得告诉它是类型还是其它什么东西。这里，我们希望它是个类型。
好一点的做法（差的做法是在所有用到instantiated_type的地方都改成typename X_base<B>::instantiated_type）
template<typename A, typename B>
class X: public X_base<B>
{
public:
	typedef typename X_base<B>::instantiated_type instantiated_type;
	bool operator()(const instantiated_type& i) const
	{
		return i != instantiated_type();
	}
};

附笔：关于typename的小幽默
#include <iostream>
using namespace std;

class Rose { };

class A
{
public:
	typedef Rose rose;
};

template<typename T>
class B
{
public:
	typedef typename T::rose foo;
};

template<typename T>
void smell(T)
{
	cout << "awful" << endl;
}

//写成
//template<>
//void smell<Rose>(Rose)
//或
//template<>
//void smell(Rose)
//或如下：都对
void smell(Rose)
{
	cout << "sweet" << endl;
}

int main(int argc, char* argv[])
{
	smell(A::rose());
	smell(B<A>::foo());//虽然看起来不是Rose，但是还是声明了个Rose对象
}
输出如下：
sweet
sweet
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款6：容器、指针和“不是容器的容器”
使用迭代器有两个潜在的缺陷，只在其中一个落到你头上，你就要继续使用指针：
1. 能使用指针的地方，不一定总能方便地使用迭代器。
2. 如果迭代器是一个对象而不是一个普通指针（bald pointer），使用迭代器会空间和性能上的额外开销。
例如，假设有一个map<Name, PhoneNumber>，它在程序启动的时候载入，在此之后仅用于查询。也就是说，给出一个名称，可以很容易地在这个已有的数据字典中查找到相应的号码。但如果需要进行反向查找怎么办？一个干净的手法是，再构造第二个数据结构，例如map<PhoneNumber*, Name*, Deref>，它让你可以进行反向查找，但避免了双倍的存储开销；因为使用指针，就不需要将每个名称和电话号码存储两次，第二个存储结构拥有的只是指针，指向第一个结构的内部。
如果不使用指针而是迭代器，就很难达到这种效果，因为作为当然的候选者，map<Name, PhoneName>::iterator指向的是pair<const Name, PhoneName>，没有某种方便的方法可以得到一个迭代器，让它单独指向姓名部分或者电话号码部分。
#include <iostream>
#include <map>
#include <string>
#include <algorithm>
using namespace std;

typedef string Name;
typedef string PhoneNumber;

struct Deref: public binary_function<PhoneNumber*, Name*, bool>
{
	bool operator()(const PhoneNumber* lhs, const PhoneNumber* rhs) const
	{
		return *lhs < *rhs;
	}
};

class PointerMaker
{
public:
	PointerMaker(map<const PhoneNumber*, const Name*, Deref>& m): m_(m) {}
	void operator()(const pair<const Name, PhoneNumber>& namePhoneNumberPair)
	{
		m_.insert(make_pair(&namePhoneNumberPair.second, &namePhoneNumberPair.first));
	}
private:
	map<const PhoneNumber*, const Name*, Deref>& m_;
};

int main()
{
	map<const Name, PhoneNumber> namePhoneNumberMap;

	namePhoneNumberMap.insert(make_pair("Ben", "123"));
	namePhoneNumberMap.insert(make_pair("John", "456"));
	namePhoneNumberMap.insert(make_pair("Lee", "789"));

	//map<const PhoneNumber*, const Name*, [] (const PhoneNumber* lhs, const PhoneNumber* rhs) {return *lhs < *rhs;}> phoneNumberNamePointerMap;//这里map的构造用lambda表达式无法实现
	map<const PhoneNumber*, const Name*, Deref> phoneNumberNamePointerMap;//这里的第二个参数Name*必须加const，因为是要把const Name的地址存储在value处，所以该value值必须为const

	for_each(namePhoneNumberMap.begin(), namePhoneNumberMap.end(), [&] (const pair<const Name, PhoneNumber>& namePhoneNumberPair)
	{
		phoneNumberNamePointerMap.insert(make_pair(&namePhoneNumberPair.second, &namePhoneNumberPair.first));//用lambda表达式实现
	});
	//for_each(namePhoneNumberMap.begin(), namePhoneNumberMap.end(), PointerMaker(phoneNumberNamePointerMap));//用函数对象实现

	map<const Name, PhoneNumber>::iterator iter = namePhoneNumberMap.begin();
	cout << *phoneNumberNamePointerMap[&(*iter).second] << endl;//是这样用吗？感觉没什么用处
}

为什么要获取指向容器内部的指针或引用？

template<typename T>
void f(T& t)
{
	typename T::value_type* p1 = &t[0];
	typename T::value_type* p2 = &*t.begin();
}
对标准库中支持operator[]()的任何容器来说，上例中的代码都是合法的；如果去掉“&t[0]”的那行语句，对标准库中的每一个容器来说，它都是合法的，但是，唯独vector<bool>除外。
template<typename T>
void g(vector<T>& v)
{
	T* p = &v.front();
}
不幸的是：并非所有定义在C++标准库中并且看起来像容器的模板都真的是容器。具体来说，C++标准库要求vector必须针对bool进行特殊化，于是，作为一个模板特殊化，vector<bool>不是一个容器，它不符合标准库容器的条件，是的，vector<bool>的确出现在C++标准的“容器和序列”部分；是的，标准中没有提到它实际上既不是容器也不是序列。但事实是，vector<bool>不是容器，所以，它不总是能够作为一个容器来使用，对此不必奇怪。
vector<bool>被代理容器。“被代理容器（proxied container）”指的是其对象不能被直接访问和操作的容器。被代理容器不会向你提供被包含对象的指针或引用，而是提供一个代理对象，让你通过这个代理对象间接地访问和操作被包含对象。如果一个集合（容器是一种特殊的集合）中的对象不能（像被放在内存中那样）被可靠地直接访问，被代理集合（proxied collection）会很有用。
（vector<bool>的功能在许多方面是多余的，std::bitset就是专门用来完成它那种压缩式表示（packed-representation）的功能的。）
从满足标准容器和迭代器条件的意义上来说，vector<bool>不是一个“容器”。被代理容器是绝对不会被标准容器和迭代器条件所接受的。如container<T>::reference必须是一个真实的引用（T&），绝对不能是一个代理。迭代器也有类似的要求，所以解引用（dereference）一个单向（forward）、双向（bidirectional）或随机访问（random-access）迭代器必须产生一个真实的引用（T&），绝对不能是一个代理。有了这些条件，任何基于代理的容器都绝对不会满足C++标准目前所规定的容器条件。
为了让vector<bool>在空间使用上更高效，在内部将所有bool进行压缩存储，让它们每一个各占1位（bit）（可以称之为内部char或bool），给vector<bool>带来了空间存储上的优势。
这种压缩表示的一个后果是，vector<bool>不能通过它的operator[]或“被解引用的迭代器”返回一个正常的bool&。相反，只能返回一个“和引用类似”的代理对象。这个代理对象表面上在很多方面像bool&，但实际上不是bool&。这样对vector<bool>内部的访问还会变得更慢，因为我们必须得和代理打交道，而不是直接使用指针或引用（更不用说那些的额外的位操作了）。所以，vector<bool>不是一种纯粹的优化，而是一种选择，用“潜在的速度上的损失”换取“较少的空间占用”。
有一项功能vector<bool>::reference肯定无法提供，即bool* operator&();，也就是说，它无法提供一个合适的取地址运算符：因为，作为vector<bool>的代理，reference无法取得vector<bool>内部单个比特的地址。

被代理容器与STL假设
结论：或许可以说，std::vector<bool>是符合标准的，但这不是个容器。（它也不是个很好的存储比特值的vector，因为它丧失了一些针对比特的操作功能，而提供这些操作是很合理的，std::bitset就提供了这些功能。）
最初的STL容器条件和C++标准的容器条件都基于一个假设（这个假设是众多假设中的一个），即，解引用一个迭代器（a）是一个常数时间的操作；（b）和其它操作相比，它需要的时间可以忽略不计。
在一定程度上，vector<bool>可以作为一个例子，用来演示如何写被代理容器，同时，vector<bool>还可以用来说明，被代理容器不符合C++标准目前的容器条件。

谨防过早优化
规则可以总结为：（1）不要太早优化。（2）除非知道确实必要，否则不要使用优化。（3）即使那样，除非知道了要优化什么、哪里需要优化，否则也不要使用优化。
有些人说得更直截了当：
1. 使用优化的第一条原则：不要使用它。
2. 使用优化的第二条原则：还是不要使用它。
一般来说，对于自己所写的代码在空间和时间性能上的实际瓶颈，程序员的猜测糟糕得一踏糊涂。如果没有性能分析或者其它实验数据指导你，你会轻易地花掉几天的时间去优化一些不需要优化的东西，或者，实际上不影响运行时期空间性能或时间性能的东西。更糟的是，当不知道什么东西需要优化时，实际上可能在借“优化”之名行“恶化”（损害你程序）之实，因为你可能会为了节省一点成本，却在无意中搜到更大的成本。一旦你进行了性能分析或其它测试，并且确实知道某种优化会对你有帮助，这时候进行优化才是水到渠成之事。
这里想说的要点是：正确的优化取决于具体的应用。假设你在写一个程序，你在一个内部循环中操作一个有1000个元素的vector<bool>，这种情况下，较之节省少量的空间，由于CPU负荷减少（没有代理对象和位操作的开销，）所带来的最根本的速度上的提高会更能让你的程序受益――即使空间的节省会提高高速缓存的命中率。
如果正在为vector<bool>的“非容器性”所困，或者，如果在环境中所测量出来的性能差异并非微不足道，而且这种差异对你的应用程序影响巨大，那么，请不要使用vector<bool>。你可能会想到用vector<bool>或vector<int>来代替它（即，将bool作为char或int来存储），并且，在对容器中的值进行设定时使用类型转换，但这样做很麻烦。更好的解决之道是使用deque<bool>：这是一个更简单的方案，而且它和条款7中有关deque的使用建议相吻合。
明智地使用优化，除非有实验数据证明，在你所在有情况下，优化会带来好处，否则，绝对不要屈服于过早优化的诱惑。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款7：使用vector和deque
尽量使用vector（或deque），不要使用数组。
在大多数情况下，尽量使用vector
关于应该优先使用何种容器，C++标准提供了一些建议，它是这么说的：
vector是那种应该在默认情况下使用的序列……当大多数插入和删除操作发生在序列的善或尾部时，应该选用deque这种数据结构。、
deque的分布组织方式提供了几个好处：
1. 在容器前端，deque也提供了常数时间的insert()和erase()操作，而vector则不行。
2. deque使用内存的方式对操作系统更友好。
3. deque更容易使用一些，而且在体积增长方面，它天生比vector更有效率。
在C++标准中，stack适配器优先使用的是deque。尽管stack只能在一个方向上增长，因而永远不需要在中间或另一端进行插入，但它的缺省实现使用的是deque。
尽管如此，为了可读性和简单化，在默认情况下，请尽量在程序中使用vector，除非你需要在容器的头部执行有效的增加或删除操作，并且不需要底层对象连续存储。请注意，vector之于C++，正如数组之于C――它应当是你的程序中使用的默认容器类型，它可以相当出色地帮助你完成大多数工作，除非你知道自己需要的是与之不同的东西。

缩小vector
调用reserve()永远不会缩小vector的容量。调用reserve()只能增加容量；或者，如果容量已经足够，它就什么事都不做。
vector<Customer> c(1000);
vector<Customer>(c).swap(c);
vector<Customer>().swap(c);
这些技术对deque也一样奏效，但无需对list、set、map、multiset或multimap做类似的事，因为它们基于“严格遵循所需”的原则分配空间，因而永远不会存在多余的容量。
除非你真的需要空间优化，否则请总是使用deque<bool>，而不要使用vector<bool>。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款8：使用set和map
关联式容器依赖一个基本条件：一旦一个键被插入容器，那么无论那个键被什么方式修改，它在容器中的相对位置不能改变。如果这种事真的发生，容器会毫不知情，它对元素次序的假设将被推翻，查找合法元素的操作会失败，迭代器就不一定能按照键的次序遍历容器的元素。
解决之法：
选择1：规定“const就是const”（不充分）
就算告诉人们去尊重const，这还不够。例如，如果Key类型有一个mutable成员，这个成员影响Compare对Key对象作比较的方式，那么，在一个const键上调用const成员函数还是可以改变键的相关次序的。
选择2：规定“总是以‘先删除再重装插入’的方式对键进行修改”（好一些，但还是不充分）
很遗憾，它还是不足以应用到一般场合，因为在容器内部，键还是可以被修改。这里有两个反例：
（1）假设Key类型具有某种外部可见状态，这个状态可以被其它代码得到――例如一个指针，指向共享缓冲区，系统的其它部分无需操作Key对象就可以修改这一缓冲区。再假设那个外部可见的状态值参与了Compare执行的比较操作。那么，即使对Key对象一无所知，即使对使用这个关系式容器的代码一无所知，如果对外部可见的状态值进行修改，就还是可以改变键的相关次序。
（2）假设Key的类型为string；Compare类型将这个Key解释为“文件名”，在做比较时，比较的对象是文件的“内容”。在这种情况下，显然，即使键永远没有被修改，但如果文件内容被另一个进程修改，或者被世界另一端的另一台计算机上的某个用户修改，键的相关次序还是可以被改变的。

对于set，可以把它看作一个map<Key, Value>，但Value的类型为void。
在本书交付之际，正式要求set::iterator和set::const_iterator必须是常量迭代器（即constant iterator，它是一种“无法改变其所指之值”的迭代器，但迭代器本身可能为const，也可能不是），因而，如果想修改set中的对象，你就必须使用const_cast这一转换工具。
目前的一些set实现允许你不用转换就可以修改它，一些则不请允许。如果你使用的set实现允许修改，无论它要求必须使用const_cast还是无需使用const_cast，请记住：在修改Customer对象时，你还是不能改变它在容器中的相关次序。
//下例为VS2010中set改变内容的例子，必须加const_cast<Type&>
#include <iostream>
#include <algorithm>
#include <set>
#include <string>
using namespace std;

class Employee
{
	friend class CompareEmployee;
public:
	Employee(int id, const string& name): id_(id), name_(name) { } 
	void show() const
	{
		cout << "ID: " <<  id_ << ", Name: " << name_ << endl;
	}
	void setId(int newId)
	{
		id_ = newId;
	}
	void setName(const string& newName)
	{
		name_ = newName;
	}
private:
	int id_;
	string name_;
};

class CompareEmployee: public binary_function<Employee, Employee, bool>
{
public:
	bool operator()(const Employee& lhs, const Employee& rhs) const
	{
		return lhs.id_ < rhs.id_;
	}
};

int main(int argc, char* argv[])
{
	Employee employee1(1, "Li Lei");
	Employee employee2(2, "Han Meimei");
	Employee employee3(3, "Kate");
	set<Employee, CompareEmployee> employeeSet;
	employeeSet.insert(employee1);
	employeeSet.insert(employee2);
	employeeSet.insert(employee3);
	for_each(employeeSet.begin(), employeeSet.end(), mem_fun_ref(&Employee::show));
	set<Employee, CompareEmployee>::iterator iter = employeeSet.begin();
	const_cast<Employee&>(*iter).setName("Green");//这里必须加const_cast
	for_each(employeeSet.begin(), employeeSet.end(), mem_fun_ref(&Employee::show));
}
如果将倒数第二行换成const_cast<Employee&>(*iter).setId(6);
则输出如下：
ID: 1, Name: Li Lei
ID: 2, Name: Han Meimei
ID: 3, Name: Kate
ID: 6, Name: Li Lei
ID: 2, Name: Han Meimei
ID: 3, Name: Kate
请按任意键继续. . .
为确保正确使用关联容器，如果能制定一条明确的规则，那当然好，但const无法独立承担使用（不管怎么说，目前的现实是，对于“键的const性”这一问题，set和map在策略上存在分歧），简单的编程规范也无法独立承担使用。所以，我们真的无法做得更明确，只能陈述条件本身，并加上一句：“你必须清楚自己在做什么。”
关联式容器的重要使用规则：一个键一旦被插入到关联式容器中，那个键在容器中的相对位置绝对不能改变。
一定要知道哪些直接或间接的行为会改变一个键的相关次序，并且避免这样的行为，这样，在使用标准关系容器时，就可以避免不必要的问题发生。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款9：等同的代码吗？
1. 下面代码做了什么：
f(a++);
首先，f可以是下面中的任何一个：
1） 宏
这种情况下，这条语句可以表示几乎任何东西
#define f(x) x
#define f(x) (x,x,x,x,x,x,x,x,x)
#define f(x)
设计准则：避免使用宏，宏往往使得代码更难以理解，从而更难以维护。
2） 函数
首先，a++会求值，然后，结果被传递给函数作为参数（这里说的没有问题，对于a++来说，内部实现确实是先递增运算，然后return递增前的临时变量）。通常，后置递增运行会以临时对象的形式返回a的旧值，所以，f()获取参数的方式要么是通过传值，要么是通过传递const引用，但不会是传递非const引用，因为非const引用不能被绑定于临时对象。
#include <iostream>
using namespace std;

void show(int number)//这里只能是int number或const int& number，而不能是int& number，因为传进来的是临时变量，临时变量不能做为非const引用
{
	cout << number << endl;
}

int main(int argc, char* argv[])
{
	int a = 3;
	show(a++);
	cout << a << endl;
}
输出如下：
3
4
请按任意键继续. . .
如果改为show(++a)，则int number、int& number或const int& number都行。
3） 对象
这种情况下，f将是是一个函数对象，即，一个定义了operator()()的对象，同样，如果后置递增运算返回a的旧值（后置递增运算总会这样做），那么，f的operator()()可以通过传值或者传递const引用来获取参数。
4） 类型名称
这种情况下，这个语句首先对a++求值，然后用这个表达式的结果来初始化一个类型为f的临时对象。

再往下看，a可以是：
1） 宏
a可以表示任何东西。
2） 对象（有可能是内建类型）
这种情况下，它的类型必须定义了合适的后置递增运算符operator++(int)。
通过，后置递增应该利用前置递增来实现，并且返回a的旧值：
//后置递增的规范形式：
T T::operator++(int)
{
	T old(*this);
	++*this;//总是用前置递增来实现后置递增
	return old;//返回旧值
}
当然，重载一个运算符时，的确可以改变它的正确语义，让它做些“与从不同的事”。例如，假设a的类型为A，那么对大多数类型的f来说，下面的做法都很可能使得上例中代码无效：
void A::operator++(int)//不返回任何值
不要这么做
设计准则：始终要为被重载的运算符保留正常语义。“像int那样做”；即，遵循内建类型的语义。
3） 值，例如地址
举例来说，a可以是一个指针。

f(a++);
执行步骤如下：
（1）a++：递增a并返回a的旧值。
（2）f()：将a的旧值传递给f()，然后执行f()。
上例保证，在f()执行前，后置递增操作已经完成，因而a获得新值。正如前面所说，f()还是可以是一个函数、一个函数对象、或一个导致构造函数调用的类型名称。
一些编程标准规定，++这样的操作应该总是出现在单独一行代码中，理由在于：考虑到程序执行顺序点（sequence points，详见条款20和21）方面的原因，在同一个语句中执行多个++这样的操作很危险，所以，编程标准推荐这样做法：
f(a);
a++;
执行步骤如下：
1. f()：将a的旧值传递给f()，然后执行f()。
2. a++：递增a并返回a的旧值，旧值随后被忽略。
区别：第二例保证，在f()执行之后才会执行后置递增，从而使得a得到新值。（貌似对于int& number这样的声明方式也可以支持）
这有两个主要后果：
首先，在f()产生异常的情况下，第一例会保证a++和它所有的副作用都成功执行结束；而第二例则保证a++没有执行，它的副作用一个也没有发生。
其次，即使在没有异常产生的情况下，如果f()和a.operator++(int)有可见的副作用，那么，它们的执行顺序会很重要。更明确地说，如果f()有一个副作用，这个副作用可能影响a本身的状态，那两种方式将有不同的结果。

剪刀，交通和迭代器
3. 将问题2简化，假设f()是一个函数，它通过传值的方式获得参数：a是一个类对象，它提供了一个具有正常语义的operator++(int)。则两列有区别吗？
区别在于，对于完全正规的C++代码来说，当第二例不合法的时候，第一例可以是合法的。这是因为，在第一例中，有一段时期，对象会同时具有a的旧值和新值，而第二例中则没有这样的重叠。
如果我们将f()换成list::erase()，将a换成list::iterator，考虑一下将会发生什么，这样的话，第一种形式是合法的：
l.erase(i++);//没问题，递增一个有效的迭代器
第二种形式不合法：
l.erase(i);
i++;//错误，i不是一个有效的迭代器
一些母亲（同时也是软件工程师）提出了下面三条忠告：
（1）不要摆弄剪刀
（2）不要在交通道路玩耍
（3）不要使用无效的迭代器
除了上面的例子，条款20和21将看到，一般情况下，避免在函数调用中写出++这样的操作还是个好主意。
//------------------------------------------------------------------------------------------------
//More Exception C++ 条款10：模板特殊化与重载
非模板函数总是优先于模板函数。
非模板函数只有在完全匹配的时候才会被优先选用。
//------------------------------------------------------------------------------------------------
//More Exception C++ 条款11：Mastermind
#include <iostream>
#include <map>
#include <algorithm>
#include <string>
#include <ctime>
#include <cstdlib>//srand函数
using namespace std;

typedef map<int, int> M;

class ChoosePeg
{
public:
	ChoosePeg(const string& colors): colors_(colors) {	}
	char operator()()
	{
		return colors_[rand() % colors_.size()];
	}
private:
	const string& colors_;
};

class CountPlace
{
public:
	CountPlace(M& cm, M& gm, int& pok): cm_(cm), gm_(gm), pok_(pok = 0) { }//在给类数据成员赋值的同时，还可以给传进来的参数赋值
	char operator()(char c, char g) //const //这里的const也可加可不加，因为该类没有类中的私有数据成员，所有的数据成员皆为外部对象的引用，故该函数不会改变类中的私有数据成员值，可以加const；如果该类又定义了一个数据成员int n_，并且在该函数中改变n_的值，则无法加const，或将n_声明为mutable int n_;
	{
		++cm_[c];
		++gm_[g];
		pok_ += (c == g);
		return g;//第二个迭代器的值仍返回去，不改变第二个迭代器的值
	}
private:
	M &cm_, &gm_;
	int& pok_;
};

class CountColor
{
public:
	CountColor(M& cm, M& gm, int& cok): cm_(cm), gm_(gm), cok_(cok = 0) { }//同上
	void operator()(char c) const //这个const没大看懂，感觉没什么用？同上分析
	{
		cok_ += min(cm_[c], gm_[c]);//如comb为RRGB，guess为RGBB，cm_[R]=2, cm_[G]=1, cm_[B]=1, gm_[R]=1, gm_[G]=1, gm_[B]=2，所以cok_=1+1+1
	}
private:
	M &cm_, &gm_;
	int& cok_;
};

int main(int argc, char* argv[])
{
	const string colors("BGR");//可能颜色
	string comb(4, '.'), guess;//组合和当前猜测
	int cok = 0, pok = 0;//正确的颜色和位置
	M cm, gm;//辅助结构

	srand(static_cast<unsigned>(time(0)));
	generate(comb.begin(), comb.end(), ChoosePeg(colors));
	//cout << comb << endl;
	cout << "Please guess the color and position!. (Color: " << colors << ", length: " << comb.size() << ")" << endl;
	while(pok < comb.size())
	{
		cout << "\nguess --> ";
		cin >> guess;
		guess.resize(comb.size(), ' ');
		cm = gm = M();//这里要每次把两个辅助结构清空
		transform(comb.begin(), comb.end(), guess.begin(), guess.begin(), CountPlace(cm, gm, pok));
		for_each(colors.begin(), colors.end(), CountColor(cm, gm, cok));
		cout << cok << ' ' << pok << endl;
	}
	cout << "Solved. Congratulations!" << endl;
}

//增加提示语句和猜测次数
int main(int argc, char* argv[])
{
	const string colors("BGR");
	string comb(4, '.'), guess;
	int cok = 0, pok = 0;
	M cm, gm;
	int totalTryTimes = 10;

	srand(static_cast<unsigned>(time(0)));
	generate(comb.begin(), comb.end(), ChoosePeg(colors));
	//cout << comb << endl;
	cout << "Please guess the color and position!. (Color: " << colors << ", length: " << comb.size() << ")" << endl;
	while(pok < comb.size())
	{
		cout << "\nThere is still " << totalTryTimes << " times.\n";
		cout << "guess --> ";
		cin >> guess;
		guess.resize(comb.size(), ' ');
		cm = gm = M();
		transform(comb.begin(), comb.end(), guess.begin(), guess.begin(), CountPlace(cm, gm, pok));
		for_each(colors.begin(), colors.end(), CountColor(cm, gm, cok));
		cout << cok << ' ' << pok << endl;
		if (--totalTryTimes == 0)
		{
			cout << "Game over, the color is " << comb << endl;
			break;
		}
	}
	if (totalTryTimes != 0)
	{
		cout << "Solved. Congratulations!" << endl;
	}
}

//关于初始化列表中赋值的一例，其实就相当于做了一次赋值操作，然后将左值作为返回值再次赋值而已，如果传进来的是引用，则会改变传入的实参
class Test
{
public:
	Test(int& n): n_(n = 3) { }
	void show()
	{
		cout << n_ <<endl;
	}
private:
	int& n_;
};

int main(int argc, char* argv[])
{
	int number = 10;
	Test test(number);
	test.show();
	cout << number << endl;

	number = 15;
	test.show();
	cout << number << endl;
}

//方案2
#include <iostream>
#include <functional>
#include <numeric>
#include <algorithm>
#include <string>
#include <ctime>
#include <iterator>
#include <cstdlib>
using namespace std;

class ColorMatch
{
public:
	ColorMatch(int i, const string* comb, const string* guess)
		: cok_(i), comb_(comb), guess_(guess) { }
	operator int()//这里如果不提供隐式转换，则可以写成int getResult()，则调用accumulate().getResult()，这与for_each().func()的调用如出一辙，见后所试代码
	{
		return cok_;
	}
	//参见“accumulate模板实现”，该算法所需要的函数需要提供两个参数：第一个为初始对象（这个对象可以为任意对象，而不是开始所认为的只能是0或者其它的int值），第二个为迭代器解引用对应的对象；并且该算法返回一个初始对象同类型对象，作为下次迭代计算的初值。这也正是“Effective STL 条款37：用accumulate或for_each来统计区间”所说的两个算法进行统计的方法。而for_each可以用来统计的原因是：第三个参数函数对象可以储存计算结果和状态并最后作为返回值返回
	static ColorMatch colorCount(ColorMatch& cm, char c)
	{
		return ColorMatch(cm.cok_ +
			min(count(cm.comb_->begin(), cm.comb_->end(), c), count(cm.guess_->begin(), cm.guess_->end(), c)), 
				cm.comb_, cm.guess_);
	}
private:
	int cok_;
	const string *comb_, *guess_;
};

class Combination
{
public:
	Combination(): comb_(4, '.')//这里的成员列表即构造成员变量，就是类构造初始化过程，所有的初始化方法都可以在这里用
	{
		generate(comb_.begin(), comb_.end(), choosePeg);
		//cout << comb_ << endl;
		prompt();
	}
	bool operator()(string guess) const
	{
		int cok, pok;
		guess.resize(comb_.size(), ' ');
		cok = accumulate(colors.begin(), colors.end(), ColorMatch(0, &comb_, &guess), ColorMatch::colorCount);//见对ColorMatch的分析
		pok = inner_product(comb_.begin(), comb_.end(), guess.begin(), 0, plus<int>(), equal_to<char>());//对两个区间进行op1和op2两种操作，op2按次序各取两个区间中的一个对象进行某种操作并返回一值，op1将初值和返回值作累计操作，并将最终值返回。这里的op2（equal_to<>）将bool值作为0和1进行计算了。可以把inner_product想像成accumulate和transform的混合物
		cout << cok << ' ' << pok << endl;
		return (pok == comb_.size()) ? 
			(cout << "Solved. Congratulation!\n", true) : (prompt(), false);
	}
private:
	string comb_;
	static char choosePeg()//这里如果不用static函数，则生成随机字符的函数对象必须用类成员函数指针传入，&Combination::choosePeg，但是报generate错，这里应该是类成员函数作为函数对象所产生的问题；这里也提供了一个将类的函数放入算法的方法：即将类的成员函数声明为static，即可正常放入算法中。（或另声明函数或函数对象，见后所试代码）
	{
		return colors[rand() % colors.size()];
	}
	static void prompt()//这里声明为static，即可以不声明为const，因为static不会操纵类私有成员变量，所以在operator()中的调用不会导致问题；如果将static去掉，则该函数必须声明为const私有函数void prompt() const，见后所试代码
	{
		cout << "guess --> ";
	}
	static const string colors;//static成员函数只能操作static成员变量，所以这里必须声明为static成员变量；如果将choosePeg从类中拿出，则colors可以声明为非static，见后所试代码
};

const string Combination::colors = "BGR";

int main(int argc, char* argv[])
{
	srand(static_cast<unsigned>(time(0)));
	find_if(istream_iterator<string>(cin), istream_iterator<string>(), Combination());//这里每打一次回车，则之前所输入的字符串就会分隔并按照所生成的字符串进行相应次数的Combination::operator()判断
}

//之前分析的试验，主要有：static成员函数和static变量的拆分和改为非static；隐式转换改为提供公有函数
#include <iostream>
#include <functional>
#include <numeric>
#include <algorithm>
#include <string>
#include <ctime>
#include <iterator>
#include <cstdlib>
using namespace std;

class ColorMatch
{
public:
	ColorMatch(int i, const string* comb, const string* guess)
		: cok_(i), comb_(comb), guess_(guess) { }
	int getResult()
	{
		return cok_;
	}
	static ColorMatch colorCount(const ColorMatch& cm, char c)
	{
		return ColorMatch(cm.cok_ +
			min(count(cm.comb_->begin(), cm.comb_->end(), c), count(cm.guess_->begin(), cm.guess_->end(), c)), 
				cm.comb_, cm.guess_);
	}
private:
	int cok_;
	const string *comb_, *guess_;
};

char choosePeg()
{
	string colors("RGB");
	return colors[rand() % colors.size()];
}

class Combination
{
public:
	Combination(): comb_(4, '.'), colors("RGB")//
	{
		generate(comb_.begin(), comb_.end(), choosePeg);//
		cout << comb_ << endl;
		prompt();
	}
	bool operator()(string guess) const
	{
		int cok, pok;
		guess.resize(comb_.size(), ' ');
		cok = accumulate(colors.begin(), colors.end(), ColorMatch(0, &comb_, &guess), ColorMatch::colorCount).getResult();//
		pok = inner_product(comb_.begin(), comb_.end(), guess.begin(), 0, plus<int>(), equal_to<char>());
		cout << cok << ' ' << pok << endl;
		return (pok == comb_.size()) ? 
			(cout << "Solved. Congratulation!\n", true) : (prompt(), false);
	}
private:
	string comb_;
	void prompt() const//bool operator()(string guess) const为const，所以调用的函数必须为const
	{
		cout << "guess --> ";
	}
	const string colors;
};

//const string Combination::colors = "BGR";

int main(int argc, char* argv[])
{
	srand(static_cast<unsigned>(time(0)));
	find_if(istream_iterator<string>(cin), istream_iterator<string>(), Combination());
}
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款12：内联
如果想用什么方式提高效率，总是先借助你的算法和数据结构。它们会给你的程序带来数量级的整体改善，而内联之类的过程优化（process optimization）通常（注意，“通常”）收效甚微。
何时使用：
在分析工具告诉你这样做之前，不要贸然行事。几个合理的例外――例如空函数，而且会持续保持为空；或者，你非得这么做不可的时候――例如，在写一个非输出模板（non-exported template）的时候。（什么意思？）
设计准则：
使用优化的第一条原则：不要使用它。
使用优化的第二条原则：还是不要使用它。
最后注意，使用这条准则的另一个实际原因是：对于哪一个内联函数不应该被内联，分析工具并不善于识别。

关于存取函数
不管怎么说，所有被内联的代码都会增加耦合性，所以，除非你事先确信内联会带来好处，否则，将使用内联的决定延迟到分析之后是没有坏处的。到那时候，如果分析工具指出内联会有好处，你至少知道，你正在做的值得做的事；你也将耦合和可能的编译开销延迟了――延迟到你确实知道内联真的有必要的时候。

设计准则：
在性能分析证明确实必要之前，避免内联或详细优化。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款13：缓式优化，之一：一个普通的旧式String
有不少错误，见注释
//myString.h
#ifndef __MYSTRING_H__
#define  __MYSTRING_H__

namespace Original
{
	class String
	{
	public:
		String();
		String(const String&);
		void append(char);
		~String();
	private:
		void reserve(size_t);
		char* buf_;
		size_t len_;
		size_t used_;
	};
}
#endif

//myString.cpp
#include "myString.h"
#include <algorithm>

Original::String::String(): buf_(0), len_(0), used_(0)
{

}

Original::String::String(const String& other)//这里是拷贝构造函数。。。应该用初始化列表来写，并且不会涉及到delete oldBuf;
{
	char* oldBuf = buf_;
	buf_ = new char(other.len_);//这里的new char[]，括号还写错了。。。
	std::copy(other.buf_, other.buf_ + other.used_, buf_);
	used_ = other.used_;
	len_ = other.len_;
	delete oldBuf;//删除还写错了，这是删除字符数组，而且不是只删除一个字符指针。。。应该用delete [] oldBuf;
}

Original::String::~String()
{
	delete buf_;//删除写错了
}

void Original::String::append(char c)
{
	reserve(used_ + 1);
	buf_[used_++] = c;
}

void Original::String::reserve(size_t n)
{
	if (len_ < n)
	{
		size_t newLen = std::max(static_cast<size_t>(len_ * 1.5), n);//这里如果不用静态转换的话，则两个参数一个是double，一个是int值，两个参数类型不同，没有匹配的标准算法
		char* newBuf = new char[newLen];
		std::copy(buf_, buf_ + used_, newBuf);
		delete [] buf_;
		buf_ = newBuf;
		//这里忘记将len_赋值成新长度值了
	}
}

这是修改后的
//myString.cpp
#include "myString.h"
#include <algorithm>

Original::String::String(): buf_(0), len_(0), used_(0)
{

}

Original::String::String(const String& other): buf_(new char[other.len_]), len_(other.len_), used_(other.used_)
{
	std::copy(other.buf_, other.buf_ + other.used_, buf_);//这里用used_即可
}

Original::String::~String()
{
	delete [] buf_;
}

void Original::String::append(char c)
{
	reserve(used_ + 1);
	buf_[used_++] = c;
}

void Original::String::reserve(size_t n)
{
	if (len_ < n)
	{
		size_t newLen = std::max(static_cast<size_t>(len_ * 1.5), n);
		char* newBuf = new char[newLen];
		std::copy(buf_, buf_ + used_, newBuf);
		delete [] buf_;
		buf_ = newBuf;
		len_ = newLen;
	}
}

字符串长度增加方式通常指数增长方式较优，最佳增长因子不是2，而可能是1.5 左右。给定字符的平均拷贝次数是常量――也就是说，不依赖于字符串的长度。

//增加了char*构造函数，但是因为最后一个字符有个'\n'，导致append有问题，懒得改了
//myString.h
#ifndef __MYSTRING_H__
#define  __MYSTRING_H__

namespace Original
{
	class String
	{
	public:
		String();
		String(const char*);
		String(const String&);
		void append(char);
		~String();
		void show() const;
	private:
		void reserve(size_t);
		char* buf_;
		size_t len_;
		size_t used_;
	};
}
#endif

//myString.cpp
#include "myString.h"
#include <iostream>
#include <algorithm>
#include <cstring>

Original::String::String(): buf_(0), len_(0), used_(0)
{

}

Original::String::String(const String& other): buf_(new char[other.len_]), len_(other.len_), used_(other.used_)
{
	std::copy(other.buf_, other.buf_ + used_, buf_);
}

Original::String::String(const char* s)
	: buf_(new char[static_cast<size_t>((strlen(s) + 1)*1.5)]), //这里都要用strlen，sizeof(char*)永远是4！
	len_(static_cast<size_t>((strlen(s) + 1)*1.5)), 
	used_((strlen(s) + 1))
{
	std::copy(s, s + strlen(s) + 1, buf_);
}

Original::String::~String()
{
	delete [] buf_;
}

void Original::String::append(char c)
{
	reserve(used_ + 1);
	buf_[used_++] = c;
}

void Original::String::reserve(size_t n)
{
	if (len_ < n)
	{
		size_t newLen = std::max(static_cast<size_t>(len_ * 1.5), n);
		char* newBuf = new char[newLen];
		std::copy(buf_, buf_ + used_, newBuf);
		delete [] buf_;
		buf_ = newBuf;
		len_ = newLen;
	}
}

void Original::String::show() const
{
	std::cout << buf_ << '\t' << len_ << '\t' << used_ << std::endl;
}

//main.cpp
#include <iostream>
#include "myString.h"
using namespace std;

int main(int argc, char* argv[])
{
	Original::String s1("nihao"), s2(s1);
	s1.show();
	s2.show();
	s1.append('m');
	s1.show();
}
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款14：缓式优化，之二：引入缓式优化
copy-on-write，缓式拷贝，需要修改时才拷贝，对底层字符串实体实施引用计数
//myString.h
#ifndef __MYSTRING_H__
#define  __MYSTRING_H__

namespace Optimized//这里用命名空间Original和Optimized，里面分别放入各自的类，比放入同一命名空间的两个OriginalString和OptimizedString要好
{
	class StringBuf
	{
	public:
		StringBuf();
		~StringBuf();
		void reserve(size_t);

		char* buf;
		size_t len;
		size_t used;
		size_t refs;
	private:
		StringBuf(const StringBuf&);
		StringBuf& operator=(const StringBuf&);
	};

	class String
	{
	public:
		String();
		String(const String&);
		~String();
		void append(char c);

	private:
		void aboutToModify(size_t);
		StringBuf* data_;
	};
}
#endif

//myString.cpp
#include "myString.h"
#include <iostream>
#include <algorithm>
#include <memory>

namespace Optimized
{
	StringBuf::StringBuf()
		: buf(0), len(0), used(0), refs(1)
	{

	}

	StringBuf::~StringBuf()
	{
		delete [] buf;
	}

	void StringBuf::reserve( size_t n )
	{
		if (len < n)
		{
			size_t newLen = std::max(static_cast<size_t>(len * 1.5), n);
			char* newBuf = new char[newLen];
			std::copy(buf, buf + used, newBuf);
			delete [] buf;
			buf = newBuf;
			len = newLen;
		}
	}

	String::String(): data_(new StringBuf)
	{

	}

	String::String(const String& other): data_(other.data_)
	{
		++data_->refs;
	}

	String::~String()
	{
		if (--data_->refs == 0)
		{
			delete data_;
		}
	}

	void String::aboutToModify(size_t n)
	{
		if (data_->refs > 1)
		{
			std::auto_ptr<StringBuf> newData(new StringBuf);//如果下面的reserver抛异常，这里可以保证自动销毁
			newData->reserve(std::max(data_->len, n));
			std::copy(data_->buf, data_->buf + data_->used, newData->buf);
			newData->used = data_->used;

			--data_->refs;
			data_ = newData.release();
		}
		else
		{
			data_->reserve(n);
		}
	}

	void String::append( char c )
	{
		aboutToModify(data_->used + 1);
		data_->buf[data_->used++] = c;
	}
}
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款15：缓式优化，之三：迭代器与引用
重要概念：“不可共享”的String
//myString.h
#ifndef __MYSTRING_H__
#define  __MYSTRING_H__

namespace Optimized
{
	class StringBuf
	{
	public:
		StringBuf();
		~StringBuf();
		StringBuf(const StringBuf& other, size_t n = 0);
		void reserve(size_t);

		char* buf;
		size_t len;
		size_t used;
		size_t refs;
	private:
		//StringBuf(const StringBuf&);上面的构造函数和这个有二义性，所以这个要去掉
		StringBuf& operator=(const StringBuf&);
	};

	class String
	{
	public:
		String();
		String(const String&);
		~String();
		void append(char c);
		size_t length() const;
		char& operator[](size_t index);
		const char& operator[](size_t index) const;
		void show() const;

	private:
		void aboutToModify(size_t n, bool bUnshareable = false);
		static const size_t unShareable;
		StringBuf* data_;
	};
}
#endif

//myString.cpp
#include "myString.h"
#include <iostream>
#include <algorithm>
#include <memory>
#include <limits>
#include <iterator>

namespace Optimized
{
	StringBuf::StringBuf()
		: buf(0), len(0), used(0), refs(1)
	{

	}

	StringBuf::StringBuf(const StringBuf& other, size_t n /*= 0*/)
		: buf(0), len(0), used(0), refs(1)
	{	
		reserve(std::max(other.len, n));
		std::copy(other.buf, other.buf + other.used, buf);
		used = other.used;
	}

	StringBuf::~StringBuf()
	{
		delete [] buf;
	}

	void StringBuf::reserve(size_t n)
	{
		if (len < n)
		{
			size_t needed = std::max(static_cast<size_t>(len * 1.5), n);
			size_t newLen = needed > 0 ? 4 * ((needed - 1)/4 + 1) : 0;
			char* newBuf = newLen > 0 ? new char[newLen] : 0;
			if (buf != 0)
			{
				std::copy(buf, buf + used, newBuf);
			}			
			delete [] buf;
			buf = newBuf;
			len = newLen;
		}
	}

	String::String(): data_(new StringBuf)
	{

	}

	String::String(const String& other)
	{
		if (other.data_->refs != unShareable)
		{
			data_ = other.data_;
			++data_->refs;
		}
		else
		{
			data_ = new StringBuf(*other.data_);
		}
	}

	String::~String()
	{
		if (data_->refs == unShareable || --data_->refs == 0)
		{
			delete data_;
		}
	}

	void String::aboutToModify(size_t n, bool bUnshareable /*= false*/)
	{
		if (data_->refs > 1 && data_->refs != unShareable)
		{
			StringBuf* newData = new StringBuf(*data_, n);
			--data_->refs;
			data_ = newData;
		}
		else
		{
			data_->reserve(n);
		}
		data_->refs = bUnshareable ? unShareable : 1;
	}

	void String::append( char c )
	{
		aboutToModify(data_->used + 1);
		data_->buf[data_->used++] = c;
	}

	size_t String::length() const
	{
		return data_->used;
	}

	char& String::operator[]( size_t index )
	{
		aboutToModify(data_->len, true);
		return data_->buf[index];
	}

	const char& String::operator[]( size_t index ) const
	{
		return data_->buf[index];
	}

	void String::show() const
	{
		std::copy(data_->buf, data_->buf + data_->used, std::ostream_iterator<char>(std::cout, ""));
		std::cout << std::endl;
	}

	const size_t String::unShareable = std::numeric_limits<size_t>::max();
}

//main.cpp
#include <iostream>
#include "myString.h"
#include <string>
using namespace std;

int main(int argc, char* argv[])
{
	std::string	stdString("hello, world");
	Optimized::String optimizedString;
	for (string::iterator iter = stdString.begin(); iter != stdString.end(); ++iter)
	{
		optimizedString.append(*iter);
	}
	optimizedString.show();
	Optimized::String newOptimizedString(optimizedString);
	newOptimizedString.show();
	newOptimizedString[3] = 'W';
	optimizedString.show();
	newOptimizedString.show();
}
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款16：缓式优化，之四：多线程环境
假设一段代码使用了某个对象，如果在必要的时候，对这个对象的访问需要确保被串行化（serialized），那么，这种串行化的责任要由这段代码代码来承担。例如，如果某个String对象可以被两个不同的线程修改，可怜的String对象是没有责任去防止它自己被滥用的。要保证两个线程永远不会在同一时间修改同一个String对象，其责任在于使用String对象的那段代码。
在条款15的代码中，问题表现为两点。首先，之所以提供copy-on-write（COW）实现，其目的在于隐藏一个事实，即，两个不同的可见String对象可以共享同一个隐藏状态。所以，要想保证一个内部实体（representation）被共享的String对象永远不会被调用者代码修改，其责任在于String类。前面演示的String代码已经完全做到了这一点，即当一个调用者试图修改String的时候，如果有必要，它会执行深拷贝（从而使得实体不可共享）。大体来说，这一点没有问题。
请注意，对于String的拷贝构造函数，我们可以假设，在这个操作期间，其它String的数据缓冲区不会被修改或移动：因为，对可见对象的访问进行串行化是调用者的责任！（这解释了以前写的ACE多线程程序的一个问题）。
append()和operator[]()不需要加锁，因为一旦aboutToModify()执行结束，我们所使用的就必然不是一个被共享的实体。Length()不需要加锁，因为根据定义，如果我们的StringBuf没被共享，我们会没事儿（没有其他人会修改我们使用的字符串长度值）；如果它被共享，我们也没事儿（另一个线程在对它进行操作之前会先让自己拥有一个拷贝，所以还是不会修改我们使用的计数）
再次注意其中有趣的一点：需要加锁的地方只涉及到refs计数本身。

一般来说，如果准备将代码用于多线程环境，在这样的代码中使用copy-on-write通常是个坏主意。原因在于，对于两个不同的String对象在否在底层实际共享同一实体，调用者代码不再可能知晓；所以，String必须通过一定的开销完成必要的串行化工作，这样，调用者代码才有可能在线程安全方面承担其正常的责任。至于性能上的影响到底有多大，这取决于是否丰存在更具效率的实现手段，如原子整数操作；有无这样的实现手段，其性能影响的差异可以从一般到巨大。
如果需要线程安全，COW会将巨大的性能损失强加给所有的用户――即使用户只是运行单线程程序。
//------------------------------------------------------------------------------------------------
//条款17：构造函数失败，之一：对象生命期
class C: private A
{
	B b_;
};
在C的构造函数中，捕捉从基类子对象（例如A）或成员对象（例如b_）的构造函数中抛出的异常，这正是function try block的用武之地：
C::C()
try
	: A(/*...*/)
	, b_(/*...*/)//可选的初始化列表
{
}
catch(...)
{
	//一旦A::A()或B::B()抛出异常，会到这儿。如果A::A()成功，然后B::B()抛出异常，C++语言保证，在到达本catch block之前，A::~A()会被调用，以摧毁已经创建的基类A子对象。
}

问：一个对象的生命期何时开始？
答：当它的构造函数成功执行完毕并正常返回之时。也就是说，当控制（control）抵达构造函数体的末尾之时，或执行完一个更早的return语句之时。
问：一个对象的生命期何时结束？
答：当它的析构函数开始执行之时。也就是说，当控制抵达析构函数体的开始处之时。

在生命期开始之前与生命期结束之后，对象的状态完全一样――没有对象存在。
问：从构造函数中抛出异常意味着什么？
答：这意味着构造已经失败，对象从没存在过，它的生命期从没开始过。确实，报告构造失败――也就是说，无法正确构造出某种类型的有效对象――的唯一方法是抛出一个异常。（是的，有一条如今已经过时的编程规则这么说：如果程序出了问题，可以将一个状态标志设为“bad”，让调用者通过一个IsOK()函数去检查它。）
如果构造函数不成功，析构函数就永远不会被调用，其原因在于此――没有东西可以摧毁。它无法死亡，因为它从来就未曾生存过。这样，“一个对象的构造函数抛出异常”这句话实际上具有矛盾性。这样一种东西甚至不能被称为一个前对象（ex-object）。它从没有生存过，从没有加入过对象家族。它是一个非对象（non-object）。
对于C++的构造函数模型，总结如下，只会是二者之一：
（a）构造函数正常返回，即，控制抵达函数体的尾部，或者执行了一个return语句。这种情况下，对象真实存在。
（b）构造函数抛出异常后退出。这种情况下，对象不仅不会继续存在，而且，实际上它根本就从未作为一个对象存在过。
没有其它的可能性。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款18：构造函数失败，之二：吸收异常？
条款17中的try block处理程序（handler）将如何退出？请注意以下几点：
1. 这个处理程序不能简单地以“return;”返回，因为这不合法。
2. 如果在处理程序中写上“throw;”，那么，无论A::A()或B::B()最初抛出什么异常，它都会将其重新抛出。
3. 如果处理程序抛出其它某个异常，最终抛出的也就是那个异常，而不是基类或成员子对象的构造函数最初抛出的异常。
4. 还有一点不太，但在C++标准中表述得很清楚，这就是：如果处理程序没有以抛出异常的方式退出（既没有重新抛出最初的异常，也没有抛出什么新的东西），那么，在控制抵达构造函数或析构函数的catch block的末尾时，最初的异常会被自动地重新抛出，就像处理程序的最后一个语句是“throw;”一样。
这意味着：一个构造函数或析构函数的function try block的处理程序代码“必须”以抛出某个异常结束。没有其它方式。只要不违反异常规范，C++语言不关心你抛出的是什么异常――可以是最初的那个，或者是其它某个经过转化（translated）的异常――但必须有个异常！只要基类或成员子对象的构造函数抛出任何异常，就一定会导致某个异常从它们外层构造函数（containing constructor）中泄露出来，想阻止这一点是不可能的。
简而言之，这意味着：在C++中，只要任何一个基类或成员子对象构造失败，整个对象的构造必然失败。
如果一个类可以具有某种合理的“部分”构造失败（construction partially failed）状态呢？――也就是说，它真的具有某些不是绝对需要的“可选”成员，对象可以没有它们而苟延残喘，只是缺省某些功能而已。这种情况下可以运用Pimpl手法 （Exceptional C++条款27-30 中有详细介绍），在定的安全距离内拥有对象中可能损坏的部分。与此类似的论述请参见Exceptional C++的条款31-34 中有关“滥用继承”的讨论。“对象的可选部分”这一观念也是“无论何时都 要尽量使用委托（delegation）”而不是使用继承（inheritance）的另一个重要原因。基类子对象永远不能成为可选部分，因为你不可能将基类子对象放进一个Pimples。

法则1：构造函数的function try block唯一（重复一遍：唯一）可能的用处是“转化（translate）从基类或成员子对象抛出的异常”。（上述第4点已说必须以抛出某个异常结束）
法则2：析构函数的function try block完全没有用处。

C++标准：在一个对象的构造函数或析构函数的function try block处理程序中，引用对象的任何非静态成员或基类将导致不可预测的行为。

有关Function Try Block的法则：
法则1：构造函数的function try block处理程序只能用于转化（translate）从基类或成员子对象的构造函数抛出的异常（也可能做一些相应的记录工作，或其它某种附带性的工作，以响应构造失败）。此外没有其它用途。
法则2：析构函数的function try block鲜有或没有实际用处，因为析构函数不应该产生异常。所以，绝对不应该有这样一种东西，析构函数的function try block能够发现到它，而普通的try block却发现不到。
法则3：其它所有的function try block都没有实际用处。对一个函数来说，其内部正常的try block不能捕捉到的东西，其正常的function try block也不能捕捉得到。
法则4：“获取未管理资源（unmanaged resource）”的操作总是应该放到构造函数体内，绝对不要放在初始化列表中。换句话说，要么运用“获得资源才是初始化”的策略（从而完全 避免未管理资源的存在），要么在构造函数体内执行资源获取的操作。
假设在初始化列表中通过new[]操作获得资源。这样一来，在异常处理程序中，或是其它任何地方，我们都无法对它执行delete[]操作。解决之道是，要么将动态分配的内存资源包装起来（例如，将char*改为string）；要么在构造函数体内执行new[]，这样，在构造函数体内，通过使用局部try block或其它方式，它可以被安全地清除。
法则5：清除“获取未管理资源的操作”总要放在构造函数或析构函数体内的局部try block处理程序中，绝对不要放在构造函数或析构函数的function try block处理程序中。
法则6：如果构造函数有异常规范，那么，对于基类和成员子对象可能抛出的所有异常，这个异常规范必须留有余地。（的确，隐式生成的构造函数就是以这样的方式声明的。不太懂？）
法则7：使用Pimpl手法保存类（class）内部的“可选部分”。如果一个成员对象的构造函数可以抛出异常，但你不需要这个成员也可以照常动作，那么，和入学一样，你可以这将这个成员用指针保存，并通过指针是否为null来判断你是否得到这个对象。如果运用Pimpl手法将这些“可行”成员集中起来，你就只用做一次分配工作。
法则8：尽量使用“获得资源才是初始化”的技术来管理资源。

如果真的想写一个“承诺不会抛出异常的构造函数”，你可以绕过“可能会抛出异常的成员子对象”（例如，如果它们确实是可选部分，你可通过指针或Pimpl来保存它们），但你无法躲避“可能会抛出异常的基类子对象”――这也是为什么要避免不必要的继承的另一个原因，因为不必要的继承总是意味着不必要的耦合。
如果想给一个构造函数加上空throw规范，我们就得确认：所有的基类和成员子对象绝对不会抛出异常――无论它们有没有提供throw规范来表明这一点。构造函数上的空throw规范意味着向世界宣告：构造永远不会失败。如果出于某种原因它实际上会失败，那么，这个空throw规范就不合适。
如果你为构造函数写了一个空throw规范，但某个基类或成员子对象的构造函数真的会抛出异常，那将会发生些什么，简短的回答是：会去执行terminate()，会直接执行terminate()，不会经过try。稍微详细一点的回答是：函数unexpected()会被调用，它有两个选择――一个选择是：抛出或重新抛出异常规范所允许的一个异常（这不可能，因为它是空的，不允许抛出任何异常）；另一个选择是：调用terminate()。而terminate()会立即中止程序。
正如Exceptional C++条款8至19反复强调的那样：使用“有拥有权的对象（owning object）”，并运用“资源获取才是初始化”的策略来管理资源。这样，在你的代码中，你往往可以避免写try和catch，更不用说function try block了。
//------------------------------------------------------------------------------------------------
//More Exceptioanl C++ 条款19：未捕获的异常
#include <iostream>
#include <exception>
using namespace std;

class Test
{
public:
	~Test()
	{
		cout << uncaught_exception() << endl;
	}
};

int main(int argc, char* argv[])
{
	try
	{
		Test t;
		throw out_of_range("abc");
	}
	catch(exception& e)
	{
		cout << e.what() << endl;
	}
}

正确的方案
T::~T()/*throw()*/
{
	//不会抛出异常的代码
}
上例演示了如何在设计中明作决断，而不作无意义的拖沓。
注意，为了表示不抛出异常，这个throw()的规范只是作为注释出现在代码中。这是我所采用的编码风格，其部分原因在于：实际上，异常规范没有像它所吹嘘的那样带来多少好处。是否真的要写一个异常规范，只是你的喜好问题。重要的在于，这个函数真的不会产生异常。
如果需要，T可以提供一个“用在析构之前的函数”（例如T::close()），这个函数可以抛出异常，并针对T对象及其拥有的所有资源执行终止（shutdown）操作。采用这种方法，在调用者代码需要检测严重错误的时候，它就可以调用T::close()；T::~T()可以用T::close()加上一个try/catch block来实现：（与Effective C++ 条款8提到的一样）
T::close()
{
	//...会抛出异常的代码
}

T::~T()/*throw()*/
{
	try
	{
		close();
	}
	catch(...){	}
}
设计准则：决不允许异常从析构函数抛出。写析构函数的时候，就像它已经有了一个throw()异常规范一样（至于这个throw规范是否真的出现在代码中，这纯属个人喜好问题。）
设计准则：如果析构函数调用了一个可能会抛出异常的函数，一定要将这个调用包装在try/catch block中，以防止异常逃出析构函数。

抱歉，作者不知道uncaught_exception()有什么既好又安全的用途，建议是：不要用它。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款20：未管理指针存在的问题，之一：参数求值
C++标准没有提及线程，所以，不考虑线程的话，第一个问题的答案依赖以下基本规则：
（1）在函数调用之前，对函数所有参数的求值必须全部完成。这包括，如果函数参数是表达式，那么，表达式所产生的任何副作用也得全部完成。
（2）一旦一个函数开始执行，调用者函数中的表达式将不会开始求值或继续求值，直至被调用函数执行结束。函数执行永远不会交叉（interleave）进行。
（3）如果函数参数是表达式，这些表达式通常可以按任何次序求值，包括交叉求值，除非另有其它规则限制。
f(expr1, expr2);
上例能够作出的结论只能是：expr1和expr2都必须在f()调用之前求值。
f(g(expr1), h(expr2));
上例，函数和表达式的运算会在遵循以下规则的基础上以任意次序进行：
1. expr1必须在g()被调用前求值。
2. expr2必须在h()被调用前求值。
3. g()和h()都必须在f()被调用前执行完毕。
4. expr1和expr2的求值可以交叉进行，但任何函数调用不能交叉执行。例如，从g()开始执行到结束，不可能有“expr2中的某部分被求值”或“h()的某部分在执行”的情况发生。（Effective C++条款17）
例如，下面这些情况是可能的，甚至还有更多的可能：
1. g()或h()都有可能被先调用。
2. expr1开始运算，然后被h()调用中断，然后又继续执行运算，直至结束。（expr2和g()也类似。）

//在某个头文件中：
void f(T1*, T2*);
//在某个实现文件中：
f(new T1, new T2);

new表达式实际上做些什么（不考虑in-place和数组形式）：
1. 分配内存；
2. 在内存中构造一个新对象；
3. 如果由于异常导致构造失败，已分配内存被释放。
所以，每一个new表达式实质上由两个连续的函数调用构造：首先调用operator new()（要么是全局的那个，要么由被创建对象的类型提供），然后调用构造函数。
如果编译器如下生成代码：
（1）为T1分配内存
（2）构造T1
（3）为T2分配内存
（4）构造T2
（5）调用f()
如果3，4步失败，C++标准不会要求T1对象被摧毁并释放内存，典型的内存泄漏。
另一种可能事件顺序是：
（1）为T1分配内存
（2）为T2分配内存
（3）构造T1
（4）构造T2
（5）调用f()
这一顺序不只产生一个问题，而产生两上具有不同后果的异常安全问题：
（a）如果异常导致第（3）步失败，那么，为T1对象分配的内存会被自动释放（第（1）步操作被撤消），但C++标准没有要求释放“为T2对象分配的内存”，内存泄漏了。
（b）如果因为异常导致第（4）步失败，那么，T1对象此时已经被分配并完全构造，但C++标准没有要求将其摧毁并释放其内存，T1对象泄漏了。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款21 未管理指针存在的问题，之二：使用auto_ptr？
//在某个头文件中
void f(auto_ptr<T1>, auto_ptr<T2>);
//在某个实现文件中
f(auto_ptr<T1>(new T1), auto_ptr<T2>(new T2));
只是真正被交给了有管理能力的auto_ptr之后，资源都是安全的。但这里，在任何一个auto_ptr的构造函数执行之前，前面说过的问题还是会发生。只不过，这一次，在执行次序的后期，f()之前，多了auto_ptr的构造函数。这是一个例子：
（1）为T1分配内存
（2）构造T1
（3）为T2分配内存
（4）构造T2
（5）构造auto_ptr<T1>
（6）构造auto_ptr<T2>
（7）调用f()
类似的，如果第3或第4步中的任何一个抛出异常，同样的问题还是会发生。类似的：
（1）为T1分配内存
（2）为T2分配内存
（3）构造T1
（4）构造T2
（5）构造auto_ptr<T1>
（6）构造auto_ptr<T2>
（7）调用f()
相同问题还是会发生。
但幸运的是，这并非auto_ptr的罪过；在这里，我们是在以错误的方式使用auto_ptr，仅此而已。

演示如何写一个auto_ptr_new工具，用来解决问题1中的安全问题，并且可以通过如下方式调用：
void f(auto_ptr<T1>, auto_ptr<T2>);

f(auto_ptr_new<T1>(), auto_ptr_new<T2>());

最简单的方案，提供一个像下面这样函数模板：
//例21-2（a）：不完整的方案
template<typename T>
auto_ptr<T> auto_ptr_new()
{
	return auto_ptr<T>(new T);
}
如下顺序：
（1）调用auto_ptr_new<T1>()
（2）调用auto_ptr_new<T2>()
如果第（1）步抛出异常，没有内存泄漏，因为auto_ptr_new()模板本身具有强烈的异常安全性。
如果第（2）步抛出异常，通过第（1）步创建的临时auto_ptr<T1>对象一定会被清除。这里的auto_ptr<T1>实际上是个临时变量，而“清除临时变量”在标准中是有明文规定的。以下摘自标准第12.2/3 节：
摧毁临时对象是“从（代码书写的角度来看）这个对象被创建时所在的整个表达式”运算的最后一步。即使那个表达式以抛出一个异常结束，也是如此。
但例21-2（a） 是一个有局限性的方案：它只对缺省构造函数有效，如果某个T没有缺省构造函数，或者你不想使用缺省构造函数，方法就行不通。
//例21-2（b）改进方案
template<typename T>
auto_ptr<T> auto_ptr_new()
{
	return auto_ptr<T>(new T);
}
template<typename T, typename Arg1>
auto_ptr<T> auto_ptr_new(const Arg1& arg1)
{
	return auto_ptr<T>(new T(arg1));
}
template<typename T, typename Arg1, typename Arg2>
auto_ptr<T> auto_ptr_new(const Arg1& arg1, const Arg2& arg2)
{
	return auto_ptr<T>(new T(arg1, arg2));
}
//其它
现在，auto_ptr_new()可以充分、自然地支持非缺省构造函数。

一个更好的方案
通过更好的编程规范来避免这些问题：
在一个表达式中，如果其它代码有可能抛出异常，就绝对不要在这个表达式中分配资源（例如，通过new）。即使通过new获得的资源会立即在同一个表达式中被管理起来（例如，被传给一个auto_ptr的构造函数），也不要这样做。
对于上例，遵循这一规范的做法是，将其中一个临时auto_ptr对象放进一个独立的命名变量中：
//例21-1（a）：一个方案
//某个头文件中
void f(auto_ptr<T1>, auto_ptr<T2>);
//某个实现文件中
{
	auto_ptr<T1> t1(new T1);
	f(t1, auto_ptr<T2>(new T2));
}
这符合上面的规范，虽然我们还是分配资源，但它不会因为某个异常而被泄漏，因为它不是一个“有其它代码会抛出异常”的表达式中创建的。
这里还有另外一条可能的编程规范，它更简单、更容易做到（在阅读代码的时候更容易让人理解）：在各自独立的程序中执行每一个显式的资源分配（例如，new），并将（通过new）分配的资源立即交给管理者对象（例如，auto_ptr）。
遵循第2条规范的做法是，将两个临时auto_ptr对象分别放进各自的命名变量中：
//例21-1（b）：一个更简单的方案
//某个头文件中
void f(auto_ptr<T1>, auto_ptr<T2>);
//某个实现文件中
{
	auto_ptr<T1> t1(new T1);
	auto_ptr<T2> t2(new T2);
	f(t1, t2);
}
这符合第2条规范。

设计准则：在各自独立的程序语句中执行每一个显式的资源分配（例如，new），并将（通过new）分配的资源立即交给管理者对象（例如，auto_ptr）。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款22：异常安全与类的设计，之一：拷贝赋值
规范的Abrahams保证：
1. 基本保证（basic guarantee）
2. 强烈保证（strong guarantee）
3. 不抛出异常保证（nothrow guarantee）：在任何条件下，函数都不会产生异常。有时，除非某些函数保证不抛出异常（例如，析构函数、资源释放函数），否则不可能实现强烈保证甚至基本保证。标准auto_ptr的一个重要特性是，auto_ptr操作决不会抛出异常。

具有强烈异常安全性的“拷贝赋值”规范形式：
包括两步：首先，提供一个不抛出异常的Swap()函数，用以交换两个对象的内容，或内部状态：
void T::swap(T& other)/*throw()*/
{
	//...交换*this和other的内容
}
接着，运用“创建一个临时对象然后交换”的手法来实现operator=()：
T& T::operator=(const T& other)
{
	T temp(other);//先在一旁完成所有的工作
	swap(temp);//然后“提交”工作，仅使用
	return *this;//不抛出异常的操作
}

Cargill Widget范例
下面这个类：
//例22-1：Cargill Widget范例
class Widget
{
public:
	Widget& operator=(const Widget&);
private:
	T1 t1_;
	T2 t2_;
};
假设T1或T2的某一操作会抛出异常。如果不改变类的结构，可能写出一个具有强烈异常安全性的Widget::operator=(const Widget&)吗？

简而言之：不改变Widget的结构一般无法达成异常安全。上例中，根本不可能写出一个安全的Widget::operator=()。如果有异常抛出，甚至不能保证Widget对象会最终处理某种调和状态，因为我们无法以原子操作的方式改变t1_和t2_成员的状态；或者，在中途出错的情况下，我们甚至不能可靠地回退到某种一致（相同或不同）的状态。

通用技术：使用Pimpl手法
尽管不改变Widget的结构就无法使得Widget::operator=()具有强烈的异常安全性，但通过以下面这个简单的转换手法，我们总可以实现一个具有“近乎”强烈异常安全性的赋值。即：通过“指针”而不是“值”来拥有成员对象，最好是运用Pimpl转换手法，将一切都隐藏在单个指针之后。（关于Pimpl手法的更详细介绍，包括使用它所带来的成本以及如何降低那些成本，请参见Exceptional C++条款26至30.）
//例22-2：Cargill Widget范例的通用解决方案
class Widget
{
public:
	Widget();//用新的WidgetImpl来初始化pimpl_
	~Widget();//这个析构函数必须提供，因为隐式生成的版本会导致使用上问题（参见条款30和31）
private:
	class WidgetImpl;
	auto_ptr<WidgetImpl> pimpl_;
	//...提供可以正常工作的拷贝构造函数，或者禁止它
};
//然后，一般是一个单独的实现文件中：
class Widget::WidgetImpl
{
public:
	T1 t1_;
	T2 t2_;
};
请注意，如果使用auto_ptr成员，那么：
（a）要么，你必须将WidgetImpl的定义提供给Widget；要么，如果你想隐藏WidgetImpl，你就必须为Widget写一个自己的析构函数，即使这个析构函数很简单；（这解释了之前数据成员auto_ptr对象指针变量必须完整定义或必须声明析构函数的问题？？？）
注：如果使用编译器自动生成的析构函数，那个析构函数将被定义在每个编译单元（translation unit）中，因而，WidgetImpl的定义必须在每个编译单元可见。
（b）对于Widget，你还应该提供自己的拷贝构造和赋值函数，因为一般来说，你不会希望类的成员具有“拥有权转移”的语义。如果有另外一种智能指针，你也可以考虑用它来取代auto_ptr，但上述原则依然重要。

现在，可以很容易地实现一个不抛出异常的swap()，这意味着，我们可以很容易地写出一个“近似满足强烈异常安全保证”的拷贝赋值函数。首先，提供一个不抛出异常的swap()函数，用以交换两个对象的内容（状态）。注意，这个函数确实能够提供不抛出异常的保证，即，在任何情况下它都不会有异常抛出，因为auto_ptr操作不允许抛出异常：
void Widget::swap(Widget& other)/*throw()*/
{
	auto_ptr<WidgetImpl> temp(pimpl_);
	pimpl_ = other.pimpl_;
	other.pimpl_ = temp;
}
注，如果将这个有三行代码的swap函数体用单行的swap(pimpl_, other.pimpl_);来代替，就不一定会工作正常，因为，对于auto_ptr，std::swap()不一定会正常工作。
然后，通过“创建一个临时对象然后交换”的手法实现operator=()，从而达成operator=()常见的异常安全形式：
Widget& Widget::operator=(const Widget& other)
{
	Widget temp(other);//先在一旁完成所有的工作
	swap(temp);//然后“提交”工作，仅使用
	return *this;//不抛出异常的操作
}
这具有“近似”强烈的异常安全性。如果一个异常抛出，它不绝对保证程序状态会完全保持不变。因为，我们创建临时Widget对象并因此创建pimpl_的t1_和t2_成员的时候，那些成员的创建（以及/或者析构――如果操作失败的话）可能会有副作用，比如修改一个全局变量，对于这一点，我们无法知晓，也无法控制。

Pimpl转换手法的确是一个普遍方案，利用它，即使对类数据成员的安全性一无所知，你也可以写出一个可以提供异常安全保证（的确，近似强烈保证）的类。

结论1：异常安全影响到类的设计
异常安全绝对不只是“一个实现细节”。Pimpl转换是一种简单直接的“结构上的改变”，但毕竟是个改变。
结论2：总能让你的代码具有（近似）强烈的异常安全性
重要论断：仅仅因为你所使用的类不具有起码的异常安全性，就说使用这个类的代码不能做到强烈的异常安全（副作用除外），这是没有道理的。
局部强烈保证：如果有异常抛出，就“正在被操作的对象”而言，程序状态保持不变，这一级别总是意味着局部“提交或回退（commit-or-rollback）”语义，这包括：如果操作失败，指向容器内部的引用或迭代器不会失效。
对于这种“将细节隐藏在指针之后”的技术，Widget的实现者和Widget的用户都可以做得很好。但如果是由Widget的实现者来做，它就总会是安全的，用户就不必做下面这样的事：
//例22-3：如果Widget的设计者没有那样做，用户就必须得做
class MyClass
{
	auto_ptr<Widget> w_;//通过一定的距离保存“拷贝操作不安全”的Widget
public:
	void swap(MyClass& other)/*throw()*/
	{
		auto_ptr<Widget> temp(w_);
		w_ = other.w_;
		other.w_ = temp;
	}
	MyClass& operator=(const MyClass& other)
	{
		MyClass temp(other);
		swap(temp);
		return *this;
	}
	//...提供可以正常工作的析构函数，拷贝构造和赋值函数，或者禁止它们
};

结论3：明智地使用指针
每当谈到EH（Exception Handling，异常处理），告诉大家两件事：
（1）指针是你的敌人。因为它们带来的种种问题正是auto_ptr想要消除的。
就是说，普通指针通常应该被管理者对象拥有，这个管理者对象拥有所指向的资源，并自动执行清理工作。
（2）指针是你的朋友。因为指针上的操作不会抛出异常。
实践中，可以在夹缝中做得最好，也应该做到最好。
1. 使用指针，因为指针上的操作不会抛出异常。
2. 和它们保持友好，将它们包装在auto_ptr这样的管理者对象中，这将保证正确的清理工作。这不会使指针“不抛出异常”的优点打折扣，因为auto_ptr操作同样绝不会抛出异常（而且只要需要，总可以得到auto_ptr内部真正的指针――如，通过auto_ptr::get()）。
通常，实现Pimpl手法的最好方式是例22-2 中所演示的那样，使用一个指针（以利用操作不抛出异常的优点），同时还将动态资源安全地包装在一个管理者对象中（此例中，是一个auto_ptr）。请记住，如果使用了auto_ptr，你的类就必须提供自己的具有正确语义的析构函数、拷贝构造函数和赋值操作符；或者，如果拷贝构造和赋值操作符对你的类没有用，你可以禁止掉它们。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款23：异常安全与类的设计，之二：继承
Is-Implemented-In-Terms-Of
Is-A（是一个）――更准确地称为“Is-Substitutable-For-A（可以替换为一个）”――必须符合Barbara Liskov的可替换原则（LSP，Substitutable Principle），这条原则中，定义了“类型S可以替换为类型T”的定义：
如果对于类型S的每一个对象o1，都有类型T的一个对象o2，使得在“用类型T定义的所有程序P”中，o1替换o2后P的行为不变，那么S是T的一个子类型（subtype）。
所有的公有继承都应该符合LSP，从而保证可替换性；Is-A就常被用来描述这种公有继承。
但要记住的重要一点，在C++中有很多方式可以表示“Is-A”，比仅限于继承这一范围所能想象的要多。Is-A还可以用来描述“支持相同接口但（从继承的角度来看）不相关”的类，这些类可以相互替换地用于“具有公共接口的模板化代码”中。LSP也适用于这种形式的可替换性，就像它适用于其它形式一样。例如，这种形式下，“X Is-A Y”或“X Is-Substitutable-For-A Y”表示：如果模板化代码接受类型Y的对象，那么，它也会接受类型X的对象，因为X和Y都支持相同的接口。

代码中另一个同样常见的关系是Is-Implemented-In-Terms-Of（用。。。来实现），或简称为IIITO。如果T在它的实现中以某种形式使用了另一种类型U，就称“T IIITO U”。“以某种形式使用”这一措词留了很大余地，它表示的范围很广，如，T可以是U的一个适配器（adapter）、代理（proxy）或包装类（wrapper）；或者，T仅仅只是在它的实现形式中偶尔用到了U。
“T IIITO U”通常意味着：要么，T有一个U（T Has-A U），如例23-1 （a）所示：
//例23-1（a）：运用Has-A
class T
{
private:
	U* u_;//或者，通过“值”或“引用”
};

要么，T非公有派生于U，如例23-1 （b）所示：
//例23-1（b），运用派生
class T: private U
{
	//...
};

一条有效的工程设计原则是：将耦合性降至最低。如果一种关系（relationship）可以用多种有效方式来表达，请使用关系最弱（松散）的那一个。继承近乎是C++中可以表达的最强烈（紧密）的关系――仅次于友元，那么，只有在没有更弱的关系可供选择时，使用它才合适 。如果仅用委托就可以表达出类的关系，应该总是优先选择委托。
耦合性原则是这样描述的：
低耦合性提高程序的正确性（包括异常安全），高耦合性降低程序的“最大可能的正确性”（包括异常安全）。

先看看，如果用Has-A来表达IIITO关系，应当怎样写出T::operator=()
//例23-2（a）：运用Has-A
class T
{
private:
	U* u_;
};
T& T::operator=(const T& other)
{
	U* temp = new U(*other.u_);//先在一旁完成所有工作
	delete u_;
	u_ = temp;//然后“提交”工作，仅使用不抛出异常的操作
	return *this;
}
不需要对U做任何假设，我们可以写出一个具有“近似”强烈异常安全性的T::operator=()，当然，U可能产生副作用的情况除外。（这里的强烈安全性并不是说不抛异常，而是说如果抛出异常，可以保证状态不变。所以说如果有两个对象，把这两个对象封装在指针中，就可以先new出两个对象的指针，如果没有抛异常，则用不会抛异常的指针交换赋值，如果抛异常了，则两个对象的状态都没有改变，所以说异常安全强烈保证。）
可见，委托（Has-A）给了我们很大的灵活性，它让我们可以很容易地写出一个具有一定异常安全性的T::operator=()，但无需对U做任何假设。

再看看，T和U涉及到任何方式的继承：
//例23-1（b），运用派生
class T: private U
{
	//...
};
T& T::operator=(const T& other)
{
	U::operator=(other);//???
	return *this;
}
问题出在对U::operator=()的调用。正如条款22副栏中提到的，如果U::operator=()可以在“已经开始修改目标的情况下”抛出异常，我们就无法写出一个具有强烈异常安全性的T::operator=()，除非U通过其它某个函数提供了合适的功能。（但如果U可以那么做，为什么不让U::operator=()也那么做呢？）
换句话说，现在，T为它的成员函数T::operator=()提供异常安全保证的能力必然依赖于U的安全和保证。正是在表达T和U之间的联系时，例23-2 （b）使用了最大可能的紧密关系，从而导致了最大可能的耦合性。

总结：
松散的耦合促进程序的正确性（包括异常安全），紧密的耦合降低程序的“最大可能的正确性”（包括异常安全）。
无论何时都要做到将耦合性降至最低。如果类的有关系可以用多种方式表达，请使用关系最弱的那个有效方式。特别是，只有在委托不能独立完成使用情况下，我们才会使用继承。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款24：为什么要使用多继承？
多继承（MI，即multiple inheritance），指的是从多个（多于一个）直接基类（direct class）继承的能力。
C++中引入MI带来的可能性是：一个类的同一个（直接或间接）基类（base class）可能会不只一次地作为它的基础类（ancestor）出现。
钻石形状继承图B-C1-D、B-C2-D。这里，B两次作为C的间接基类出现。
这种情况下，很有必要引入C++的另一个特性：虚拟继承。现在问题是：程序员希望D拥有基类B的一个子对象还是两个？如果答案是一个，B就应该是一个虚拟基类；如果答案是两个，B就应该是一个普通（非虚拟）基类。
虚拟基类的主要复杂性在于：它们必须通过最底层的派生类（most-derived class）直接初始化。
设计准则：
避免多继承自多个“非protocol类”。（protocol类是一种抽象基类（abstract base class），或简称ABC，它完全由纯虚函数组成，没有数据成员。）

MI必要吗？
简短回答：只要程序可以用汇编语言（或更低级的语言）来写，就能说某些特性绝对“必要”。
如果在使用MI时有欠考虑，它的确会招致不必要的耦合性和复杂性。然而，任何一种被误用的继承都是这样（参见Exceptional C++条款24），但大家不会就此认为继承不是一个好东西。还有，在完全不使用MI的情况下，任何程序都可以写出来，但你也得知道，在完全不使用继承的情况下，任何程序也都可以写出来。任何程序都可以用汇编语言写出来，但这并不是说用汇编语言来写程序就一定是个好主意。

什么时候使用MI才算合适？
简而言之，只有在每一个继承单独取出来看都合适的时候，这样的MI才算合适。Exceptional C++条款提供了一个相当详尽的列表，说明了什么时候该使用继承（去看？）
现实中，MI应用大多逃不出以下三类：
（1）结合使用程序模块或程序库。很多类被设计为基类――即，在使用时你得从它继承。如果想写一个类，它用到了两个程序库，但每个程序库都要求你从它的某个类继承，这时候怎么办？
这种情况下，一般无法通过修改程序库代码来避免某个继承。这时MI就是必要的：没有其它（自然的）方法可以帮助你去做你必须做的事；此时，使用MI完全合理。
在实践中，知道如何运用MI来结合使用供应商提供的程序库，这是每一个C++程序员必须具备的素质。
（2）Protocol类（interface类）。C++中，MI最合适、最安全的应用是定义procotol类――即，完全由纯属虚函数构造的类。由于这种基类没有数据成员，MI臭名昭著的复杂性得以完全避免。
（3）易于（多态）使用。有了继承，在接受基类对象的任何代码中，我们就都可以使用派生对象。在某些场合，如果同一个派生对象可以代替数种基类对象使用，那将会很有用处，这正是MI大显身手的地方。

注意，第（3）点在很大程序上与第（1）、（2）点重叠。在实施另两点之一时，同时、并出于相同的理由运用第（3）点，往往很有用处。

还要考虑另一点：有时候，单纯从两个不同的基类继承并没有必要，相反，我们要让每一个继承都有不同的理由。“多态的LSP Is-A公有继承”并非唯一故事（参见条款23）；使用继承还有很多其它可能的原因。例如，一个类可能需要从一个基类A私有继承，以获得对类A的保护成员的访问权，同时，它还要从另一个基类B公有继承，以多态地实现类B的某个虚函数。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款25：模拟多继承
#include <iostream>
#include <string>
using namespace std;

class A
{
public:
	virtual ~A() { }
	string name()
	{
		return doName();
	}
private:
	virtual string doName()
	{
		return "A";
	}
};

class B1: virtual public A
{
	virtual string doName()
	{
		return "B1";
	}
};

class B2: virtual public A
{
	virtual string doName()
	{
		return "B2";
	}
};

class D: public B1, public B2
{
	virtual string	doName()
	{
		return "D";
	}
};

void f1(A& x)
{
	cout << x.name() << endl;
}

void f2(B1& x)
{
	cout << x.name() << endl;
}

void f3(B2& x)
{
	cout << x.name() << endl;
}

void g1(A x)
{
	cout << x.name() << endl;
}

void g2(B1 x)
{
	cout << x.name() << endl;
}

void g3(B2 x)
{
	cout << x.name() << endl;
}

int main(int argc, char* argv[])
{
	D d;
	B1* pb1 = &d;
	B2* pb2 = &d;
	B1& rb1 = d;
	B2& rb2 = d;
	
	f1(d);
	f2(d);
	f3(d);

	g1(d);
	g2(d);
	g3(d);

	cout << ((dynamic_cast<D*>(pb1) != 0) ? "ok" : "bad") << endl;
	cout << ((dynamic_cast<D*>(pb2) != 0) ? "ok" : "bad") << endl;

	try
	{
		dynamic_cast<D&>(rb1);
		cout << "ok" << endl;
	}
	catch(...)
	{
		cout << "bad";
	}

	try
	{
		dynamic_cast<D&>(rb2);
		cout << "ok" << endl;
	}
	catch(...)
	{
		cout << "bad";
	}
}
输出如下：
D
D
D
A
B1
B2
ok
ok
ok
ok
请按任意键继续. . .

不运用MI，写一个与上面等价（或尽可能接近）的类D，即，在不使用多继承的情况下，演示出能找到的“拐弯抹角解决问题”的最好方法。要让D得到相同的效果和可用性，同时又要尽量避免对调用者代码的句法做修改，如何做到？
#include <iostream>
#include <string>
using namespace std;

class A
{
public:
	virtual ~A() { }
	string name()
	{
		return doName();
	}
private:
	virtual string doName()
	{
		return "A";
	}
};

class B1: virtual public A
{
	virtual string doName()
	{
		return "B1";
	}
};

class B2: virtual public A
{
	virtual string doName()
	{
		return "B2";
	}
};

class D: public B1
{
public:
	class D2: public B2
	{
	public:
		void set(D* d)
		{
			d_ = d;
		}
	private:
		virtual string doName()
		{
			return d_->doName();
		}
		D* d_;
	} d2_;
	D()
	{
		d2_.set(this);
	}
	D(const D& other): B1(other), d2_(other.d2_)
	{
		d2_.set(this);
	}
	D& operator=(const D& other)
	{
		B1::operator=(other);
		d2_ = other.d2_;
		d2_.set(this);
		return *this;
	}
	operator B2&()
	{
		return d2_;
	}
	B2& asB2()
	{
		return d2_;
	}

private:
	virtual string doName()
	{
		return "D";
	}
};

void f1(A& x)
{
	cout << x.name() << endl;
}

void f2(B1& x)
{
	cout << x.name() << endl;
}

void f3(B2& x)
{
	cout << x.name() << endl;
}

void g1(A x)
{
	cout << x.name() << endl;
}

void g2(B1 x)
{
	cout << x.name() << endl;
}

void g3(B2 x)
{
	cout << x.name() << endl;
}

int main(int argc, char* argv[])
{
	D d;
	B1* pb1 = &d;
	B2 *pb2 = &d.asB2();
	B1& rb1 = d;
	B2& rb2 = d;
	
	f1(d);
	f2(d);
	f3(d);

	g1(d);
	g2(d);
	g3(d);

	cout << ((dynamic_cast<D*>(pb1) != 0) ? "ok" : "bad") << endl;
	cout << ((dynamic_cast<D*>(pb2) != 0) ? "ok" : "bad") << endl;

	try
	{
		dynamic_cast<D&>(rb1);
		cout << "ok" << endl;
	}
	catch(...)
	{
		cout << "bad";
	}

	try
	{
		dynamic_cast<D&>(rb2);
		cout << "ok" << endl;
	}
	catch(...)
	{
		cout << "bad" << endl;
	}
}
输出如下：
D
D
D
A
B1
B2
ok
bad
ok
bad
请按任意键继续. . .

不足：
这个方案漂亮地实现了MI，模拟了MI的大多数行为，只要你依照编程规范填补上没有完全实现的部分，它就可以支持MI的所有应用，下面特别列出这个方案的一些缺点，说明MI的哪一部分特性没有完全实现。
1. 由于提供了operator B2&()，较之指针，引用就得特殊（不一致地）对待。
2. 将D作为B2使用时，调用者代码必显式地调用D::asB2()。（这意味着，在测试程序中，必须将“B2* pb2 = &d;”修改为“B2* pb2 = &d.asB2();”）（这里需要的&B2，但是D中的operator B2&()并不知道需要的&B2，所以要由调用者手动调用d.asB2()；与之比较的“B1& rb1 = d;”可以自己由D引用到B1，和“B2& rb2 = d;”的等号前是B2&，程序自己知道调用operator B2&()）
3. 不能通过dynamic_cast将D*转换为B2*。（应该是将B2*转换到D*吧？好像B2&也不能转换到D&）（如果不在意使用预见处理，你可以重新定义dynamic_cast，就有可能解决这一问题，但那是一个万不得已的方案）

你可能已经发现：和多继承所给出的内存而已相比，D对象的内存与之类似。这是因为，我们在尽力模拟MI――虽然我们没有利用语言本身所提供的语法上的所有好处和便利。

你可能不是经常需要MI，但当你需要它的时候，你是“真的”需要。（访问者模式也提到了这句话？）。本条款在于说明：对于这种有用的特性，如果语言提供了必要的支持，就远比你自起炉灶要好得多――即使你可以结合其它语言特性和编程规范完全模拟出它的功能。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款26：多继承与连体双婴问题
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class BaseA
{
public:
	virtual ~BaseA() { }//基类一定要写析构函数，一定要加virtual，切记！！！系统自动生成的是不会有virtual的。另外单继承如果不写析构函数是没有问题的，多重继承不写析构函数就会出错，有可能是内存布局的相关问题，相同的内存被重复删除导致出错
	virtual void show()
	{
		cout << "BaseA::show()" << endl;
	}
};

class BaseB
{
public:
	virtual ~BaseB() { }
	virtual void show()
	{
		cout << "BaseB::show()" << endl;
	}
};

class Derived: public BaseA, public BaseB
{
public:
	virtual void show()
	{
		cout << "Derived::show()" << endl;
	}
};

int main(int argc, char* argv[])
{
	auto_ptr<BaseA> pba(new Derived);
	pba->show();
	auto_ptr<BaseB> pbb(new Derived);
	pbb->show();
}
通过增加两个中间类解决调用各自函数的问题
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class BaseA
{
public:
	virtual ~BaseA() { }
	virtual void show()
	{
		cout << "BaseA::show()" << endl;
	}
};

class BaseB
{
public:
	virtual ~BaseB() { }
	virtual void show()
	{
		cout << "BaseB::show()" << endl;
	}
};

class BaseA2: public BaseA
{
public:
	virtual void doShowA() = 0;
	virtual void show()
	{
		doShowA();
	}
};

class BaseB2: public BaseB
{
public:
	virtual void doShowB() = 0;
	virtual void show()
	{
		doShowB();
	}
};

class Derived: public BaseA2, public BaseB2
{
public:
	virtual void doShowA()
	{
		cout << "Derived::showA()" << endl;
	}
	virtual void doShowB()
	{
		cout << "Derived::showB()" << endl;
	}
};

int main(int argc, char* argv[])
{
	auto_ptr<BaseA> pba(new Derived);
	pba->show();
	auto_ptr<BaseB> pbb(new Derived);
	pbb->show();
}
BaseA2和BaseB2可能还需要复制（duplicate）BaseA和BaseB的构造函数，使得Derived可以调用到它们。但要做的修改也就这么多。（通常，比“在代码中复制构造函数”更简单的方法是：让BaseA2和BaseB2从基类虚拟继承。这样，Derived就可以直接访问基类的构造函数。）BaseA2和BaseB2是抽象类，所以，它们不需要复制BaseA或BaseB的其它任何函数或运算符，例如赋值运算符。
对于更底层的派生类来说，它们只需要知道：一定不要再次改写show()，如果真这么做，那么中间类中所做的一切努力（更改函数名称）都会付之东流。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款27：（非）纯虚函数
纯虚函数（pure virtual function）首先是一个虚函数，此外，它强制实体派生类（concrete derived class）必须对它进行改写。一个类如果存在任何未改写的纯虚函数，这个类就是一个“抽象”类，你就不能创建那种类型的对象。

在声明一个纯虚函数后，为什么还会为它提供定义（函数体）？尽可能多地列举出这样做的理由和场合。
1） 纯虚析构函数
所有基类的析构函数要么应该是虚拟公有成员，要么应该是非虚拟保护成员。简单地说，这是因为：首先，要记住，你应该总是避免从实体类（concrete class）派生。因而，假设基类不是实体类，那么，它就不会出于“实例化自身”的目的而去提供一个公有析构函数（就是说，基类是抽象类，是否可以有数据成员？好像没有影响，就算有数据成员，也不会实体化，也就是说不会出现需要析构的情况，因此也就不会需要公有析构函数）。这样，你就只剩下两个选择：
（a）要么，你需要“通过基类指针进行多态删除”的功能，这种情况下，析构函数必须是虚拟公有成员；
（b）要么，你不需要这一功能，这种情况下，析构函数应该是非虚拟保护成员――之所以是保护成员，是为了防止被滥用。
如果一个类应该是抽象类（你想禁止将其实例化），但它没有其它任何纯虚函数，而有一个公有析构函数，那么，请将这个析构函数声明为纯虚函数（如上段所述，无论如何它也应该这样）。
//例27-2(a)
//文件b.h
class B
{
public:
	virtual ~B() = 0;//纯虚析构函数
};
当然，任何派生类的析构函数必须隐式地调用基类的析构函数，所以，析构函数还是得定义（即使为空）。
//文件b.cpp
B::~B() {/*可能为空*/}
如果不提供这个定义，你还是可以让其它类从B派生，但那些派生类就不能被实例化，从而没有什么特别的用处。
设计准则：
基类的析构函数要么是虚拟公有成员，要么是非虚拟保护成员。
2） 明确使用缺省行为
如果派生类没有改写某个普通的虚函数，它就会默认地继承基类中的行为。如果想提供一个默认行为但又不想让派生类这么“无声无息”地继承，你可以声明一个纯虚函数并依然提供缺省实现；这样，派生类的设计者如果想使用它，就必须主动对它进行调用。
//例27-2(b)
class B
{
protected:
	virtual bool f() = 0;
};
bool B::f()
{
	return true;//这是一个不错的缺省实现，但不应该被派生类稀里糊涂地使用
}

class D: public B
{
	virtual bool f()
	{
		return B::f();//如果D需要缺省行为，就必须像这样明确地说出来
	}
};
在Gamma等四人所著的Design Patterns【Gamma95】一书中，State模式就是这样一个例子，它演示了如何将这一技术加以有效地利用。（不太懂跟状态模式什么关系？）

3） 提供部分行为
有时，我们需要向派生类提供“部分行为”（partial behavior），同时，这个派生类还必须保持完整。这是一种很有价值的应用。其设计思想是：在派生类中，将基类实现作为派生类实现的“一部分”来执行。
//例27-2(c)
class B
{
protected:
	virtual bool f() = 0;
};

bool B::f()
{
	//执行某一通用操作
}

class D: public B
{
	virtual bool f()
	{
		//首先，使用基类的实例
		B::f();
		//...现在，做其它工作
	}
};

4） 应付功能不足的编译器诊断程序
有些情况下，你会无意中调用了一个纯虚函数（间接地从基类的构造函数或析构函数调用；具体例子请参数最常用的高阶C++书籍。Effective C++中说的不要在构造函数和析构函数中调用虚函数？）
在出现这种问题时，并不是所有的编译器都会确切地告诉你问题所在。因为这是“不可预测行为”的表现之一。
要想避免这种调试时间上的浪费，一个办法是：为这种永远不应该被调用的纯虚函数提供定义，并在那些定义中置入一些恶性代码。这样，如果无意中调用了那些函数，你就会立刻知道。
//例27-2(d)
class B
{
public:
	bool f();//可能会提供这个函数调用do_f()（非虚拟Interface模式）
private:
	virtual bool do_f() = 0;
};

bool B::do_f()//这个函数永远不应该被调用
{
	if (promptUser("pure virtual B::f called--abort or ignore") == Abort)
	{
		dieDieDie();
	}
}
在公有的dieDieDie()函数中，你可以对系统进行任何操作：让程序进入调试器，或者导出堆栈数据，或者得到诊断信息。下面是一些常用方法，在大多数系统中，它们会将你带入调试器。选择你喜欢的一个吧。
void dieDieDie()//C风格的方法：用一个null指针乱写，这是一个大家都喜欢的方法
{
	memset(0, 1, 1);
}

void dieDieDie()//另一个C风格的方法
{
	abort();
}

void dieDieDie()//C++风格的方法：用一个null数据指针乱写
{
	*static_cast<char*>(0) = 0;
}

void dieDieDie()//C++风格的方法：通过一个null函数指针调用并不存在的代码
{
	static_cast<void(*)()>(0)();
}

void dieDieDie()//展开（unwind）至最后的“catch(...)”
{
	class LocalClass {};
	throw LocalClass();
}

void dieDieDie()//信奉标准者的选择方案
{
	throw std::logic_error();
}

void dieDieDie() throw()//信奉标准者的做法，而且有很好的编译器
{
	throw 0;
}

明白了这一思想，就请举一反三。想有意摧毁一个程序，方法当然不胜枚举；但这里的目的是：让运行时期调试器（runtime debugger）尽可能地将你带到离错误最近的地方。用一个null指针乱写的方法总是很合算。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款28：受控的多态
#include <iostream>
using namespace std;

class Base
{
public:
	virtual ~Base() { }
	virtual void virtFunc() const
	{
		cout << "Base::virFunc()" << endl;
	}
};

class Derived: public Base
{
public:
	virtual void virtFunc() const
	{
		cout << "Derived::virtFunc()" << endl;
	}
};

void someFunc(const Base& b)//这里加了const，所以类成员函数必须提供const版本，否则编译不通过，无法从非const转化到const。另外，加与不加const是两个完全不同的函数，跟重写无关
{
	b.virtFunc();
}

int main(int argc, char* argv[])
{
	Derived d;
	someFunc(d);
}

我们之所以能够在接受Base对象的地方多态地使用Derived对象，原因在于Derived从Base公有继承。
相反，如果Derived从Base私有继承，那么，几乎没有代码可以多态地将Derived作为Base使用。之所以说“几乎”，原因在于：如果代码可以访问Derived的私有成员，它就还是可以访问Derived的私有基类，因而可以动态地将Derived代替为Base使用。正常来说，只有Derived成员函数具有这种访问权。然而，通过C++的友元特性，我们可以将类似的访问权扩充到其它外部代码中。
综合以上分析，得到结果如下：
还有另外两个f1()和f2()。我们的目标是：允许f1()在所有接受Base对象的地方多态地使用Derived对象，但防止其它所有函数（包括f2()）这样做。
void f1()
{
	Derived d;
	someFunc(d);//允许，正确
}

void f2()
{
	Derived d;
	someFunc(d);//想防止这种情况
}

演示如何达到这一效果。
答案如下：
#include <iostream>
using namespace std;

class Base
{
public:
	virtual ~Base() { }
	virtual void virtFunc() const
	{
		cout << "Base::virFunc()" << endl;
	}
};

class Derived: private Base
{
public:
	friend void f1();
	virtual void virtFunc() const
	{
		cout << "Derived::virtFunc()" << endl;
	}
};

void someFunc(const Base& b)
{
	b.virtFunc();
}

void f1()
{
	Derived d;
	someFunc(d);
}

void f2()
{
	Derived d;
	someFunc(d);
}

int main(int argc, char* argv[])
{
	f1();
	f2();
}
将继承类型声明为private，并且将f1()声明为友元函数，则f1()函数可以访问到Derived内部，f2()函数则编译不通过，报如下错误：
“类型转换”: 从“Derived *”到“const Base &”的转换存在，但无法访问

它干净利落地解决了问题――尽管和最初版本相比，f1()获得了更大的访问权。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款29：使用auto_ptr
auto_ptr只是用来包含单个对象，所以，对于自己拥有的指针，auto_ptr总是会调用delete，而不是delete[]。
//在我电脑上直接崩溃了
#include <iostream>
#include <memory>
#include <string>
using namespace std;

int c = 0;

class X
{
public:
	X(): s_("1234567890") 
	{
		++c;
	}
	~X()
	{
		--c;
	}
private:
	string s_;
};

template<typename T>
void f(int n)
{
	{
		auto_ptr<T> p1(new T);
		//auto_ptr<T> p2(new T[n]);//这句出错
	}
	cout << c << " ";
};

int main(int argc, char* argv[])
{
	int i = 0;
	while (++i < 10)
	{
		f<X>(100);
		//f<X>(0);//同样程序出错，不是很理解这句话为什么出问题auto_ptr<X> p2(new X[0]);
	}
}

旁白：零长度数组是合法的
如果f()参数为零会怎么样？第二个new语句就变成了new T[0]。零长度数组完全正确、合法而且简洁。new T[0]的结果是一个指针，指向包含零个元素的数组。这个指针具有的行为特征和其它new[n]的结果一样，包括：对于这个数组，你不可能访问到n个以上的元素。对零长度数组来说，你根本不能访问到任何元素，因为数组中没有元素。
以下摘自C++标准5.3.4 节第7段：
在直接new声明符（direct-new-declarator）中，如果表达式（expression）的值为零，分配函数将被调用，用来分配一个包含零个元素的数组。new表达式（new-expression）返回的指针不是null。【注：如果程序库分配函数被调用，返回的指针不同于指向其它任何对象的指针。】
int main(int argc, char* argv[])
{
	int* pInt = new int[0];
	cout << pInt << endl;
	delete [] pInt;//这里是可以的

	auto_ptr<X> pX(new X[0]);//这里可以正常分配
	cout << "allocate auto_ptr successfully." << endl;//这里也可以运行到
	//但是是在这里pX删除指针时程序中止。
}
零长度数组什么都不能做（除了需要你记住它的地址），它存在的一个重要原因是：有了它，在编写动态数组分配代码时会更容易。例如上面的f()函数，如果在每次执行new T[n]调用时都需要检查参数n的值，代码就会变得不必要的复杂。
回到主要问题：仅仅因为零长度数组合法，并不意味着我们可以让一个auto_ptr拥有这样一个零长度的数组，正如我们不能让auto_ptr拥有一个具有其它长度的数组一样。我们不能！删除数组的问题依然存在。

如何解决这一问题。
方案1：打造自己的auto_array
这一方案可以比听上去更容易，也可以更难。
方案1(a)：...通过从auto_ptr派生（得分：0/10 ）
方案1(b)：通过复制auto_ptr的代码（得分：8/10 ）
取出程序库实现中的auto_ptr代码，复制它（将其更名为auto_array或其它名字），然后将其中的delete语句改为delete []语句。
优点：（a）易于实现（只需一次）。无需手工编写自己的auto_array，但同时，auto_ptr的所有语义自动地得以保留；将来维护这段代码的程序员只要熟悉auto_ptr，就不会对这里的代码大惊小怪。（b）没有空间或时间上的显著开销。
缺点：难以维护。当你升级到新的编译器/程序库版本时，或是更换编译器/程序库供货商时，你得十分小心地使用auto_array与之同步。

方案2：运用Adapter模式（得分：7/10 ）
最简单的办法应该是写一个适配器（adapter）来让标准auto_ptr工作正常，而不是重写auto_ptr，或使用其它什么方法。这个思路尽管还是有有那些一点点缺陷，但的确具有它的优点。
以下就是它设计思想。我们不这么写：
auto_ptr<T> p2(new T[n]);
而这么写：
auto_ptr< ArrDelAdapter<T> > p2(new ArrDelAdapter(new T[n]));
其中，ArrDelAdapter（即Array Deletion Adapter）具有一个“参数为T*指针的构造函数”；在析构函数中，它用那个指针调用delete[]：
template<typename T>
class ArrDelAdapter
{
public:
	ArrDelAdapter(T* p): p_(p) { }
	~ArrDelAdapter() {delete [] p_;}
	//“->”、“T*”等运算符以及其它辅助函数
private:
	T* p_;
};
既然只有一个ArrDelAdapter<T>对象，~auto_ptr()中“单个对象”形式的delete语句就不会有问题。因为~ArrDelAdapter<T>对数组正确地调用了delete []，最初的问题已经得以解决。
这也许是不是世界上最优雅最漂亮的手法，但至少我们无须手工编写自己的auto_array模板。
优点：
（a）易于实现（利用了固有的功能）。我们无须编写auto_array。实际上，我们还自动保留了auto_ptr的所有语义；将来维护这段代码的程序员只要用惯了auto_ptr，就不会对此大惊小怪。
缺点：
（a）可读性差。代码过于唆。
（b）（可能）难以使用。在f中，后面的代码只要使用了p2的值，那些代码就得做句法上的改变；额外的间接性往往会带来更多的麻烦。
（c）带来空间和时间上的开销。这个方案需要额外的空间，因为它需要存储每一个数组所需的Adapter对象。它还需要额外的时间，因为它需要执行多达两次的内存分配（这一点可以通过重载new运算符得以改善），这样一来，调用者代码每次访问数组时，都多了一层间接性。
再补充一句：即使在当前这一特定场合，可能还会有其它更好的方案，但希望大家能够立即想到使用Adapter模式。Adapter模式是广泛应用的核心模式之一，每一位程序员都应该了解它。
设计准则：了解并使用设计模式。
关于方案2，下面这样写：
auto_ptr< ArrDelAdapter<T> > p2(new ArrDelAdapter<T>(new T[n]));
和这样写没有什么大的不同：
auto_ptr< vector<T> > p2(new vector<T>(n));
请思考：和单纯写一句vector p2(n);相比，动态地分配这个vector会有什么好处吗？如果有，好处在哪儿？答案请参见4。（我自己没想出来，这个问题是否可以转化为一个局部对象和new出来的指针对象有什么差别？指针对象占字节小，传递方便，但局部对象也可以通过传引用）

方案3：用手工编写的异常处理逻辑取代auto_ptr（得分：1/10 ）
函数f()之所以要使用auto_ptr，是为了获得对象自动清除的好处，还可能是为了得到异常安全。既然如此，我们可以为p2数组剥掉auto_ptr这层外衣，手工编写自己的异常处理逻辑。
即，我们不这么写：
auto_ptr<T> p2(new T[n]);
//...更多处理
取而代之，我们这么写：
T* p2(new T[n]);
try
{
	//...更多处理
}
delete [] p2;
优点：
（a）易于使用。对于那段使用了p2的“更多处理”的代码块，这个方案几乎不会给它带来影响；需要做的可能只是删除每一个出现的.get()而已。
（b）没有空间或时间上的显著开销。
缺点：
（a）难以实现。这个方案可能涉及大量的代码改动，远远多于上面所提到的工作量。
因此，对于新的T对象，无论函数如何退出，p1的auto_ptr都会自动清除它；然而，要清除p2，针对函数退出时可能经过的每一条路径，我们都必须提供清除代码。例如，考虑这样情形：“更多处理”代码块中包含更多的分支，其中一些分支以“return”结束……
（b）缺乏健壮性。参见（a）：在每一个执行路径上，我们都提供了合适的清除代码吗
（c）可读性差。参见（a）：额外的“清除操作”逻辑很可能掩盖函数的正确逻辑。

方案4：用vector取代数组（得分：9.5/ 10 ）
前面方案中，遇到的大部分问题应该归因于：我们使用的是C风格的数组。一个事实是：只要合适，用vector取代C风格的数组会更好，况且，这样做几乎总是合适的。毕竟，vector之所以存在于标准库中，主要原因就在于，它可以替代C风格的数组，而且提供了更高的安全性，更便于使用。
所以，我们不这样写：
auto_ptr<T> p2(new T[n]);
取而代之是：
vector<T> p2(n);
优点：
（a）易于实现（使用固有的功能）。我们还是无须编写auto_array。
（b）可读性好。熟悉标准容器的人（每个人现在都应该这样）会立刻明白是怎么回事。
（c）程序健壮性提高。既然将内存管理的细节丢给了底层，我们的代码（通常）将更为简化。我们无须管理T对象的内存缓冲区――那是vector<T>对象的工作。
（d）没有空间和时间上的显著开销。
缺点：
（a）语法改变。在f中，后面的代码只要使用了p2的值，就需要作语法上的改变，尽管这种改变十分简单、不像方案2要求的那样强烈。
（b）（有时）使用性改变。如果T类型不支持拷贝构造和赋值，任何标准容器（包括vector）就都不能通过这样的T类型实例化。大多数类型都支持拷贝构造和赋值。但如果某种类型不支持，这个方案就对它不适用。
注意，和传递或返回auto_ptr相比，通过值（value）传递或返回vector所带来的开销更大。但这一异议和此话题有点无关，因为这是一种不公平的对象，如果想得到同样的效果，你可以传递vector的指针或引用。
设计准则：
尽量使用vector，不要使用内建的（C风格的）指针。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款30：智能指针成员，之一：auto_ptr存在的问题
//例30-1
class X1
{
private:
	Y* y_;
};
如果X1对象拥有（owns）所指向的Y对象，那么，X1的设计为什么不能使用编译器自动生成的析构函数、拷贝构造函数和拷贝赋值函数？
如果X1拥有所指向的Y，编译器生成的上述函数不会提供正确的功能。

下面的做法优缺点？
//例30-2
class X2
{
private:
	auto_ptr<Y> y_;
};
自动生成的拷贝构造和拷贝赋值函数还是会做错误的事，只不过，是在做不同的错事。
首先，如果X2具有用户自定义的构造函数，让这些构造函数具有异常安全性会更容易，因此，如果构造函数抛出异常，auto_ptr会自动执行清除工作。但是，在auto_ptr对象获得Y对象的拥有权之前，X2的设计者还是得分配自己的Y对象并通过一个普通指针来保存它――无论这一过程多么短暂。
第二，现在，编译器自动生成的析构函数的确会做正确的事。当X2对象超出生成空间并被摧毁时，auto_ptr<Y>的析构函数会删除它拥有的Y对象，自动执行清除工作。即便如此，这里还是有一个很微妙的限制：如果你必须依赖于自动生成的析构函数，那么，在使用了X2的每一个编译单元（tranlation unit）中，这个析构函数都得提供定义。这几乎意味着，对使用了X2的任何人，Y的定义都必须可见。举个例子，如果Y是一个Pimpl，那就不是件好事，因为Pimpl的全部意义在于对X2的用户隐藏Y的定义。所以，你可以依赖自动生成的析构函数，但必须将Y的完整定义提供给X2才行（例如，x2.h包含y.h）：
//例30-2(a)：Y必须被定义
{
	X2 a;//分配一个新的Y对象并指向它
	//...
}//当a走出生成空间并被摧毁时，它删除所指向的Y：只有存在Y的完整定义时，这才会发生。之前也有介绍，搜“请注意，如果使用auto_ptr成员，那么：”
如果你不想提供Y的定义，就必须显式地写出X2的析构函数，即使函数体为空。！！！
第三，至于自动生成的拷贝构造函数，不再具有两次delete问题。不太好的消息是，这个自动生成的版本带来了另一个问题――数据偷窥（grand theft）。“被创建的X2对象”会偷走“被拷贝的X2对象”中的Y对象，包括Y对象的所有信息。
数据偷窥问题中仅有的一占安慰（虽然太少）是：如果盗窃似的行为会发生，自动生成的X2的拷贝构造函数至少会提供某种合理的警告。因为这个函数的原型将是X2::X2(X2&)。请注意，它的参数是一个指向非const对象的引用。毕竟，auto_ptr的拷贝构造函数就是这样做的（这是因为源拷贝对象被作了修改，所以无法声明为const），所以X2自动生成的拷贝构造函数也必须这么做。这确实是细微之处，但它至少可以防止对const X2进行拷贝。（可惜，参数的“非const性”是不可见的。函数由编译器无声无息地生成，你永远不能在人眼所能看到的代码中读到这些函数的原型。）
#include <iostream>
#include <memory>
using namespace std;

int main(int argc, char* argv[])
{
	auto_ptr<int> pInt(new int(3));//如果这里是const auto_ptr<int> pInt，则下面的拷贝构造编译出错
	auto_ptr<int> pInt2(pInt);
	if (pInt.get() != 0)
	{
		cout << *pInt << endl;
	}
}

#include <iostream>
#include <memory>
using namespace std;

int main(int argc, char* argv[])
{
	const auto_ptr<int> pInt(new int(3));//声明了const，则pInt不可变，其内部指针所指向的内容可以修改，但指针不可变
	*pInt = 4;
	int* rawPInt = pInt.release();//相当于指针由非null值变为了null，这里将编译出错
}
最后，说说自动生成的拷贝赋值运算符。不再具有两次delete和资源泄漏问题。但数据偷窥问题同样存在：赋值过程中的“目标X2对象”会偷走“源X2对象”中的Y对象，包括Y对象的所有信息；除此以外，它还会（可能过早的）删除自己最初拥有的Y对象。
和前面类似，至少这种偷窥行为会被提示，因此自动生成的函数会被声明为X2& X2::operator=(X2&)，这就相当于广告天下（尽管是用极小的字体，而不是头版头条标题）：操作数可以被修改。
总而言之，auto_ptr确实带来了某些好处，特别是，它为构造函数和析构函数自动完成了清除工作。然而，在本例中，它没有有过自身回答最初的主要问题――我们必须为X2提供自己的拷贝构造和拷贝赋值函数，或者如果拷贝操作对这个类没有意义，我们必须禁止它们。关于这一点，我们可以采用更专用一点的方式，从而做得更好。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款31：智能指针成员，之二：设计ValuePtr
一个简单的ValuePtr：绝对的拥有权
1. 写一个合适的ValuePtr模板，它可以像下面这样使用：
//例31-1
class X
{
	//...
private:
	ValuePtr<Y> y_;
};
我们将考虑三种情况。在所有三种情况中，构造函数的好处还是得保证：清除工作自动进行、X::X()的设计者只需做少量工作就可以保证异常安全、避免构造函数失败造成资源泄漏。同样，在所有三种情况中，对于析构函数的限制依赖存在：要么，Y的完整定义必须和X如影相随；要么，必须显式地提供X的析构函数，即使函数体为空。
a)不允许对ValuePtr进行拷贝和赋值。
//例31-2(a)：简单情况：
//没有拷贝和赋值的ValuePtr
template<typename T>
class ValuePtr
{
public:
	explicit ValuePtr(T* p = 0): p_(p) { }
	~ValuePtr() 
	{
		delete p_;
	}
	T& operator*() const
	{
		return *p_;
	}
	T* operator->() const 
	{
		return p_;
	}
	//没有提供.reset()和.release()，不要提供过于全面的功能；相反，好好理解你的需要，只提供真正需要的功能：
	void swap(ValuePtr& other)
	{
		swap(p_, other.p_);
	}
private:
	T* p_;
	//禁止拷贝
	ValuePtr(const ValuePtr&);
	ValuePtr& operator=(const ValuePtr&);
};
我们获得指针的拥有权，后来删除之。我们处理空指针的情况：而且，拷贝和赋值被特别禁止，做法很平常――将它们声明为私有成员但不提供定义（另外参数Uncopyable类）。将构造函数声明为explicit是一种好的做法，它避免了隐式置换；对于这种转换，ValuePtr的用户绝对不会需要。

拷贝构造和拷贝赋值
b)允许对ValuePtr进行拷贝和赋值，且具有这样的语义：在创建其Y对象的拷贝时，使用的是Y的拷贝构造函数。
下面的方法满足这个要求，但没有做到应有的通用性。与例31-2 (a)相同，但为拷贝构造和拷贝赋值提供了定义。
//例31-2(b)，允许拷贝和赋值的ValuePtr，第1步
template<typename T>
class ValuePtr
{
public:
	explicit ValuePtr(T* p = 0): p_(p) { }
	~ValuePtr() 
	{
		delete p_;
	}
	T& operator*() const
	{
		return *p_;
	}
	T* operator->() const 
	{
		return p_;
	}
	void swap(ValuePtr& other)
	{
		swap(p_, other.p_);
	}
	//检查other的指针是否为空很重要。
	ValuePtr(const ValuePtr& other): p_(other.p_ ? new T(*other.p_) : 0) { }
	//但operator=()是通过拷贝构造来实现的，所以只需将检查工作放在一个地方。
	ValuePtr& operator=(const ValuePtr&)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}
private:
	T* p_;
};
这满足前面提出的要求，因为在预定的使用场合下，我们只需要从“管理T类型的ValuePtr”拷贝或赋值，不需要从“管理任何其它类型的ValuePtr”拷贝或赋值。如果确信这是我们的需求，上面这个ValuePtr已经很不错了。但无论何时，当我们在设计一个类时，如果不需要很多额外的工作就可以提供新的功能，而且这些新功能在将来会对用户更有用处，那么，我们至少应该考虑到设计的可扩充性。与此同时，在“提高设计的可利用性”和“避免设计过度（overengineering）的危险”之间，我们需要做出权衡：所谓设计过度，指的是对一个简单的问题提供过于复杂的方案。

模板化的构造和模板化的赋值
如果允许“将来可以在不同类型的ValuePtr之间进行拷贝和赋值”，会对例31-2 (b)的代码带来哪些影响？就是说，希望：如果X可以转换为Y，就可以将ValuePtr<X>拷贝或赋值给ValuePtr<Y>。
答案是，这种影响可以做到最小（minimal）。我们可以复制（duplicate）出拷贝构造函数和拷贝赋值函数的模板化版本，这只用在它们前面加上template<typename U>，并且，取一个类型为ValuePtr<U>&的参数，如下：
//例31-2(c)：允许拷贝和赋值的ValuePtr，第2步
template<typename T>
class ValuePtr
{
public:
	explicit ValuePtr(T* p = 0): p_(p) { }
	~ValuePtr() 
	{
		delete p_;
	}
	T& operator*() const
	{
		return *p_;
	}
	T* operator->() const 
	{
		return p_;
	}
	void swap(ValuePtr& other)
	{
		swap(p_, other.p_);
	}
	ValuePtr(const ValuePtr& other): p_(other.p_ ? new T(*other.p_) : 0) { }
	ValuePtr& operator=(const	ValuePtr&)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}
	
	template<typename U>
	ValuePtr(const ValuePtr<U>& other): p_(other.p_ ? new T(*other.p_) : 0) { }
	
	template<typename U>
	ValuePtr& operator=(const ValuePtr<U>& other)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}
private:
	template<typename U> friend class ValuePtr;
	T* p_;
};
注意到我们躲开了一个陷阱――我们还是得写出非模板形式的拷贝和赋值函数。这样做是籽 禁止自动生成的版本：因为，模板化的构造函数绝不是拷贝构造函数，模板化的赋值运算符也绝不是拷贝赋值运算符。更多介绍，请参见Exceptional C++条款5。
还有一个微妙之处要当心，甚至可以说，那不是ValuePtr的设计者的责任。这个微妙之处是：无论是模板形式或是非模板形式的拷贝赋值函数，在我们执行切割（slicing）操作的情况下，源对象other还是可以拥有一个指向派生类型的指针。例如：
class A {};
class B: public A {};
class C: public B {};
ValuePtr<A> a1(new B);
ValuePtr<B> b1(new C);
//调用拷贝构造函数，切割
ValuePtr<A> a2(a1);
//调用模板化的构造函数，切割
ValuePtr<A> a3(b1);
//调用拷贝赋值函数，切割
a2 = a1;
//调用模板化的赋值函数，切割
a3 = b1;
之所以指出这一点，原因在于，我们不应该忘记把这类事情写在ValuePtr的说明文档中，而且最好放在“不要这样做”一节中，从而提醒用户注意。作为ValuePtr设计者，我们没有办法能够在代码中阻止这类误用。
两个方案都不错，需要你的判断和经验，取决于你在“提高设计的复用性”和“避免设计过度”之间如何作出权衡。“最小化设计”的拥护者会自然而然地使用方案31-2(b)，因为它完全满足最小需求。如果ValuePtr是在一个库中，由一个团队写成，并被几个不同的开发小组共享：这种情况下，因为方案31-2(c)具有可复用性并可以避免重复开发，使用就会节省整个开发的工作量。

通过traits增加可扩充性
如果Y有一个Clone()虚拟函数怎么办？从条款30的例30-1 看来，X似乎总会创建自己的Y对象，但实际上，这个对象有可能是从一个工厂（factory）（一个封装了一组对象创建操作的抽象类）或从某个派生类型的new表达式中得到的。这种情况下，所拥有的Y对象可能根本就不是一个真正的Y对象，而是从Y派生的某种类型的对象，那么，如果将它作为一个Y来拷贝，最好的结果是会切割这个对象，最坏的结果是这个对象不可用。这类情况下，一个常用的技术是为Y提供一个专门的clone()虚拟成员函数；这样一来，即使不知道所指向对象的完整类型，完整的拷贝操作也可以执行。
如果有人想用ValuePtr来保存这样一种对象，这个对象就只能用其它某个函数来拷贝，而不是拷贝构造函数，这是最后一个问题的要点。

c)允许对ValuePtr进行拷贝和赋值，且具有这样的语义：如果Y提供了一个virtual Y::clone()函数，在创建Y对象的拷贝时，将使用这个函数；否则，如果Y没有提供这样一个函数，将使用Y的拷贝构造函数。
在ValuePtr模板中，不知道T的真正类型是什么，我们不知道这是否有一个clone()虚函数，因此，不知道如何通过正确的方式拷贝它。

一个方案是使用traits。
例31-2(d)：允许拷贝和赋值的ValuePtr，对例31-2(c)做了少量的改动
template<typename T>
class ValuePtr
{
public:
	explicit ValuePtr(T* p = 0): p_(p) { }
	~ValuePtr() 
	{
		delete p_;
	}
	T& operator*() const
	{
		return *p_;
	}
	T* operator->() const 
	{
		return p_;
	}
	void swap(ValuePtr& other)
	{
		swap(p_, other.p_);
	}
	ValuePtr(const ValuePtr& other): p_(createFrom(other.p_)) { }
	ValuePtr& operator=(const ValuePtr&)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}

	template<typename U>
	ValuePtr(const ValuePtr<U>& other): p_(createFrom(other.p_)) { }

	template<typename U>
	ValuePtr& operator=(const ValuePtr<U>& other)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}
private:
	template<typename U>
	T* createFrom(const U* p) const
	{
		return p ? new T(*p) : 0;
	}
	template<typename U> friend class ValuePtr;
	T* p_;
};
现在，“以不同方式对T进行拷贝”的所有信息可以被封装起来，放在createFrom()这个函数。

运用traits
现在，可以通过下面的方式运用traits技术。请注意，这不是运用traits的唯一方式，还有其它很多应用。还请注意，要通过不同的方式拷贝T，除了运用traits之外也还有其它的方式。（比如说？）这里决定使用一个traits类模板，它有一个静态clone()成员函数，这个函数可以调用任何所需操作，以完成实际的复制（cloning）工作；因而，我们可以将其看作是一个适配器（adapter）。这种做法遵循char_traits的风格：例如，有了char_traits，basic_string就可以将“字符处理策略的定义工作”委托给一个traits类。（作为一种选择，traits类也可以提供typedef或其它辅助手段，这样，ValuePtr模板就可以知道要做什么，但岂不是，这些工作还是得由它自己来做。作者不喜欢这种做法，因为这似乎是一种不必要的责任分工。对于这样一种简单的事情，何苦在一个地方判断出应该什么事，然后又在另一个地方完成实际工作呢？）
//决定“做正确的事”……但如何做？
template<typename U>
T* createFrom(const U* p) const
{
	return p ? VPTraits<U>::clone(p) : 0;
}
我们希望VPTraits是一个完成实际复制（cloning）工作的模板，其中，主模板（main template）中clone()的实现使用的是U的拷贝构造函数。有两点要注意：首先，既然ValuePtr负责对空指针进行检查，VPTraits::clone()就不必这么做。第二，为了在T为基类、U为派生类的情况下可以正确地处理多态操作，那么，在U和T不同的情况下，只有U*可以转换为T*，这个函数才可以通过编译。
template<typename T>
class VPTraits
{
public:
	static T* clone(const T* p)
	{
		return new T(*p);
	}
};
这样，针对任何一个不想使用拷贝构造的类型Y，VPTraits可以像下面那样被特殊化。如果，假设某个Y有一个Y* cloneMe()虚函数，某个Z有一个void copyTo(Z&)虚函数。那么，可以将VPTraits<Y>特殊化，让那些函数完成复制工作：
//用户必须做的绝大部分工作就在这里，而且只需要在一个地方做一次
template<>
class VPTraits<Y>
{
public:
	static Y* clone(const Y* p)
	{
		return p->cloneMe();
	}
}

template<>
class VPTraits<Z>
{
public:
	static Z* clone(const Z* p)
	{
		Z* z = new Z;
		p->copyTo(*z);
		return z;
	}
}
（感觉这些工作还是要用户来完成，并不能完全由开发人员完全做啊？）
这个方案大大避免了设计修改，同时提高了设计的可扩充性：它适用于具有风格和原型的cloneMe()函数、甚至将来的某个函数。在底层，clone()可以通过任何合适的方式创建对象，唯一可见的结果一一个指向新对象的指针――这是提高封装性的又一个好论据。
如果某个用户（设计者）想通过一个新的Y使用这个ValuePtr，只需要将VPTratis特殊化一次，然后，在她的代码中的任何地方，都可以使用ValuePtr<Y>，的确太容易了。如果Y没有clone()虚函数，Y的用户（或设计者）甚至连那些工作都不用做，也就是说，不用做任何工作也可以使用ValuePtr。
简短的结尾：既然VPTraits仅有一个静态函数模板，为什么要写一个类模板而不是一个函数模板呢？――主要目的在于封装性（尤其是，更好地管理名称）和可扩充性。我们不需要用自由函数搅乱全局名称空间。有一种做法是：无论ValuePtr本身在哪个名字空间，将函数模板也放在这一名称空间范围之中。但这样一来，和同一名字空间中的其它代码相比，函数模板和ValuePtr的耦合性会变得更加紧密。在目前看来，clone()函数模板或许是我们需要的唯一一种trait，但如果明天我们需要一个新的trait怎么办，如果新的traits是函数，我们就不得不继续用自由函数将名字空间搅得一团糟。但如果新增的traits是typedef甚至是类，VPTraits是一个把这一切封装起来的好地方。

运用了Traits的ValuePtr
下面是新的ValuePtr代码，运用了具有复制功能的traits，并满足前面问题c)中的所有要求。（有可能，一些人会提供一个traits对象，作为ValuePtr模板的另一个参数Traits，这个参数的缺省值为VPTraits<T>，就像std::basic_string所做的那样，
template<typename T, typename Tratis = VPTraits<T> >
class ValuePtr{/*...*/};
这样一来，在同一个程序拷贝中，用户甚至可能通过不同的方式拥有不同的ValuePtr<X>对象。在我们这个特定场合下，这种额外的灵活性似乎没有多大的意义，所以不准备这样做――但要知道有这种可能。）
和例31-2(d)相比，这里只对ValuePtr改动了一行代码，并提供了一个新模板，这个模板仅有一个简单的函数。这就是所说的最小（minimal）影响，换来的是前面说过的所有灵活性
//例31-2(e)：允许拷贝和赋值的ValuePtr，提供了基于traits的完整定制功能
template<typename T>
class VPTraits
{
//public://这里不需要吗？
	static T* clone(const T* p)
	{
		return new T(*p);
	}
};

template<typename T>
class ValuePtr
{
public:
	explicit ValuePtr(T* p = 0): p_(p) { }
	~ValuePtr() 
	{
		delete p_;
	}
	T& operator*() const
	{
		return *p_;
	}
	T* operator->() const 
	{
		return p_;
	}
	void swap(ValuePtr& other)
	{
		swap(p_, other.p_);
	}
	ValuePtr(const ValuePtr& other): p_(createFrom(other.p_)) { }
	ValuePtr& operator=(const	ValuePtr&)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}

	template<typename U>
	ValuePtr(const ValuePtr<U>& other): p_(createFrom(other.p_)) { }

	template<typename U>
	ValuePtr& operator=(const ValuePtr<U>& other)
	{
		ValuePtr temp(other);
		swap(temp);
		return *this;
	}
private:
	template<typename U>
	T* createFrom(const U* p) const
	{
		return p ? VPTraits<U>::clone(p) : 0;
	}
	template<typename U> friend class ValuePtr;
	T* p_;
};

int main(int argc, char* argv[])
{
	ValuePtr<int> pInt(new int(3));
	cout << *pInt << endl;

	int* p = new int(10);
	int* p2 = VPTraits<int>::clone(p);//这里编译不通过，访问不到
	cout << *p2 << endl;
	delete p2;
	
	ValuePtr<int> pInt2(pInt);//ValuePtr这里也访问不到，编译不通过
	cout << *pInt2 << endl;
}

要么把VPTraits中的static声明为public，要么在其中将ValuePtr声明为友元
template<typename T>
class VPTraits
{
public:
	static T* clone(const T* p)
	{
		return new T(*p);
	}
};
或
template<typename T>
class VPTraits
{
	template<typename U> friend class ValuePtr;//这里要写U，让任何类型的ValuePtr对象都可以访问，如果写T，则ValuePtr中的类型派生类无法访问
	static T* clone(const T* p)
	{
		return new T(*p);
	}
};
应用实例
下面例子是一个类，使用了ValuePtr的最终版本。
//例31-3：ValuePtr应用实例
class X
{
public:
	X(): y_(new Y(/*...*/)) { }//这种分配资源方式不符合条款19法则4？
	~X() { }
	X(const X& other): y_(new Y(*(other.y_))) { }
	void swap(X& other)
	{
		y_.swap(other.y_);
	}
	X& operator=(const X& other)
	{
		X temp(other);
		swap(temp);
		return *this;
	}
private:
	ValuePtr<Y> y_;
};

总结
在本条款能够吸取这样一条经验：在设计的时候，可扩充性一定要牢记在心。
设计准则：一般情况下，尽量提高设计的通用性。
在避免“设计过度”的陷阱时，总要保持长远的眼光。可以每次否决它，但总要清楚它的存在。这样，从长远来看，你和你的用户就会节省大量的时间和人力；在长远的将来，你的用户在使用他们编写的新类时，也会乐于复用你的代码。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款32：递归声明
函数指针
一个对象指针可以让你动态地指向某种类型的对象，同样，一个函数指针可以让你动态地指向具有某种原型的函数。
状态机简介
假设可以写一个函数，它能返回指向自身的指针。这个函数同样可以返回一个指针，指向任何一个“和它具有相同原型”的函数。这种功能什么时候会有用？
最常见的例子是在实现一部状态机的时候。
简而言之，状态（state machine）由一组“可能的状态”和那些状态之间的一组“合法转换”组成。
start->("a")->s2->("see")->stop
start->("be")->stop
为了实现一部状态机，有时候，将每一个状态写成一个函数就够了。所有状态函数都具有相同的原型，它们都返回一个指针，指向下一个将要调用的函数（状态）。例如下面是一个极度简化的代码片段，演示了上面的设计思想。

StartPtr start(const string& input);
StartPtr s2(const string& input);
StartPtr stop(const string& input);
StartPtr error(const string& input);//错误状态
StartPtr start(const string& input)
{
	if (input == "a")
	{
		return s2;
	}
	else if (input == "be")
	{
		return stop;
	}
	else
	{
		return error;
	}
}

一个函数如何返回指向自身的指针
有可能写出一个函数f()，使其返回指向自身的指针。在下面这种自然的使用方式下，应该很有用：
//例32-3
//FuncPtr是某种函数指针的typedef，这种函数具有和f()相同的原型
FuncPtr p = f();
(*p)();

可能，但实现方式不是那样显而易见
//例32-3(a)：不正确
typedef FuncPtr (*FuncPtr)();

尽管一个void*的大小足以保存任何对象指针的值，但它不一定适合保存一个函数指针。在某些平台上，一个函数指针比一个对象指针要大。
一个正确且具可移植性的方案
要想完全达到问题的效果，的确有一个类型安全且具有可移植性的方案，它无须依靠非标准的代码，也无须依靠非类型安全的转换。其做法是：增加一层间接性――具体形式是一个代理类（proxy class），这个类不但接受它想要的指针类型，同时还有一个隐式转换，用以转换到它想要的指针类型：
//例32-3(d)：正确的方案
class FuncPtr_;
typedef FuncPtr_ (*FuncPtr)();

class FuncPtr_
{
public:
	FuncPtr_(FuncPtr p): p_(p) { }
	operator FuncPtr()
	{
		return p_;
	}
private:
	FuncPtr p_;
};

现在，我们可以很自然地声明、定义和使用f()：
FuncPtr_ f()
{
	return f;//自然的return语法
}

int main()
{
	FuncPtr p = f();//自然的使用语法
	p();
}
这个方案三大优点：
（1）解决了提出的问题。更好的是，它不失类型安全，且具有可移植性。
（2）它的实现机制是透明的。对调用者或者用户来说，使用它时采用的语法很自然：对函数自身的“return myname;”语句来说，语法也很自然。
（3）它的开销可能为零。在现代编译器上，借助内联和优化，代理类连同它的存储空间和成员函数会被消除得无影无踪。
#include <iostream>
using namespace std;

class FuncPtr_;
typedef FuncPtr_ (*FuncPtr)();

class FuncPtr_
{
public:
	FuncPtr_(FuncPtr p): p_(p) { }
	operator FuncPtr()
	{
		return p_;
	}
private:
	FuncPtr p_;
};

FuncPtr_ f()//这里是对代理类的初始化，如果将class FuncPtr_的构造函数声明为explicit，则编译不通过；但是这个类的实例是哪里？？？以我现在（2014-4-5）的理解是：实例为一个临时变量，构造函数参数为f，构造了一个FuncPtr_类的临时变量，但是f函数需要一个返回类型，而FuncPtr_恰好有一个隐式转换函数operator FuncPtr()，可以隐式转换为类型FuncPtr。
{
	cout << "f()" << endl;
	return f;
}

int main(int argc, char* argv[])
{
	FuncPtr p = f();//这里调用了第一次函数f()，并把返回值赋给函数指针p
	p();//这里调用函数指针，执行第二次函数f()
}
输出如下：
f()
f()
请按任意键继续. . .

结尾
通常情况下，你很可能想将这种专用的FuncPtr_代理类（包含某个旧对象，而且不关心它的类型）模板化，使之成为一个通用的Holder代理类。可惜，对于上面这个FuncPtr_类，你却不能直接将它模板化：如果那样做，typedef看起来必然会像下面这样：
typedef Holder<FuncPtr> (*FuncPtr)();
它引用了自身。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款33：模拟嵌套函数
回顾嵌套类和局部类两个概念时，要集中在：如何应用这些特性写出健壮、易于维护的代码，并表达出优良的对象设计――具有弱耦合性、强内聚性的设计。
嵌套类（nested class）是一个“包含在另一个类（范围）中”的类。如：
//例33-1：嵌套类
class OuterClass
{
/*public, protected, 或private*/:
	class NestedClass
	{
		//...
	};
};
在组织代码、控制访问权限和从属关系方面，嵌套类很有用处。如果NestedClass声明为public，则任何外部代码都可以使用它，称之为OuterClass::NestedClass。通常，嵌套类包含的是私有实现细节，因而会被声明为private，那么，只有OuterClass的成员（member）和友元（friend）可以使用NestedClass。
注意，仅使用名字空间不可能达到与此相同的效果，因为名字空间只是将名称组织为不同的区域。名字空间本身不提供访问控制，但类会提供。所以，如果想对一个类的访问权限进行控制，一个可以使用的方法是：将它嵌套在另一个类中。
局部类（local class）是一个“定义在一个函数范围内”的类――任何函数，无论是成员函数还是自由函数。例如：
//例33-2：局部类
int f()
{
	class LocalClass
	{
		//...
	};
	//...
}
像嵌套类一样，在管理代码的从属关系方面，局部类是一个有用的工具。在例33-2 中，只有f()的内部代码知道LocalClass并能够使用它。当LocalClass是f()的内部实现细节，因而永远不就应该公开给其它代码的时候，它就显示出了价值。
在可以使用非局部类的大多数地方，你也可以使用局部类；但有一个很重要的限制一定要牢记在心：局部类或未命名的类不能作为模板参数使用。以下摘自C++标准第14.3.1/2 节：
局部类型，没有链接（linkage，精确定义详见C++标准3.5 节）的类型、未命名的类型以及从这些类型中的任何一个复合而成的（compounded）的类型都不能作为模板类型参数（template type-parameter）实参（template-argument）使用。【示例：
template<class T>
class X {};
void f()
{
	struct S {};
	X<S> x3;//错误：局部类型用作模板实参
	X<S*> x4;//错误：局部类型的指针用作模板实参
}
--示例结束】
在C++用于信息隐藏和从属关系管理的众多有用工具中，嵌套类和局部类是其中的两个。

嵌套函数：概述
一些语言（不包括C++）支持嵌套函数（nested function），它和嵌套类有相似之处。嵌套函数定义在另一个函数――即外围函数（enclosing function）――之内，使得：
1. 嵌套函数可以访问外围函数的变量；
2. 嵌套函数局部存在于外围函数之内――即，除非外围函数提供一个指向嵌套函数的指针，否则我们无法在其它地方调用这个嵌套函数。
嵌套类之所以有用，在于它有助于控制一个类的可见性（visibility）；同样，嵌套函数之所以有用，在于它有助于控制一个函数的可见性。
C++不支持嵌套函数。也就是说，不能写出下面这样的代码：
//例33-3
int f(int i)
{
	int j = i*2;
	int g(int k)//不合法的C++代码
	{
		return j + k;
	}
	j += 4;
	return g(3);
}

请示范：怎样做才有可能在标准C++中得到相同的效果，并演示如何将解决方案扩充至一般化。
//可以用Lambda表达式，如下：
#include <iostream>
#include <string>
using namespace std;

int f(int i)
{
	int j = i*2;
	auto g = [=] (int k) {return j + k;};//这里声明一个Lambda函数，不需要在最后加()；需要调用函数时，才需要在Lambda函数最后加(入参)。[=]是值捕获，所以j即为i*2的值，[&]为引用捕获，j为i*2+4的值。
	j += 4;
	return g(3);
}

int main(int argc, char* argv[])
{
	cout << f(3) << endl;
}
//结束

只需要重要组织一下代码，只会有一点点的局限性。基本思想是将函数转换为函数对象。这个讨论也恰好显示了函数对象的某些威力。
尝试在C++中模拟嵌套函数
要解决问题3的难题，大多数人会从下面这样的尝试开始：
//例33-3(a)：幼稚的“局部函数对象”方案（不正确）
int f(int i)
{
	int j = i * 2;
	class g_
	{
	public:
		int operator()(int k)
		{
			return k + j;//错误：j不能被访问
		}
	} g;
	j += 4;
	return g(3);
}
例33-3(a)的设计思想是：将函数包装在一个局部类中，并通过一个函数对象调用这个函数。
主意不错，但却不可行，原因：这个局部类对象不能访问外围函数的变量。
那么，有人会说，为什么不将函数中所有变量的指针或引用提供给个局部类呢，确实，通常这是下一步尝试。
//例33-3(b)：幼稚的“局部函数对象加变量的引用”方案（复杂、脆弱）
int f(int i)
{
	int j = i * 2;
	class g_
	{
	public:
		g_(int& j): j_(j){}
		int operator()(int k)
		{
			return k + j_;//通过引用访问j
		}
	private:
		int& j_;
	} g(j);
	j += 4;
	return g(3);
}
得承认这个方案“可行”――但只是勉强可行。这个方案脆弱、难以扩充；准确地说，只能将它看作一种非常手段。例如，要增加一个新变量，将要做四个改动：
（a）增加这个变量；
（b）为g_增加一个相应的私有引用成员；
（c）为g_增加一个相应的构造函数参数；
（d）为g_::g_()增加一个相应的初始化操作。
这将难以维护，而且也不容易扩充为多个局部函数。

一个略有改善的方案
把变量本身转移到局部类中，我们就可以做得更好。
//例33-3(c)：一个更好的方案
int f(int i)
{
	class g_
	{
	public:
		int j;
		int operator()(int k)
		{
			return k + j;
		}
	} g;
	g.j = i * 2;
	g.j += 4;
	return g(3);
}
这个方案向前迈出了坚实的一步。现在，在g_的数据成员中，指向外部数据的指针或引用不再需要；它也不需要构造函数；一切都是更加自然。还请注意，这一技术现在可以扩充到任意数目的局部函数；所以，多增加几个局部函数。再将g_换个名字，让它更能体现局部类的实际功能。
//例33-3(d)：快接近正确方案了！
int f(int i)
{
	class Local_
	{
	public:
		int j;
		//
		int g(int k)
		{
			return k + j;
		}
		void x() {}
		void y() {}
		void z() {}
	} local;

	local.j = i * 2;
	local.j += 4;
	return local.g(3);
}
当你需要用其它什么东西而不是缺省值来初始化j时，你必须为局部类增加一个蹩脚的构造函数，用以传递初始化值。在最初的提问中，我们是将j初始化为i*2 的值。这里，我们不得不创建j然后对它赋值，这就和最初的要求不尽相同，而且，对于更复杂的类型，这会有困难。

一个完整的方案
如果你不需要让f本身成为一个“真正的”函数（例如，不需要取函数指针），你就可以将这一切转换为一个函数对象，并且可以非常漂亮地支持非缺省初始化。
//例33-3(e)：一个完整、极具扩充性的方案
class f
{
//private:
	int j;
	int retVal;//f的“返回值”
	int g(int k)
	{
		return k + j;
	}
	void x() {cout << "x()" << endl;}
	void y() {cout << "y()" << endl;}
	void z() {cout << "z()" << endl;}
public:
	f(int i): j(i * 2)//最初的函数，现在是一个构造函数
	{
		j += 4;
		x();
		y();
		z();
		retVal = g(3);
	}
	operator int() const//返回结果
	{
		return retVal;
	}
};

int main(int argc, char* argv[])
{
	cout << f(3) << endl;//把函数对象声明为临时变量
}
为了让代码更简短，以内联的形式书写代码，但所有私有成员也可以隐藏在一个Pimpl之后，从而像最初那个简单的函数一样，将接口同实现完全分离。
请注意，这个方案可以很容易地扩充为成员函数。例如，假设f()不是自由函数，而是一个成员函数，我们想在f()中写一个嵌套函数g()，如下所示：
//例33-4：这不是合法的C++代码，但它演示了我们的需要：一个局部函数存在于一个成员函数之中
class C
{
public:
	int f(int i)
	{
		//一个假想的嵌套函数
		int g(int i)
		{
			return data_ + i;
		}
		return g(data_ + i*2);
	}
private:
	int data_;
};
想要表达这种关系，可以将f()变成一个类，就像例33-3(e)演示的那样；只不过，例33-3(e)中的那个类是在全局空间，而现在它是一个嵌套类，并需要通过辅助函数来访问。
//例33-4(a)：完整肯极具可扩充性的方案，现在应用于成员函数
class C
{
//private:
	int data_;
	friend class C_f;
public:
	int f(int i);
};

class C_f
{
//private:
	C* self;
	int retVal;
	int g(int i)
	{
		return self->data_ + i;
	}
public:
	C_f(C* c, int i): self(c)
	{
		retVal = g(self->data_ + i*2);
	}
	operator int() const
	{
		return retVal;
	}
};

int C::f(int i)
{
	return C_f(this, i);
}
总结
在上面例33-3(e)和33-4(a)中，我们所演示的方法模拟了局部函数的大多数特性，而且，我们还可以很容易地将其扩充到任意数目的局部函数。其主要不足在于，它要求所有变量都被定义在“函数”的开始处，不（轻易地）请允许我我们将变量声明放在离“第一次使用变量”更近的地方。和局部函数相比，它写起来更让人感到枯燥，它显然只是针对语言限制的权宜之计。但归根结底，它还不错；它演示了函数对象相对于普通函数所具有的与生俱来的威力。（感觉也不能完全当做函数对象吧？？？什么叫函数对象？）
本条款目的并不在于让你去认识“C++中有了局部函数会有多好”。其目的在于：先提出一个特定的设计问题，然后探究解决问题的各种方案，最后权衡这些方案并作出最佳选择。沿着这条道路，我们也体验了各种不同的C++特性，透彻理解了函数对象在应用中威八面的原因。
在设计自己的程序时，无论如何都要力求简化和整洁，上面的一些过渡方案的确“可行”，但在你的产品代码中，你绝对不能让它们得见天日。它们复杂、难以理解，因而使得维护更加困难、更加昂贵。
设计准则：力求清晰。避免复杂的设计。避免招致困惑。

简单的设计更易于实现和测试。一定要避免复杂的方案；几乎可以肯定，复杂的方案更脆弱、更难以理解和维护。在小心谨慎地避免设计过度的陷阱时，请认识到：即使找出一个简单合理的设计会让你在前面多花一点时间，但它所带来的长期好处通常会让你觉得这是值得的。现在多花点时间往往意味着节省“以后更多的时间”。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款34：预处理宏
还是有一些很好的理由去使用#define。
1)守护头文件
为了防止头文件被多次包含，这是一种常用技巧。
#ifndef MYPROG_X_H
#define MYPROG_X_H
//...
#endif
2)使用预处理器特性
在诊断代码中，插入行号或编译时间这类信息，一个简单方法是使用预定义的标准宏，如__FILE__、__LINE__、__DATE__和__TIME__。基于相同原因，以及其它原因，使用stringizing（字符串化）和token-pasting（标记合并）预处理运算符（#和##）也很有用。
3)在编译时期选择代码（或称：特定编译代码）
A.调试代码
在编译你的系统时，时想使用某些“额外”代码（通常是一些调试信息），但有时又不想这样做。
void f()
{
#ifdef MY_DEBUG
	cerr << "some trace logging" << endl;
#endif
	//...f()其余部分
}

例：
//Test.h
#ifndef __TEST_H__
#define __TEST_H__

const int a = 3;

#endif

//main.cpp
#include <iostream>
#include "Test.h"
using namespace std;

int main(int argc, char* argv[])
{
#ifdef __TEST_H__//同#if defined __TEST_H__
	cout << a << endl;
#endif
	cout << "end" << endl;
}
输出如下：
3
end
请按任意键继续. . .
--
#include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
#ifdef __TEST_H__
	cout << a << endl;
#endif
	cout << "end" << endl;
}
输出如下：
end
请按任意键继续. . .

这段代码实际上有了两个不同的程序。如果编译时定义了MY_DEBUG，得到的是包含“输出到cerr”的源代码，编译器也会去检查那行代码的语法和语义。如果在编译时没有定义MY_DEBUG，得到的是不同的程序，不包含那行“输出到cerr”的代码，对于那行没有包含在内的代码，编译器也就无法检查其正确性。
通常，用条件表达来代替这个#define会更好。
void f()
{
	if (MY_DEBUG)
	{
		cerr << "some trace logging" << endl;
	}
	//...f()的其余部分
}
例：没有成功？？？
int main(int argc, char* argv[])
{
	if (__TEST_H__)//编译不通过啊
	{
		cout << a << endl;
	}
	cout << "end" << endl;
}
采用这种方式，只用对一个程序进行编译和测试，编译器会检查所有的代码，如果MY_DEBUG不为true，编译器会很容易忽略掉无法到达的代码。
B.特定平台代码
通常，在处理“针对特定平台”的代码时，最好运用factory模式：采集用这种方法，代码的组织会更合理，运行时期会更具灵活性。但有时，由于存在的差异太少，很难去构造一个合理的factory，这时候，预处理就是一种切换可选代码的好办法。
C.不同的数据表示方式
一个常见的例子是：对于一个模块所定义的一组错误代码，外部用户看到的应该是一个简单的enum，并带有注释：但在模块内部，它们应该被存储在一个map中，以便于查找。即：
// 对于外部用户
enum Error
{
	ERR_OK = 0, //No error
	ERR_INVALID_PARAM = 1//<description>
}
//对于模块的内部使用
map<Error, const char*> lookup;
lookup.insert(make_pair(Error_OK, (const char*)"No error"));
lookup.insert(make_pair(ERR_INVALID_PARAM), (const char*)"<description>");
...
我们想同时拥有两种表示方式，但不希望将实际信息（成对的“代码/消息”）定义两次。有了宏这一魔法，就可以像下面这样，简单地写一个错误列表，在编译时期创建相应的数据结构：
ERR_ENTRY(ERR_OK, 0, "No error"),
ERR_ENTRY(ERR_INVALID_PARAM, 1, "<description>"),
...
ERR_ENTRY以及相关的宏实现留给读者去完成。//...
这里只是列出了三个常见的例子，除此之外还有很多应用。虽然很多地方，我们应该避免使用C风格的预处理，但预处理还是有其自身的价值；明智地使用它，我们写出的C++代码就会更简单、更安全。
设计准则：
除了以下情况之外，避免使用预处理宏：
1)守护头文件；
2)条件编译，以获得可移植性，或在.cpp文件（不是.h文件！）中进行调试；
3)用#pragma禁止掉无伤大雅的警告，但这种#pragma总得包含在一个“为了获得可移植性而提供的条件编译”之中，以防编译器不认识它们而发出警告。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款35：宏定义
宏的常见陷阱
1. 示范写一个简单的预处理宏max()：取两个参数，通过普通的“<”运算，比较出其中的较大值。写这样一个宏时，一般会有哪些易犯错误。
四大易犯错误：
1)不要忘记为参数加上括号
//例35-1(a)：括号陷阱之一：参数
#define max(a, b) a < b ? b : a
max(i += 3, j)
展开为
i += 3 < j ? j : i += 3
考虑到运算符优先级和语言规则，实际上是：
i += ((3 < j) ? j : i += 3)
这种错误需要很长时间调试才能发现。另一个问题和顺序点（sequence points）有关，在不同的顺序点，它会对i修改两次。
2)不要忘记为整个展开式加上括号
#define max(a, b) (a) < (b) ? (b) : (a)
问题是，整个展开式没有被正确的加上括号。如
k = max(i, j) + 42;
展开后为
k = (i) < (j) ? (j) : (i) + 42;
考虑运算符优先级，实际上是
k = ((i) < (j)) ? (j) : ((i) + 42);
可以为宏的整个展开式加上括号，从而解决第二个问题，但还有另外一个问题。
3)当心多参数运算
如果其中某个表达式有作用，或者两个都有副作用
//例35-1(c)：多参数运算
#define max(a, b) ((a) < (b) ? (b) : (a))
max(++i, j)
如果++i的结果大于等于j，i会递增两次，这可能不是程序员想要的：
((++i) < (j) ? (j) : (++i))
类似的地，请看
max(f(), pi)
展开后为：
(f()) < (pi) ? (pi) : (f())
如果f()的结果大于等于pi，f()会执行两次，几乎可以肯定，这绝对缺乏效率，而且往往是错误的。
虽然头两个问题可以解决，但这是一块真正的硬石头，只要max是个宏，我们对此只能束手无策。
4)名字冲突
宏对“范围（scope）”漠不关心。（宏对大多数事都漠不关心：参见GotW #63 ）它只是执行文本替换，而不管文本在哪儿。这意味着，只要使用宏，我们就得小心地对这些宏命名。具体来说，这个max宏最大的问题是，它极有可能会和标准max()函数模板相冲突：
//例35-1(d)：名字冲突
#define max(a, b) ((a) < (b) ? (b) : (a))
#include <algorithm>
问题在于，在头文件<algorithm>中，有像下面这样的东西：
template<typename T> 
const T& max(const T& a, const T& b);
宏“好心好意”地将它转换成一团糟，从而导致无法编译：
template<typename T>
const T& ((const T&a) < (const T& b) ? (const T& b) : (const T& a));
如果你认为，只需要将宏定义放在所有被包含的头文件之后（在任何情况下，这都是个好的做法），这种问题就很容易避免，那么请想象一下，如果在其它代码中，有些变量什么东西刚好也叫max，宏会对那些代码做些什么好事。
如果非得写一个宏不可，那么，尽量为它想出一个不平常的、难以拼写的名字，这样才能最大可能地避免和其它名字相冲突。

宏的其它缺陷
5)宏不能递归
6)宏没有地址
你有可能得到任何自由函数或成员函数的指针（例如，这把用作predicate，谓词），但你不可能得到一个宏的指针，因为宏没有地址。之所以没有，原因很显然――宏不是代码。宏不会以自身的形式存在，因为它只是一种被美化了的（不是特别光荣的）文本替换规则。
7)宏有碍调试
在编译器有机会看到代码之前，宏就会修改相应的代码――因而，它会严重破坏变量名称和其它名称；此外，在调试阶段，你无法跟踪到宏的内部。

有些事甚至宏也不会去做
使用宏有许多正常的理由（详细请参见条款34），但使用宏也有限制。
预处理宏不能创建哪些东西，为什么不能？
C++标准中，条款2.1 对编译阶段（phases of translation）作了严格规定。预处理指令和宏的展开发生在第4个阶段。这样，在一个符合标准的编译器上，宏不可能创建以下任何东西：
1. 三图符（trigraph）（三图符在第1个阶段被替换）；（什么东西？）
2. 通用字符名（\uXXXX，在第一个阶段被替换）；
3. 用于行连接的行尾反斜线符（在第2个阶段被替换）；
4. 注释（在第3个阶段被替换）；
5. 另一宏或预处理指令（在第4个阶段展开和执行）；
6. 通过字符串中宏的名称改变字符字面值（character literal，例如，'x'）或字符串字面值（string literal，例如，"hello, world"）。
关于最后一点，C++标准第16.3 /8 节的脚注7有如下说明：
在宏替换期间，所有字符字面值和字符串字面值都是预处理标记，而不是“可能包含标识符似的子序列”的序列（参见2.1.1.2 ，编译阶段），所以，它们永远不会被作为“宏的名称”或“参数”来扫描。
一篇公开发表的文章声称，宏可能创建注释，像下面这样：
#define COMMENT SLASH(/)
#define SLASH(s) /##s
这种做法不符合标准、不具有可移植性，但这是一个可以理解的错误，因为它的确在某些很普及的编译器上可行，因为那些编译器没有正确地支持“编译阶段”。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款36：初始化
1. 直接初始化和拷贝初始化有何不同
直接初始化（direct initialization）指的是：使用单个构造函数（可能是转换构造函数）来初始化对象，它相当于“T t(u);”的形式：
U u;
T t1(u);//调用T::T(U&)，或类似
拷贝初始化（copy initialization）指的是：使用拷贝构造函数来初始化对象，如果必要，在此之前会先调用一个用户自定义的转换，它相当于“T t = u;”的形式：
T t2 = t1;//相同类型：调用T::T(T&)，或类似
T t3 = u;//不同类型：调用T::T(T(u))或T::T(u.operator T())，或类似
之所以加上“或类似”这样含糊的用词，原因是：拷贝和转换构造函数可以接受的参数可能会和普通引用稍有不同（即，这个引用可能为const，或volatile，或二者兼备）；此外，用户自定义的转换构造函数或运算符还可以接受和返回一个对象，而不是引用；而且，拷贝和转换构造函数还可以有缺省参数。
注意，在最后一个例子“T t3 = u;”中，编译器可以调用用户自定义的转换（以构造一个临时对象）和T的拷贝构造函数（以从临时对象构造t3）；或者，也可以省略临时对象，直接从u构造t3（这就最终等价于“T t3(u);”）。无论哪种方法，未被优化的代码还是得合法。具体来说，拷贝构造函数还是得可以访问――即使对它的调用会被优化掉。
如今，编译器省略临时变量的自由度有了限制，但对于上面这种优化、乃至返回值优化（return value optimization），省略还是允许的。请阅读Exceptional C++条款42和46。
设计准则：变量初始化时，尽量采用“T t(u)”形式，不要采用“T t = u”形式。

class T: public S
{
public:
	T(): S(1), x(2) {}
	X x;
};
基类和成员的初始化都是采用直接初始化
T f(T t)
{
	return t;
}
值的传递和返回都是采用拷贝初始化
S s;
T t;
S& r = t;
reinterpret_cast<S&>(t);
dynamic_cast<T&>(r);
const_cast<const T&>(t);
圈套：这些地方完全没有涉及到新对象的初始化，只是创建了引用。
static_cast<S>(t)
static_cast使用直接初始化。（不太懂？） 
try
{
	throw T();//抛出异常
}
catch(T t)
{}
异常对象的抛出和捕获都是使用拷贝初始化。
注意，上面这段代码存在两个T对象的拷贝，因而一共有三个T对象。在异常抛出现场，被抛出对象的拷贝会被创建。另外，在代码的异常处理程序中，被抛出对象是通过传值来捕获的，所以还会创建第二个拷贝。
在一般情况下，应该尽量通过“引用”来捕获异常，而不是通过“值”；这样，我们就可以避免创建额外的拷贝，并消除可能存在的对象切割（object slicing）。
f(T(s));//函数形式的类型转换
这种“函数风格的类型转换”采用的是直接初始化。
S a[3] = {1, 2, 3};//大括号初始化语句
大括号初始化语句采用的是拷贝初始化。
S* p = new S(4);//new表达式
new表达式采用的是直接初始化。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款37：前置声明
前置声明是“消除不必要的编译时期依赖性”的一种重要方法。
（1）前置声明（forward declaration）是非常有用 的工具。但在这个例子中，它没有像程序员所预计的那样工作。做了标记的两行代码错误是什么
//文件f.h
class ostream;//错误
class string;//错误
string f(const ostream&);
错误出在：不能以这种方式前置声明ostream和string，因为它们不是类。它们都是模板的typedef。

不包含任何其它文件，为上面的ostream和string写出正确的前置声明。
简短的答案是：不可能。实际情况是：不存在某种标准且具有可移植性的方法，可以做到不包含另一个文件却能前置声明ostream；根本没有一种标准且具有可移植性人方法可以前置声明string。
之所以不能对二者进行前置声明，原因在于，C++标准已经有了明确的规定，不能对namespace std写出我们自己的声明，而ostream和string就在namespace std之中：
除非另有说明，如果一个C++程序向“namespace std”或“namespace std内的某个名字空间”增加声明或定义，其后果不可预测。
你能做得最好的（但它不是“不包含任何其它文件”这一问题的解决方案）只能是像下面这样：
#include <iosfwd>
#include <string>
iosfwd头文件的确包含的是真正的前置声明。string头文件则不是。这是你能做到的最好结果，并且不失移植性。幸运的是，在实际工作中，前置声明string和ostream算不上什么大不了的事，因为这些头文件通常很小而且使用广泛。大多数标准头文件也都是这样。但请当心陷阱：不要经不起诱惑，试图前置声明那些属于namespace std中的模板或其它任何东西。这些至高无上的特权是保留给编译器和程序库的设计者的――而且，仅仅是他们。
设计准则：
当前置声明可以满足需要时，绝对不要包含（#include）头文件。在不需要流（stream）的完整定义时，尽量只包含（#include）<iosfwd>
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款38：typedef
1. 使用typedef的场合和理由
1)便于打字
2)可读性
使代码易于阅读，对长的模板名称来说尤其如此。
int (*t(int))(int*);
typedef可以帮助你，即使是使用一个像Func这样没什么含义的typedef名称：
typedef int (*Func)(int*);
Func t(int);
现在很清楚了，这是一个函数声明：此函数的名称为t，输入参数为int，返回值为一个函数指针，指向一个输入参数为int*、返回值为int的函数。这种情况下，typedef比语言文字更具可读性。
使用typedef可以增加语义。如，PhoneBook比map<string, string>更容易理解：后者几乎没有语义，因而几乎可以表示任何东西。
3)便于交流
typedef有助于表达程序的意图。如，如果不在程序中四处乱扔不加修饰的int，而是给这个类型一个名称――即使它本质上还是一个int，那么，代码就会更清晰。请看：
int x;
int y;
y = x * 3;//可能是正确的――谁知道？
再比较：
typedef int Inches;
typedef int Dollars;
y = x * 3;
4)可移植性
对那些“和平台相关的名称”或其它“不具可移植性的名称”，如果使用typedef，将它们移植到新的平台就会更容易。
#if defined USING_COMPLILER_A
	typedef __int32 Int32;
	typedef __int64 Int64;
#elif defined USING_COMPLIER_B
	typedef int Int32;
	typedef long long Int64;
#endif
你就不会为了某个“和平台相关的名称”而在整个代码中忙于查找和替换。有了typedef的帮助，你的代码就可以避免一些简单的平台依赖性问题（但是，为达到这一目的，你一般会用#define，原因参见条款35。）

2. 在用到了标准（STL）容器的代码中，使用typedef是个好主意。
1)灵活性
较之在整个代码中修改所有的名称，仅在一处修改typedef名称会更容易。如，下面代码：
void f(vector<Custormer>& custs)
{
	vector<Customer>::iterator i = custs.begin();
	//...
}
最终发现vector容器不合适。如果要存储巨量的Customer对象，vector连续存储的特点就成为了一种缺点，我们就会转而使用deque（条款7？？？）。或者，我们发现，需要在序列的中部频繁地插入和删除元素，就会转而使用list。
针对上面的代码，在出现类型名称vector<Customer> 所有地方，我们都得作修改。如果代码这样写，会很容易：
typedef vector<Customer> Customers;
typedef Customers::iterator CustIter;
/...
void f(Customers& custs)
{
	CustIter i = custs.begin();
	//...
}
要作的改动仅仅只是将那个typedef变成list<Customer>或deque<Customer>。当然，事情不会总那么容易――如，我们的代码可能需要Customer::iterator是个随机访问迭代器，而list<Custormer>::iterator不是。尽管如此，typedef还是可以让我们从枯燥的修改工作中解脱出来。

2.)便于使用traits
traits技术具有强大的功能，它可以将信息和类型关联起来；如果想定制标准容器或算法，你会经常需要提供traits。有关traits的论述，请阅读“泛型程序设计”章节；此外，可参阅Exeptional C++条款2、3，有一个不区分大小写的string，定义了自己的char_traits，用以替换其缺省版本。

总结
一般来说，typedef可能让代码更易于编写、更易于阅读、更易于通过“额外一层间接”而被修改――在这里，仅仅只是一种名称上的间接性，但它还是为你带来了好处。
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款39：名字空间，之一：using声明和using指令
using声明和using指令
using声明（using-declaration）为实际声明在另一个名称空间中的名称创建一个本地同义词（local synonym）。为了重载名称解析的需要，using声明的动作方式和其它的任何声明一样。
//例39-1(a)
namespace A
{
	int f(int);
	int i;
}
using A::f;
int f(int);
int main()
{
	f(1);//歧义，A::f()是::f()？
	int i;
	using A::i;//错误，重复声明（就像写了两次“int i;”一样）
}

只有已经出现过声明的名称，using声明才能将其引入。
//例39-1(b)
namespace A
{
	class X {};
	int Y();
	int f(double);
}
using A::X;
using A::Y;//函数A::Y()，而非类A::Y
using A::f;//A::f(double)，而非A::f(int)
namespace A
{
	class Y {};
	int f(int);
}
int main()
{
	X x;//正确，X是A::X的同义词
	Y y;//错误，A::Y不可见，因为using声明出现在它想要的实际声明之前
	f(1);//这里偷偷使用了一个隐式转换，它调用的是A::f(double)，而不是A::f(int)。因为在using声明之前，只有头一个A::f()声明出现过
}
（如果更换using声明位置，那么在有int Y()函数声明的情况下，class Y{};不起作用，Y y;这里编译不过
#include <iostream>
using namespace std;

namespace A
{
	class X {};
	int Y();
	int f(double)
	{
		cout << "int f(double)" << endl;
		return 0;
	}
}

namespace A
{
	class Y {};
	int f(int)
	{
		cout << "int f(int)" << endl;
		return 0;
	}
}

using A::X;
using A::Y;
using A::f;

int main()
{
	X x;
	Y y;//编译不过
	f(1);
}
）
这一特点使得using声明具有顺序相关性――特别是，如果一个名字空间分布在一组头文件中，在使用这个名字空间中的名称时，情况更是如此。头文件包含的顺序，特别是，哪个头文件包含在using声明之前或之后，都会影响到using声明会将哪些名称引用到所在空间。当然，名称空间std就恰好属于“一个名字空间分布在一组头文件中”的情况。

using指令
有了using指令（using-directive），另一个名字空间中的所有名称就都可以使用于using指令所在的空间。和using声明不同，using指令会将声明在using指令之前、之后的所有名称都引用进来。
//例39-1(c)，书上的例子，不太对，不指定空间，则A中的声明都用不了？？？
#include <iostream>
using namespace std;

namespace A
{
	class X {};
	int f(double)
	{
		cout << "int f(double)" << endl;
		return 0;
	}
}
void f()
{
	X x;
	Y y;
	f(1);
}

using namespace A;

namespace A
{
	class Y {};
	int f(int)
	{
		cout << "int f(int)" << endl;
		return 0;
	}
}

int main()
{
	X x;
	Y y;
	f(1);
}
修改为如下：
#include <iostream>
using namespace std;

namespace A
{
	class X {};
	int f(double)
	{
		cout << "int f(double)" << endl;
		return 0;
	}
}

using namespace A;

void f()
{
	X x;
	Y y;//编译不过，这里还是不知道Y
	f(1);//这里也只能调到int f(double)
}

namespace A
{
	class Y {};
	int f(int)
	{
		cout << "int f(int)" << endl;
		return 0;
	}
}

int main()
{
	X x;
	Y y;
	f();
	f(1);
}


（之前的例子改写的
#include <iostream>
using namespace std;

namespace A
{
	class X {};
	int Y();
	int f(double)
	{
		cout << "int f(double)" << endl;
		return 0;
	}
}
using namespace A;

namespace A
{
	class Y {};
	int f(int)
	{
		cout << "int f(int)" << endl;
		return 0;
	}
}

using A::X;
using A::Y;

int main()
{
	X x;
	//Y y;
	f(1);//int f(int)
}
）
//------------------------------------------------------------------------------------------------
//More Exceptional C++ 条款40：名称空间，之二：迁徙到名字空间
好的长期方案的设计准则
简而言之，在使用名字空间时，一个好的长期方案至少应该遵循以下规则：
名字空间使用规则1：绝对不要在头文件中使用using指令
理由是，using指令会恣意污染名字空间，因为它有可能引用大量名称，而其中的许多名称（通常绝大多数）是不必要的。不必要的名称一旦出现，名称冲突的可能性就会在无意中大大增加――不仅头文件本身如此，每一个包含（#include）了这个头文件模块也如此。可以将头文件中的using指令看作野蛮人，它们对所过之处肆意破坏：仅仅只是出现它们的身影，“无意的冲突”就会发生――即使你认为自己和它已经结成盟友。
名字空间使用规则2：绝对不要在头文件中使用名字空间using声明
（这里的限定词――“名字空间”using声明。当然，可以放心地写一个类成员的using声明，以引用所需的基类名称。）
这条规则可能会让你吃惊，和最为普遍的建议相比，它的要求又进了一步。大多数程序员的建议是，using声明绝对不要出现在共享头文件的“文件范围”。就其本身而言，这是一条好建议：因为，和using指令一样，文件范围内的using声明也会导致同样的名字空间污染，只是少一些而已。
依作者看，上面的“普遍建议”还不够，根本就不应该在头文件中使用using声明，即使是在某个名字空间范围也不应该。using声明的含义是会发生变化的，在某个模块中，它取决于哪些头文件被包含（#include）在这个using声明之前。这种不可预测性应该禁止，这种做法不仅糟糕，还会导致程序不合法。考虑一种可能情况：如果头文件中有某个函数f()的内联定义（例如，假设f()是一个模板，或是某个模板的一部分），而且，f()中某行代码的含义会根据#include指令发性变化，这种情况下，这整个程序就是不合法的，因为它违反了“一个定义规则”（ODR，One Definition Rule）。ODR要求，在每一个使用了某个实体（这里，也就是f()）的编译单元中，这个实体的定义必须完全相同。如果不是这样，我们就会被流放到“具有不可预测行为的荒原”。即使在没有违反ODR的情况下，不可预测性也不是件好事。

名称空间使用规则3：在实现文件中，绝对不要在#include指令之前用using声明或using指令。
所有的using声明和using指令必须跟在所有的#include指令之后。否则，由于using会引入意想不到的名称，（通过#include指令）被包含进来的头文件的语义就有可能发生变化。
除此之外，在实现文件中，你可以继续使用using声明和（或）using指令的任意组合，只要有意义，无论是在文件范围和（或）函数范围，你都无需要担心。在那个特定的文件中，你在局部范围作出的决定取决于怎样让自己觉得方便，并且不会对别的实现文件有潜在的副作用。using声明和using指令的存在是为了给你提供方便，而不是要你为它们提供方便。做你想做的（如果没有名称冲突，使用所有名称又有什么错？）只要它影响的只是你自己的编译单元，而不是别人的头文件或编译单元。

“一定意义上的”名字空间使用规则4：在使用C头文件时，采用新风格的#include<cheader>，而不采用旧风格的#include<header.h>。当包含（#include）那引起原始版本的头文件时，相应的C库函数会像以前一样现身于全局名字空间。在用新名称包含（#include）C头文件时，你得到的是相同的C库函数，只不过，如今它们存在于名字空间std之中。

一个好的长期方案
这个好的长期方案是：在头文件（.h文件）中，为每一个出现的标准名称都显式地加上修饰；在每一个源文件（.cpp文件）中， 为了方便，只用为所需的名称加上using声明――因为在那个源文件中，那些名称可能会被大量使用。
//例40-3(b)：一个好的长期方案
//文件x.h
#include "y.h"
#include <deque>
#include <iosfwd>

std::ostream& operator<<(std::ostream&, const Y&);
Y operator+(const Y&, int i);
int f(const std::deque<int>&);

//文件x.cpp
#include "x.h"
#include "z.h"
#include <ostream>
using std::deque;//“using”出现在所有的#include之后
using std::ostream;
using std::operator+;
//或者，如果合适的话，使用“using namespace std;”
ostream& operator<<(ostream& o, const Y& y)
{
	//...
	return o;
}
Y operator+(const Y& y, int i)
{
	//...在实现中使用另一个operator+()
	return result;
}
int f(const deque<int>& d)
{
	//...
}
注意，x.cpp中的using声明应该出现在所有#include指令之后，否则，它们可能会给别的头文件带来名称冲突，具体情况取决于这些头文件被包含（#include）的次序。例如，使用x.h的operator+()可能会有歧义，这取决于是否有别的operator+()函数可见，而后者又取决于哪些标准头文件刚好被包含在using声明之前或之后。（不太懂？？？）
有这样一些人，即使在他们的.cpp文件中，他们也完全放弃了“using”的使用，而在每一个标准名称前都显式地加上修饰。作者不推荐这样做，因为这需要大量的额外工作，但通常不会带来任何实际好处。

一个不那么好的长期方案
与些相反，另一个常被推荐使用的方案实际上很危险，这个糟糕的长期“方案”建议：将项目中所有的代码都置于自身的空间中（这种做法本身不错，但它没有你所想象的那样有用），并在头文件中使用using声明或using指令（无意之中，它为潜在的问题敞开了大门）。之所以会有人建议使用这种方法，原因在于：和其它某些名字空间迁徙方案相比，在修改代码时，它需要的打字工作量最少。（错误的长期方案，绝对不能在头文件中使用using声明――即使在一个名字空间中）

一个有效的短期方案
移植步骤1：在每个头文件中，为所有所需之处添加“std::”修饰符。
我们绝不能在头文件中添加using声明或using指令；在头文件中，唯一的选择是在合适 的地方添加“std::”。
使用自动文本替换功能，可以迅速完成大部分工作――如，使用一个工具，在所有“*.h*”文件中将“string”修改为“std::string”（vector、list等常见名称也如法炮制）。要注意的一点是，在你使用的其它名称空间中，这些常见名称可能也会出现，不要无意中把它们也替换掉了。如，在你使用的某个第三方程序中，代码中有它自己的非标准的string，对于这样的名称，只能手工处理。
移植步骤2：创建一个名为myproject_last.h的新头文件，使之包含using namesapce std;指令。然后，在每一个实现文件中，在所有其它#include指令之后包含（#include）myproject_last.h。
对实现文件来说，情况好办一些。只需在每一个实现文件中简单地写上一个using指令就可以。当然，using指令要出现在所有#include语句之后。这种做法不违反规则1的精神，因为这里的头文件很特殊。它不是一种普通头文件，用来声明某种东西然后供以后使用；相反，它是一种机制，用来将代码插入到实现文件中，而且，是插在实现文件中某个易于控制的特定之处。
最后，怎么处理新的<cheader>头文件风格，这是一个可选任务。所以，在初次迁徙名字空间的过程中，这一步不需要做（或者，实际永远都不需要做）。

结尾：转向长期方案
最后，很可能在以后某个适当的时候，暂时不再为工程期限所近，就可以实施简单的移植策略，过渡到例40-3(b)所介绍的完整长期方案，简单地遵循以下步骤。
（1）在myproject_last.h中，注释掉using指令。
（2）重新编译你的工程。看看哪些地方不能通过编译。然后，在每个实现文件中，增加正确的using声明和（或）using指令――要么在文件范围（位于所有#include之后），要么在每个函数内部，视具体情况而定。
（3）这一步可做可不做。在每一个头文件或实现文件中，将“包含（#include）C头文件的代码”修改为新的<cheader>形式。可以通过自动文本替换工具很快完成。还可以更快！因为我们甚至可以完全省略这一步。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第1条 vector的使用
1. 
//示例1-1：
void f(vector<int>& v)
{
v[0];//A
v.at(0);//B
}
在示例1-1 中，如果v非空，A行跟B行就没有区别；如果v为空，B行一定会抛出一个std::out_of_range异常，至于A行的行为，标准未加任何说明。任何事情都可能发生，程序直接崩溃，或抛出异常，或没发生任何事情。
既然下标越界检查帮助我们避免了许多常见问题，为什么标准不要求operator[]实施下标越界检查呢，简短的答案是效率。总强制下标越界检查会增加所有程序的性能开销（虽然不大），即使有些程序根本不会越界访问。一句名言反映了C++的这一精神：一般说来，不应该为不使用的东西付出代价（或开销）。所以，标准并不强制operator[]进行越界检查。况且我们还有另一个理由要求operator[]具有高效性：设计vector是用来替代内置数组的，因此其效率应该与内置数组一样，内置数组在下标索引时是不进行越界检查的。如果需要下标越界检查，可以使用at。
2.
//示例1-2：vector的一些函数
vector<int> v;
v.reserve(2);
assert(v.capacity() == 2);
这里的断言存在两个问题，一个实质性的，另一个则是风格上的。
首先实质性问题是，这里的断言可能会失败。reserve的调用将保证vector的容量至少为2，然而，它也可能大于2.事实上这种可能性是很大的，因为vector的大小必须呈指数速度上升，因而vector的典型实现可能会选择按指数边界来增大其内部缓冲区，即使是通过reserve来申请特定大小的时候。因此，上面代码中的断言条件表达式应该使用>=，而不是==，如下：
assert(v.capacity() >= 2);
其次，风格上问题是，该断言（即使是改正后的版本）是多余的，因为标准已经保证了这里所断言的内容。所以再将它明确地写出来只会带来不必要的混乱。这样做毫无意义，除非你怀疑正在使用的标准库实现有问题。
v[0] = 1;
v[1] = 2;
这两句的问题比较明显，但可能是比较难于发现的明显错误，因为它们很可能会在你所使用的标准库实现上“勉强”能够“正常运行”。
大小（size，跟resize相对应）跟容量（capacity，与reserve相对应）之间有着很大的区别：
1. size告诉你容器中目前实际有多少个元素，而对应地，resize则会在容器的尾部添加或删除一些元素，来调整容器当中实际的内容，使容器达到指定大小。这两个函数对list、vector和deque都适用，但对其他容器并不适用。
2. capacity则告诉你最少添加多少个元素才会导致容器重分配内存，而reserve在必要的时候总是会使容器的内部缓冲区扩充至一个更大的容量，以确保至少能满足你所指出的空间大小。这两个函数仅对vector适用。
本例中使用的是v.reserve(2)，因此我们知道v.capacity()>=2， 这没有问题，但值得注意的是，我们实际上并没有向v当中添加任何元素，因而v仍然是空的。v.reserve(2)只是确保v当中有空间能够放得下两个或更多的元素而已。
准则：记住size/resize以及capacity/reserve之间的区别。
我们只可以使用operator[]()（或at()）去改动那些确实存在于容器中的元素，这就意味着它们是跟容器的大小息息相关的。
for(vector<int>::iterator i = v.begin(); i < v.end(); i++)
{
	cout << *i << endl;
}
一些风格上的问题，大多数意见是初级的，如下所示：
（1）尽量做到const正确性。可以改用const_iterator。（记得某个书上说可以不要用const的，很多算法不支持const_iterator？？？）
（2）尽量使用!=而不是<来比较两个迭代器。由于vector<int>::iterator恰巧是一个随机访问迭代器（当然，并不一定是int*），因此在这种特定情况下将它跟v.end()比较没有问题。但问题是<只对随机访问迭代器有效，而!=对任何迭代器都是有效的，因此我们将使用!=比较迭代器作为日常惯例，除非某些情况下确实需要<（注意，使用!=还有一个好处就是便于将来（如有需要）更改容器类型）。如，std::list的迭代器并不支持<，因为它们只不过是双向迭代器。
（3）尽量使用前缀形式的--和++。让自己习惯写++i而不是i++，除非真的需要用到i原来的值。例如，如果既要访问i所指的元素，又要将i向后递增一位的话，后缀形式v[i++]就比较适用了。
（4）避免无谓的重复求值。本例中v.end()所返回的值在整个循环的过程中不会改变，因此应该避免在每次判断循环条件是都调用一次v.end()，或者应当在循环之前预先将v.end()求出来。
注意，如果你的标准库实现中的vector<int>::iterator就是int*，而且能够将end()进行内联及合理优化的话，原先的代码也许并不任何额外开销，因为编译器或许能够看出end()返回的值一直是不变的，从而安全地将求值提到循环外部。这是一种相当常见的情况。然而，如果你的标准库实现的vector<int>::iterator并非int*（例如，在大多数调试版实现当中，其类型都是类类型的），或者end()之类的函数并没有内联，或者编译器并不能进行相应的优化，那么只有手动将这部分代码提出才能获得一定程序上的性能提升。
（5）尽量使用\n而不是endl。使用endl会迫使输出流刷新其内部缓冲区。如果该流的确有内部缓冲区，而且又确实不需要每次都刷新它的话，可以在整个循环结束之后写一行刷新语句，这样程序会执行得快很多。
最后一个意见稍微高级一些：
（6）尽量使用标准库中的copy()和for_each()，而不是自己手写循环，因为利用标准库的设施，你的代码可以变得更为干净简洁。这里，风格跟美学判断起作用了。在简单的情况下，copy()和for_each()可以而且确实比手写循环的可读性要强。不过，也只有像本例这样的简单情形才会如此，如果情况稍微复杂一些的话，除非你有一个很好的表达式模板库，否则使用for_each()来写循环反而会降低代码的可读性，因为原先位于循环体中的代码必须被提到一个仿函数当中才能使用for_each()。有时候这种提取是件好事，但有时它只会导致混淆晦涩。
之所以说大家的口味可能各不相同，就是这个原因。另外，在本例中我倾向于将原先的手写循环替换成如下形式：
copy(v.begin(), v.end(), ostream_iterator<int>(cout, "\n"));
此外，如果你如此使用copy()，原先关于!=、++、end()以及endl的问题就不用操心了，copy()已经帮你做了这些事情（当然，还是假定你并不希望在每输出一个int的时候都去刷新输出流，否则只有手写循环了）。复用如果运用得当的话不但能够改善代码的可读性，而且还可以避开一些陷阱，让代码更佳。
更进一步，编写一个基于容器的复制算法，就是说，施加在整个容器（而不仅仅是迭代器区间）之上的算法。这种算法同样也可以自动纠正const_iterator问题，如：
template<class Container, class OutputIterator>
OutputIterator copy(const Container& c, OutputIterator result)//迭代器不需要用引用，直接传值
{
	return std::copy(c.begin(), c.end(), result);
}
//例
#include <iostream>
#include <algorithm>
#include <vector>
#include <iterator>
using namespace std;

template<class Container, class OutputIterator>
OutputIterator copy(const Container& c, OutputIterator result)
{
	return std::copy(c.begin(), c.end(), result);
}

int main(int argc, char* argv[])
{
	vector<int> intVec(10);
	fill_n(intVec.begin(), 10, 1);
	copy(intVec.begin(), intVec.end(), ostream_iterator<int>(cout, " "));
	cout << endl;
	copy(intVec, ostream_iterator<int>(cout, " "));//这里是函数重载，程序会根据参数类型自动识别而不会与std::copy冲突。同::copy(intVec, ostream_iterator<int>(cout, " "));
	cout << endl;
}
//结束
这里只需要简单地包装std::copy()，让它对整个容器进行操作，此外由于是以const&来接受容器参数的，因而迭代器自然就是const_iterator了。
准则：
1)确保const正确性。特别是不对容器内的元素做任何改动的时候，记得使用const_iterator。
2)尽量使用!=而不是<来比较两个迭代器。
养成默认情况下使用前缀形式的--和++习惯，除非你的确需要用到原来的值。
实施复用：尽量复用已有的算法，特别是标准库算法（例如for_each()），而不是手写循环。
小结：
了解size()和capacity()之间的区别，了解operator[]()跟at()之间的区别。如果需要越界检查，请使用at()而不是operator()。这么做可以帮助我们节省大量的调试时间。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第2条 字符串格式化的“动物园”之一：sprintf
1. 什么是sprintf，尽可能多列举出sprintf的替代方案
考虑如下的C代码，它使用sprintf将一个整型值转化为可读的字符串形式，之所以要这样做可能是为了将一个整型输出到报表或者打印到GUI窗口上：
//示例2-1：在C里面使用sprintf来字符串化某些数据，PrettyFormat()接受一个整型为参数，将它格式化并放入给定的输出缓冲区当中。出于格式化的考虑，格式化的结果必须至少为4个字符宽。
void PrettyFormat(int i, char* buf)
{
	//代码就是这些，优雅、简洁
	sprintf(buf, "%4d", i);
}
int main()
{
	char s[10];// = new char[10];
	PrettyFormat(5, s);
	cout << s << endl;
	//delete [] s;
}
是不是有办法借助于C++中的类和模板等特性来将这件事做得更好呢
为实现这一目的，至少有不下四种截然不同的、直接了当的标准做法，示例2-1 是其中第一种。其中任一种都提供了在清晰性、类型安全性、运行时安全性以及效率之间的权衡。此外，套用名言：所有这四种选择都是标准的，但其中有些比其他选择要“更标准”一些。而且，说得更严重一些，它们并非全都基于同一个标准。分别是：
sprintf[C99, C++03]
snprintf[C99]
std::stringstream[C++03]
std::strstream[C++03]
除此之外，还有另一个“目前虽不合标准但很有希望成为标准”的替代方案，好像嫌手头方案还不够多似的，它就是：
boost::lexical_cast[Boost]
boost::lexical_cast主要用在不需要任何特殊格式化的简单转换当中。
2. sprintf的主要优势跟弱点分别是什么，明确加以说明。
我们的大方向：兴趣在于通常情况下如何将非字符串的值格式化为字符串形式，或许在实际编码中，我们的做法是在不断变化和改进的，而不像示例当中的一行简单代码那样。
sprintf()有两个主要的优点，还有三个明显缺陷。
议题#1:易用性与清晰性。一旦学会了sprintf常用格式化标志以及它们的各种组合，其使用就会变得简洁明了。使用sprintf的代码明白无误地说明了它正在做的事情。因此printf家庭在大多数文本格式化场合下是很难有功能能够与之匹敌的。
议题#2:
效率最佳（能够直接复用现有的缓冲区）。通过使用sprintf将结果直接放入一个已有的缓冲区中，PrettyFormat()将不用牵涉任何动态内存分配或者其他额外的幕后操作就能完成任务。将一块已分配好用于存放输出结果的缓冲区传递给PrettyFormat()，后者负责将格式化的结果直接写入这块缓冲区。
告诫：现在不必过分在乎效率，因为你的应用程序或许根本就不会在意这一点效率差别。永远不要过早进行优化，只有当时间测试显示确实有必要时才去进行优化。遇到这种情况时，永远不要忘记，效率是以牺牲内存管理封装性来换取的。议题#2 等于是在说：你自己去管理内存。

sprintf同样存在一些显著缺陷：
议题#3:
长度安全性。sprintf是引起缓冲区溢出错误的原因之一，如果目标缓冲区碰巧不够大，装不下整个输出结果的话，就会发生缓冲区溢出。
char smallBuf[5];
int value == 42;
PrettyFormat(value, buf);//隐患
assert(value == 42);
本例中，42恰好足够小，以至于5字节大小的结果“42\0” 恰巧能够放在smallBuf中。然而，某一天代码改成：
char smallBuf[5];
int value = 12108642;
PrettyFormat(value, buf);
assert(value == 12108642);//这个断言很可能失败！
这会导致smallBuf尾部之后的区域也被改写。
我们无法轻易地改善示例2-1 的安全性。的确，可以让PrettyFormat()接受缓冲区的长度并对sprintf()的返回值进行检查，但这等于事后诸葛亮。具体做法如下：
//糟糕的主意：丝毫没有改观
void PrettyFormat(int i, char* buf, int buflen)
{
	if (buflen <= sprintf(buf, "%4d", i))//并不比以前好，现在情况如何呢，既然在这里问题被侦测出来，那么就意味着问题已经发生，换句话说该被破坏的内存已经被破坏了
	{
	
	}
}
//------------------------------------------------------------------------------------------------
对于这个问题，根本没有解决方案。当错误被侦测出来时，内存已经被破坏，我们已经在不该写的地方写下了一些字节，如果情况糟糕的话，程序甚至根本没有机会运行到报错代码处。
议题#4:
类型安全性。对于sprintf来说，类型错误就意味着运行时错误，而非编译期错误，更可怕的是这些类型错误甚至根本就不会表现出来。printf家庭使用C的可变参数列表，C编译期通常并不检查这类实参列表的类型。
诚然，示例2-1 中代码如此简单，至于只要清楚知道只要将一个int传给sprintf，就可能足够简单地维护它。不过，如果不小心把d错打成了c，结果就成了这样：
sprintf(buf, "%4c", i);
这会导致输出结果为字符而不是数字，这种情况下我们或许很快能意识到错误所在，因为sprintf会把i的第一个字节解释为一个char值。此外，把d把打成s：
sprintf(buf, "%4s", i);
这样做的话，或许我们同样能够很快反应过来，因为这么做可能会令程序立即崩溃或偶发性崩溃。因为这时sprintf会不加提示地将i解释为指向字符串的指针，并顺着这个指针所指的方向去寻找一个实际上并不存在的字符串，实际上，这个指针可能指向躺在中的任何位置。
下面情况可就微妙了，假设我们将d错打成ld，会出现什么情况呢
若是这种情况的话，给出的格式字符串就等于告诉sprintf，给它的是long int，而实际上却是int。这同样也是糟糕的C代码，不过，问题是它不仅不会以编译期错误的表现出来，甚至不会导致运行时错误。在许多流行的平台上，程序的运行结果仍然会跟以前一样，因为int在许多流行平台上碰巧跟long int具有相同的大小和内存布局。因而你也许一直都不会注意到这个潜在的问题，直到某一天将代码移植到某个平台上，该平台上的int跟long int具有不同的大小，这时才发现这个问题，甚至就连这个时候，程序可能也并不总是产生错误的结果或立即崩溃。
议题#5:
模板亲和性。很难将sprintf放在一个模板当中。如下：
template<typename T>
void PrettyFormat(T value, char* buf)
{
	sprintf(buf, "%/**这里应该写些什么呢？/", value);
}
所能做到的最好的（最糟的？）就是声明一个主模板，并为所有那些与sprintf兼容的类型分别提供对应的特化版本：
//不算好点子：一个东拼西凑出来的PrettyFormat
template<typename T>
void PrettyFormat(T value, char* buf);//注意，主模板只有声明，没有定义
template<>
void PrettyFormat<int>(int value, char* buf)
{
	sprintf(buf, "%d", value);
}
template<>
void PrettyFormat<char>(int char, char* buf)
{
	sprintf(buf, "%c", value);
}
//………还有其他特化版本
总的来说，sprintf是这样的：
标准吗：是[C90]，[C++03]，[C99]
易用吗，代码清晰明确吗：是
高效吗，没有额外的内存分配吗：是
长度安全吗：否
类型安全吗：否
可用在模板当中吗：否
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第3条 字符串格式化的“动物庄园”之二：标准的（或极度优雅的）替代方案
1. 比较下面这些替代方案的优点和弱点。
（a）snprintf
（b）std::stringstream
（c）std::strstream
（d）boost::lexical_cast

替代方案#1 ：snprintf
（a）snprintf
与sprintf最相近的选择是snprintf。snprintf只是在sprintf上增加了一项功能，不过是一项重要功能，即用户可以给出输出缓冲区的最大长度，从而避免缓冲区溢出。当然，如果缓冲区太小的话，输出结果就会被截断。
坦白说，早该使用snprintf来取代sprintf了，即使在snprintf还没有标准化之前。大多数良好的编码标准都不推荐你使用像sprintf这样的不检查长度的函数，而且该原则是很有道理的。使用不检查的sprintf常引起一些声名狼藉的常见问题，通常会导致程序崩溃，尤其会导致安全脆弱问题。
借助于snprintf，可以正确编写出刚才一直试图实现的带长度检查的PrettyFormat()版本。
//示例3-1：在C中使用snprintf来字符串化某些数据
void PrettyFormat(int i, char* buf, int buflen)//这就是代码，简洁优雅，关键是比以前要安全得多
{
	snprintf(buf, buflen, "%4d", i);//在VS2010里用的是：sprintf_s(buf, buflen, "%4d", i);
}
即使这样做了，仍然存在另一种出错的可能，即调用者将缓冲区长度搞错了。这意味着跟那些具有资源管理功能的替代方案相比，snprintf还算不上百分之百地杜绝缓冲区溢出可能性，不过跟sprintf相比它显然要安全多了，在“长度是否安全”问题上应该算是合格的。使用sprintf没有合适的途径来避免缓冲区溢出，而通过snprintf则可以（很大程序上）杜绝缓冲区溢出。
snprintf的一些标准化之前版本的行为稍有不同。尤其是在一个主要实现中，如果输出结果填满或者大于缓冲区容量，缓冲区里的串就不会以“\0” 结尾。这种情况下，PrettyFormat()函数就得稍作调整以应付这种非标准的行为：
//在C中使用一个并不十分遵从C99标准的_snprintf来将数据字符串化
void PrettyFormat(int i, char* buf, int buflen)//这里是代码，简洁优雅，安全得多
{
	if (buflen > 0)
	{
		_snprintf(buf, buflen - 1, "%4d", i);//sprintf_s
		buf[buflen - 1] = '\0';
	}
}
在其他任何方面，sprintf和snprintf都是一样的。综上，snprintf与sprintf相比：
标准吗：是，仅[C99]，不过也可能进入C++0x 
长度安全吗：是
从这些比较当中，可以给出如下建议：
准则：永远不要使用sprintf。
如果你真的决定使用C的stdio设施的话，一定要记住，使用那些进行长度检查的函数，如snprintf。即便在你的编译器上它们只是作为非标准扩展存在，也得使用它们，因为使用它们没有任何损失，还能够带来实实在在的好处。

替代方案#2 ：std::stringstream
（b）std::stringstream
C++中用于字符串化的最常见设施是stringstream这一族的类了。示例3-1 如果用ostringstream来替代sprintf的话看起来就会像这样：
//示例3-2：在C++中进行字符串化，使用ostringstream
#include <iostream>
#include <sstream>
#include <string>
#include <iomanip>
using namespace std;

void PrettyFormat(int i, string& s)//不如原先的简洁优雅
{
	ostringstream temp;
	temp << setw(4) << i;
	s = temp.str();
}

int main()
{
	string s;
	PrettyFormat(5, s);
	cout << s << endl;
}

相对于sprintf来说，stringstream具有一些优点，也有缺点。
议题#1:
易用性和清晰性。使用stringstream让原先的一行代码变成了三行，还得引入一个临时变量。使用stringstream的做法有几个优势，不过清晰性并非其中。像setw(4)这样的流操纵子跟sprintf的格式标志一样易学，只不过通常更笨拙冗长一些。像<<setprecision(9)和<<setw(14)这样的长名字代码会难于阅读（跟%14.9 这种格式化字符串相比），即便所有的操纵子都整齐排列也无济于事。
议题#2:
效率（能否直接利用现在缓冲区）。stringstream会自己另外分配一份单独的缓冲区来存放结果，另外还需要使用一些辅助性的对象，通常所有这些都意味着需要进行额外的内存分配。
议题#3:
长度安全性。stringstream内部的basic_stringbuf缓冲区类会根据需要自动增长，以便容纳需要存放的数据。
议题#4:
类型安全性。使用operator<<和重载决议，即使是对于那些提供了自己的流插入操作符的自定义流类型，也总能够实现类型安全性。不会因为类型不符而导致运行时错误。
议题#5:
模板亲和性。编译器会自动调用正确的operator<<，那么将PrettyFormat泛化为可接受任何类型的数据是举手之劳：
template<typename T>
void PrettyFormat(T value, string& s)
{
	ostringstream temp;
	temp << setw(4) << value;
	s = temp.str();
}
综上，stringstream跟sprintf比较
标准：是
易用，代码清晰明确：否
高效，无额外内存分配：否
长度安全：是
类型安全：是
可用于模板之中：是

替代方案#3 ：std::strstream
（c）std::strstream
标准委员会觉得stringstream可以取代strstream，因为stringstream更好地封装了内存管理，所以他们装饰strstream标明为deprecated（不赞成的），然而strstream仍然还是标准的法定成员，任何符合C++标准的实现都必须提供它。
使用strstream的话，示例3-1 会像这样：
//示例3-3：在C++中使用ostrstream进行字符串化
#include <iostream>
#include <strstream>
#include <iomanip>
using namespace std;

void PrettyFormat(int i, char* buf, int buflen)//不算太差，不过别忘了最后要输出结束符
{
	ostrstream temp(buf, buflen);
	temp << setw(4) << i << ends;
}

int main()
{
	char s[10];
	PrettyFormat(5, s, 10);
	cout << s << endl;
}
议题#1:
易用性和清晰性。在易用性跟清晰性方面略逊stringstream一筹。两者都要求建立一个临时对象，不过strstream要求你记得手动输出一个结束符来结束字符串，这比较危险，如果不小心忘记了，同时在读取结果串的时候又期望该串是以'\0'字符结尾的话，就面临着读取超过结果串末尾之后的内存数据的危险，而就算sprintf也没这么脆弱，它总是会在结果串的末尾加上结束符。不过，按照示例3-3 所展示的方式使用strstream至少有一个优点，无需在最后调用c_str()来获取结果串。（当然，如果让strstream创建自己的缓冲区，其内存只是部分封装的，你除了得在最后调用.str()来将其中的结果串取出来之外，还得加上一次.freeze(false)调用，否则strstreambuf在析构的时候是不会释放内存的。）
议题#2:
效率。只需要在创建ostrstream对象的时候传递一个指向现有缓冲区的指针，可以避免任何额外的内存分配，ostrstream会将它的结棍直接输出到该缓冲区中。这跟stringstream相比是一个非常重要的区别，在能否将结果串直接输出到现有的目标缓冲区（从而避免额外的内存分配）这个问题上，stringstream无法与strstream比拟。当然，如果没有现在可利用的缓冲区，ostrstream也可以使用自己动态分配的缓冲区，只需调用它的默认构造函数即可。strstream是我们所讨论的所有可选方案当中惟一能够提供这种选择自由的方案。
议题#3:
长度安全性。ostrstream内部的strstreambuf缓冲区会自动检查它的长度以确保不会写超过给定缓冲区之外的内存区域。如果我们使用的是一个默认构造的ostrstream对象的话，其内部的strstreambuf缓冲区就会根据需要自动增长以容纳有待存储的值。
议题#4:
类型安全性。strstream和stringstream一样，完全是类型安全的。
议题#5:
模板亲和性。和stringstream一样，如
template<typename T>
void PrettyFormat(T value, char* buf, int buflen)
{
	ostrstream temp(buf, buflen);
	temp << setw(4) << value << ends;
}
strstream与sprintf比较：
标准：是[C++03]
易用，代码清晰明确：否
高效，无额外内存分配：是
长度安全：是
类型安全：是
可用于模板之中：是

替代方案#4 ：boost::lexical_cast
（d）boost::lexical_cast
boost库中提供的设施之一就是boost::lexical_cast，它是stringstream的一个易用的包装类。此外boost中还包括一些其他华丽和重要的设施，它们同样在内部借助于流来实现，并提供了更为sprintf式的格式化选择，其中尤为突出的要数boost::format。
template<typename Target, typename Source>
Target lexical_cast(Source arg)
{
	std::stringstream interpreter;
	Target result;
	if (!(interpreter << arg) || !(interpreter >> result) || !(interpreter >> std::ws).eof())
		throw bad_lexical_cast();
	return result;
}
lexical_cast的意图并非是想要成为sprintf的直接竞争者。实际上，sprintf比lexical_cast更为通用，而lexical_cast的目的只是为了将数据从一个可流化的类型转换为另一个可流化的类型，因而它与C中的atoi等转换函数以及非标准但广泛使用的itoa等函数的竞争更为直接一些。
下面是使用lexical_cast改造示例3-1 后的情形：
//示例3-4：在C++中使用boost::lexical_cast进行字符串化
#include <iostream>
#include <string>
#include "boost/lexical_cast.hpp"
using namespace std;
using boost::lexical_cast;

void PrettyFormat(int i, string& s)
{
	s = lexical_cast<string>(i);//没有设置对齐位数啊？？？
}

int main()
{
	string s;
	PrettyFormat(5, s);
	cout << s << endl;
}
议题#1:
易用性和清晰性。在所有这些例子当中，使用lexical_cast的代码最为直接地表达了实际意图。
议题#2:
效率。由于lexical_cast使用的是stringstream，因此它需要至少跟stringstream一样多的内存分配次数。
跟stringstream一样，在长度安全性、类型安全性以及模板亲和性这些方面，lexical_cast也有优秀表现。
lexical_cast与sprintf比较：
标准：否，有可能成为[C++0x]的候选
易用，代码清晰明确：是
高效，无额外内存分配：否
长度安全：是
类型安全：是
可用于模板之中：是

还有一些并没有详细讨论的非标准方案，将boost::lexical_cast作为非标准方案的代表是因为它简洁优雅，不过即便是在boost当中也存在着更为完备更为重量级的方案，特别值得注意的是boost::format，这建立在与这儿提到的stringstream和strstream技术类似的方法基础之上，提供了更自动化的能力来支持sprintf式的格式化。

在以上分析基础上，得出如下准则
1. 如果你所要做的只是将一个值转换为一个字符串（甚至于其他任何类型）的话：尽量默认使用boost::lexical_cast。
#include <iostream>
#include <string>
#include "boost/lexical_cast.hpp"
using namespace std;
using boost::lexical_cast;

void PrettyFormat(int& i, string& s)
{
	i = lexical_cast<int>(s);
}

int main()
{
	string s("100");
	int i;
	PrettyFormat(i, s);
	cout << i << endl;
}
2. 如果想进行简单的格式化，或者需要支持宽字符串，或者想要让进行格式化的代码能够用在模板当中：尽量使用stringstream或strstream。跟snprintf相比，使用stringstream/strstream的代码会比较冗长，且难于理解，不过对于简单的格式化任务来说，情况不会太糟。
3. 如果想要进行一些更为复杂的格式化任务，同时并不需要宽字符串支持，也不想让代码用在模板当中的话：尽量使用snprint。这是C的做法，并不意味着C++程序员就不能用它。
4. 仅当实际的性能测试显示那些较好的替代方案在你的代码中某个特定的地方确实都会造成瓶颈时，只在这些特定地点改用strstream或snprintf，具体用哪个则要看谁更适合。
5. 永远不要使用sprintf。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第4条 标准库成员函数
1. 什么是std::mem_fun，什么时候会使用它
标准库里面的mem_fun是一个适配器（adapter）类，能够将成员函数适配为所谓的仿函数（functor），从而可被标准库算法以及其他正常情况下只使用自由函数的代码所使用。
例：
class Employee
{
public:
	int doStandardRaise() {/*...*/}
	//...
};

int giveStandardRaise(Employee& e)
{
	return e.doStandardRaise();
}

std::vector<Employee> emps;
下面这种用法可能是司空见惯了的：
std::for_each(emps.begin(), emps.end(), &giveStandardRaise);
（例：
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Test
{
public:
	Test(int i): i_(i) { }
	void show()
	{
		cout << i_ << endl;
	}
private:
	int i_;
};

void doTestShow(Test& t)
{
	t.show();
}

int main()
{
	vector<Test> tVec;
	tVec.push_back(Test(1));
	tVec.push_back(Test(2));
	for_each(tVec.begin(), tVec.end(), &doTestShow);//这里的&加不加无所谓
	for_each(tVec.begin(), tVec.end(), mem_fun_ref(&Test::show));//成员函数指针的&必须要加
}
）

但是，如果giveStandardRaise()并不存在，或者由于某些原因需要直接去调用Employee中对应的成员函数的话，可以这么写：
std::vector<Employee> emps;
std::for_each(emps.begin(), emps.end(), std::mem_fun_ref(&Employee::doStandardRaise));
如果容器是老式的，其中包含的是对象的话，就应当记住使用mem_fun_ref，因为for_each操纵的将会是容器中对象的引用。而倘若容器中包含的是指向对象的指针，就应该使用mem_fun：
std::vector<Employee*> empPtrs;
std::for_each(empPtrs.begin(), empPtrs.end(), std::mem_fun(&Employee::doStandardRaise));
你可能已经注意到了，在示例中展示的成员函数皆是无参的，对于那些接受一个参数的成员函数，可以利用std::bind...()辅助函数，使用原则跟mem_fun一样。然而遗憾的是，这种做法不适用于那些接受两个或更多参数的函数。
（例：
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Test
{
public:
	Test(int i): i_(i) { }
	void show(int n)
	{
		cout << i_ + n << endl;
	}
private:
	int i_;
};

int main()
{
	vector<Test> tVec;
	tVec.push_back(Test(1));
	tVec.push_back(Test(2));
	for_each(tVec.begin(), tVec.end(), bind2nd(mem_fun_ref(&Test::show), 2));//感觉bind1st和bind2nd是绑定两个对象，这里把2绑定到第二个参数上，第一个参数是类对象
}
）

使用mem_fun，但不要将它用在标准库自己身上。
2. 假设在下面代码中的/*...*/处放入恰当的模板参数，这行代码会成为合法且可移植的C++代码吗，请说明理由。
std::mem_fun</*...*/>(&(std::vector<int>::clear));
首先注意到，其实/*...*/处根本没必要放置任何模板参数。故意这样问你是因为在写作本书的时候仍然还有部分流行的编译器不能正确地推导出模板参数。在这些编译器上，你必须手动给出模板参数。取决你的标准库实现，你的代码看起来可能像这样：
std::mem_fun<void, std::vector<int, std::allocator<int> > >(&(std::vector<int>::clear));
随着时间推移，这种局限性将会消失，并且编译器也可以让你放心地省略模板参数。
你可能想知道为什么刚才说“取决于你的标准库的实现”。毕竟，std::vector<int>::clear()的函数签名是无参、返回void，不是吗，标准中是这么说的，对吗
也许你错了，触摸到了问题的症结所在。
C++标准里关于标准库的部分在描述某些成员函数的实现时故意留了一些余地，尤其是下面这句话：
1. 一个具有默认参数的成员函数签名可以被“两个或多个具有等价行为的成员函数签名”所替代。
2. 成员函数签名可以具有额外的默认参数。
上面第二句话是问题所在，即那些可有可无、若隐若现的额外参数（简称它们为“皮卡布”参数）就是肇事者。
当你调用一个成员函数的时候，那些“皮卡布”参数会绑定到它们的默认值，因而平常你根本不用去关心标准库是否为这些函数添加了一些额外的形参。然而遗憾的是，当你不得不知道某个成员函数的确切签名时，这些可能的额外形参就成了大问题。譬如在你的使用mem_fun的时候，注意，即使你的编译器能够正确地推导出模板实参也无济于事，这是因为两个潜在问题。
1. 如果有问题的成员函数实际上具有一个带默认值的形参，而你又不期望出现这个形参的话，你就得使用像std::bind2nd这样的设施来对付它。这么做了之后，如果代码移植到另一个平台上，而该平台上的标准库中相应的成员函数却具有一个不同类型的额外形参，或者根本没有额外的形参，那你的代码同样无法工作。
2. 如果有问题的成员函数实际上具有两个或多个形参（即便它们都是有默认值的），就根本没法将mem_fun用在自身上。
最后，考虑一个更为一般性的结果。
使用指向成员函数的指针，只不过不是标准库里的成员函数。
这里还存在一个更为基本的问题：我们不可能可移植地创建一个指向标准库里的成员函数的指针。
毕竟，如果想要创建一个指向函数的指针，不管该函数是不是成员函数，你都得知道该函数指针的类型，这就意味着你首先必须知道该函数的签名。
由于标准库里面的成员函数的签名无法确切得知，除非你去查看标准库实现的相应头文件，看看所需要的成员函数是否被添加了某些“皮卡布”形参，而且即便这次知道了，库的下一个发布版仍然可能改动，总之，就是无法既可靠地使用指向标准库中成员函数的指针又得到可移植的代码。

通常标准成员函数的实现自由度对用户来说是不可见的，如果所要做的仅仅是调用这些函数的话，永远不会注意到有什么差别。然而，如果要使用指向成员函数的指针，或者约束器设施的话，你就得记住，将它们用在标准库本身的成员函数是不可靠的，即使今天碰巧在你的特定标准库实现中某些特定的成员函数上能够工作了，等到库的版本一更新，说不定就又不能工作了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第5条 泛型性的风味之一：基础
1. “C++模板提供了编译期多态的能力”，请解释。
当在一个面向对象的世界当中考虑多态的时候，所考虑的是运行时多态，这种能力来自虚函数。基类建立起一个接口“合约”，该“合约”由一系列虚函数构造，派生类可以从基类进行派生，并在不违反合约所蕴涵的语义的前提下重写基类的虚函数。这么一来，那些期望使用基类对象（通过指针或引用来持有基类对象）来工作的代码使用派生类同样能够运行良好。
这是极其有用的特性，带来了若干运行时的灵活性。不过，运行时多态有两大主要缺点：首先，这些类型必须位于同一继承自某个公共基类的类层次结构当中；其次，当虚函数在一个密集的循环当中被调用的时候，你可能会注意到它会带来一些运行时开销，因为通常每次对虚函数的调用都要通过一个额外的间接层――虚函数指针，同时，编译器负责根据你的意思将函数调用分发到派生类当中对应的函数。
如果你在编译期就知道正在使用的是什么类型的话，就可以避免这两个缺陷：你可以使用那些并非具有继承关系的类型，只要它们支持你要的操作即可。
//示例5-1(b)：新型的编译期多态，这是个强大的特性，至今我们仍在不断探寻这种能力可能带来哪些令人惊奇的东西
class Xyzzy
{
public:
	void f(bool someParm = true);
	void g();
	void goToGazebo();
	//...
};

class Murgatroyd
{
public:
	void f();
	void g(double two = 6.28, double e = 2.71828);
	int heavensTo(const Z&) const;
	//...
};

template<class T>
void h(T& t)
{
	t.f();
	t.g();
}

int main()
{
	Xyzzy x;
	Murgatroyd m;
	h(x);
	h(m);
}

只要x跟m这两上对象都提供了名为f和g的无参数成员函数，h()就能够工作。在示例5-1(b)中，实际上Xyzzy和Murgatroyd中的成员函数f和g分别具有不同的函数签名，而且它们各自还提供了其他的成员函数，不过h()并不关心这些。只要的确可以无参地调用f跟g，编译器就允许h()进行这种调用。
模板提供了强大的编译期多态能力。虽说在大多数编译器上，使用模板不当可能会导致难以读懂的错误信息，然而不能否认，模板同样是C++中最强大的特性之一。

2. 下面这个函数的语义是什么，请尽量说全面一些，并务必解决一下为什么这里有两个模板参数而不是一个。
//示例5-2(a)：construct。
template<class T1, class T2>
void construc(T1 *p, const T2& value)
{
	new (p) T1(value);
}
construct()函数模板负责在给定的内存位置构造对象，并同时以某个初始值来初始化它。这里使用new操作符的形式称为定位new(placement new)，这种形式的new并不为新对象分配内存，只不过是将新对象放置到p所指的内存位置。任何以这种方式new出来的对象都应当通过显式调用其析构函数来销毁，而不是使用delete表达式。
如果construct()只有一个模板参数的话，如果要从一个不同类型对象进行复制，就得明确地给出参数类型：
//示例5-2(b)：一个功能稍差的construct()，以及为什么说这功能稍差
template<class T1>
void construct(T1* p, const T1& value)
{
	new (p) T1(value);
}

//假设p1和p2皆指向未初始化内存（raw memory）
void f(double* p1, Base* p2)
{
	Base b;
	Derived d;
	
	construct(p1, 2.718);//OK
	construct(p2, b)//OK
	
	construct(p1, 42);//错误：T1究竟是double还是int
	construct<double>(p1, 42);//OK
	
	construct(p2, d);//错误：T1究竟是Base还是Derived
	construct<Base>(p2, d);
}
这里有两处地方之所以会发生二义性是因为编译器没有足够的信息推导出模板形参T1的值，因而程序员不得不手动显式地给出一个模板实参。
假如我们想允许程序员在不用显式地给出类型名的情况下就能够完成上面这些事情，就需要使用用原先给出的具有两个独立的模板参数的construct()了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第6条 泛型性的风味之二：够“泛”了吗
准则：（指向数组内元素的）指针永远都是迭代器，而迭代器并非总是指针。
//示例6-1：destroy
template<class T>
void destroy(T* p)
{
	p->~T();
}
template<class FwdIter>
void destroy(FwdIter first, FwdIter last)
{
	while(fisrt != last)
	{
		destroy(first);//改为destroy(&*first);
		++first;
	}
}
这种做法几乎总是行之有效的。先将迭代器解引用，获得容器内对象的直接引用，然后获取它的地址，这就确保了我们能够得到想要的指针。更详细地说，所有符合标准的迭代器都要求提供operator*()，而且该操作必须返回一个真正的T&。这便是C++标准之所以不支持代理容器的原因。可参考More Exceptional C++中的条款6中关于表达式&*t.begin()的讨论（导致destroy(&*first)不能正常工作的情况还是有的，虽然极其罕见，如果T重载了operator&()并用它来返回其他东西而不是当前对象的地下，那么改进后的形式仍然是无法正常工作的，不过那是病态的做法，作者从来没有见过哪个设计有正常理由这么做）。

这个故事的精神是，在使用一个泛型函数来实现另一个泛型函数的时候，须留神一些不易觉察的泛型性丧失。本例中就是一个不易觉察但非常严重的泛型性丧失，即两个参数的destroy()在可接受的迭代器类型方面并不像代码作者原先设想的那样宽泛。甚至连改进后的版本仍旧存在着一个更微妙的将要缺陷，即改为destroy(&*first);之后，我们实际对T增加了一个额外的要求，即T上的operator&()应当具有常规语义，换句话说，应当返回目标对象的地址。而如果我们不使用一个函数来实现另一个函数的话，这两个陷阱则都可以优雅地回避掉。
并不是叫你不要使用模板来实现模板，只是建议在这么做的时候要留意它们之间潜在的相互影响。

2. 下面函数语义是什么，其中模板形参T的要求又是什么，可能将这些要求当中的任何一条消掉吗。
//示例6-2(a)：swap
template<class T>
void swap(T& a, T& b)
{
	T temp(a);
	a = b;
	b = temp;
}
swap()只不过是通过复制构造函数和复制赋值操作符来将两个值进行交换而已，因而它要求T具有一个复制构造函数和一个复制赋值操作符。（我也就能想到这些。。。）

如果答案就这些，只能得一半分。在考察任何函数的语义的时候，最值得注意的一个方面就是异常安全性，包括它提供了什么程序的异常安全保证等。本例中，swap()根本就不是异常安全的，例如我们可以假设T的复制赋值操作符会抛出异常，特别是如果T::operator=()会抛出异常但它同时又具有原子语义（要么全部成功要么全部失败），再假设第二次复制赋值失败的话，就会因异常的抛出而离开swap()函数，然而届时a的值已经被修改了。更糟的情况是T::operator=()不仅会抛出异常，而且不具有原子语义，那么就可能发生这样的结果，swap()异常退出，而它的两个参数都被修改了，其中一个被修改后的值可能既不是a也不是b的值。这样，swap()的文档就必须像下面这样来描述。
1. 如果T::operator=()不抛出异常，那么除了T操作的副作用外，swap()就能够给出“要么全部成功，要么全部失败”的原子语义保证。
2. 否则，如果T::operator=()可能抛出异常的话：
（a）如果T::operator=()具有原子语义，而且swap()是异常退出，那么第一个实参就有可能被也有可能不被修改。
（b）否则，如果T::operator=()不具有原子语义，而且swap()是异常退出，那么两个实参皆有可能被也有可能不被修改，而且其中一个实参的值有可能既不是实参一的值也不是实参二的值。
有两个办法可以消除“T必须具有一个复制赋值操作符”这一限制，第一个办法还能额外提供更好的异常安全性。
1. 第一个办法即特化或重载swap()，假设我们有一个类MyClass，该类遵循了一个常用 手法，即提供了一个不抛出异常的Swap()成员函数。这么一来就可以针对MyClass来特化标准的swap()函数了，如下：
//示例6-2(b)：特化swap()
class MyClass
{
public:
	void swap(MyClass&)/*throw()*/;
	//...
};

namespace std
{
	template<>
	swap<MyClass>(MyClass& a, MyClass& b)//throw
	{
		a.Swap(b);
	}
}

针对MyClass来重载标准的swap()函数也可以达到同样的效果，如下：
//示例6-2(c)：重载swap()
class MyClass
{
public:
	void swap(MyClass&)/*throw()*/;
	//...
};

//注意，这个重载并没有放在std名字空间当中。因为可以特化std空间的内容，但不能在std空间增加重载函数
swap(MyClass& a, MyClass& b)/*throw()*/
{
	a.Swap(b);
}
即便T确实具有一个赋值操作符（从而原先那个swap()也是可行的），这种做法通常不失为一个好主意。
如果创建的新类型提供了类似于swap的操作，那么通常最好也为你的类特化一下std::swap()（或者在其他名称空间中提供自己的swap()重载也行）。你的swap()通常要比一般化的std::swap()更高效，后者使用的是蛮力，而你的swap()则可以用巧劲，而且你的swap()往往能够改善swap()本身的异常安全性。
准则：如果你的类型（跟只知道蛮干的std::swap()相比）有一个更好的途径可以用于交换其对象的值的话，请考虑为它特化std::swap()。

2. 消除“T必须具有一个复制赋值操作符”这一限制的第二条算途径是“先析构再重建”。其核心理念是通过T的复制构造函数而非复制赋值操作符来实现交换，当然这种做法的前提是T必须确实具有复制构造函数。
//示例6-2(d)：不用复制赋值的swap()
template<class T>
void swap(T& a, T& b)
{
	if (&a != &b)//现在这个检查变得有必要了！
	{
		T temp(a);
		
		destroy(&a);
		construct(&a, b);
		destroy(&b);
		construct(&b, temp);
	}
}
首先，如果T的复制构造函数可能会抛出异常的话，这种做法则肯定是不妥当的，因为这样一来你就会面临跟最初的std::swap()一样的异常安全性问题（在construct中的定位new操作是用另一个对象拷贝构造当前内存位置的对象，所以如果抛出异常的话，则不是异常安全的）。甚至只会更严重，你可能会遇到这样的情况：被操作的对象不仅具有不确定的值，甚至根本就不存在。
而如果知道T的拷贝构造函数一定不会抛出异常的话，该版本倒的确能够额外对付那些不能被赋值但可以被拷贝构造的类型，而且实际中也确实存在着许多这样的类型（比如？）。但能够交换这些类型的值并不一定是什么好事，例如这种类型可能并不具有值语义，而且它可能具有const或引用成员，因而我们等于是在提供一种可以为类型强加值语义的机制，这可能具有误导效果，并导致意外或不正确的结果。
更糟的是，这种做法是在“玩弄”对象的生命期，而后者总是应该受到质疑的。因为它不仅改变了对象的值，而且还众真正意义上对被操作的对象的存在状态进行了改变。使用示例6-2(d)中的swap()的用户如果忘记它具有非常规的析构语义的话，则容易遇到意料之外的结果。
准则：如果必须操纵对象生命期，而且知道这么做是正确的，而且确信被操作的对象的拷贝构造函数永远不会抛出异常，而且你非常肯定当你的swap()被运用到特定对象上的时候，这种非常规的“强加的”值语义不会带来什么问题的话，那么（只有在这些前提之下）或许才可以合理地决定针对某些特定情况（对象）使用这种做法。然而即使如此，也要记住不要将这种做法用在一个通用的，可能会意外地由任何类型来实例化的模板当中，而且一定得将它的不同寻常的行为记入文档，这样可怜的毫无戒备的隔壁程序员才能知道会发生什么样的行为，因为该技术已经完全属于C++编码中的“非常规手段”了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第7条 为什么不特化函数模板
重要的区别：重载与特化
1. C++中主要有哪两种形式的模板，它们分别如何进行特化
C++中有类模板和函数模板之分。这两种模板的工作方式并不完全一样，最明显的区别在于重载，普通的C++类是不能重载的，因此类模板也不能够重载。另一方面，普通的C++函数如果名字相同（且函数签名不同）就会发生重载，因而函数模板也允许重载。
//示例7-1：类模板与函数模板，以及重载
//一个类模板
template<class T> class X {/*...*/};//(a)
//一个具有两个重载版本的函数模板
template<class T> void f(T);//(b)
template<class T> void f(int, T, double);//(c)
这些非特化版的模板也被称为主模板。
此外，主模板还可以被特化。类模板可以被偏特化或者全特化。函数模板则只能够被全特化，不过，由于函数模板被重载，所以我们通过重载也能够达到类似偏特化的效果。

//示例7-1（续）：特化模板
//将上例中的（a）针对指针类型做一个偏特化
template<class T> class X<T*>{/*...*/};
//将上例中的（a）针对int做一个全特化
template<> class X<int>{/*...*/};

//一个独立的主模板，重载了（b）和（c），注意，它并非（b）的偏特化，因为函数模板不允许偏特化
template<class T> void f(T*);//(d)
//(b)关于int的全特化
template<> void f<int>(int);//(e)
//一个普通的函数，恰好重载了（b）、（c）和（d），但并非（e）
void f(double);//(f)

准则：函数模板不能偏特化，只能重载。写一个看似函数模板偏特化的函数模板实际上是在写一个单独的主函数模板。
注意力集中到函数模板，考虑一下它们的重载规则。规则相当简单，用经典的分类讨论法来描述该规则：
1. 非模板函数是C++中的一等公民。如果一个普通的非模板函数跟一个函数模板在重载解析的参数匹配中表现一样好的话，编译器会选择普通函数。
2. 如果编译器发现没有合适的“一等公民”可选的话，那么主函数模板作为C++中的二等公民就会被纳入考虑。具体选择哪个主函数模板则取决于哪个的参数类型匹配得更好。

如果这样还不能选出惟一的主函数模板的话，编译器则会根据下面一组相当晦涩的规则确定哪个主函数模板是“最特化”的。
3. 如果显而易见存在着一个“最特化”的主函数模板的话，该主函数模板就会被选中，如果这个被选中的主函数模板碰巧又针对所使用的模板实参（列表）做了特化的话，该特化版本就会被编译器选中，否则编译器将使用以正确类型实例化的主模板。
4. 否则，如果有两个或多个“最特化”的主函数模板互相之间不能分出孰优孰劣的话，调用就是二义性的，因为编译器不能确定它们中哪个是更好的匹配。程序员只能以某种方式来对调用进行一些限定，明确指向想要调用的是哪个函数。
5. 否则，如果没有任何主函数模板可以匹配调用的话，调用就是错误的，这时候程序员就有必要去纠正他们的代码。
//示例7-1（续）：重载决议
bool b;
int i;
double d;

f(b);//(b)，T推导为bool
f(i, 42, d);//(c)，T推导为int
f(&i);//(d)，T推导为int
f(i);//(e)
f(d);//(f)

为什么不特化：Dimov/Abrahams的例子
考虑如下代码：
//示例7-2（a）：显式特化
template<class T>//(a)：一个主模板
void f(T);

template<class T>//(b)：一个主模板，重载了(a)，由于函数模板不能被偏特化，所以只能用重载来代替
void f(T*);

template<>//(c)：(b)的一个显式特化
void f<int>(int*);
//...
int* p;
f(p);//调用(c)
示例7-2(a)中最后一行的结果是意料之中的。人们可能会说“那又如何，我针对int写了一个特化，那么显然这个特化就是应当被调用的那个了”，如果这么认为，就大错特错了。

2. 如下代码中，最后一行调用的哪个f()版本，为什么
//示例7-2（b）：Dimov/Abrahams例子
template<class T>
void f(T);

template<>
void f<int*>(int*);

template<class T>
void f(T*);
//...
int* p;
f(p);
答案是第三个f()！这次加上注释，以便比较和对照这两个例子。
template<class T>//(a)：跟前面一样的主模板
void f(T);

template<>//(c)：显式特化，这次是对(a)进行特化
void f<int*>(int*);

template<class T>//(b)：第二个主模板，重载了(a)
void f(T*);
//...
int* p;
f(p);//调用(b)！重载决议无视特化的存在，只在主函数模板之间进行决议
理解这个例子的关键其实很简单：模板特化并不参加重载。
只有主模板才会参加重载（当然，还有普通函数）。
重载决议只会选出主模板（也可能选中普通函数，如果存在这么一个可用的普通函数的话）。只有在确定了到底调用哪个主模板之后，编译器才会着手四处寻找该主模板是否有某个合适的特化版本是可用的，如果找到了，就会采用那个特化版本。
准则：函数模板特化并不参与重载决议。只有在某个主模板被重载决议选中的前提下，其特化版本才有可能被使用。而且，编译器在选择主模板的时候并不关心它是否有某个特化版本。

重要教训
如果第一次看到这些东西的时候或许会问：对我来说似乎是特地写了一个针对int*的版本，而且实参的类型又的确是int*，这是个完全匹配，难道特化版本不应该被选中吗。只可惜这是个错误的想法：如果想确保你的特化版本在类型完全匹配的情况下总是被选用，就应该将它写成一个普通的函数，而不是模板特化。
至于模板特化为何时不参与重载决议：标准委员会认为，如果仅仅由于你碰巧为某个特定的模板写了一个特化就导致编译器选择了不同的模板，人们就会感到惊讶。基于这个理念，又由于倘若有需要的话我们已经有方法可以确保我们的某个特殊版本得到采用（只需将它写成普通函数，而不是模板特化即可），就不难理解为什么模板特化不会影响重载决议。
准则：教训#1 ：如果你想要将一个主模板特化，同时又希望该特化版本能够参与重载决议（或者希望确保当它能够完全匹配用户调用的时候能被编译器选用）的话，只需将其写成普通函数即可。
推论：如果你确实提供了某个函数模板的重载，那么你应当避免为它提供特化。（不太懂？？？2014-4-9： 因为就算提供了特化也不会被选中吗）

然而如果你是某个函数模板的作者而不是用户，是否能够做得更好一些，在第一时间为自己也为你的用户避免这类（以及其他）问题呢，实际上，答案是肯定的。（不太懂？？？）
//示例7-2(c)：阐释教训#2
template<class T>
struct FImpl;

template<class T>
void f(T t)//客户，请不要去动这个函数！
{
	FImpl<T>::f(t);
}

template<class T>
struct FImpl
{
	static void f(T t);//客户，你可以对这个函数进行特化。是想表达通过这种类内封装的静态函数特化出来的各种版本都可以参与重载决议吗，都可能被选中？？？2014-4-9：这里想表达的应该是客户在类中的静态特化版本不会影响到主函数模板重载决议
};
准则：教训#2 ：如果你正在写一个可能需要被特化的主函数模板的话，请尽量将它写成一个孤立的、永远不该被特化或重载的函数模板，（个人感觉应该是再提供一个类模板）并将其具体实现全部放入一个包含了一个静态函数的类模板当中。这么一来任何人都可以对后者进行特化（全特化或偏特化），而同时又不会影响到主函数模板重载决议。
这种众所周知的增加一个间接层的方法能够帮你避开函数模板的一些限制和黑暗角落。这样，使用你的模板的程序员就能够随心所欲地对包含了具体实现的类模板进行偏特化或显式特化，而再也不用担心会影响到函数模板的重载决议了。这不仅避开了函数模板不能偏特化这一限制，而且还免除了因函数模板特化不参与重载而带来的一些出人意料的结果。问题解决了！
然而，如果你正在使用的是其他人写的“普通”函数模板（即不像我们刚才所述的使用类模板来实现的函数），而且你又想要加入一个自己的针对特殊情况进行处理的“特别版”并想让它参与重载，请千万不要将它写成函数模板特化，只需将它写成一个具有相应签名的普通函数（或主函数模板）即可。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第8条 友元模板
namesapce boost
{
	template<typename T> void check_delete(T* x)
	{
		//...
		delete x;
	}
}
现在，想将函数模板用到一个类上，而这个类的析构函数碰巧是私有的。
class Test
{
	~Test() { }//私有！
};
需要将check_delete声明为Test的友元即可（除此之外惟一的选择就是放弃Test的析构函数的私有性，即将它声明为公用的。）
实际上，在标准C++当中有两条合法而简单的途径可以达到这个目的。

解决方案
将另一个名字空间中的模板声明为友元其实说起容易（在标准中）做起来难（在现实世界中那些没能很好地“领悟”标准的编译器面前）。
1. 好消息是，有两种完全OK且遵从标准的途径可以用来实现目的，而且其语法也自然而然平淡无奇。
2. 坏消息是，这两种标准语法都不可能在所有当前的编译器上皆有效。即便是一些最强大、最符合标准的编译器也不能完全支持这两种理应可用的、合法的和符合标准的语法。
3. 好消息是，这两种做法中的一个的确在作者所测试过的所有当前编译器上都是可选的，但GCC除外。

尝试
1. 有一种显而易见且符合标准的语法可以将boost::checked_delete声明为Test的友元，请说出这种语法。
//示例8-1：授予友元关系的一种做法
class Test
{
	~Test() {}
	friend void boost::checked_delete(Test* x);
};
可惜，上面代码在很大一部分编译器上都通不过。简而言之，示例8-1 中的友元声明具有如下的性质。
1. 根据标准，这种做法是合法的，然而它却依赖于语言中的一个冷僻特性。
2. 它在当前的许多编译器，包括一些非常好的编译器上都通不过编译。
3. 只需稍作修改就可以令它不再依赖于语言的冷僻特性，修改后的版本在除了gcc以外的所有其他编译器上都能够通过编译。
（//VS2010可以通过编译
#include <iostream>
using namespace std;

namespace DbSpace
{
	template<typename T>
	void printData(T* x)
	{
		x->show();
	}
}

class Test
{
	friend void DbSpace::printData(Test* x);//friend void DbSpace::printData<Test>(Test* x);或friend void DbSpace::printData<>(Test* x);
public:
	Test(int i): i_(i) { }
private:
	void show(int n = 0)
	{
		cout << i_ + n << endl;
	}
	int i_;
};

int main()
{
	Test* t(new Test(5));
	DbSpace::printData(t);
	delete t;
}
//或如下
#include <iostream>
using namespace std;

namespace DbSpace
{
	//class Test;
	template<typename T>
	void printData(T* x);
}

class Test
{
	friend void DbSpace::printData(Test* x);//friend void DbSpace::printData<Test>(Test* x);或friend void DbSpace::printData<>(Test* x);
public:
	Test(int i): i_(i) { }
private:
	void show(int n = 0)
	{
		cout << i_ + n << endl;
	}
	int i_;
};

namespace DbSpace
{
	template<typename T>
	void printData(T* x)
	{
		x->show();
	}
}

int main()
{
	Test* t(new Test(5));
	DbSpace::printData(t);
	delete t;
}
）

2. 为什么说这种显而易见的语法在实际中是不可靠的，请给出更可选的替代方案。
在声明友元时，有四种选择。将它们归结如下。
当声明一个友元，同时又没有任何地方使用template关键字的时候：
（1）如果友元的名字看起来像是一个模板特化，即显式给出了模板实参的话（例如Name<SomeType>）
则该友元就是指那个模板的特化体。
（2）否则如果该友元的名字由一个类或名字空间所限定（例如Some::Name），并且这个类或名字空间当中的确包含一个名字与友元声明中的名字相匹配的非模板函数的话
则这个非模板函数就是所声明的友元。
（//无法编译通过，问题哪里？？？
#include <iostream>
using namespace std;

namespace DbSpace
{
	class Test;
	//template<typename T>
	void printData(Test* x);
}

class Test
{
	friend void DbSpace::printData(Test* x);
public:
	Test(int i): i_(i) { }
private:
	void show(int n = 0)
	{
		cout << i_ + n << endl;
	}
	int i_;
};

namespace DbSpace
{
	void printData(::Test* x)
	{
		x->show();
	}
}

int main()
{
	Test* t(new Test(5));
	DbSpace::printData(t);
	delete t;
}
）
（3）否则如果该友元的名字由一个类或名字空间所限定（例如Some::Name），并且该类或名字空间当中的确包含一个名字与友元声明中的名字相匹配的函数模板的话（推导出相应的模板参数）
则该友元就是指那个函数模板的特化体。
（4）否则友元声明中的名字肯定是非限定名（即没有Some::），声明（或重复声明）了一个普通（非模板）函数。
显然，第（2）跟第（4）种情形只匹配非模板函数，因此要想将模板特化声明为类的友元，有两个选择，一是制造情形#1 ， 二是制造情形#3 。在我们的例子当中，有如下选择。
//原始代码，合法，因为它属于情形#3
friend void boost::checked_delete(Test* x);
或者
//添加“<Test>”，仍然合法，因为它属于情形#1
friend void boost::check_delete<Test>(Test* x);
第一种做法是第二种做法的简略形式，只不过第一种做法是生效有一个前提条件，即仅当友元名字是限定名（这里是boost::），且在同一个域中找不到匹配的非模板函数的情况下它才表示友元模板。虽说这两种做法都是合法的，但第一种做法利用了友元声明规则的一个冷僻特性，这一特性会令许多人乃至时下的大多数编译器感到惊讶。给出三个理由来避免这种做法，虽然从技术角度来说是合法的。
问题1：它并非问题行之有效的
情形#3 的语法是显式给出模板实参的做法#1 的一个简略形式，然而它只有在友元名是限定名，且限定的类或名字空间当中不包含匹配的非模板函数的情况下才是行之有效的。
特别地，如果限定的名字空间中具有（或者后来拥有了）一个匹配的非模板函数，那么编译器就会选择那个非模板的函数，这是因为非模板函数的存在意味着我们会先落入情形#2 ，而并非情形#3 。让我们避开这种微妙的情况。
问题2：它让程序员感到惊讶
情形#3 是脆弱的，当程序员看到这样的代码并试图弄明白它到底做了什么的时候，结果往往令人大吃一惊。考虑下面这个稍作改动后的例子，仅仅将boost::限定去掉了。
//稍加改动后的例子，将友元的名字改成非限定名，结果就完全两码事
class Test
{
	~Test() {}
	friend void check_delete(Test* x);
};
如果将boost::省略的话（即改成非限定名），就落入了一个完全不同的情形，即情形#4 中，而情形#4 根本不会匹配出一个函数模板。想想看，我们仅仅省略了一个名字空间前缀就完全改变了友元声明的含义。令人意外，因此最好别去碰这个烫手山芋。
问题3：它令编译器感到“惊讶”
情形#3 是脆弱的，而且令一些编译器也感到“惊讶”，因此即便我们不去理会前面的两个缺点，仅此一点就会导致 它无法在实践中的使用。
情形#1 让人感觉更为放心――示例8-2 除了在gcc上通不过编译之外，在其他所有编译器上都畅通无阴，而在旧的编译器中则除了VC6.0 之外其他都没问题。

如果要声明为友元的函数模板并不位于其他名字空间中，我们就可以在几乎所有的编译器上使用情形#1 的做法。

两个不是办法的办法
有人建议写一个using声明（或者也可以用using指示），并将友元声明改为非限定名。
namespace boost
{
	template<typename T> void check_delete(T* x)
	{
		//...
		delete x;
	}
}

using boost::checked_delete;//或者using namespace boost;

class Test
{
	~Test() {}
	friend void checked_delete(Test* x);//并不是指模板特化
};
上面的友元声明属于情形#4 ：“4. 否则该名字必须为非限定名，并且声明（或重新声明）了一个普通（非模板）函数。”因此这处做法实际上是在外围空间作用域中声明了一个全新的普通函数，叫作::checked_delete(Test*)。
如果你试着编译上面的代码，就会发现这些编译器中许多都会报错，说checked_delete()还没有被定义。然后如果你试图利用这个友元关系，将一个私有成员调用放到boost::checked_delete()模板中的话，会发现所有的编译器都开始“抱怨”了。
一个专家给出了他的建议：在使用using语句的同时也使用模板语法<>。
namespace boost
{
	template<typename T> void check_delete(T* x)
	{
		//...
		delete x;
	}
}

using boost::checked_delete;//或者using namespace boost;

class Test
{
	~Test() {}
	friend void checked_delete<>(Test* x);//合法吗
};
然而上面的代码也许并非合法的C++代码，标准并没有明确指出这种做法到底合不合法。实际上几乎所有尝试过的当前编译器都拒绝它。
有人觉得这种做法不合法的原因在于一致性，因为using关键字的作用是让程序员更容易地使用名字，例如在调用函数的时候，或者在声明变量或参数时给出类型名的时候。而声明就完全是另一回事了，因为你必须在主模板所在的名字空间中才能声明它的特化版本（不能通过using从而在另一个名字空间中声明其特化版本），因此在声明友元的时候你也应当恪守一致性，既然想将一个模板的特化体声明为友元，就应当指出它的主模板所在的名字空间（而不仅仅是通过一个using）。

小结
要想将一个函数模板特化声明为友元，可以以下两种方法中任选其一。
//来自示例8-1
friend void boost::checked_delete(Test* x);//糟糕的做法
//来自示例8-2：加上“<>”或“<Test>”
friend void boost::checked_delete<>(Test* x);//或“<Test>”，好的做法
本条说明在C++中仅仅忽略小小的<>或<Test>就有可能损失相当多的可移植性。

准则：（在代码中）明确地表达出你的意图。如果你所指的确实是一个模板，然而你的表达方式可能存在歧义的话，可以在模板名字的后面加上模板实参列表（这个列表可能是空的，即<>）。
避开语言的冷僻特性，包括那些虽然可以说是合法但容易使程序员甚至编译器迷惑的地方。

然而，如果你的编译器目前连这两种合法的语法都不允许的话，你就只能将某些函数放到公用区段了，不过同时还要记住加上一句注释，说明为什么这么做，并且做个记号，以便在将来升级了编译器之后及时改回去。（将某些函数放到公用区段：并非只有这种弥补手段，只不过其他手段都显得太笨拙了。如，可以在boost名字空间中为想声明为友元的函数模板创建一个代理类，然后将这个代理类声明为类的友元。）
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第9条 导出限制之一：基础
1. 包含模式
使用包含模式时，从源代码角度来看，模板代码和内联代码没什么区别（尽管模板并不一定要声明为内联的）：模板的全部代码对于使用它的客户代码来说必须是完全可见的。这被称为包含模式，因为基本上我们必须在模板头文件中包含所有的模板定义代码。（另外还有一些等价的做法，例如将模板定义分离到一个单独的.cpp文件中，然后让该模板的.h头文件#include这个.cpp文件，效果也一样。）
2. 分离模式
另一方面，（模板的）分离模式以允许模板“分离式”编译为目的。在分离模式下，模板定义对调用者不一定得是可见的。很想在这句话后面加上“就像普通函数那样”，然而那样做是不尊重事实的。在我们概念中似乎这两者并没有什么区别，然而它们实际表现出来的效果却是截然不同的。

我们得牢牢记住包含模式跟分离模式之间的一个细微但重要的区别，即其实它们的不同之处在于它们是不同的源代码组织方式。就是说，它们的区别之处在于如何安排和组织源代码。它们并不会影响模板实例化的方式，换句话说，不管你使用包含模式还是分离模式，编译器在实例化模板的时候都是做完全一样的工作。

3. 对于普通函数来说包含模式的主要缺陷是什么，对于模板函数来说呢
将会以包含模式和分离模式来组织一个函数模板的代码，出于比较目的，同样给出一个普通函数在内联与分离编译模式下的代码组织形式。这样做有助于凸显当前的普通函数分离编译模式与export所支持的模板“分离”编译模式的区别。这两者是不同的，虽然描述它们的术语是相同的。正因如此才在后一个“分离”上加上双引号。
考虑如下代码，它们是一个普通的内联函数，以及一个包含模式组织的函数模板：
//示例9-3(a)：一个司空见惯的内联函数
//--file f.h，给用户使用的--
namespace MyLib
{
	inline void f(int)
	{
		//优雅而高超的实现，使用了一些其他的辅助类和函数
	}
}
下面是一个函数模板在包含模式下的代码组织形式，跟上例形成对比：
//示例9-3(b)：一个毫不知情的可怜模板，使用了包含模式
//--file g.h，给用户使用的--
namespace MyLib
{
	template<typename T>
	void g(T&)
	{
		//同样漂亮的实现，使用了另一个辅助类和函数。模板函数不一定声明为内联，不过函数体仍然需要全部放在这个头文件中
	}
}
C++程序员应当熟悉这两段示例代码中存在的问题。
1. 实现代码暴露：全世界都可以看到f()和g()的代码，而后者可能是专有代码。
2. 源代码依赖性：f()和g()的所有调用方都依赖于它们所调用函数的函数体内的实现细节，因而每次这些函数的作者改过函数体之后，其所有调用方都必须重新编译。另外，如果f()或g()的定义中使用了其他类型，那么调用它们的客户代码同样也得依赖于这些类型的定义。

export的实际能力
4. 对于普通函数来说，标准C++分离模式对于问题3中的缺陷能有哪些帮助。
对于普通函数来说，答案再简单不过了，只需改用分离编译模式即可。
//示例9-4(a)：再普通不过的分离式编译（普通函数）
//--file f.h，给用户使用的--
namespace MyLib
{
	void f(int)
}
//--file f.cpp，可以不发布给用户--
namespace MyLib
{
	void f(int)
	{
		//不同的是现在这个函数体跟函数声明分开了
	}
}
毫不奇怪，该方案解决了上面所提到的“实现代码暴露”和“源代码依赖性”问题，至少对于f()是这样的（同样的手段也可以用在类的“分离式编译”上，即PImpl惯用法，参见Exceptional C++）。
1. 定义/实现代码不再暴露给外界：如果愿意，仍可以发布实现的源代码，假若不愿意，就完全不必发布它们了。
2. 消除了源代码依赖性：调用方不再依赖于f()的内部实现细节，因而每当其定义体改变，调用它的代码只需重新连接一下即可。这往往能够令构造速度快一个数量级乃至更多。类似地，f()的调用方不再依赖于那些只是在f()的定义体中被使用的类型，这也会缩短构造时间，只不过效果较小。

真正的问题是：对于模板来说，上面的这些讨论还成立吗；如果不成立，情况又是怎样的呢
export背后的理念是对模板也能够实现类似于普通函数分离式编译那样的效果。人们可能会认为下面的代码能够像示例9-4(a)那样具有类似的优势。然而如果这么想的话可就错了。
//示例9-4(b)：一个依赖性“稍有减弱”的函数模板
//--file g.h，给用户使用的--
namespace MyLib
{
	export template<typename T>
	void g(T&);
}
//--file g.cpp，也给用户使用??--
namespace MyLib
{
	template<typename T>
	void g(T&)
	{
		//使用了一些其他类或模板，现在被“分离式”编译了！
	}
}
令人惊讶的是，对于g()来说这种做法并不能像f()那样解决那两个问题。也许可以缓解其中一个问题。

问题一：源代码暴露
模板的分离式编译并不能解决这个问题，源代码暴露问题依然存在。
C++标准中没有说或者暗示你可以仅通过一个小小的export关键字就能避免发布g()的完整源代码。实际上，就export现有的惟一实现而言，编译器仍然得提供被export之模板的完整定义，即全部源代码。原因之一是C++编译器在实例化这些模板的时候仍会需要用到它们的完整定义。C++标准中对实例化模板的时候会发生什么情况是这样来描述的：
“[依赖]名字是‘非绑定’的，编译器对它们的名字查找会在模板实例化处，在模板定义的上下文跟实例化的上下文中进行。”
依赖名字是指那些依赖于某个模板形参的名字，大多数有用的模板都包含依赖名字。在模板的实例/使用处，编译器会在两个地方查找依赖名字。一是实例化处的上下文，因为编译器正处于这个点上。还有另一个上下文，即模板定义的上下文，这正是问题的关键，因为这便意味着编译器不仅需要知道模板的完整定义，而且还需要知道包括该定义在内的其所在文件的上下文，包括哪些相关的函数签名位于作用域内等等，这样重载决议以及其他工作才能顺利进行。
导出的模板并非是我们通常（对于普通函数）所说的真正的“分离式编译”。导出模板通常不能在使用之前就分离编译成目标代码。一方面，这是因为编译器直到使用模板的确切地点才能知道用哪些模板实参来实例化它。因此导出模板至多只能算是“分离式部分编译”或者“分离式解析”。而实际上，在每次实例时模板的定义都要使用对应的一组模板实参编译一次。
准则：export并不能带来像普通函数那样真正的分离式编译。

问题二：依赖性与构建时间
第二个问题同样没有得到解决：依赖性被隐藏了起来，但依然存在。
每次模板的定义体改变时，编译器都要将使用它的客户代码重新实例化。而在这个过程中，使用了g()的编译单元仍然跟g()的内部实现密不可分，后者包括g()的定义体以及仅在g()的定义体中使用的类型。
而当日后被客户使用，且实例化上下文皆已知的情况下，模板的（实现）代码仍然需要全部经过编译器编译。
准则：export只能隐藏依赖性，并不能消除依赖性。
即便是在包含模式下，例如代码是像示例9-4(b)中那样组织的，只不过将export关键字移除，同时加上一行#include "g.cpp"到g.h中，编译器也可以像上面所描述的那样来处理重编译事宜，即仅仅重编译足够多的编译单元从而令所有实例化并使用过的模板实例都得到“刷新”即可。编译器可以进行这种优化是依赖于（而不是强制实施）惟一定义规则，如根据惟一定义规则，编译器可以合理假设如果出现两个或以上的模板实例对应于同一组模板实参的话，那么这些实例肯定是相同的，这样一来编译器就只需实例化其中的一处，而无需一一实例化并检查它们是否真的一致。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第10条 导出限制之二：相互影响，可用性问题以及准则
许多人都期望，export意味着模板库可以不必发布全部源代码定义（或者其等价物），同时构造速度也会有所提高，然后实际上export没有提供这两个保证。
目前为止，C++界所获得的关于export的经验表明，使用export仍需发布全部源代码（或者其等价物），而且人们尚不知道在实际使用当中export究竟会使构建速度变得更快、更慢，还是相差无几。主要是因为依赖性仍然存在，只不过被隐藏了起来，而且在一般应用中编译器仍至少需要做等量的工作。被export的东西在某种意义上类似于Java和.NET的库，Java的字节码与.NET的IL代码都可以通过逆向工程得到非常类似于源文件的内容，所以说被export的东西并非传统意义上的目标（二进制）代码。
export难于实现主要原因：
（1）export依赖于Koenig查找。
（2）从概念上来说，export要求编译器同时处理多个符号表。
准则：如果你想编写可移植的代码，那就别用export。
准则：（就目前而言）避免使用export。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第11条 try和catch
2. “编写异常安全的代码基本上即意味着在正确的位置上写try和catch。”请就此进行讨论。
这个说法代表了人们对异常安全的一种最为常见的误解。异常只是错误报告的另一种形式而已，我们当然知道编写错误安全（error-safe）的代码并不仅仅意味着在适当的地方检查返回码并处理错误条件。
事实表明编写异常安全的代码绝不仅仅意味着编写try和catch，甚至这种做法越少越好。同样，始终牢记，异常安全性会影响一段代码的设计，不要以为你可以事后再去添加一些catch块。
在编写异常安全代码的时候主要得考虑三点因素：
（1）应当在何时何地抛出异常。这个问题是关于如何在正确的地点抛出异常的。特别地，我们得回答下列问题：
1) 哪些代码应当抛出异常。就是说，哪些错误值得我们使用抛出异常的方式来加以报告，而不用返回错误值或其他方式。
2) 哪些代码不应当抛出异常。特别地，哪些代码应当提供“不失败”保证。（见第12条）
（2）应当在何时何地处理异常。只有这个问题与“在正确的地方编写try和catch”搭得上边，但甚至连这个问题多数时间也是自动处理的。首先，考虑需要回答的：
1) 哪些代码可以去捕获异常（catch）。换句话说，哪些代码具有足够的上下文和知道去处理给定异常所代表的错误（其处理异常的方式可能是将异常转换为另一种形式?）尤其要注意的是，负责捕获异常的代码同样需要足够的知识来进行任何必要的清理，如对一些动态分配的资源的清理。
2) 哪些代码应当去捕获异常。换句话说，在可以用于捕获给定异常的代码中，哪个才是最合适的。
在解答以上问题后，我们应当注意到，使用“资源获取即初始化（RAII）”惯用法，可以消除许多不必要的try块，因为该惯用法能够使异常环境下的清理善后工作自动化。根本就无需编写try或catch块。
准则：尽量通过析构函数来进行异常环境下的自动清理工作，而不是通过try/catch。

3. 什么时候应当使用try和catch，什么时候不应当使用它们。给出一个能够作为良好的编码标准的答案。
一组建议：
（1）为你的程序或子系统确立一个整体上的错误报告/处理策略并始终遵循它。特别地，该策略应当照顾到如下几个基本方面（通常就所遇到的实际情况而言，远远不止要考虑这些方面）：
1)错误报告。对哪种错误需要被报告以及如何报告它们给出一个明确的定义，尽量使用异常而不是其他错误报告机制。通常，对你面临的每种情况都默认选用最具可读性和可维护性的方案，例如，对于那些不能返回值的函数（如构造函数和操作符）来说，异常是最有效的方案。同样，对于错误抛出端与处理端相隔遥远的情况来说，异常也是最理想的方案。
2)错误传播。
3)错误处理。
（2）只在那些侦测到错误但自己却无法处理的地方抛出异常。（很明显，能够就地将错误处理掉的代码当然不需要报告该错误了）
作为每个函数或模板的文档的一部分，在每个操作的文档里面明确指出该操作可能会抛出哪些异常，以及为什么抛出这些异常。你并不需要真正去为每个函数加上异常规格声明（事实上不应该这么做，见第13条），但确实有必要在文档中明确且来帮地指出函数的调用方可以对它的异常语义作什么样的假设，因为错误语义也是一个函数或模板接口的语义的一部分。
（3）在设置try和catch的地方必须有足够的知识和上下文去处理/转换特定异常，或强制实施错误策略中指出的异常边界。编写try和catch有三个主要理由：
1) 为了处理错误。最简单的情况：错误发生了，我们知道应该对此做些什么，于是就做了，程序继续运行（原先的异常已被安全地处理掉了）。再次申明，尽可能地在析构函数中完成你的动作，实在不行才去使用try/catch。
2)为了转换异常。这意味着捕获一个汇报了较低层错误的异常，然后抛出另一个在执行转换的代码自身的（较高层面的）语义上下文中重新表达的异常。还有一种做法是将原先的异常转换为另一种表示形式，如错误代码。
例如，考虑一个通信会话（session）实用类，它能应付多种主机（host）类型和传输协议，而打开与另一个主机会话的尝试可能会因任意的低层原因而失败，失败原因能够被会话类探测出来（例如无法找到网络或远程主机拒绝认证/许可等）。Open()函数自身就足以应付这些情况，因而没必要将它们汇报给调用方，毕竟调用方对会话中涉及的具体哪个分组一无所知，也不知道该分组出现某种情况时该怎么办。会话类直接就将它的内部发生的低层错误处理掉了，从而令它自身仍然处于一致的状态下，并同时汇报一个属于会话类自身的、较高层别的错误或异常来告知调用方“本次会话无法打开”这一信息。
void Session::Open(/*...*/)
{
	try
	{
		//整个的操作
	}
	catch(const ip_error& err)
	{
		//对IP错误进行一些处理
		//清理
		throw Session::OpenFailed();//抛出另一较高层的异常
	}
	catch(const KerberosAuthentFail& err)
	{
		//对认证错误进行一些处理
		//清理
		throw Session::OpenFailed();//抛出另一较高层的异常
	}
	//其他内容
}
3)为了在子系统边界或其他运行时防火墙边界上进行catch(...)。这通常也会涉及到异常/错误的转换，通常是转换为错误代码或其他非异常形式的表示方式。例如，当栈展开（stack unwind）到达了某个C API的时候，就只剩下两个选择：一是从该API函数中立即返回一个错误代码，二是设置一个错误状态以便事后调用方可以通过GetLastError() API函数去查阅。
准则：为应用程序或子系统确实一个整体的错误报告/处理策略，并始终遵循它。并为错误报告、错误传播以及错误处理制定策略。
在那些侦测到错误而自身又无法对其进行处理的地方抛出异常。
在那些具有足够知识和上下文信息去处理/转换错误或强制实施边界条件的地方编写try/catch（例如，在子系统上或其他运行时防火墙边界上进行catch(...)）。
小结
在异常安全分析中，可以这么说：
try、catch，否则闪到一边去！
在实践当中，最后一个“闪到一边去”占有了异常安全分析和测试的大部分份额。这正是为什么会说异常安全编码并不仅仅意味着在正确的位置编写try和catch的原因。进一步说，异常安全编码通常即意味着在正确的地点避开“路过”的异常。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第12 条 异常安全性：值得吗
Abrahams保证
1. 回顾：简要地定义Abrahams异常安全保证（基本保证、强保证以及无失败保证）。
2. 什么时候值得去编写满足下列异常安全保证的代码
（a）基本保证
（b）强保证
（c）无失败保证
始终要让代码至少满足以上保证之一。有如下几点很好的理由：
（1）异常总是会发生的。标准库函数可能会抛出异常；语言实现也可能会抛出异常。我们得对这些意外情况有所防备。我们现在已经知道怎么正确地应对了，这倒是要求我们首先得接受一种新的习惯，并持之以恒（对于学习针对错误代码的编程也同样如此）。
问题还是关于错误处理的一个一般性问题。从细节上来说，到底是使用返回错误码还是抛出异常的形式来报告错误，几乎只是个语法细节上的差异而已，主要区别在语义上，即错误报告是如何完成的，因而每种做法都需要其自身的风格。
（2）编写异常安全的代码是好处的。异常安全的代码往往就意味着良好的代码。被普遍用来帮助人们编写异常安全代码的技术，通常也正是我们即便在基本无异常的环境下也应当使用的技术。就是说，即便你无需考虑异常安全性，支撑异常安全编码的技术本身对你也有利无弊。
考虑下面一些使异常安全变得更容易的主要技术：
1)使用“资源获取即初始化”（RAII）惯用法来管理资源的所有权。使用对资源具有所有权的对象，如Lock类和shared_ptr类。它们除了具有很多优点之外，还具有异常安全性。
2)使用“先在一旁将所有事情做完，然后再通过不抛出异常的操作来提交整个任务”的手法，避免在不确定所有操作能否都成功的情况下贸然去改变对象的内部状态。这种事务性编程清晰、干净，也比较安全，即便是使用错误码来报错也一样。类似这种情形：某个函数由于没有采用上面所说的手法，然而其函数体中的某个代码分支却又导致了过早返回，此时由于在失败的操作之前对象的内部状态已经部分地改变了，因而这里的过早返回就导致对象被留在了不一致的状态下。
3)尽量使用“单一职守的类（或函数）”像Stack::Pop()和EvaluateSalaryAndReturnName()（分别在Exceptional C++第10条和第18条介绍）这样的做多件事情的函数很难实现强异常安全保证的。只需简单遵从单一职守原则，许多异常安全问题会变得简单，甚至无需多加思考就解决了。而且单一职守原则很早就出现了，只是后来才发现它恰巧能够用在解决异常安全问题上，其本身就是一个很好的原则。

简单的说，下面就是C++标准库所遵从的原则，可以有效运用到自己的编码中去：
准则：函数应当总是支持它所能支持的最强的异常安全保证，但前提是不能给那些并不需要该保证的调用者带来额外开销。
这就是说，如果你的函数可以支持无失败保证，同时又不会给不需要该保证的调用者带来额外的性能开销的话，你就应当让当具有无失败保证，但也要注意，少数关键的函数一定得是无失败操作。
准则：永远不要允许析构函数、释放操作（deallocation）以及swap()函数抛出任何异常，因为否则的话，就没法安全且可靠地进行资源清理了。
否则，如果你的函数可以支持强异常安全保证，同时又不会给不需要该保证的调用者带来额外开销的话，你就应当让它具有该保证。注意，vector::insert()是一个有趣的例子：通常并不支持强异常安全保证，因为这样做意味着每次我们插入一个元素的时候，它都得对整个vector的内容进行一份完全的副本才行，况且也并非所有的程序都如此在乎一个需要付出这么大代码才能换来的强异常安全保证。（那些在乎这一点的程序员可以手动将vector::insert()包装成一个具有强异常安全保证的操作，很简单：首先对vector作一份副本，然后对这份副本进行insert()，一旦这个插入操作成功了，最后就将原来的vector跟这份副本swap()一下即可。）
否则你的函数就应当支持基本的异常安全保证。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第13条 对异常规格的实际考虑
1. 违反异常规格会导致什么样的后果，讨论该C++特性的基本理念。
异常规格的理念在于使用运行期检查来确保只有某些特定的异常能够从某个函数当中逃逸出去（其他情况下则不会有任何异常从中逃出来）。例如，如下函数的异常规格确保了f只会允许A或B类型的异常从它的函数体内逃出来：
int f() throw(A, B);
如果函数体内抛出了某个不在该函数的异常规格列表里面的异常，unexpected()函数就会被调用。例如：
//示例13-1
int f() throw(A, B)//A和B都跟C无关
{
	throw C();//导致unexpected被调用
}
可以通过调用标准的set_unexpected函数，来注册你自己的用于处理非预期异常（unexpected-exception）的函数，你自己的处理函数必须为无参且返回void的函数。例如：
void MyUnexpectedHandler() {/*...*/}
std::set_unexpected(&MyUnexpectedHandler);
剩下来的问题就是，这个用于处理非预期异常的函数究竟能够做些什么。首先，无论如何有一件事情它不能做，即它不能通过通常的函数返回方式来返回。而它可以做的事情有如下两件：
1)它可以决定将当前异常转换为某个被异常规格列表所允许的异常，具体做法是抛出它自己的、满足那个引发它被调用的异常规格列表所要求的异常。于是栈开解（stack unwind）就会从原来离开（去调用该函数）的地方继续下去。
2)它可以调用terminate，该函数会终止程序。（terminate函数本身也可以被替换掉，但替换它的任何函数同样还是必须终止程序。）
（例：没捕获住啊，还是abort()终止了，问题在哪里？？？
#include <iostream>
#include <string>
#include <exception>
using namespace std;

int f() throw(exception, string)
{
	throw int(3);
}

void MyUnexceptedHanlder()
{
	throw string("rethrow");
}

int main()
{
	set_unexpected(&MyUnexceptedHanlder);
	try
	{
		f();
	}
	catch(string& e)
	{
		cerr << e << endl;
	}
}

//C++ Reference上的例子 www.cplusplus.com/reference/exception/set_unexpected/
// set_unexpected example
#include <iostream>       // std::cerr
#include <exception>      // std::set_unexpected

void myunexpected () {
	std::cerr << "unexpected called\n";
	throw 0;     // throws int (in exception-specification)
}

void myfunction () throw (int) {
	throw 'x';   // throws char (not in exception-specification)
}

int main (void) {
	std::set_unexpected (myunexpected);
	try {
		myfunction();
	}
	catch (int) { std::cerr << "caught int\n"; }
	catch (...) { std::cerr << "caught some other exception type\n"; }
	return 0;
}
Output:
unexpected called
caught int

但是我自己在VS2010上跑，得到的结果是
caught some other exception type
不知道为什么？
）

异常规格背后的理念很容易理解：在C++程序中，除非一个函数带有异常规格声明，否则我们就认为它可能抛出任何异常。考虑这样一个名为Func的函数。
2. 描述如下的函数可能抛出哪些。
//示例13-2(a)
int Func();//可以抛出任何异常
C++异常规格的规则决定了它并非总是有用的，甚至往往是完全有害的。
3. 异常规格是函数类型的一部分吗，请解释。
异常规格被称为浅陋的类型系统，原因很简单：
1)异常规格并非函数的类型的一部分。。。
2)有些时候它们又的确是。
首先下面例子，展示何时异常规格并不影响函数的类型。
//示例13-3(a)：你不能在typedef当中写异常规格
void f() throw(A, B);
typedef void (*PF) throw(A, B);//语法错误
PF pf = f;//不能到达这里，上面有错误
代码中的那个typedef中异常规格是非法 ，C++不允许这样写，C++并不允许异常规格成为函数类型的一部分，至少在typedef中不能。但在其他情况下，异常规格又确实是函数的类型的一部分，譬如说，把上面代码中的typedef关键字去掉，其他部分保留原样的话：
//示例13-3(b)：如果把typedef去掉就可以了！
void f() throw(A, B);
void (*pf)() throw(A, B);//没问题
pf = f;//没问题
对于函数指针赋值而言，只要赋值目标（即函数指针）的异常规格不比赋值源（即函数）的异常规格更严格，赋值就可以成立。
//示例13-3(c)：同样可以
void f() throw(A, B);
void (*pf)() throw(A, B, C);//没问题
pf = f;//没问题，pf的异常规格比f宽松（即可以把一个严的函数赋给一个宽松的函数，或者说把一个宽松的函数当成一个严的函数来用，下例）
此外，如果你想重写虚函数的话，异常规格也会影响虚函数的函数类型：
//示例13-3(d)：异常规格会影响虚函数
class C
{
	virtual void f() throw(A, B);//跟上例中的f的异常规格相同
};
class D: C
{
	void f();//错误，现在异常规格就开始发挥作用了。派生类的虚函数必须拥有比其基类的对应虚函数更为严格的异常规格，这个限制很明显，一个派生类对象可以被当成基类对象来使用，所以派生类对象的虚函数也理所应当应该满足其对应的基类虚函数所具有的限制（这里的限制是异常规格）。站在使用指向基类的指针来操纵派生类对象的用户角度来说，他们会假定所调用的f不管动态分派到哪个派生类对象上去，都满足静态决议出的f（即基类的f）所限定的异常规格，即至多只能抛出A和B，这样他们的代码中就只需捕获A和B异常。而本例中的D::f却可能抛出任何东西，如果语言允许这一点的话，D::f抛出的其他异常对于把它当作B::f的调用方代码来说就是漏网之鱼了，后果可想而知。
}
4. 什么是异常规格，它们是用来做什么的，请准确描述。
int Gunc() throw();//什么也不抛出？
int Hunc() throw(A, B);//只会抛出A或B？
以上代码注释正确吗，不见得。实际上Gunc函数体内可能抛出异常，而Hunc函数体内也可能抛出除A跟B之外的其他异常！编译器只是确保会将这些异常“镇压住”而已。顺便提一下，编译器的这种做法大多数时候也会令你的程序“人事不省”。
由于 Gunc或Hunc实际上可能会抛出它们承诺不会抛出的异常，所以编译器不能假定这种事不会发生，如果它确实发生了，编译器必须调用unexpected函数。大部分时候这会导致你的程序终止。因为碰到了unexpected只有两条路可走，不管哪条路都不是正常的返回。你可以根据具体情况进行抉择：
1)抛出一个异常规格列表允许的异常。如果采取了这种做法，异常就会按照通常的方式继续传播。但是，unexpected处理函数是全局的，对于整个程序来说只有一个unexceted。全局处理函数几乎不可能智能到能够针对任意给出的特定情况作出相应的正确响应，所以结果它只能调用terminate了事，而且是直接调用terminate，不经过catch。
2)抛出（或重新抛出）一个异常规格（仍然）不允许的异常。如果原来的函数的异常规格表允许bad_exception类型的话，没问题，现在就轮到bad_exception开始传播了。但如果不允许的话，结果就是terminate，直接terminate。
由于违反异常规格大部分时候最终会导致你的程序终止，把它的行为称作“把你的程序打得不省人事”是合适的。
异常规格到底真正能够做些什么：
1)强制（Enforce）函数在运行期只能抛出其异常规格列表里列出的异常（也可能不抛出任何异常）。
2)编译器必须检查是否的确只有列出的异常被抛出了，这一点使编译器能够（或阻止了编译器）去进行优化。
为了弄清编译器究竟必须做什么，考虑如下例子，为示例函数Hunc提供了一个函数体：
//示例13-4(a)
int Hunc() throw(A, B)
{
	return Junc();
}
从功能上说，编译器必须生成类似如下的代码，它的运行期开销跟你自己手写这些try-catch相比通常是一样的：
//示例13-4(b)：示例13-4(a)经编译器改过的版本
int Hunc()
{
	try
	{return Junc();}
	catch(A)
	{throw;}
	catch(B)
	{throw;}
	catch(...)
	{std::unexpected();}//不返回！但可能会抛出A或B，如果幸运的话
}
这里可以把在异常规格背后发生的事实看得更清楚，并不是假设只有某些特定的（异常规格列表中指出的）异常会抛出从而让编译器据此进行优化，而是恰恰相反：编译器必须得在运行期进行更多的工作以确保只有这些特定的（异常规格列表中指出的）异常从函数中逃逸出来。

深入异常规格
异常规格会导致性能损失。导致这个结果的原因之一：异常规格会导致隐式生成try/catch块，从而带来额外开销。
异常规格通常至少有两种方式会导致运行时的开销：
1)有些编译器会自动拒绝将那些具有异常规格的函数进行内联，这种做法跟它们的其他启发式方法类似，譬如拒绝内联那些具有多于某个特定数目的嵌套语句，或者包含任何循环结构的函数。
2)有些编译器根本不能很好地基于异常相关的信息进行优化，对于这些编译器而言，即使函数体内的代码清清楚楚地表明不可能抛出任何异常，它们也会在里面生成try/catch块。
除了运行期开销之外，异常规格还会导致开发时间上的开销，因为它们增大了耦合性。例如，只需简单地从基类的虚函数的异常规格列表里面删除一个类型，就会发现许多其派生类都不能通过编译了。

5. 什么时候值得为函数加上异常规格。为什么选择这样做，或者为什么不。
C+界得到的几乎最好的建议是：
准则：
原则1：永远不要为函数加上异常规格。
原则2：除非你想声明的是空异常规格列表（即throw()），但作者甚至连这种做法也会避免。
Boost库的经验是，惟一“可能在某些编译器上带来某些好处”的异常规格声明，就是为一个非内联函数加上“不抛出异常”的异常规格声明（即throw()）。这个陈述本身根本不能激起我们的兴趣，但如果你必须编写可被用在不止一个编译器平台上的可移植的代码的话，这倒是个有用的思路。
然而，事实上，它甚至比实际情况中的还糟糕一些，因为似乎一些流行的编译器实现处理异常规格的方式各有不同，至少有一个流行的C++编译器，即微软的Visual C++仅仅只会去解析异常规格，而实际上却不去实施它，这就令异常规格变成了有名无实的注释（是否可以解释之前我所试的例子？？？）。
这些编译器根本不去实施异常规格，但却仍然依赖于“它被实施了”这个假定，在这些编译器上，throw()的含义改变了，原来C++标准中的说法是“根据这个来检查我，如果我一不小心抛出了异常，那就终止我”，而在这些编译器上却变成了“相信我说的，假定我永远不会抛出，并据此进行你的优化吧。”所以你得小心了：如果选择使用了哪怕一个空的异常规格，也得阅读一下你的编译器的文档，看看它对此实际上会做些什么。
小结
一句话，别去惹异常规格。即便专家也是如此。
详细一点说，主要问题在于：
1)异常规格可能会导致令人惊讶的性能损失，例如，倘若编译器对那些带有异常规格的函数不予内联的话。
2)对于异常规格意图捕获的错误来说，运行时的unexpected错误不总是你所愿意看到的。
3)通常不能为函数模板编写有用的异常规格，因为你无法预知它们所操作的类型会抛出什么。
“这只不过是我们所要求的，而不是我们想要的！”
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第14条 顺序、顺序
1. 以下代码的错误
#include <string>
using namespace std;
class A
{
public:
	A(const string& s) {/*...*/}
	string f() {return "hello, world";}
};

class B: public A
{
public:
	B(): A(s = f()) {}
private:
	string s;
};

int main()
{
	B b;
}
注意，表达式s = f()是传给B的基类A子对象的构造函数的实参，因而会在A的构造函数被调用之前执行（或者，对于本例来说，也是在B的任何子部件被构造之前执行）。
首先，这行代码试图在基类A子对象存在之前使用它。写这行代码所用的编译器并没有指出误用了A::f()，之所以说误用是因为成员函数f()是在A子对象上被调用的，而此时A子对象还没有构造起来。诚然，标准并没有要求编译器在这种情况下一定给出警告，然而应该知道这正是标准所称的“由实现决定”的一种情况，也就是说编译器并不是一定要做，但好一点的编译器可能会做。
其次，这行代码企图在成员子对象s存在之前使用它，换句话说，在一个string成员子对象被构造之前调用它的成员操作符operator=。
2. 当创建一个类类型的C++对象时，其各个“部件”分别是按什么顺序被初始化的。请尽量给出明确而完整的答案。
这组规则是递归描述的：
首先，最上层派生类的构造函数负责调用虚基类子对象的构造函数。所有虚基类子对象会按照深度优先、从左到右的顺序进行初始化。
其次，直接基类子对象按照它们在类定义中声明的顺序被一一构造起来。
再次，（非静态）成员子对象按照它们在类定义体中声明的顺序被一一构造起来。
最后，最上层派生类的构造函数体被执行。
例如，考虑如下代码。由于不管它采用的继承方式是public、protected还是private，都不会影响到初始化的顺序，因此一概使用public继承。
解释下面X对象的各个部件初始化顺序。
//示例14-2
class B1 {};
class V1: public B1 {};
class D1: virtual public V1 {};

class B2 {};
class B3 {};
class V2: public B1, public B2 {};
class D2: virtual public V2, public B3 {};

class M1 {};
class M2 {};
class X: public D1, public D2
{
	M1 m1_;
	M2 m2_;
};
用图表示继承体系以进行分析。
1)首先，构造虚基类子对象：
构造V1: B1::B1() V1::V1()
构造V2: B1::B1() B2::B2() V2::V2()
2)其次，构造非虚基类子对象：
构造D1: D1::D1()
构造D2: B3::B3() D2::D2()
3)再次，构造所有成员：M1::M1() M2::M2()
4)最后，构造X本身：X::X()

小结：关于继承的另一些话
尽管该条的主要意图在于理解对象的构造顺序（以及相反的析构顺序），然而重复一下下面并非直接相关的准则也无伤大雅。
准则：避免过度使用继承。
除了友元关系外，继承是C++中所能表达出的最强的关系，因此若非必要请谨慎使用之。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第15条 访问权限的使用
1. 什么样的代码可以访问类的如下区段？
简而言之：
（a）public
公用成员可以被任何代码访问。
（b）protected
保护成员可以被类自身的成员函数访问，也可以被类的友元访问，也可以被派生类的成员函数与友元访问。
（c）private
私有成员只可以被类自身的成员函数以及类的友元访问。
这是常规答案。然而在本条中，会考虑一个特例，因为C++有时候提供了一种途径使得访问类的私有成员成为合法（如果称不上道德的话）。
2. 考虑如下头文件：
//文件x.h
class X
{
public:
	X(): private_(1) {}
	
	template<class T>
	void f(const T& t) {}
	
	int Value() {return private_;}
private:
	int private_;
};
现在想要让任何调用代码都能够直接访问到该类的private_成员，请分别给出符合以下条件的手法：
（a）一个非标准且不可移植的伎俩（hack）。
（b）一个完全符合标准且可移植的技术。

对于非标准且不可移植的伎俩，能想到下面几个方案：
嫌犯1：伪造者
//示例15-1：谎言和伪造
class X
{
	//这里不是#include x.h，而是手动（非法地）复制X的定义，并人为加上下面这一行：
	friend ::Hijack(X&);
};

void Hijack(X& x)
{
	x.private_ = 2;//得逞了！
}
当然，伪造者的所作所为是非法的，因为他违反了惟一定义规则（ODR），其中明确表示，如果一个类型（这里是X）被多次定义，那么其所有定义必须是完全相同的！本例中被使用的对象或许可以被称为X对象，而且它看起来也的确像一个X对象，然后它与程序其他地方使用的真正的X对象完全不是同一类型。
然而，这种伎俩在大多数编译器上仍然是可以工作的，因为通常真正的X类与伪造的X类的底层内存布局是一样的。

嫌犯2：偷窥者
指偷偷地改变类定义的含义。如：
//示例15-2
#define private public//非法
#include "x.h"
void Hijack(X& x)
{
	x.private_ = 2;//得逞了！
}
示例15-2 是不可移植的，其中有两个原因：
1)#define保留字是非法的。
2)这种伎俩与伪造者伎俩一样违反了单一定义规则（ODR）。然而同样，如果类的底层内存格局没有改变，该手法或许还能用一阵子。

嫌犯3：骗子
//示例15-3：企图模拟原对象的内存布局
class BaitAndSwitch//可能与X具有同样的内存布局，从而欺骗编译器把“狸猫”当“太子”
{
public:
	int notSoPrivate;
};
void f(X& x)
{
	(reinterpreter_cast<BaitAndSwitch&>(x)).notSoPrivate = 2;//恶魔得逞了！
}
示例15-3 中的代码是非法的，原因：
1)X和BaitAndSwitch的内存布局并不保证是相同的，尽管实际上它们或许总是相同的。
2)reinterpreter_cast的行为是未定义的，尽管大多数编译器都允许使用返回的结果引用。毕竟，使用reinterpreter_cast其实就是告诉编译器相信使用者，撤消防备，不再监视使用者下面将要做的那些非法勾当。
有些方法是遵从标准而且是可接受的。下面它们粉墨登场：
伪君子4：语言律师
考虑下面代码：
//示例15-4：合法的巧妙托词
namespace
{
	struct Y {};
}
template<>
void X::f(const Y&)
{
	private_ = 2;//得逞了！
}
void Test()
{
	X x;
	cout << x.Value() << endl;//打印出1
	x.f(Y());
	cout << x.Value() << endl;//打印出2
}
该例在钻法律空子的时候会小心地遵守法律条文。它并不非法，利用了X具有一个成员模板的事实。其代码是完全合乎标准的，标准也确保了这种代码会按照编码者的意图行事。原因两方面：
1)针对任何类型的来特化一个成员模板是合法的
惟一可能会带来错误的举动是将它对同样的类型作了两次特化且两次特化的方式又不同，这便违反了惟一定义规则（ODR），然而本例中并不存在这个问题，因为：
2)这里的代码使用了一个确保具有惟一性的类型，因为它位于“语言律师”自己的匿名名字空间中。因而言语确保了这种做法是合法的，而且该特化也不会影响到其任何人进行的任何特化。

不要搞破坏
3. 这是C++访问控制机制中的漏洞吗，如果是，也是C++封装机制中的漏洞吗，请就此讨论。
该例展示了C++中两个语言特性（即访问控制模型与模板模型）之间有趣的相互影响，我们看到，成员模板提供了一种有效的可移植的途径，绕过类的访问控制机制，从这个意义上来说似乎成员模板会隐式地“破坏封装性”。
然而实际上这并不是个问题。这里的问题在于提防意外的误用（语言在这个方面已经做得在当好了），还是提防故意的滥用（要想做到这一点几乎不可能）。最后，如果一个程序员确实想要破坏类型系统，他总能找到办法的，正如示例15-1 至示例15-3 中所示。
准则：永远不要对语言搞破坏。例如，永远不要企图通过复制类定义再添加友元声明，或提供成员模板函数特化等途径来破坏封装性。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第16条 （几乎）私有
基本问题：可访问性
要认识到一个基本问题：与public和protected类似，private也是一个访问控制限定符。就是说，它也是用于指出哪些代码有权利访问它所管辖范围内的成员名字的，这就是它所能做到的全部。C++标准[C++03]中相应小节的第11款写道：
类的成员可以为：
1)private。其名字只可以被该类的成员或友元使用
2)protected。其名字只可以被该类的成员和友元，以及该类的派生类的成员和友元使用（参见[C++03]中的class.protected）。
3)public。其名字可以不受访问限制地被使用。
一个简单的例子，明确显示出C++中的访问是受到良好监控的，而且确实没有任何符合标准的方式可以绕过语言的防线。示例16-1 展示了类外部的非友元代码永远不可能通过名字访问到类内部的私有成员函数，不管是直接地（显式调用）还是间接地（通过函数指针调用），因为私有成员函数的名字对于它们来说根本就是不可用的，更谈不上获取函数的地址了。
//示例16-1：无法得到No::Satisfaction
class No
{
private:
	virtual void Satisfaction() {}
};

int main()
{
	No no;
	no.Satisfaction();//错误
	typedef void (No::*PMember)();
	PMember p = &No::Satisfaction;//错误
	return (no.*p)();
}
注意，这也包含虚函数的情况。一个私有的虚函数可以被任何派生类中的相应虚函数重写，但不能被派生类访问。换句话说，派生类可以对基类中的任何同名虚函数进行重写，但不能调用（或以其他形式使用）基类中的私有虚函数的名字。例如：
//示例16-1（续）：派生类可以重写，但不能访问基类的私有虚函数
class Derived: public No
{
	virtual void Satisfaction()//没问题，重写
	{
		No::Satisfaction();//错误
	}
};
简而言之，外界（非成员或非友元）代码没有任何办法可以接触到私有函数的名字。前面提到的“私有到底有多私有”这个问题现在有了初步的答案：
1)私有成员的名字只对其所属类的其他成员以及友元是可访问的。

另一个问题：可见性
关键字确实控制了成员的可访问性。然而与此相关的还有另外一个概念，通过与可访问性混淆，这就是可见性。
//示例16-2（重复有问题的代码并加以说明）
//Twice(x)返回2*x
class Calc
{
public:
	double Twice(double d);
private:
	int Twice(int i);
	std::complex<float> Twice(std::complex<float> c);
};

int main()
{
	Calc c;
	return c.Twice(21);
}
一个明显的错误：
即便接受std::complex<float>型参数的Twice()成员函数对于main()中的调用代码来说是不可访问的，但它仍然是可见的，且也构造了源代码依赖性的一部分。尤其是即便main()当中的代码永远不会（也无法）关心std::complex，永远也不可能使用Twice(complex<float>)（无法调用它，甚至不能取得它的地址），而且std::complex的使用也不可能以任何方式影响到Calc的大小或内存布局，但无论如何这段代码要想通过编译至少需要一个complex的前导声明。（如果Twice(complex<float>)也是被定义为内联，那么就进一步需要std::complex<float>的完整定义，虽然这对这段代码来说毫无意义。）（说白了就是要增加#include <complex>头文件）
目前为止，对于“private在多在程序上是私有的”这个问题，我们又有了另外一些答案：
1)一个private成员（函数）对于任何看到其所属类定义的代码都是可见的。这意味着它的各个参数的类型必须事先声明，即便在当前的编译单元中永远不会使用这些参数。
第二个问题，一个更隐蔽的问题：
//示例16-3：示例16-2的一个修补版本
#include <complex>
class Calc
{
public:
	double Twice(double d);
private:
	int Twice(int i);
	std::complex<float> Twice(std::complex<float> c);
};

int main()
{
	Calc c;
	return c.Twice(21);//错误，Twice(int)是不可访问的
}
重载决议发生在可访问性检查之前。
编译器在对c.Twice(21)调用进行决议时，主要做了三件事，依次如下：
（1）名字查找。在做其他任何事情之前，编译器会首先寻找一个至少包含一个名为Twice的实体的作用域，并将其中的候选实例列表。本例中，编译器的名字查找首先是从Calc的作用域中开始的，编译器会查看Calc中是否至少存在一个名为Twice的成员（第一个作用域），如果没有，就会继续依次在其基类和外围名字空间中查找（第二个，算一起第二个吗？？？），直到找到一个至少具有一个候选函数的作用域。（更多C++中名字查找的知识，参见Exceptional C++的第31条至第34条）
（2）重载决议。接受int为参数的Twice()是最佳匹配（int型的实参配int型形参属于精确匹配，无需任何转换），因为Twice(int)被重载决议选中。
（3）可访问性检查。最后，编译器进行可访问性检查，以确定被选出的函数到底是否可被调用。本例中该检查的后果是完蛋了！
至于惟一可访问的函数――Twice(double)，实质上也是一个可匹配的函数，然而这已经无关紧要了，它永远不会被调用，这里存在着一个更好的匹配，而且匹配性的好坏永远比可访问性更重要。
有趣的是，甚至二义性匹配也比可访问性匹配更优先。考虑示例16-3 的一个改版：
//示例16-4(a)：引入二义性
#include <complex>
class Calc
{
public:
	double Twice(double d);
private:
	unsigned Twice(unsigned i);
	std::complex<float> Twice(std::complex<float> c);
};

int main()
{
	Calc c;
	return c.Twice(21);//错误，调用具有二义性
}
这个例子中，永远通不过上面提到的“决议三步曲”的第二步，即重载决议。这一步，编译器会发现找不到一个惟一的最佳匹配，因为实参类型int既可以转型为unsigned又可以转型为double，因而根据语言规则，这两个Twice()被认为是同样好的匹配，编译器无法决出优劣，给出二义性调用的错误。就是说，编译器永远到不了第三步――可访问性检查。
甚至更有趣的是，即便一个不可能的匹配也比一个可访问的匹配更优先。下面将示例16-3 重新组织一下：
//示例16-4(b)：引入“老旧”的名字隐藏
#include <string>

int Twice(int i);//现在成了一个全局函数

class Calc
{
public:
	int Test()
	{
		return Twice(21);//错误，Twice(string)被隐藏了！
	}
private:
	std::string Twice(std::string s);
};

int main()
{
	return Calc().Test();
}
这里同样无法通过第二步：重载决议无法在候选列表（只包含一个Calc::Twice(string)）中找到一个可行的匹配，因为实参类型int无法转型为string。因此编译器仍然执行不到可访问性检查。在进行名字查找时，编译器只要查找到一个至少包含一个给定名字的作用域便不再继续查找了，即便这些所有查找到的候选函数可能都是无法调用或不可访问的。外围作用域中的其他潜在匹配则被隐藏了，永远不会被纳入考虑。
1)私有成员对于任何能够看到其所属类型定义的代码来说都是可见的。这意味着它会参与名字查找和重载决议，因而可能会使调用变得无效或具有二义性，即便它本身可能永远不被调用。
这个语言规则背后的理念：
允许程序员在对代码查错的时候添加或移除public和private访问指示符而同时又不会改变程序的含义。

回到当初的问题：授权访问
关于“私有到底有多私”这个问题，私有成员只对其所属类的其他成员以及友元来说是可访问的（其名字只能被这两处使用）。注意，作者故意避免了类似于“它只能被其他成员及友元调用”的说法，因为实际上后者是不确切的。可访问性是指代码使用给定名字的权利，这一点需要特别加以强调，回顾一下前面引用的C++标准：
类的成员可以为
私有的。也就是说，其名字只可以被该类的成员或友元使用。
如果某段代码具有直接使用某个私有成员名字的权限（本例中即指成员或友元），同时该段代码又利用该名字获取了相应函数的函数指针并将其传递给其他代码，那么接收代码就可以使用该指针，不管接收代码是否有权使用成员的名字，因为它根本不需要该成员的名字，它得到了它的指针。示例16-5 展示了这种技巧在实际中的情况，会看到，一个具有对Twice(int)名字的访问权的成员函数利用该职权将Twice(int)的指针泄漏出去：
//示例16-5：授权访问
class Calc;
typedef int (Calc::*PMember)(int);

class Calc
{
public:
	PMember CougultUp()
	{
		return &Calc::Twice;
	}
private:
	int Twice(int i);
};

int main()
{
	Calc c;
	PMember p = c.CoughltUp();//对Twice(int)的访问
	return (c.*p)(21);//OK
}
可参见[Newkirk97]，其中详细描述了实现这种故意泄漏私有的手法的一种有用应用。
对当初的问题，答案又进了一步：
1)具有对某个成员的访问权的代码可以通过泄漏该成员的指针（摆脱了名字的束缚）的方式将其访问授予其他任何代码。

最后，这里还有另一种做法，使用该做法的类可以向外界提供一种具有完美可移植性且符合标准的途径来访问它们的私有成员，该做法就是成员模板。在第15条讨论过访问某个类的私有成员的若干途径，其中绝大部分都是非法的或是在标准之外的，其中有一条途径却是完全符合标准的：
class X
{
public:
	X(): private_(1) {}
	
	template<class T>
	void f(const T& t) {}
	
	int Value() {return private_;}
private:
	int private_;
};

namespace
{
	struct Y {};
}
template<>
void X::f(const Y&)
{
	private_ = 2;//得逞了！
}
任何成员模板都可以针对任何类型进行特化。因此可以使用一个特殊的类型来特化它，前提是其他任何人都不会使用你所使用的这个类型来特化该成员模板，例如可以使用一个定义在自己的匿名名字空间中的类型来作为特化的模板实参。你为所特化的成员模板所属的类写了一个成员函数，而成员函数具有对其所属类的所有成员的访问权。
答案的最后一部分：
1)private成员的名字只对其所属类的其他成员或友元来说是可访问的，而这里的其他成员也包括成员模板的任何显式特化（不管它的某个给定显式特化是否为意料之中的）。
小结
private到底在多大程序上是私有的，下面就是得到的答案：
private成员的名字只对其所属类的其他成员或友元来说是可访问的，而这里的其他成员也包括成员模板的任何显式特化（不管它的某个给定显式特化是否为意料之中的）。不过，如果某段代码具有对某个成员的访问权，该段代码就可以通过泄漏该成员的指针的方式将其访问权限授予外界的任何代码。
private成员对于任何能够看到其所属类定义的代码来说都是可见的。这意味着它的函数参数的类型必须事先声明（即便它们可能对于当前编译单元来说是无用的），另外它还会参与名字查找和重载决议，因而可能会使调用变得无效或具有二义性（即便它本身可能永远不被调用）。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第17条 封装
1. “封装”意味着什么
程序设计当中，封装，即通过将类的内部实现隐藏在一层外围的、外界可见的接口后加以保护。
类接口：
1)包围、包装、包含、包裹
一个良好的类接口能够隐藏其所属类的内部实现，并向外围提供一个与类的内部实现分离和区别开来的“界面”。其接口应该是内聚的，换句话说，构成该接口的各成分互相之间应当是直接相关的。
2)封装的、密封
一个良好的类接口设计必须是完整的，同时又不能暴露类的任何内部实现。接口的作用只是作为一层密封层，而且通常是作为代码防火墙（编译时或运行时的，或既是编译时又是运行时的），令外界代码无法依赖于类的内部实现，从而确保类的内部实现的更动不会影响到外界的代码。
3)保护、外壳
一个良好的类接口会保护类的内部实现，以免它们遭受到未经授权的访问和操作。特别地，类接口的主要作用在于确保所有对类的内部结构的访问和操纵都不会破坏类的不变式。

封装在面向对象中的地位
封装对于面向对象设计和编程的重要性如何
封装是面向对象编程的核心概念。
其他面向对象技术，如数据隐藏、继承和多态，从原则上来说也是重要的，因为它们支持封装的某些特殊形式。例如：
1)封装几乎总是意味着数据隐藏。
2)运行时多态，使用虚函数，更彻底地将内部实现（由派生类提供）与对外接口（由基类提供）分离，提供内部实现的派生类甚至可以在最终用到的客户代码之后编写。
3)编译时多态，使用模板，将接口与实现完全分离，任何具有必备操作的类都可以替换使用，而无需具有任何继承或其他关系。
封装并不总是数据隐藏，不过数据隐藏总是某种形式的封装。封装并不总是多态，而多态则总是某种形式的封装。
所谓面向对象，通常是这么定义的：
--数据以及操作这些数据的函数的组合
以上定义从某种程序上来说是正确的，只不过它忽略了那些虽为非成员函数，但从逻辑上来讲仍是类的接口的一部分的自由函数，例如C++中的operator<<。同时该定义也强调了高内聚性。不过，该定义并没有充分强调面向对象的另一个重要方面，即：
--通过由一组函数构成的接口将调用代码与内部数据隔离开来（由接口来负责操纵内部数据）
这一方面强调了两点，一点是低耦合度，另一点是被组合起来的函数构成了一个起保护作用的接口。
简单地说，面向对象就是关于将接口与实现分离的方法学，只不过这种分离必须能够改善高内聚性和低耦合度。

2. 类的非静态数据成员在哪些情况下（如果存在的话）应当是public、protected还是private的，将答案归结为一条编码原则。
先看例外情况
对于一般规则来说，惟一的例外是所有的类成员（不管是函数还是数据）皆为公用（就像C风格的struct一样）的时候。这种情况下所谓的“类”其实并非功能完整的类，功能完整的类至少得有自己的接口、行为以及不变式，而我们的所有成员皆公用的“类”甚至连半个类都算不上，只能算是一堆数据（bundle-o-data）。我们的“类”仅仅是为方便起见将一组对象捆绑一起，这没什么问题，尤其是这种做法能够向后兼容那些操纵C风格struct的C程序。
除了上述特殊情况之外，数据成员永远都应当为私有的。
大多数调用代码永远都不应该直接去操纵类的内部（例如，通过查看或改变类的成员数据），因为可能很容易一不小心就干了错事；至多它们只能通过被操纵类的公用接口，在让被操纵类获并得到其认可的前提下间接地操纵其内部。当然，有些非成员代码可能的确有资格直接访问某个类的内部（通常这些代码应当是成员函数，不过也有个别例外，譬如operator<<一般就是非成员函数），然而即便如此：（a）这种情况也属罕见；（b）被操纵类有权选择是否声明其为friend；（c）被操纵类有权选择将这类外界代码中的哪些声明为具有一定信任级别的friend。
简而言之，公用数据是危险的（除非是对于C风格的struct而言）。
类似的，保护数据也是危险的（这次没有例外）。
保护数据也是接口的一部分――保护接口也是外界可见的接口，只不过这里的“外界”只是公用接口“外界”的子集而已，因为保护接口的外界就是指派生类中的代码。
准则：问题将所有数据成员放在私有区段。惟一的例外是C风格的struct，后者是意图并不在于封装什么东西，因而其所有成员都可以是公用的。

一个通用的形式转换
//示例17-2(a)：“危险的”非私有数据
class X
{
public:
	T1 t1_;
protected:
	T2 t2_;
};
首先注意到，以上的类总是可以被转换成其他等价形式，同时又不会丧失一般性或效率：
//示例17-2(b)：封装的数据（良好）
class X
{
public:
	T1& UseT1() {return t1_;}
protected:
	T2& UseT2() {return t2_;}
private:
	T1 t1_;
	T2 t2_;
};
这就是说即便有理由允许对t1_或t2_的直接访问，我们也有上面这个简单的等价形式，它能够通过一个（最初始为内联的）成员函数来实现对成员的访问。示例17-2(a)和17-2(b)是等价的。
为了证明示例17-2(a)中的做法决不该被采用，只需要说明：
（1）示例17-2(a)的做法并不具有17-2(b)的做法所不具备的优点；
（2）示例17-2(b)的做法具有一些实在的优点；
（3）示例17-2(b)的做法并不需要任何代价。
第3点不言而喻。UseT1()这样的内联函数是按引用返回的，因而不会带来任何复制开销，所以它很可能会被编译器完全优化掉。
第2点显而易见：考虑源代码依赖性。在17-2(b)当中，可以在不影响调用代码的前提下随意地添加功能，而且甚至连t1_和t2_都可以被完全删除，因为成员函数才是负责构成类的接口的部件，也是“包围”、“密封”以及“保护”类内部实现的一层保护膜。
最后，示例17-2(a)中调用代码能够直接对t1_和t2_做的事情通过示例17-2(b)中的间接调用UseT1()和UseT2()也能够完成，因而第1点得到保证。只不过在后一种情况中调用者可能需要写一对额外的圆括号而已。
考虑一个具体的例子：假设想要将某些功能，如计算对t1_和t2_的访问次数这一功能添加进类中。如果该功能需要一个数据成员来记录访问次数（像示例17-2(a)中那样），那么下面的一切就是无可避免的了：
（1）得创建访问函数来实现相应的功能，并同时将相应的数据成员设为私有的。（换句话说，还是走到了示例17-2(b)的路上，只不过是在后期作为一种改进而已。）
（2）类的使用者得将代码中任何用到t1_或t2_的地方全都改动一番，改成功能上无甚区别的另一种形式（调用访问函数）。
（3）所有客户代码得重新编译。
（4）如果漏改了某些地方，会导致编译不通过，结果又得返回重复步骤2和3，直到所有地方都修改完毕。
然而如果你原本就已经有了简单的成员访问函数（像示例17-2(b)中那样），那么只需做下面这两件事情：
（1）你在访问函数内部作一些相应的改动。
（2）所有的客户代码一般只需重新连接即可（如果你所改动的函数是位于一个分离编译的.cpp文件当中，不是内联函数），或者，最坏的情况，客户代码都需要重新编译（如果改动的函数位于头文件之中）。
依赖于一个接口的用户越多，要想改变该接口就越是困难。
准则：接口是最需要在第一时间做对的事情。其他东西都可以在后期进行修正。如果你一开始就没有把接口做对的话，那么以后你可能就永远没有机会去改正它了。
简而言之，一个糟糕的接口设计在木已成舟之后就是很难或者无法更改的了。所以你应当尽量在第一时间就将接口做对，并让它发挥包裹、密封以及保护类的内部实现的作用。

佐证
3. std::pair类模板使用公用数据成员是因为它并非一个封装类，而只是一个捆绑数据的机制。
注意，这是公用数据的一种完全合理的使用方式。不过即便如此，std::pair如果使用访问函数的话也肯定不会比现在差。
//示例17-3(b)：恰当的封装，一开始可以使用内联和访问函数。日后如果有必要的话，这些函数也许会“成长”为非平凡的非内联函数；如无必要则可保持现在的形式。
template<class T, class U>
class Couple
{
public://书上这里没有加public:？？？
	Couple(): delete_(false) { }
	T& First() {return first_;}
	U& Second() {return second_;}
	void MarkDeleted() {deleted_ = true;}
	bool IsDeleted() {return deleted_;}
private:
	T first_;
	U second_;
	bool deleted_;
};
为什么非得写几个什么也不干的访问函数呢。答案是：正如前面讨论示例17-2(b)的时候提到的，如果今天调用代码可以改变该对象的某些方面（本例中就是指deleted_属性），那么明天你或许就会想要添加某些新特性（即便它们可能无非是添加一些调试信息或者添加一些检查而已）。示例17-3(b)允许你这么做，而且这种灵活性并不会给你带来任何效率上的开销，因为函数是内联的。
例如，某天你决定要对所有对标记为“删除”的对象的访问进行检查，那么：
--如果先前采取的示例17-3(a)的做法（数据成员first和second为公用），现在就不能这么做了。至少在不改变接口设计，也不要求所有使用了first_和second_的代码重新编写前提下不能。
--而如果先前采取了示例17-3(b)中的做法的话，现在只需简单地将负责检查的代码放入First和Second这两个成员函数之中即可。这里的改动对于之前和之后Couple类的使用者来说都透明的。客户代码至多需要重新编译一下，根本无需进行任何源代码上的改动。
此外，似乎示例17-3(b)的做法在现实中还有其他一些实际的附带好处。例如，可以在访问函数中设置一个断点（或其他什么东西），以便测出何时何地你的值正在被改动。这在跟踪调试的时候会是相当有用的功能。毫无疑问，而且通常的确如此。

小结
除了C风格的struct这一特殊情况（其中所有成员皆为公用的）之外，所有数据成员都应当总是私有的。如果不这么做就会违反本条开始指出的所有的封装原则，并使客户代码与成员的名字耦合起来，后一点将使以后要将这些成员正确封装更加困难（几乎不可能）。永远没有什么充分理由支持你去写公用的或保护的数据成员。它们总能够被轻易地包装在内联的访问函数之后，这不会带来任何开销，因此在第一时间就将事情做对总是正确的。（诚然，标准库中的确有些类使用了保护的数据成员，不过这些例子属于“切勿仿效”者之列。）
在第一时间就将接口设计正确。内部实现现在事后事后皆可以容易地加以改正，但一旦将接口搞错了的话，你可能就永远也没有机会去改正它了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第18条 虚拟
关于基类析构函数的一般建议是什么。
这个问题通常的答案是：基类的析构函数当然应该是虚的！只可惜这个答案的是错误的，而且C++标准库本身当中就包含了这方面的例证，只不过这个答案经常看起来很正确，足以给人一种假象。
这只是有关虚函数可访问性的两个问题中的一个。让我们从其中更具一般性的问题开始。

虚函数问题之一：公用还是私有
需要考虑的一般性问题是：
虚函数什么时候应当为public，什么时候应当为protected，什么时候又应当为private。证明你的答案。
简单的答案分别为：很罕见（如果有的话）、有时、默认情况下。前面已经看到，对于其他类成员来说答案也是一样的。
大多数人学到要将类的所有成员默认放在私有区段，只在绝对有必要将它们暴露给外界的时候才将它们放到公用区段。这当然是良好的封装准则。之前也了解到，数据成员始终应该为私有的（除非是对于C风格的struct而言，后者只不过是一组数据的简单捆绑，其意图并非要去封装什么，见第17条）。相同的做法可以用到成员函数身上，因此建议遵循如下的准则，它可以被总结为一句对设置为私有之优点的陈述（至少对于代码来说是有好处的）。
准则：尽量让接口成为非虚的。（不太懂？？？基类继承一般接口不都是纯虚的）

我们建议通过保护的的（家族）方法来提供定制能力。基类的公用接口应当提供一组丰富的功能以供其用户使用。然而该类的定制者通常希望尽可能通过实现最少的方法就能向用户提供这组丰富的功能。为了达到这个目的，你应当提供一组非虚的或final的公用方法并让它们去调用一个单一的、具有“Core”后缀的、提供了具体实现的保护（家族）方法。该做法在设计模式领域也被称为“模板方法”（Tmeplate Method）模式。
为什么说这一在实践当中反复出现的模式是个好点子呢，来看看。
传统上，许多程序员习惯于编写具有公用虚函数的基类。如，我们可能会写：
//示例18-1：一个传统的基类
class Widget
{
public://这些函数当中每个都可被选作纯虚函数，如果这样，它们在Widget中有可能实现，也可能没有实现，参见More Exceptional C++ 23.
	virtual int Process(Gadget&);
	virtual bool IsDone();
};
这些公用的虚函数，正如所用公用的虚函数一样，同时既给出了接口又给出了可定制的行为。问题在于“同时”上，由于每个公用虚函数都得为两个不同需求和目的的客方服务：
1)其一是类的外部调用者，它们依赖于其公用接口来使用它。
2)另一个是派生类，它们同样依赖于虚函数的“定制接口”，因为通过这些接口它们才能扩展和定制它们的基类。
一个公用虚函数被强制做两件事情：其一是给出接口，由于它是公用的，因此就成为了Widget呈现给外部世界的接口的直接的一部分。其二是给出实现细节，即其内部可定制的行为，由于它是虚的，因而就提供给了派生类一个替换其基类中上的实现（如果有的话）的机会。一个公用的虚函数天生就会做两件截然不同的事情，它们的客方相互之间是一种竞争的关系，这意味着公用虚函数没能很好地将概念区分开来，我们应当考虑采用其他途径。
如果我们想要将“给出接口”与“给出实现的可定制行为”分离开来的话，我们就会发现最终的结果会让我们立即联想到模板方法模式，因为它们非常相似。然而，这里的情况又有所不同，与模板方法相比，这里采用的方法的目的要狭窄得多，因而我们给它一个更为专门的名字：非虚接口（Nonvirtual Interface, NVI）模式（感觉这里模式的目的是为了接口与定制的分离，除此之外与模板方法模式没有差别？？？）。下面就是它在实际运用中的情形：
//示例18-2：一个更“摩登”的基类，使用了非虚接口模式来将接口与内部实现分离开来。
class Widget
{
public://稳定的、非虚的接口
	int Process(Gadget&);//使用DoProcess...()
	bool IsDone();//使用DoIsDone()
private://定制属于实现细节，它可能与接口直接相关，也可能无直接关系。下面的这些函数皆可为纯虚函数，如果为纯虚函数则在Widget类中可能实现，也可能没有实现，参见More Exceptional C++中第23条
	virtual int DoProcessPhase1(Gadget&);
	virtual int DoProcessPhase2(Gadget&);
	virtual bool DoIsDone();
};
尽量使用非虚接口模式来使接口稳定和非虚，将可定制的工作放在那些负责实现可定制行为的非公用虚函数当中。毕竟，虚函数是被设计用来允许派生类定制行为的，所以最好别让公用派生类也将继承而得的接口给定制了，后者理应是一致的。
非虚接口的做法具有如下几个优点，同时并不存在显著的缺点：
第一，注意到基类现在对它的接口及策略拥有了完全的控制权，因而可以很方便地在一个单一的、可复用的地方实施（enforce）接口的前条件跟后条件、插入一些设备（instrumentation），或者做一些类似的事情等等，这个“单一的、可复用的地方”就是非虚接口函数。这促进了良好的类设计，因为它允许基类对派生类的定制（替换）举动实施一致性检查（根据Liskov替换原则），只要基类认为有意义，就完全可以进行任何程序的检查。如果需要考虑效率的话，基类可以选择只在调试模式下进行一些特定的前条件和后条件的检验，例如，我们可以通过在构造项目时选择非调试模式（release）从而阻止编译器编译所有的检查代码，或者我们也可以通过一个可配置的调试模式来允许在运行期禁用选定的检查代码。
第二，由于我们更好地分离开了接口与实现，所以我们可以让它们分别具有自然而然的形式，而不是费力寻找一个强迫它们看起来一模一样的折衷形式。例如，注意到在示例18-2 中我们发现让我们的用户看到一个单一的Process函数，同时又允许用户在两个部分（DoProcessPhase1以及DoProcessPhase2）单独作为更为灵活的定制的做法更有意义。如果使用公用虚函数的话，不将这种概念上的分离显式地呈现在接口上是不可能达到同样效果的，但这么一来就会增加复杂度，用户得知道更多信息才能够在两个函数之间进行正确的调用。（参见Exceptional C++ 条款19中的一个相关例子的更多讨论。）
第三，采用非虚接口模式可以让基类在变化面前更为稳固。我们大可以在基类完成之后再改变主意，如添加前条件及后条件检查，或者将某件事分割成更多步来完成，或者进行重构，或者使用Pimpl惯用手法（参见Exceptional C++）来实现更为完善的接口/实现分离，或者对Widget的可定制化能力进行一些其他的调整，而所有这些都可以在毫不影响Widget的客户代码的前提下完成，例如，要想一开始使用公用虚函数并在以后试图对其添加前条件和后条件检查的话会困难得多，比预先提供一个非虚的外覆转发函数（即便当时并不立即需要实施检查或其他额外工作）并在以后需要的时候再向其中插入检查代码的做法要更为困难。
这种方法是否损失了一些效率（额外的函数调用）、增加了一些复杂性（额外的函数）。答案是否定的。首先，关于效率：实际当中这种做法丝毫无损效率，因为如果公用非虚函数是只包含惟一一行转发语句的内联函数的话，那么所有的编译器都能够完全将它优化掉，不会留下任何额外开销。其次，关于复杂性：惟一的复杂性是我们需要消耗一点额外的时间来编写只有一行的通道函数，这只是小事一桩。以上是最“C”式的吹捧，而对使用它的派生类的程序员来说，它仍然具有跟原来一样多的虚函数。不管是呈现给外界的公用接口还是呈现给派生类的继承接口都丝毫不会变得更为复杂。这两种接口被明确地区分开来，这是好事情。
准则：尽量将虚函数置为私有的。
这很简单。它允许派生类根据需要通过重写函数来定制某些行为，同时又不会将这些虚函数暴露给派生类（如果将它们置为保护的，派生类就可以直接调用它们）。关键是虚函数的存在是为了允许定制；除非它们也需要被派生类中的代码直接调用，否则根本不需要将它们设为非私有的。不过有时候我们的确需要调用基类中的虚函数，只有当出现这种情况的时候才有必要将虚函数设为保护的，因此有如下准则：
准则：只有当派生类需要调用基类中实现的虚函数的时候，我们才需要将后者设为保护的。
至少，非虚接口模式运用到虚函数身上能够很好地帮助我们将接口与实现分离开来。当然，将这种分离变得更彻底也是可能的，只需借助于一些途径彻底将接口跟实现隔离开来即可，例如桥接（Bridge）这类模式或者Pimpl这类惯用法（该手法主要用在控制编译器期依赖性和异常安全保证方面），或者更为一般的handle/body或envelope/letter惯用法，等等。除非你需要更为彻底的接口/实现分离，否则非虚接口模式通常足以满足你的需求。另一方面，作者认为非虚接口模式的这种运用也是一个应当被默认采用的良好做法，同时我们也应当将它看作新编写的代码至少应当具备的必要的分离程度。毕竟，这种做法不会带来任何开销（除了需要额外写一行代码之外），却能够为以后省却许多烦恼。

虚函数问题之二：基类的析构函数――又怎么样呢
第二个经典的问题了：“基类的析构函数应当为虚函数吗”
正如前面已经提到的，通常的答案：是。只可惜这个答案是错误的，而且C++标准库本身当中就包含了这方面的例证，只不过这个答案平常总是正确到能够给人一种正确的假相的地步。
一个不那么常见，但更为贴切的答案是：“基类的析构函数应当在你需要通过指向基类的指针来多态地析构派生类对象的时候为虚的”这个答案从技术上来说的确没错，但仍然不够令人满意。
最近得出的结论是，完全正确的答案如下：
准则：基类的析构函数要么应当为公用虚函数，要么应当为保护的非虚函数。
下面来看为什么这种做法是对的。
首先，很明显任何通过基类接口来进行的、应当具有多态行为的操作都应当是由虚函数来提供的。即便对于非虚接口来说也是如此，因为尽管其公用函数是非虚的，但幕后真正的工作却是由非公用虚函数来完成的，这样才能够得到所需的多态行为。
因此，如果可能通过基类接口来多态地销毁派生类对象的话，那么这种行为就必须是多态的，承担该行为的函数当然也就应当为虚函数了。实际上，语言对这一点有强制要求的：如果你试图通过一个非虚析构函数来进行多态析构的话，你就会遇到“未定义行为”这个噩梦。因此：
//示例18-3：很明显需要虚析构函数。
class Base {/*...*/};
class Derived: public Base {/*...*/};
Base* b = new Derived;
delete b;//Base::~Base最好是虚函数！
注意，这里的析构函数只是非虚接口模式所无法应用到的一个特例。为什么这么说呢？因为一旦执行流到达了基类的析构函数体中，就意味着其任何派生类对象的部分都已经被销毁，不复存在。此时如果基类析构再去调用一个虚函数，那么虚函数分发机制有可能就会无法将该调用向继承树的下游（即派生类）转发了。简而言之，当执行流位于某个析构函数体（或构造函数体）当中的时候，其任何派生类对象都已经被析构而不复存在了（或还未诞生，对于构造函数的情况）。
然而基类并不总是需要支持多态销毁。例如，标准库自身当中的例子：std::unary_function和std::binary_function。那两个类模板看起来像这样：
template<class Arg, class Result>
struct unary_function
{
	typedef Arg argument_type;
	typedef Result result_type;
};

template<class Arg1, class Arg2, class Result>
struct binary_function
{
	typedef Arg1 first_argument_type;
	typedef Arg2 second_argument_type;
	typedef Result result_type;
};

这两者是特地为了被实例化为基类（从而将其中包含的那几个标准的typedef插入到派生类当中）而作的，而且这两个类模板并没有提供虚析构函数，因为它们并不被用于多态销毁。这就是说，像下面这样的代码并不仅仅是不被认可的，而是完全非法的，你应当假设这种代码永远也不会被编写出来：
//示例18-4：有问题的代码，你可以假定这种代码永远也不会被编写出来。
void f(std::unary_function* p)
{
	delete p;//错误，非法的！
}
注意，标准明令禁止示例18-4 中的做法，说如果你通过一个指向std::unary_function的指针来析构它的派生类对象的话，你将会遭到未定义的行为，然后标准并没有要求编译器去阻止程序员这么做。其实只要为std::unary_function（或其他类似的类）添加一个保护（保护的？？？不是私有的？？？）的空析构函数就可以达到很好的防御效果，这么一来等于要求编译器侦测出这类错误并把错误信息扔给不守规矩的家伙，这样做并不会破坏任何现存的任何标准的C++代码。或许会在标准的下一修订版中看到相应改动，或许不会，但无论如何让编译器拒绝这种错误用法（而不是在标准里面纸上谈兵）肯定是有好处的。（是的，让析构函数成为非公用即意味着你不能直接创建unary_function的对象，但这并不要紧，因为unary_function本来就只有在作为基类的进修才是有用的。）
最后，如果一个基类是具体类（concrete class，即其本身可以有实例的类），同时它又希望支持多态析构的话，该怎么办，是不是说它的析构函数得是公用的，因为如果不这样的话我们就无法容易地创建它的对象了。这样做是可以的，只不过倘若这么做的话就已经违背了另一条原则：不要继承自具体类。“让继承树中的非叶节点成为抽象类。”（诚然，这在实践当中是可能发生的（当然，是在别人而不是你编写的代码中），而在我们所讨论的这个特定的例子中，你或许得采用一个公用的虚析构函数来弥补一个已经糟糕的设计。不过，如果可以的话，最好还是进行一点重构以改正你的设计。）
那么，简而言之剩下的情况就是二选一：（a）你想要允许通过基类指针来进行多态析构，这种情况下基类的析构函数必须为公用虚函数；（b）否则虚函数就应当为保护且非虚的，保护能够防止意外的误用。

小结
总的来说，你应当尽量将基类的虚函数放在私有区段（如果的确有必要也可将其放在保护区段）。这样做能够将接口与实现分离开来，有助于接口的稳定，并易于日后对幕后实现机制进行改动或重构。对于常规的基类函数来说：
1. 准则之一：尽量利用非虚接口模式让接口函数成为非虚的。
2. 准则之二：尽量让虚函数成为私有的。
3. 准则之三：只有当派生类需要对基类中某个虚函数的实现进行调用的时候才将对应的虚函数设为保护的。
以下原则仅对析构函数这个特例有效：
4. 准则之四：基类的析构函数应当要么为公用虚函数，要么为保护非虚函数。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第19条 对派生类施加规则
隐式生成的函数（或者说编译器为你代劳的工作）
在C++中，有4个类成员函数可以被编译器隐式生成，分别为：默认构造函数、复制构造函数、复制赋值操作符以及析构函数。
这么规定的原因是为了方便组合以及向后兼容于C。C风格的结构是只包含公用数据成员的类；特别地，它们不包含任何（显式定义的）成员函数，当然得能够创建、复制以及销毁它们。为了使之成为可能，C++语言规定，如果你自己没有定义某些必要的操作的话，编译器会自动生成一些适当的函数（或这些函数某个子集）以完成适当的工作。
本条正要讨论所谓的“适当”具体是指什么：
1. 编译器什么时候会为一个类隐式声明和隐式定义如下这些函数，隐式声明/定义出来的版本具有什么样的语言，请逐一给出明确答复，并指出什么情况下隐式定义出来的版本是不合法的。
（a）默认构造函数
（b）复制构造函数
（c）复制赋值操作符
（d）析构函数
简而言之，一个隐式声明的函数仅当你实际试图去调用它的时候才会被定义出来。例如，一个隐式声明的默认构造函数，仅当你试图在无构造函数参数情况下构造其所属类的对象时才会隐式定义。
为何要区分隐式声明跟隐式定义的时机呢，这样规定有何用处。实际上，由于这些函数可能不会被调用到，所以如果它们永远不被调用到，那么即便其隐式定义生成出来的可能是非法的，但由于实际上并未生成，因而也就不会影响程序的合法性。

隐式声明的函数的异常规格（Exception Specification）
对于可能被隐式声明的所有4种特殊函数，编译器会将它的异常规格尽量放宽，以便允许其隐式定义所调用到的函数可能会抛出的所有异常。如：
//示例19-1(a)
class C
{
	//...
};
由于C中没有显式声明任何构造函数，因此编译器会隐式生成一个默认的构造函数，后者的语义为调用所有基类以及成员子对象的默认构造函数。因而其隐式生成的默认构造函数的异常规格必须允许所有基类及成员默认构造函数可能抛出的所有异常。如果其中有任何基类或成员的默认构造函数不带有异常规格的话，就意味着隐式生成的构造函数可能会抛出任何异常：
//公用的：
inline C::C();//可能抛出任何异常
如果C的每个基类或成员都具有一个带有显示异常规格声明的默认构造函数，那么C的隐式生成的默认构造函数将可能抛出前者的异常规格列表里面列出的任何异常：
//公用的：
inline C::C() throw(
	//C的基类或成员的默认构造函数可能抛出的任何异常；即C的基类或成员的默认构造函数的异常规格列表的并集
);
一个潜藏的陷阱。考虑这么一种情况：如果隐式生成的函数有一个重写了基类对应的虚函数的话会出现什么情况。这对构造函数来说不会发生（因为构造函数永远也不是虚函数），然而对于复制赋值操作符来说则是有可能发生的（如果你故意在基类当中设置一个签名跟派生类中自动生成的复制赋值操作符签名一模一样的虚函数的话），而对于构造函数则更是如此：
//示例19-1(b)：危险
class Derived;
class Base
{
public:
	//这个例子有点故意 捏造的意思，如果真出现这种情况几乎肯定是糟糕的做法，不过从技术上来说，使用这种技巧来声明一个与派生类中的复制赋值操作符的签名一模一样的基类赋值操作符是可行的；不过在动下面这样的念头之前记得一定要先阅读中的第33条：
	virtual Base&/*或Derived&*/
	operator=(const Derived&) throw(B1);
	
	virtual ~Base() throw(B2);
};

class Member
{
public:
	Member& operator=(const Member&) throw(M1);
	~Member() throw(M2);
};

class Derived: public Base
{
	Member m_;
	//隐式声明了4个函数；
	//Derived::Derived();//没问题
	//Derived::Derived(const Derived&);//没问题
	//Derived& Derived::operator=(const Derived&) throw(B1, M1);//错
	//Derived::~Derived() throw(B2, M2);//错
};
问题是上面代码中标明的两个函数是非良构的，因为不管什么时候只要你重写了继承的虚函数，那么你的派生类函数的异常规格就必须至少跟对应的继承的虚函数一样严格。这样规定是有意义的：因为如果不这样的话就意味着那些通过基类指针来调用派生类虚函数的代码可能会得到一个不在基类相应虚函数的异常规格列表中异常。例如，假设示例19-1 (b)中的情况的允许的，那么考虑如下的代码：
Base* p = new Derived;
//哎呀――这里可能会抛出B2或M2，而不像Base::~Base
//承诺的那样最多只会抛出B2：
delete p;
这是关于“为什么每个析构函数应当要么具有空异常规格（throw()，不抛异常），要么根本没有异常规格（可能抛出任何异常）”这一原则的另一个正面论据。此外，析构函数应当永远不抛出任何异常，而且你在编写析构函数的时候应该当它具有一个空的异常规格列表似的（即便其函数声明上并没有throw()的字样）。（参见Exceptional C++的第12条，其中有一节为“抛出异常的析构函数以及为什么说它们是危险的”）。
准则：永远不要让异常从析构函数中跑出来，在编写任何析构函数的时候总是就当它具有一个不抛出任何异常的异常规格声明那样。永远不要为函数编写异常规格声明。或者你可以编写一个空的，不过如果我是你的话，我连这个也会避免（见第13条）。

这也是关于当心虚赋值操作符的另一个证据。
准则：避免将赋值操作符设为虚函数。

逐一来考虑上文提到的4个能被隐式生成的函数：
隐式默认构造函数
（a）默认构造函数
默认构造函数仅在你自己不声明任何构造函数的时候才会被隐式声明。一个隐式声明的默认构造函数是公用内联的。
一个隐式声明的默认构造函数只有在你实际试图调用它的时候才会被隐式定义，其隐式定义的效果就好像是你自己写了一个空的默认构造函数那样，可能抛出其基类成员的默认构造函数可能抛出的任何异常。如果你自己手写的那个空的默认构造函数是非法的，那么该隐式定义就是非法的（例如，如果某个基类或成员没有默认构造函数的话它就是非法的）。

隐式复制构造函数
（b）复制构造函数
如果不自己声明一个复制构造函数的话，编译器就会为你自动隐式声明一个。隐式声明的复制构造函数是公用内联的，编译器会尽可能地将其形参声明为const引用（其形参为const引用仅当其每个基类和成员都具有按const或const volatile引用来接受参数的复制构造函数），实在不行才将形参声明为non-const引用（印象里auto_ptr是个非引用？？？，下面有讲解）。
一个隐式声明的复制构造函数会在你实际试图调用它去复制给定类型的对象时被隐式定义出来，对其所有基类和成员子对象进行逐成员复制，并可能抛出它的基类或成员复制构造函数可能抛出的所有异常。如果有任何基类或成员具有不可访问或二义性的复制构造函数的话，该定义就是非法的。

隐式复制赋值操作符
（c）复制赋值操作符
如果你自己不声明任何复制赋值操作符的话，编译器会为你隐式生成一个。隐式声明的复制赋值符是公用内联的，会返回被赋值对象的non-const引用，并尽可能会按const引用接受参数（当且仅当其所有基类及成员的复制赋值操作符都是按const引用传参时该隐式生成的复制赋值操作符的形参才是const引用的，否则就是non-const引用）。同样，标准在这里对volatile也语焉不详。
一个隐式声明的复制赋值操作符仅当你实际需要调用它（对给定类型的对象进行赋值）时才会由编译器隐式定义出来，其语义是对所有基类及成员子对象进行逐成员赋值（包括对虚基类子对象可能存在的多次赋值），并且可能抛出其基类或成员的复制赋值操作符可能抛出的所有异常。如果其任何基类或成员为const、为引用或者具有不可访问或二义性的复制赋值操作符的话，该隐式生成的复制赋值操作符就是非法的。

隐式析构函数
（d）析构函数
如果你自己不去声明任何析构函数的话，编译器就会自动为你隐式地生成一个。一个隐式声明的析构函数是公用内联的。
一个隐式声明的析构函数仅当你实际试图调用它的时候才会被隐式定义出来，其效果等同于你自己写了一个空的析构函数一样，它可能抛出其基类或成员的析构函数可能抛出的任何异常。如果其任何基类或成员具有不可访问的析构函数，或者如果有任何基类析构函数为虚且并非所有基类及成员析构函数都具有同样的异常规格的话，该隐式生成的析构函数就是非法的（参见上文关于“隐式声明的函数的异常规格”的描述）。（注：析构函数为虚说明可以由基类指针调用派生类对象，异常规格不同说明基类指针可能抛出不在其异常规格的异常，因此非法）

一个auto_ptr成员
2. 对如下的类X来说具体有哪几个函数是被隐式声明和隐式定义的，它们的函数签名分别是什么
//示例19-2
class X
{
	auto_ptr<int> i_;
};
题外话：这个例子很好地说明了语言在隐式声明/定义4个特殊成员函数方面的规则。这并不是个关于良好编码风格的例子。总的来说你应当避免将auto_ptr作为成员并尽量避免使用auto_ptr。你应当尽量使用shared_ptr，shared_ptr目前已经被加入了C++标准库。
在类X中，如下函数被隐式声明为公用成员。当你试图调用它们的时候，编译器就会将它们隐式定义出来，效果如下：
inline X::X() throw(): i_() { }
inline X::X(X& other) throw(): i_(other.i_) { }
inline X& X::operator=(X& other) throw() {i_ = other.i_; return *this;}
inline X::~X() throw() { }
这里，隐式生成的复制构造函数及复制赋值操作符之所以接受non-const引用的参数是因为auto_ptr中的相应函数也是这么做的。类似的，所有这些函数都具有不抛任何异常的异常规格声明，因为auto_ptr中相关的函数也没有哪个会抛出异常，而且实际上auto_ptr的任何操作都不能抛出异常。
注意，上面的复制构造函数以及复制赋值操作符会导致auto_ptr成员的指针所有权的传递。后者可能是X的作者不愿意看到的，因此对于X来说自己编写这些函数通常是有必要的。（参见More Exceptional C++的条款30跟31中更多关于相关主题的详细讨论。）

“逆子”以及其他“家族”问题
3. 假设你有一个基类，它要求其所有派生类都不使用隐式声明和定义的特殊函数。例如：
//示例19-3
class Count
{
public:
	//Count的作者在这里注明了所有派生类都应当采用虚继承，并且它们的所有构造函数都只该调用Count类特意准备的这个构造函数。
	Count(/*一些特殊的参数*/);
	Count& operator=(const Count&);//常规
	virtual ~Count();//常规
这里有这样一个类：它想要它的任何派生类都乖乖听话地调用它特地准备的构造函数，或许这样一来Count才可以对系统中创建的派生类的数目进行跟踪。这是一个要求进行虚继承的有说服力的理由，因此虚继承可以避免在一些特殊情况下（譬如某个派生类中具有多个Count类的子对象）发生重复计数的情况。
Count中可能已经存在了一个设计错误，它有一个隐式生成的复制构造函数，这对于跟踪计数的正确性也许没什么好处。只需将它声明在私有区段且不加定义就可以将它禁用掉：
private:
	//未定义，无复制构造函数
	Count(const Count&);
};
这就是说Count想要它的派生类们乖乖听话。然而这些家伙并不总是会循规蹈矩，如：
class BadDerived: private virtual Count
{
	int i_;
	//默认构造函数：应当调用Count特地准备的构造函数，但事如人愿吗

简单地说，未如人愿，BadDerived的默认构造函数非但不会调用Count特地准备的构造函数，甚至还面临一个更为根本的问题：究竟存不存在一个BadDerived的默认构造函数呢，答案是：某种程序上。BadDerived的确具有一个隐式声明的默认构造函数（没问题），然而一旦你试图去调用它的话，程序就会成为不合法的。
看一看为什么会这样。首先，BadDerived并不会定义任何它自己的构造函数，因此一个默认的构造函数就会被隐式声明出来。但当你试图使用该构造函数的时候[即当你试图创建一个BadDerived对象（你可能认为创建其对象是相当重要的能力，你的想法也的确没错）的时候]，编译器就会为这个隐式声明的构造函数生成定义，或者说至少编译器应当在此时这么做，然而由于这个隐式定义应当调用基类的默认构造函数，后者又根本不存在，所以程序就成不合法的了。至少，任何试图创建BadDerived对象的程序都不是符合C++标准的程序，因此应当将责任归咎于BadDerived。
那么，关于“BadDerived究竟存不存在一个默认构造函数呢”这个问题，答案是“某种程序上”。实际上编译器声明了它，但你不可以去调用它，这令它变得形同虚设。
类似的，隐式生成的复制构造函数也会被声明，但在定义时并不会调用Count中特定的构造函数。如果这里的Count类就是原来那个Count类的话，BadDerived的复制构造函数就会调用Count的隐式生成的复制构造函数。
如果我们决定抑制Count的隐式生成的复制构造函数（参考上文），那么BadDerived虽然具有一个隐式声明的复制构造函数，但由于它不能被隐式定义（因为编译器会发现Count的默认复制构造函数是不可访问的），所以任何使用它的企图都会使程序变成非法的C++代码。
	//复制赋值：没问题吗
	//析构函数：没问题吗
};
是的，隐式生成的复制赋值操作符及析构函数的行为都是正确的，即调用（对于析构函数来说则是重写）基类中的相应的函数。

对派生类施加规则
在我们的这个例子的上下文当中，Count的作者有没有办法迫使派生类进行正确的编码吗。换句话说，如果派生类没有正确编码的话，会引发一个编译器（最好）或者运行时（最少）的错误吗。
办法不是去禁止编译器为派生类隐式声明特殊函数（我们还做不到这一点），而是让编译器试图进行的隐式定义成为非法的，从而导致编译器给出一个可以理解的错误。
更一般的说法是：基类作者有办法迫使派生类作者显式地编写出这4个基本操作吗，如果可以的话，怎么做。如果不可以的话，为什么。

随着我们逐步认识到在这四个基本操作的隐式声明和定义的过程当中发生了什么，我们逐渐开始注意到“不可访问”及“二义性”这两个字眼。一种做法是通过为基类的某些特殊函数添加具有二义性的重载版本（即便具有不同的访问限定）从而阻止编译器为其派生类隐式定义对应的特殊函数，不过这种做法似乎起不到多大帮助。如下：
class B
{
public:
	B() { }
	B(const B&) { }
	B(const B&, int i = 0) { }
};

class D: public B
{
};

int main()
{
	D d1;//没问题
	D d2 = d1;//错，编译器试图定义D的隐式声明的复制构造函数，却发现B的复制构造函数调用具有二义性！
}
（接上段）最简单的做法是将基类中相应的函数声明（定不定义随你）在私有区段从而有选择性地禁用它们，而且这种做法对虚函数之外的所有其他函数皆有效。
//示例19-4：迫使派生类不能使用它们隐式生成的函数
//做法是让Base中相应的函数变成不可访问的
class Base
{
public:
	virtual ~Base();
private:
	Base(const Base&);//无定义
	Base& operator=(const Base&);//无定义
};
这里的Base类没有默认的构造函数（因为一个用户自定义的构造函数已经被声明了，从而抑制了编译器的自动生成），同时Base具有一个隐藏的（私有的）复制构造函数和复制赋值操作符。但我们无法将析构函数也藏起来，因为它必须对派生类总是可见的，而且它通常应当为公用虚函数（如示例19-4 所示），或者为保护非虚的（见第18条）。
来看看
class Derived: private Base
{
	int i_;
	//默认构造函数：声明了，但定义是不合法的（因为不存在Base的默认构造函数）
	//复制构造函数：声明了，但定义是不合法的（因为Base的复制构造函数是不可访问的）
	//复制赋值操作符：声明了，但定义是不合法的（因为Base的复制赋值操作符是不可访问的）
	//析构函数：合法，将会通过编译
};
这个简单的解决方案无法解决析构函数的问题，但这无关紧要，因为相较之下我们不大可能使用一个特殊意图的成员函数来替换析构函数；基类的析构函数必须永远得到调用，这可不像构造函数可以有多个重载版本，析构函数没有多条路可走（永远只有惟一一个析构函数）。困难的部分是如何确保基类的那些特地准备的构造函数能够被正确地调用起来从而正确地初始化基类子对象：这样基类子对象才有足够的信息以备日后能正确地析构。（感觉有问题，派生类如果想正常编写这些函数，如何做？？？还是没办法访问到）
这还不赖。简单地解决方案通常就意味着最好。本例还有一些更为复杂的解决方案：下面来看一下，确信它们在析构函数或其他任何方面也没什么优势
替代方案之一：让基类中相应的函数成为二义性的。这种做法没任何优势，它仍旧没有禁止隐式生成的析构函数，而且工作量也更大。
替代方案之二：让基类中相应的函数在运行时出错。如可以让它们抛出std::logic_error异常。但这种做法也没有阻止编译器隐式生成析构函数（在不破坏任何可行的析构函数的前提下），而且它还将编译器错误推迟到了运行时，这可不太妙。
准则：尽量用编译期错误来取代运行时错误。
替代方案之三：将基类中相应的函数设为纯虚函数。这毫无用处：它对构造函数一点作用也不起（不管是默认构造函数还是复制构造函数）；对复制赋值操作符也没什么帮助，因为派生类的复制赋值操作符跟基类中的具有不同的签名（参数类型不同）；而且它对析构函数也不起作用，因为仍然满足编译器为派生类生成默认析构函数的条件。
替代方案之四：使用不具备默认构造函数的虚基类。这迫使最上层派生类构造函数负责调用该虚基类的构造函数（从而出错）。该方案在两种构造函数身上有运用前景，另外还有一个优势就是对并非直接继承自Base的类也能起作用，因此这是惟一一个能和示例19-4 中的解决方案结合使用的方案。不过这种做法只对构造函数有效，派生类的隐式生成的复制赋值操作符和析构函数仍然未被禁止。
小结
为了阻止编译器为派生类隐式生成默认构造函数、复制构造函数或者复制赋值操作符，最简单的、最佳的选择是将基类中相应的函数“藏”在非公用区段（或者干脆让它消失，例如默认构造函数）。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第20条 内存中的容器之一：内存管理的层次
1. 内存管理（也称为内存分配器）是指什么，其基本功能是什么，简要地描述C++中的两个主要的动态内存管理策略。
简而言之，C++中存在着如下两个流行的内存管理策略。
1)其一是通用意图（general-purpose）的分配策略，可提供调用方可能要求的任意大小（称为请求大小或块大小）的内存块。通用意图的分配策略灵活，但有几个缺点，其中两个就是：(a)性能，因为这种分配策略需要做更多的工作；(b)碎片，因为随着内存块的不断分配和释放，最终可能会导致许多小的、不连续的未分配内存区域。
2)其二是固定大小（fixed-size）的分配策略，总是返回固定大小的内存块。不像通用意图的分配特事特办那样灵活，但它的好处是可以在短得多的时间内完成分配，而且不会产生那样的内存碎片。
第三种主要的分配特事特办就是垃圾收集，该策略与C/C++指针、malloc和new并不完全兼容，因此与当前讨论的主题不直接相关。
实际上，通常会见到这些策略是被组合在一起运用的。如，或者你的内存管理器对任何大于S的内存请求使用的都是通用意图的分配策略，而对小于等于S的请求则一律采用固定大小的分配策略以获得优化的效果。
划分策略
2. 在C++标准库以及使用了C++标准库实现的典型环境中存在有几种不同层次的内存管理，它们相互之间的关系有什么特点，它们之间如何交互，它们是如何各司其职的。
1)首先是操作系统内核提供了最为基础的内存分配服务。
2)编译器的默认运行时库也会建立起它自己的内存分配服务，譬如C++中的operator new和C中的malloc，这一层是建立在操作系统的本地分配服务基础上的，可能只是后者的一层薄薄的外衣，继承了其特性；也有可能通过先从后者那里“买进”大块的内存（chunk），然后再切割转手分配出去的方式来覆盖操作系统的本地内存分配服务，至于具体如何切割“买来的”大块内存就是由这一层运行时库自己自由选择的了。
3)标准库容器和标准分配器进而又利用（也许会覆盖）运行时库提供的服务来实现它们自己的策略和优化。
4)最后，用户自定义的容器或用户自定义的分配器可能会进一步利用上面提到的任何一层服务（例如，如果可移植性并不那么重要的话，它们可能会想要直接访问本地分配服务），并按照它们自己的意愿来进行定制。
因此，内存分配器有好些不同的形式和种类，而且在不同的操作系统上，或者相同操作系统上的不同编译器间，或者不同容器间都会有所不同，甚至即便在不同的对象间也会有所不同，譬如说vector<int>使用allocator<int>而vector<int, MyAllocator>的MyAllocator则可以是任何你喜欢的分配策略。
准则：弄清谁负责做什么：弄清你当前的平台和标准库所使用的实际（且系统相关的）分配策略以及它们各自的职责是什么。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第21条 内存中的容器之二：它到底有多大
1. 当你使用new或malloc请求n字节的内存时，你实际只消耗了n字节内存吗，为什么。
当你使用new或malloc请求n字节内存时，你实际上至少耗用了n字节的内存，因为一般情况下内存管理器必须加上一些额外的开销。一般来说包括两项额外开销：系统维护（housekeeping）开销以及大块内存导致的开销。
先来考虑第一项开销：在一个通用意图（即不是固定大小的）的分配策略中，内存管理器必须以某种方式记住每块分配出去的内存块的大小，这样以后当这些内存块被归还（当你调用delete或free时）的时候才知道释放多大的内存。通常内存管理器会将实际分配的内存块的大小存放在该内存块的头部，而返回给你的指针就是从实际分配的内存块头部向后偏移系统维护信息所耗大小之后的指针。当然，这意味着它得耗用额外的空间来存放内存块的大小值，该值的最大值是可能分配出的最大空间大小，因此一般情况下它是一个指针大小（因为有效的内存分配大小不可能突破指针寻址能力的上限，例如典型的32位机器上指针的寻址极限是2的32次方，超过这个大小的内存就无法寻址了，因此低层细节数据的最大值也就是2的32次方，即耗用一个指针所耗用的相同大小的空间，32位机器上是4字节）。在释放内存块的时候，内存管理器会首先通过你返还给它的指针寻找到低层细节信息，将指针向后偏移系统维护信息所占大小进而得到内存块的大小，然后才进行实际的内存释放。
-----------------------new或malloc返回的指针
---------实际分配的缓冲-------------
大小							n字节
（系统维护信息）----（请求的内存）
当然，固定大小的分配策略（即总是返回给定大小的内存块）并不需要存放此类信息，从而节省了这笔开销，因此它们是知道分配出去的内存块是多大的。

来看一看所谓的大块内存开销：即便你并不需要存放额外的信息，通常某些内存管理器也会预留（reserve）出比你请求的空间更大的空间，因为内存通常是按照一定大小的chunk来分配的。
一方面，有些平台要求某些特定类型的数据满足特定的字节边界对齐条件（例如有些平台就要求指针只能存放在4字节边界上），如果特定的条件不能满足的话就会影响访问内存的速度，或者干脆出错。这就是所谓的“对齐”（alignment），正是该现象导致了对象数据中存在着（可能是在尾部）填充字节（padding）。
C++标准保证所有通过operator new 或malloc分配的内存对于你想要存储的任何类型的对象来说都是满足对齐条件的，这就意味着operator new/malloc必须遵从本地平台对于可能的数据类型的最为严格的对齐要求。

2. 给定同一类型同样数目的一组对象，各种标准库容器各消耗多少内存去存放它们。
不同的标准库容器使用了不同的底层内存结构，因而它们的“每对象”开销自然也就不尽相同。
1)vector<T>内部是以连续的C风格数组来存放T类型对象的，因而根本不用为每个元素花任何额外开销（当然是除了用于内存对齐的填充字节之外，注意，这里的“连续”跟C风格数组所谓的连续是同一个意思）
2)deque<T>可被当作vector<T>来看待，不同的是它将vector<T>内部的存储空间拍成了一块一块的。deque<T>是一块一块（chunk）（或谓之一页一页page）地保存对象的。其每一页的实际大小在标准里并没有明确说明，主要依赖于存储的对象的大小以及你的标准库实现在大小方面作出的决策。这种分布式存储要求deque为每一页都保存一个额外的指针以便管理其相关信息，这整个的开销如果分摊到每个存储的对象的话就只有少之又少的一点点开销了。除此之外就没有其他需要每个对象来承担的开销了，因为deque<T>并不为其中的每个对象存储任何额外的指针或其他信息。另外，标准中没有任何强制要求说deque的页一定得是C风格的数组，这只不过是常用的实现方式而已。
3)list<T>是一个保存着T元素的双向链表。这意味着对于每个T元素，list<T>都要额外存储两个指针，一个指向前一节点，另一个则指向后继节点。此外每次往list<T>中插入一个T元素的时候，我们也会创建出两个新的指针，因此list<T>中的每个元素至少需要花费两个指针的额外开销。
4)set<T>（还有multiset<T>、map<Key, T>或multi-map<Key, T>）同样保存了持有T对象（或pair<const Key, T>）的节点。set通常的内部实现是树，其中每个节点都有三个指针的额外开销。一个指向左子节点，一个指向右子节点，还有一个“向上”的指针回指向父节点，否则从任意一个迭代器推导出其“下一个”元素就不可能足够高效地完成了。
有时候如果愿意付出更高的“每迭代器”开销的话，就可以得到更低的“每元素”开销。换句话说，有些低层细节信息是可以放在迭代器中的，从而增大每个迭代器的开销，换取更小的容器开销。

在许多情况下，或者说，在所有可能的元素大小中有75%的可能情况下，list和set/multiset实际上在假设的特定环境下的内存开销是一模一样的。一个更为有趣的现象：list<char>和set<int>在这个特定环境下的实际额外开销是一样的，虽说后者在其每个节点中存放了更多的对象数据和系统维护信息。

小结
每种容器都会选择不同的空间/性能平衡点。在效率方面，使用vector和set可以做到list无法高效做到的事情，譬如说O(logN)时间复杂度的搜索；你也可以利用vector做到list或set无法做到的事情，譬如随机的元素访问；你可以使用list来高效地完成某些任务，而set在完成这些任务时可能就稍逊一筹了，vector则可能更慢，譬如说在中部插入元素等等。为了得到更好的灵活性，我们通常得花更多的内存开销，不过如果将数据对齐和内存分配策略都考虑进去的话，这些容器之间的实际开销差别可能会远远出乎你的意料。
准则：弄清你究竟得到了什么；弄清动态内存分配以及不同容器的实际的（和与系统相关的）空间开销。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第22条 进行new操作，也许会抛出异常之一：new的方方面面
陈述两个正确建议：
1) 任何类只要提供了自己的operator new或operator new[]，就得同时提供对应的类相关版本的简单new、定位new以及nothrow new。不这么做可能会给类的用户带来不必要的麻烦。
2)避免使用new(nothrow)，当你在对一次new操作失败进行检查时，确保你真的是在检查你所认为你正在检查的。

定位new、nothrow new以及简单new（即我们最常用的那种new）
1. C++标准中提供了哪三种形式的new
C++标准提供了三种形式的new，并允许人们对其进行任意数目的重载。
其中一个有用的形式是定位new，定位new负责在给定的内存地址处构造起一个对象来，此举不会分配任何新空间。例如：
//示例22-1(a)：使用定位new，相当于一次“显式的构造函数调用”
void* p = ::operator new(sizeof(T));
new (p) T;//在p所指之处构造一个T对象，可能调用::operator new(std::size_t, void*) throw()
C++标准同样提供了“简单的旧式new”（plain old new），这种形式的new不接受任何额外参数；此外还有nothrow new，这种形式接受额外的参数。下面是标准C++中提供的operator new重载的一个完整罗列：
//标准提供的operator new重载（此外还有对应的数组形式new[]）
void* ::operator new(std::size_t size) throw(std::bad_alloc);//最常用的简单new，用法：new T
void* ::operator new(std::size_t size, const std::nothrow_t&) throw();//nothrow new，用法：new (std::nothrow) T
void* ::operator new(std::size_t size, void* ptr) throw();//定位new，用法：new (ptr) T
标准允许程序员替换除最后一种new之外的所有其他形式的new，即用自己的版本来替换它们。所有这些标准函数都位于全局名字空间，而不是std名字空间当中。

标准版new的相互比较
标准版的new				额外的形参			是否进行内存分配			是否可能失败			抛出异常			是否可替换
简单new						无						是						是（抛出）			std::bad_alloc			是
nothrow new				std::nothrow_t				是						是（返回null）		无						是
定位new						void*					否						否					无						否

下面一个例子，展示了new的这些不同版本的使用方式：
//示例22-1(b)：使用各种形式的new，包括标准中提供的new，还有用户自定义的new
FastMemory f;
new (f) T;//调用某种用户自定义的new：operator new(std::size_t, FastMemory&)（或相似的，允许实参类型转换），一般出现这种形式的new基本都是从一块自定义的arena取内存
new (42, 3.14159, "xyzzy") T;//调用用户自定义的new：operator new(std::size_t, int, double, const char*)（或相似的，允许实参类型转换）
new (std::nothrow) T;//可能调用的是标准的或用户自定义的new：operator ::new(std::size_t, const std::nothrow_t&) throw()
从示例22-1(a)加上22-1(b)中的所有用法可以看出，调用new时放在括号内的额外实参对应于相应operator new声明时形参列表里多出来的形参。当然，跟22-1(a)中的情况不同，22-1(b)中的例子可能确实以某种方式分配了内存，并非使用现在有内存。

类相关的new
2. 什么是“类相关”的new，如何使用这种new。描述在提供自己的类相关new和delete时任何需要特别注意的地方。
除了允许程序员替换某些全局operator new之外，C++还允许类也具有自身的类相关的new。
在上两例中，只说“可能”，这是因为被调用的new不一定是位于全局名字空间中的，而可能是类相关的new。为了弄清这一点，请注意类相关的new跟全局new之间的两个有趣的相互作用：
1)尽管你不能直接将标准的全局定位new替换掉，但你却可以编写自己的、类相关的定位new，这么一来当你对拥有该类相关的定位new的类进行定位new时，调用的就是你自己定义的定位new而不是全局的那个了。
2)你可以在不替换全局nothrow new的情况下添加类相关的nothrow new。
这就是说在上面的两行代码中，有可能T（或T的基类）提供了自己的类相关版本的new，从而代码中的一处或两处所调用的就有可能并非全局版本，而是用户自定义的版本了。
下面就是一个简单的示范类相关new的例子，其中的类X提供了自己的、类相关的new，它们分别对应于三种不同风格的全局new：
//示例22-2：样例：类相关版本的new
class X
{
public:
	static void* operator new(std::size_t) throw();//1
	static void* operator new(std::size_t, const std::nothrow_t&) throw();//2
	static void* operator new(std::size_t, void*) throw();//3
};

X* p1 = new X;//调用1
X* p2 = new (std::nothrow) X;//调用2
void* p3 = /*足够放下一个X的有效内存*/;
new (p3) X;//调用3（！）
特地在“调用3”后面加了个感叹号，这是为了再次强调一下一个事实：虽说你不能替换掉全局的定位new，但你可以提供自己的类相关的定位new。

名字隐藏所导致的令人惊讶的行为
上面机制是为了引出下面的名字隐藏问题：
3. 在如下的代码中，从标准为1到标注为4的代码行分别调用了哪个operator new？
//示例22-3：名字隐藏了的“new”
class Base
{
public:
	static void* operator new(std::size_t, const FastMemory&);
};

class Derived: public Base
{
	//...
};

Derived* p1 = new Derived;//1

Derived* p2 = new (std::nothrow) Derived;//2

void* p3 = /*足够放的下一个Derived对象的有效内存*/;
new (p3) Derived;//3

FastMemory f;
Derived* p4 = new (f) Derived;//4
名字隐藏对大多数人来说并不陌生，不过通常见到的也许并非new的名字隐藏，而是诸如派生类中的名字隐藏基类中的名字这类隐藏，不过值得注意的是，名字隐藏有时也会发生在operator new身上。
回顾下名字隐藏机制：简而言之，编译器会从当前域开始查找（本例中是从Derived类的定义内）查找需要的名字（本例中为operator new）；如果没有找到该名字，编译器就会持续在外围作用域查找（本例中为Base类的定义内，然后是全局名字空间）。一旦发现某个作用域内包含有需要的名字（本例中是在Base的定义内发现的）就会停下来，并就该作用域内的名字进行决议，这便意味着再往外层去的作用域（本例中是全局名字空间）就不予考虑了，从而其中的同名函数就被隐藏了；取而代之的是，编译器会在当下的名字空间中找到的与所求名字同名的实体之间进行决议，即通过函数重载决议选出一个被实际调用的函数，最后，编译器检查被选中的函数的访问规则看它是否可被访问/调用。需要注意的是，即便在这个过程结束后编译器仍没有发现可用的重载版本，刚才提到的再往外层的作用域中的名字也仍然是不予考虑的；另外，即便选出的重载版本是不可访问的（从而不可被调用），也要忽略在外层作用域内的名字。这就是C++中的名字隐藏机制。
上面这段话意味着如果一个类C，或者其任何基类包含了类相关的operator new，那么不管该operator new具有什么样的签名，它都会隐藏所有的全局new，这就导致你无法为C编写再正常不过的、使用全局new的new表达式了。
下面就是以示例22-3 为前提编写的用户代码，从中会看到所说的情况：
Derived* p1 = new Derived;//错误：无可用的匹配

Derived* p2 = new (std::nothrow) Derived;//错误：无可用的匹配

void* p3 = /*足够放的下一个Derived对象的有效内存*/;
new (p3) Derived;//错误：无可用的匹配

FastMemory f;
Derived* p4 = new (f) Derived;//调用Base::operator new()

但如果非要使用全局new又该怎么办，对于上边的例子来说，至少前两个调用希望使用全局new的，但由于基类中的重载版本并非有效的匹配，因此得想一个合理的办法来将全局new重新放到编译器下。对此惟一合理的途径是让Derived自身提供必要的类相关operator new（并由它们来将调用转发给全局new），否则调用代码就只能使用全局限定符来引导编译器选出全局operator new了。
准则：如果你为某个类提供了任何类相关的new，那么记得同样为它提供类相关的简单（额外参数的）new。
类相关的new在大部分情况下应当总是遵循相应的全局new的语义，因此声明的时候应当加上throw(std::bad_alloc)异常规格，并尽量通过全局版本的new来实现它们，除非你真的需要插入一些特殊的手动处理：
//类相关的简单new应当尽量像这样来实现：
void* C::operator new(std::size_t s) throw(std::bad_alloc)
{
	return ::operator new(s);
}
这里你可能是在调用一个被替换后的全局new，而不是标准默认的那个，但这通常是件好事：大多数情况下，替换全局operator new的目的是为了调用或堆监测相关的原因，因此让这种行为反映在类相关版本的new上也是有必要的。
如果不这么做的话，你的类的客户代码就无法以通常动态分配对象的方式来分配你的类对象。
准则：如果你为某个类提供了任何类相关的new，那么记得同样为它提供类相关的定位new。
类相关的定位new应当问题遵照其全局版本的语言，因此将它声明为什么异常也不抛出，并通过全局的定位new来实现它：
//类相关的定位new最好像这样来实现：
void* C::operator new(std::size_t s, void* p) throw()
{
	return ::operator new(s, p);
}
如果不这么做，调用你的定位new的客户代码就有可能遇到意外的行为（甚至被破坏）。特别地，标准库容器实现通常使用定位new来构造其中的元素，并期望这种定位构造的行为能够像标准默认的定位new那样；毕竟定位new是C++中显式构造函数的惟一办法。除非你为你的类编写了定位new，否则你可能连std::vector<C>都无法使用。
准则：如果你为某个类提供了任何类相关的new，那么考虑是否同样提供类相关的nothrow new（因为有些客户代码可能的确想要调用它）；否则它就会被其他的类相关new隐藏了。
你可以使用全局nothrow new来实现类相关的nothrow new：
//选项A：类相关的nothrow new的实现。注意与全局nothrow new的一致性，应当等效于“选项B”
void* C::operator new(std::size_t s, const std::nothrow_t& n) throw()
{
	return ::operator new(s, n);
}
或者，为了确保与常规new的语义一致（全局的nothrow new也应当遵循此一致语义，不过如果有人将全局nothrow new替换为不遵循此语义的版本会怎么样），你也可以根据其语义来实现它：
//选项B：实现类相关的operator new。注重与对应的类相关简单new的语义的一致性。应当等效于“选项A”
void* C::operator new(std::size_t s, const std::nothrow_t&) throw()
{
	try
	{
		return C::operator new(s);
	}
	catch(...)
	{
		return 0;
	}
}
有一点值得注意，即这里展示的类相关new无法通过using声明来实现，例如“using::operator new;”，这行using声明如果说非得找一个地方放的话那就是放在类C的定义体中，但可惜的是放在那里是非法的；在一个类的定义内部，你只可能通过using声明来带入基类中的名字，而不能带入诸如全局名字或其他类中的名字。要求调用代码自己去添加using不但费事，而且甚至根本就行不通，因为我们或许根本就无权改动它们――有些调用代码位于对我们来说是只读模块当中（例如第三方库），或者甚至位于C++标准库当中（如果我们试图向标准库容器提供对定位new的访问的话）。

小结
如果你提供了任何类相关的new，那么：
1)应该总是同时提供类相关的简单（无额外参数的）new。
2)应该总是提供类相关的定位new。
3)应该考虑也提供类相关的nothrow new（因为有些客户代码可能的确想要调用它）；否则它就会被其他的类相关new隐藏了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第23条 进行new操作，也许会抛出异常之二：内存管理中的实际问题
避免使用new(nothrow)，当你在对一次new操作失败进行检查时，确保你真的是在检查你所认为你正在检查的。
1. 标准的new如遇内存不足的情况，有两种主要的报告方式。请解释。
大多数形式的new通过抛出bad_alloc异常来报告分配失败，nothrow new则通过malloc方式来报告失败（即返回空指针）。这确保了nothrow new永远都不会抛出异常，正如它名字所暗示的那样。
2. 使用nothrow形式的new能够令我们的代码更异常安全吗，证明你的答案。
答案是：不能。错误汇报和错误处理是两个完全直交的（无关的）问题。
抛出bad_alloc跟返回空指针其实是两个等价的错误报告机制。因此，检测并处理分配错误也只不过是在检查异常跟检查空指针之间进行选择而已。
对于那些反正会进行错误检查的调用方来说，这期间的差别只是语法上的。这意味着不客采用哪种报错机制，客户代码都可以实现完全等价的程序安全性和异常安全性，即检测错误的语法与安全性是无关的，因为差异性只不过是在语法上面，而且只不过会对调用方代码的结构稍有影响而已（例如，if(null){HandleError();throw MyOwnException();}跟catch(bad_alloc){HandleError(); throw MyOwnException();}）。哪种错误汇报机制都不能提供额外的信息或额外的内存安全性，因此两者都不会令程序更“安全”或“能够更正确”。
然而，对那些并不检查错误的客户代码来说，惟一的区别就在于最终引发的错误在方式上会有所差别，但在严重程度上并没有任何差别：一个未被捕获的bad_alloc异常会粗暴地结束程序（不管程序栈是否会展开到main），而一个未被检查的空指针则会导致一次内存非法访问，当用户试图对一个空指针进行解引用时程序会立即崩溃。这两种失败方式的危害性都是相当大的，但前者尚有一些优势：在栈开解的过程中至少会深度销毁一部分对象从而令它们持有的资源得到释放，而且如果其中有些对象像TextEditor这样的类的对象的话（TextEditor对象在被过早销毁的时候会自动保存恢复信息），那么一个精心编写的程序可以防止程序的状态被丢得一干二净。（告诫：当内存真的是被耗尽了的时候，要在不试图获取哪怕一丁点儿内存的情况下正确完成栈开解和退出可谓难上加难）。与此相比，因此用坏指针而引发的崩溃则要“不健康”得多。
准则：教训#1 ：避免使用nothrow new。
nothrow new对程序的正确性或异常安全性并没有本质上的好处，某些失败情况下它甚至还及不上异常，因为它有时候会掩盖某些失败，而异常至少有机会通过栈开解来进行一定程序上的恢复。正如上一条款指出的，如果一个类提供了它自己的new，但忘记了提供nothrow new的话，nothrow new就会被隐藏从而变得不可用的。大多数情况下，nothrow new没提供任何好处，因此基于以上原因，我们应当避免使用它。
不过少数情况下nothrow new也能带来好处。第一种情况属于：老的C++应用代码会通过检查（简单）new的返回值是否为null来确定它是否失败了（当时简单new的行为的确如此，通过返回null来报告失败），当你将这类代码移植到现代编译器上时，（为了将对代码的影响降到最低限度）你可以将其中的简单new全局替换为nothrow new，这样它的客户代码就不需要作任何改变。
另一种情况是在时间关键（time-critical）的函数内或内层循环中大量使用nothrow new，而且所使用的编译器较差，在编译涉及异常处理的代码时会引入较高的开销，并且在这一特定情况下使用常规new跟nothrow new会导致该函数的性能出现明显的差别，这种情况下使用nothrow new就能够给代码带来性能提升。
准则：教训#2 ：无论如何，检查new是否失败通常都没多大意义。

在现实中，有时候试图去检测内存是否已耗尽实际是不可能或无用的，试描述这类场合，不管是标准C++中还是位于严格意义上的标准C++之外的。
说检查new的失败与否并不像有些人想像得那么重要，原因：
（1）有些操作系统直到内存需要被实际使用到的时候才会提交（commmt）实际的物理或虚拟内存，在这些系统上检查new失败与否可能会是无用的。有一些操作系统上，内存分配总是会成功。
操作系统进行惰式分配，在new时只是提交一个申请，在内存被使用时，才会分配。
回来原来的问题，即是否符合标准的问题。由于::operator new和::operator new[]本身就是编译器提供的，所以作为编译器自然要比程序员更容易把这件事做理更好。特别地，编译器实现者或许能够利用对操作系统的认知来截获访问违规并进而阻止程序崩溃。换句话说，C++实现者可能可以做到如下事情：分配内存，然后通过写每个字节（或至少每个页面）来“确认”分配，并以平台相关的手段来捕获这期间发生的失败（通常是访问违规），然后将其转换为标准的bad_alloc异常（对于nothrow new来说则是null返回值）。
（2）在现实中，new失败的可能性本来就相当小，而又因为系统颠簸的存在则变得几近绝迹了。实际上，许多现代的、基于服务器的程序基本从不会遇到内存耗尽的情况。
（3）当你检测到new失败的时候并不总能有办法应付。大多数情况下，特别是在进行程序测试时，当new失败时默认让程序崩溃（通常至少会先尝试进行栈开解）实际上是最好的选择。
当然，有些情况下当new失败时你的确可以采取一些应付手段：例如，假设你想要记录一些诊断信息的话，new的失败处理函数就是进行这件事情的绝佳地点。
有时候，你可以做一些事情来应付某些特定类型的new失败，但通常并不值得去这么做，还不如就让栈自动开解，让new失败处理函数（也许还包括一些日志记录）完成它的工作。

你应当检查什么
的确，在某些特定情况下，检查内存是否耗尽并试图从中恢复的举动是有意义的。例如，你可以在程序一开始就把你以后将会用到的所有内存一次性分配完成，然后自己去管理它们：如果你的程序注定是要崩溃的，那么它就会在所有事情开始之前崩溃掉。这种方法需要你进行一些额外的工作，而且要求你必须预先知道所有的内存需求。
在产品中见到过的可恢复的new失败主要归结为这么一类情况：即分配的缓冲区大小是从外部输入中获取的。一旦发现数据无效或缓冲区大小无意义就中止操作，因为这种情况下程序通常可以继续做一些有意义的事情，例如减少包大小并重试传送，甚至也可以干脆放弃这一操作去继续干别的事情。毕竟，分配2G内存的失败并不代表真的“没内存用了”，可能还有1G内存呢。
还有一种特殊情况，在这种情况下new失败恢复也是有意义的：当你的程序乐观地试图分配一个巨大的工作缓冲区时，如果这时分配无法完成的话，你只需降低标准，即重试获取一个较小的缓冲区，直到得到一个合适大小的。这种做法的前提是假定程序整体上是能适应实际的缓冲区大小的，也能在有必要的时候进行大块内存的分配。

小结
避免使用nothrow new，因为它如今并不能提供任何显著的优点，而且其特性通常要比简单new（可能抛出异常）的还差。
记住，无论如何，检查new是否失败几乎是没什么意义的，原因有若干。
如果你理当关心内存耗尽的话，请确保你正在检查的是你所认为你正在检查的，因为：
1)在那些直到内存被用到时才去提交实际内存的系统上，检查new失败通常是没有意义的。
2)在拥有虚拟内存的系统上，new失败几乎不会发生，因为早在虚拟内存耗尽之前，系统通常就已经开始颠簸了，而此时系统管理员自然会杀掉一些进程。
3)除了一些特殊情况之外，通常即便你检测到了new失败，要是真的没内存剩下的话，那么你也就做不了什么了。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第24条 常量优化
1. 考虑如下代码：
//示例24-1
const Y& f(const X& x)
{
	//处理x并查找Y对象
	return someY;
}
将形参和（或）返回值声明为const能够帮助编译器生成更优化的代码或改善其代码生成吗。为什么能或不能，请解释。
简短地回答是“不”，它也许并不能。
编译器怎么能够做理更好，能避免掉参数复制或返回值复制吗。不能，因为参数本来就是按引用传递的，而且返回值也是按引用返回的。能将x或someY的复制放在只读内存中吗。不能，因为不管是x还是someY其实都存活在该函数的作用域之外：x是来自外界的，而someY则是传递给外界的。即便someY是f内部就地动态分配出来的，它及它的所有权也因为这次调用而转交给了调用方。
2. 大体上，解释一下const的存在与否为何能或不能帮助编译器改善它所生成的代码。
上面所提到的“形参的const性（constness）通常并不能帮助编译器完成某些优化工作”的论断在这里仍然有效：即便你调用的是一个const成员函数，编译器仍然无法假设目标对象x或someY的内存字节不会被改变（有mutable，还有const_cast）。此外还有其他问题（除非编译器进行全局优化）：编译器可能无法确切知道其他地方是否存在着一个非const引用也绑定到了x或someY所引用的对象，也不知道这些非const引用会不会在f的执行期间不小心被用到；编译器甚至不知道x和someY所引用的实际对象到底是不是被声明为const。
之所以出现上述那些问题，是因为x和someY被声明为const并不代表它们所引用的对象物理上也是const的。因为两者的类（X、Y）当中都可能具有mutable成员数据，另外，其成员函数也可能会使用跟mutable关键字在本质上一致的const_cast。实际上，f本身之内的代码就可能会对x或someY使用const_cast或C风格的cast，从而令它们的const限定符形同虚设。
不过有些情况下const倒的确能够起到一定作用，即在对象的定义点上使用const限定。这种情况下，编译器往往能够成功地将这些“真正的const”对象放入只读内存，尤其当它们为POD类型的对象时，因为这类对象的内存镜像往往可以直接在编译器创建，因为可以直接放到程序的可执行镜像中。这种对象一般被称为“可放入ROM的”（ROM-able）。

const什么时候真正能够起到促进优化的作用
考虑如下代码：
//示例24-3
void f(const Z z)
{
	//...
}
问题：
（a）什么样的场合，当Z为什么样的类型时，以上代码中的const限定才能真正帮助编译器生成不同的、更好地代码，请讨论。
如果编译器知道z确实为const对象，那么即便它不作全局分析也可以进行一些有用的优化。例如，倘若f的函数体中包含了像g(&z)这样的调用，编译器就可以确信z中的非mutable部分在g调用的过程中是不会被改变的。（倘若g试图通过const_cast改变z的非mutable成员，那么结果就是未定义的）（不是很懂，是指在g的调用中进行优化？？？）
否则，示例24-3 中的const对大多数z类来说都算不上是优化了，即便是优化也不是编译器代码生成方面的优化。
对于编译器代码生成来说，问题很大程序上归于编译器是否能够消除复制构造或将z放入只读内存区段。也就是说，如果我们知道z确实不会被f内部的代码改动的话就好办了，因为从理论上来说这就意味着我们或许能够直接使用调用方从外界传给该函数的对象，而不用对其进行复制（并使用这份副本）；或者我们也可以复制一份副本并将该副本放入只读内存（如果这恰巧能够提高速度或实际有此需求的话）。
一般来说，编译器是无法使用参数的常量性来消除复制构造或假定逐位（bitwise）常量性的。如前提到的，可能出差错的地方实在太多了。特别地，Z可能具有mutable成员，或者有些人在有些地方（例如，在f函数体中、在其他函数中、或者在Z的某些直接或间接被调用的成员函数中）可能会进行const_cast或做些其他手脚。
但有一种情况，在该情况下编译器或许能够生成更好的代码，前提是：
1)Z的复制构造函数以及所有被f体内直接或间接调用的成员函数的定义在f的定义外都是可见的；以及
2)上述的这些函数都简单，无副作用；以及
3)编译器在优化方面不那么保守。
这就意味着编译器能够通晓全盘，因为能够在“好像”（as if）规则的指导下消除复制构造动作（不改变语义），该规则即编译器可以不按标准所说的做，只要没改变符合标准的程序的行为即可。
（b）对于（a）当中提到的情况，我们讨论的是编译器优化还是其他类型的优化，请解释。
特别地，存在着一些实际的优化，例如Z的作者可以明智地选择特殊对待const对象（以获得优化的效果）。
（c）要想获得同样的效果还有什么更好的途径吗
你只需简单地通过引用来传递参数就可以获得完全相同的效果，甚至还有过之：
//示例24-5：很简单，只需要换成引用――比示例24-3中做法还好
void f(const Z& z)
{
	//...
}
而且这种做法的好处是，不管Z使用的是handle/body惯用法还是引用计数，都照样有效。
准则：避免按const值传递对象。尽量按const引用传递，除非它们是像int这样的复制开销很低的对象。

小结
本条款旨在说明const主要是写给人看的，而不是编译器或优化器。
说到编写安全的代码，const是个极好的工具，因为它能辅助编译器去对代码进行检查，从而令程序员编写的代码更为安全。即便是在优化方面，从它允许类的设计者更好地实现手工优化这个方面来说，它也是非常有用的；不过从帮助编译器生成更好的代码这个方面来说它就显得没那么重要了，因为编译器本来就是通晓一切的。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第25条 再论内联
1. 什么是内联
简单地说，“内联”意味着将一个函数调用“就地”展开（in-place）为被调用函数的函数体。如，考虑如下代码：
//示例25-1
double Square(double x){return x * x;}

int main()
{
	double d = Square(3.14159 * 2.71828);
}
对上面这段代码进行内联的结果（至少从概念上）像下面这样：
int main()
{
	const double __temp = 3.14159 * 2.71828;
	double d = temp * temp;
}
这里，内联消除了执行函数调用的开销，也就是将参数压栈并让CPU跳转至目标函数的入口点（这会导致引用局部性的丧失）所花费的开销。注意，这里的内联并不代表将Square当成宏，因为内联函数调用仍然是函数调用，其实参只被求值一次。而如果用宏来实现的话，实参就可能被多次求值，例如宏#define SquareMacro(x) ((x)*(x))，这样如果调用SquareMacro(3.14159*2.71828)的话，它实际会被扩展成(3.14159*2.71828)*(3.14159*2.71828)（这相当于进行了两次“pi跟e相乘”的操作，而不像函数调用那样只做一次）。
另外还有一个值得一提的特殊情况：递归调用。当进行递归调用时，一个函数会直接或间接地调用它自身。尽管这类调用通常是无法内联的，但某些情况下编译器仍然能够对某些递归进行内联，这很大程度上就跟它们对某些循环进行部分解循环差不多。
另外，示例25-1 其实展示了一种不用inline关键字的内联，给出这个例子是有意图的。

2. 编译器在什么（哪些）阶段实施内联，请选择：
（a）编码期
（b）编译期
（c）连接期
（d）应用程序安装时
（e）运行时
（f）其他时候
3. 附加题：什么样的函数是从来都不会被内联的。

答案A：编码期
在编码期，开发者可以在代码中放置inline关键字。严格意义上来说（如果内联是指以函数体代码替换消除函数调用的话）这其实算不上真正的内联，但由于在代码中放置inline关键字相当于选择内联发生的合适地点，因此将它看成是进行内联决策的最早时机。（有疑义的是，“在编码期”进行内联的另一种解释为开发者可以自由地通过手动复制源代码来实现就地展开。这跟通常的“内联”的意义相关甚远，因此不讨论。）
如果想在代码中添加inline关键字的话，记住三件重要的事情：
1)若非必要，别这么做。不成熟的优化没什么好处，在没有对实际情况进行分析之前尽量不要写inline。
2)inline的惟一作用是向编译器发出“邀请”。inline关键字的作用只过是编译器一个提示，作为一个语言中的关键字，它使程序员能够和编译器“对话”（这同时也带来了坏处，见下文）。不过它全部的好处也就这些了：inline关键字的有无并不会对一个C++程序的语义产生任何影响。同样，inline也不会影响标准语言的其他部分，因为将一个函数设为内联并不会改变你使用该函数的方式（例如，你仍然可以取得该函数的地址），而且符合标准的C++代码也无法以编程的方式来侦测出给定的函数是否为内联的。
3)inline关键字往往显得“粒度”不够。将一个函数设为内联函数，但实际上内联却是发生在函数被调用的点上。这是一个重要区别，它意味着同一个函数可以（而且通常应当）在一个地方被内联而在另一个地方却不被内联。使用inline是无法表达这一事实的，因为我们只可以用它来修饰函数本身，因而当我们将一个函数设为内联函数时，我们其实相当于在说“我们认为我们知道将该函数在它的任意调用点上内联是合适的”。这一预见性的描述很大程度上是不准确的。因此，尽管我们常常称“内联某某函数”，但要想说得更准确一点的话最好统一改成“内联某处函数调用”。
准则：避免写inline或试图进行其他优化，除非性能测试显示出有此必要。

答案B：编译期
在编译期，编译器会按照惯例进行示例25-1 中描述的内联。
当我们试图通过将特定函数声明为内联函数来“诱使”编译器去对其进行内联时，编译器实际会怎么做，答案是不一定的。并非所有的编译器都吃这一套，即便你“巧言令色”也不一定有用。你的编译器（或其他工具，下面我们会提到）可能并不会按你的指示行事，例如，你的编译器可能会：
1)拒绝在调用点上对你声明为内联的函数进行内联。
2)对你并没有声明为内联的函数进行内联。
3)对一个函数的某些调用点进行内联，其他调用点则不予内联（不管这个函数是否已经被声明为内联的）。
再次注意，示例25-1 中并没有使用inline关键字。之所以这么做是有目的的，因为想让你知道，即便不写inline关键字，内联也照样可能发生。实际上，即便你现在用的编译器对示例25-1 中的函数调用进行了内联的话，也不要惊讶。因为编译器这么做根本不会对一个符合标准的程序的语义或行为产生任何影响，编译器的这种做法属于从你的角度考虑可以（而且往往应当）进行的完全合法的优化。
在决定对哪些函数调用进行内联，包括是否对某个函数的某些调用点进行内联而在其他调用点不予内联时，现代编译器往往比程序员的表现要好。最简单的原因是编译器通晓更多的上下文知识，因为它知道调用点的“真实”构造，即在其他优化（诸如解循环以及消除死分支）完成之后为调用点实际生成的机器代码。例如，编译器或许能够检测出在某个特定的内部循环中内联某个函数调用会导致循环体膨胀至无法放入调整缓存（cache），进而导致执行效率降低，于是编译器可能会决定对这一特殊情况放弃内联，同时仍然对该函数的其他调用点进行内联。

答案C：连接期
问题：函数可能在连接期被内联吗，答案是肯定的。这个问题触及到了本条款开头的那个“附加题”的核心：什么样的函数是从来都不会被内联的。之所以提出这个问题是因为人们普遍相信有些函数是不能被内联的。特别地，若一个函数的定义体没被放在头文件中而是被放在了其他独立模块当中的话，这类函数通常被认为是不可内联的。
考虑示例25-1 的一个细微的变形：
//示例25-2：故意给编译器找茬：将函数放在另一模块中，并让编译器无法看到该函数的定义体。
//--file main.cpp--
double Square(double x);

int main()
{
	double d = Square(3.14159 * 2.71828);
}

//--file square.obj(or.o)--
//包含了以下函数的编译后的目标代码
double Square(double x) {return x * x;}
我们将Square的实现移出了main.cpp编译单元。实际上我们所做的并不止这些：Square的源代码甚至也是不可用的，惟一可用的就是它的目标二进制代码。于是有人说“这种情况下对Square的调用当然肯定是无法内联的！”的确，对“编译器”来说他们的这些话是正确的。在编译main.cpp时，即便一个异常聪明的编译器可能也无法窥视到Square的定义。
然而，一个聪明的连接器却可以，而且实际上一些流行的商业连接器的确是这么做的。这种晚期内联的一个实际优势在于优化工具能够知道每个调用点上下文的更多信息，因而对于何时何地值得对某处调用进行内联能够给出更为明智的答案。
但是还没完：有没有注意到在示例25-2 的描述中没有任何地方提到Square必须是由C++写的。这其实体现了编译后内联的第二个优势：它是语言中立的。Square可以是Fortran写的，也可以是Pascal写的，都没问题。连接串成惟一需要注意的地方就是传参惯例，并记得将参数压栈代码、参数弹出代码以及跳转指令一起去掉。

答案D：应用程序安装时
答案E：运行时
“性能导向的优化”和“试探式内联”
答案F：其他时候
准则：记住，内联可能发生在任何时候。

小结
正如所有的优化一样，内联优化由那些通晓生成代码和执行环境的工具来执行往往能够取得比由程序员来“执行”更好的效果。越是晚进行内联，内联的目的性就越明确，越具有针对性。
本条款讨论了内联函数，不过更精确一点说应当是对函数调用进行内联。毕竟，同一个函数可能在它的某些被调用点上被内联了而在其他调用点上则没被内联。而且由于即使是在初期编译完成之后仍然还存在着许多内联的好机会，因此同一个函数不但可在不同地点被内联，而且可在同一地点由不同工具来内联。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第26条 数据格式和效率之一：什么时候压缩是真正重要的
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第27条 数据格式和效率之二：（甚至更少的）位操纵
1. 为了实现第26条中2(e)的解决方案，假设决定创建如下的类来管理缓冲区。可移植地实现它，以便让它能够在所有符合C++标准的编译器（不管是什么平台）上正确工作。
class BitBuffer
{
public:
	//...根据需要增加其他函数
	
	//添加p所指的位缓冲区头部的num个位。
	void Append(unsigned char* p, size_t num);
	
	//查询正被使用的位数目，初始为0。
	size_t Size() const;
	
	//从第start位开始获取num个位，并将结果存入dst所指的缓冲区中（从缓冲区的第一位开始存放）
	void Get(size_t start, size_t num, unsigned char* dst) const;
	
private:
	//...这里增加一些细节实现
};

我们所要求的接口总的来说像这样：
class BitBuffer
{
public:
	void Append(unsigned char* p, size_t num);
	size_t Size() const;
	void Get(size_t start, size_t num, unsigned char* dst) const;
};
BitBuffer的接口是以unsigned char来表示位缓冲区指针的。首先，标准C++中并没有“位指针”这样的概念，因此这种做法也就不可能了。其次，C++标准保证了对无符号类型（包括unsigned char、unsigned short、unsigned int以及unsigned long）的操作不会遭到编译器的“非议”（如“你没有初始化这个字节”或者“那不是一个有效的值”）。
无符号整型是用于将内存当成位数组来看待的理想选择。
所以编译器被要求将unsigned char（以及其他无符号整型）当成原始的存储位来看待，而且这正是我们所需要的。除此之外还有其他途径，不过这一选择恰恰适合于用来实践我们的“位操纵”编码技术，后者恰巧是本条款的主要目的之一。

#include <iostream>
using namespace std;

int main()
{
	cout << numeric_limits<unsigned char>::digits << endl;//8
	cout << numeric_limits<unsigned int>::digits << endl;//32
}

方案1：使用unsigned char缓冲区
方案2：复用标准的位容器
准则：仅当你明确知道：（a）应当进行优化；（b）应当怎样优化时，才着手进行优化。另外，领域相关的专业知道是无可替代的。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第28条 不是关键字的关键字（或者：另一种注释）
关键字
C++标准保留了63个名字作为关键字，见表28-1 。除此之外还有11种操作符可以用单词形式来表达。如，在一个条件表达式中，可以用“and”代替“&&”。标准同样也保留了这些名字，见表28-2 。
一些关键字在语义上完全等同于空白或者是装饰性的注释。auto、register；另外，在很多方面而言inline（见第25条）也算是一个这样的例子。（export见第9、10条款）
2. 在一段C++代码中加入关键字“auto”会产生什么样的影响。
完全没有影响。auto是一个完全多余的存储类别指示符。它仅能出现在代码块中对象的声明语句里，表示这些对象将会在函数或者代码块结束的时候自动销毁；然而，在所有auto能够出现的地方，就算auto没有出现，“局部变量‘自动’销毁”这一规则也仍是有效的。简单地说，auto可有可无。
C++在处理二义性的规则是：如果一个东西可以被解释为一个声明，那么它就是一个声明；而auto的加入也并没有改变这一点。如：
//示例28-2：auto的加入并没有消除二义性。
int i;
int j;
int main()
{
	int(i);//声明了一个i，而不是对::i的引用。
	auto int(j);//仍然是声明，并非是对::j的引用。
	int f();//一个函数声明，并非一个默认构造的int变量。
	auto int f();//仍然是一个函数声明，只不过这种写法在一些严格的编译器上可能无法通过编译。
}
归根结底，auto在这种二义性情况下并不能用来消除二义性。
准则：绝不要用auto。它跟空白没什么区别。
题外话：将来auto可能会变得有意义。随着C++委员会在下一代C++标准（也就是俗称的C++0x ）方面的工作的进展，auto可能的另一种复用，即用作“自动”类型推导，那时可以极大程序上简化某些变量声明，如：
vector<SomeNamespace::SomeType>::const_iterator i = v.begin();
替换为：
auto i = v.begin;//现在虽然是非法的，但有可能在以后的C++扩展中就是合法的了（还是没办法区分是不是const的iterator？？？）

register
在一段C++代码中加入关键字“register”会对其语义产生什么样的影响。
简单回答就是：在大部分现代的编译器上，根本没影响。
register指示符与auto指示符拥有相同的语义……
依照已经讨论过的，这就应该意味着“没有语义”。
标准接着说：
……对实现是一个提示，提示被修饰的对象将会被非常频繁地使用。【注释：特定的实现可能会选择忽略该提示，而倘若你对该对象进行了取地址操作，则大多数实现都会忽略该提示。――注释结束】
register关键字背后的想法是如果某些变量会被非常频繁地使用，那么尽可能将它们放到物理CPU寄存器上（进行使用）将会是非常有价值的做法，因为平常CPU得从相对（寄存器来说）较慢的高速缓存、甚至更慢的主存中读取数据，而一旦将数据存放在寄存器中的话，CPU就可以以高得多的速度完成操作。
代码生成器在看到代码并决定哪些部分能够放到寄存器中而获益时，原始代码已经经过了重重转换了（例如内联、解循环、消除死分支、变量折叠等），而程序员根本就不知道这期间究竟发生了哪些转换。你其实不仅做不到和你的编译器一样好，而且根本就不应该考虑自己亲手来做这个事情，显然这种事情应该交给自动化工具来做。
准则：不要用register（除非你明确地知道你的编译器会特殊对待带有register的代码）。对大数编译器而言它跟空白也没什么区别。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第29条 这是初始化吗
deque<string> coll3(istream_iterator<string>(cin), istream_iterator<string>());
以上代码存在一个潜在问题和一个实际问题。潜在问题是cin将会被耗尽，因此后面代码不能再从其中读入输入，这很可能会是逻辑问题。
更大的问题是这段代码实际上根本不做任何事情，因为这里实际上并没有声明一个名为coll3的deque<string>对象，而是声明了：
一个名为coll3的函数，会按值返回一个deque<string>，该函数有两个参数：一个是类型为istream_iterator<string>名为cin的形参；另一个（无名）参数则是一个不接受任何参数，并返回一个istream_iterator<string>的函数。
本质上，我们碰上了C++为了保持与C的兼容性而从C那里继承来的规则：如果一段代码能够被解释成声明，那就是声明。
《Exceptional C++》条款42，讨论了同样的示例。
//示例29-2(d)：等同于29-2(c)，只不过删除了多余的括号，并添加了一个typedef
typedef istream_iterator<string> (Func)();
deque<string> coll3(istream_iterator<string> cin, Func);
看上去更像一个函数声明，再前进一步：去掉前面的形参名cin（反正没什么用），同时将coll3改成一个习惯的函数名字：
//示例29-2(e)：仍然等同于29-2(c)，只是名字上做了少许的改动
typedef istream_iterator<string> (Func)();
deque<string> f(istream_iterator<string>, Func);
现在代码清晰了许多：上面这段代码看上去非常像是一个函数声明了，因此按照C和C++的语法规则，它实际上就是一个声明。之所以这个形式看起来很让人迷惑，是因为它也很像构造函数调用的语法；而那个形参的名字则让这种情况越发混乱：即cin看起来非常像是这个作用域的一个变量名，而且这个名字甚至还是标准预先定义好的！（程序员的配音就是使用标准库定义好的cin。）但是，最误导人的就是它们居然相安无事，因为形参名cin跟std::cin除了名字凑巧一样之外没有任何共同点。

正确的做法
我们所要做的就是避免让编译器将其识别为一个函数声明。两个简单的方法可以做到这一点：
//示例29-3(a)：通过添加括号来消除二义性（可行，得分：7/10）
deque<string> coll3((istream_iterator<string>(cin)), istream_iterator<string>());
这是因为虽然istream_iterator<string>(cin)可以被看成变量声明（也可以是参数声明），但(istream_iterator<string>(cin))却不行，它只能被解释为表达式，因此，示例29-3(a)中的代码不可能是函数声明，这跟void f((int i))不可能是函数声明是一回事，那对冗余的括号使得这种形式的代码不可能被解释成合法的声明语句。
准则：避开语言中那些冷僻特性，包括那些对程序员（甚至是编译器）来说模棱两可的语法结构。
如果能从一开始就避开这种二义性，最好不过。推荐使用下面的替代方案，因为它显然更容易把事情做对，而且就算是最差劲的编译器也能很好地理解这些代码的意义，此外它也更利于我们阅读代码：
//示例29-3(b)：使用具名变量（推荐做法，分数：10/10）
istream_iterator<string> first(cin), last;
deque<string> coll3(first, last);
准则：优先使用具名变量作为构造函数的参数。这样可以避免与声明语句产生二义性。况且这样做也能令你的代码更清晰，更易于维护。

小结
保持代码清晰而明确，明确地表达你的意图：在给构造函数提供参数的时候，尽可能提供具名变量作为参数，以避开语言中那些很微妙诡异的规则，同时又可以让你的代码更加干净和易于维护。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第30条 要么double要么彻底完蛋
1. float和double有什么区别
C++标准如题说：
总共有3种浮点类型：float、double以及long double。double的精度要比float的高；long double的精度要比double高。float的值域是double值域的子集；double的值域又是long double值域的子集。
2. 假设对于现代计算机而言，下面这段代码运行需要一秒，这是比较正常的：
int main()
{
	double x = 1e8;
	while(x > 0)
	{
		--x;
	}
}
如果将double换成float，你觉得需要的运行时间是多少，为什么
答案是可能是1秒（在特定的语言实现上，float比double可能更快、一样快或更慢），也可能永远，具体取决于float能否精确地表示从0到1e8闭区间内的所有整数。
上述摘自C++标准的文字说明了可能存在某些可以用double表示而不能用float表示的值。特别是在一些流行的平台和编译器上，double可以精确地表示从0到1e8闭区间内的所有整数，而float不行。
如果float不能表示从0到1e8闭区间内的所有整数，那么，float改用的版本将从开始一直递减，最终会达到一个不能表示的值N，其中N-1 == N（由于浮点精度不够）……，于是这个循环就会永远停留在该值直到运行这个程序的机器断电或者操作系统崩溃。

关于窄化转换
标准：
一种浮点类型的右值 可以转换成另一种浮点类型的右值。如果目标类型能够精确地表示源值，那么转换的结果就是那个精确表示。如果源值处于目标类型所能精确表示的两个相邻值之间，那么转换的结果具体选择哪个值，由语言实现定义（implementation-defined）。此外的行为则是未定义的。
double类型的常量可以被隐式地（也就是无提示地）转换成一个float类型的常量，即便该转换会引发精度的损失（数据、信息、知识、状态、意义等）。之所以允许这种转换是考虑到与C的兼容性和可用性，但在进行浮点操作时，就紧记这些相关问题。
准则：记住，浮点运行是神秘且深奥难懂的。在使用浮点数时请提高警惕，避免依赖于浮点转换操作。人们对算术的所有认识在面对浮点运算时几乎都或多或少存在错误。
质量不错的编译器在你试图进行一些未定义操作时会提出警告，例如，将一个比float所能表示的最大值还大或者比最小值还小的double值转换成float；而优秀的编译器则会在你试图进行一些有定义但会损失信息精度的操作时提出警告，例如，试图将一个处于float所能表示的数据值范围之间，却又不能被float精确表示的double值转换成float。
对那些可能具有奇怪行为的浮点数操作要保持警惕，尽最大努力避免依赖于浮点的转换操作，打开编译器的所有诊断开关，这多多少少会让你在漆黑的浮点算术世界里行进得更安全一些。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第31条 狂乱的代码
宏是不负责任的
宏是一种在预处理阶段发挥作用的文本替换设施，而在预处理阶段所有的C++语法语义规则还没有起作用，下面是宏的一些不良行为：
（1）宏会改变名字。这一行为通常是有害的。
保守一点说，这种不加提示就改变名字的行为会让调试过程显得令人迷惑不解。例如你可能认为你调用了某个函数，而实际上由于宏将名字篡改了，结果你所认为的那个函数并未被调用。
C++在处理名字方面有自己的一套特性。宏则提供了一条不同的途径来做类似的事情，这就导致了两者之间至少存在着有害的交互作用。
你也许认为仅仅改变一个函数的名字并不会带来大问题。大部分情况下的确不会带来什么问题。可是如果函数的名字被改成了另一个现在有函数的名字，C++在碰到两个具有相同名字的函数时，就是重载。而倘若你不能意识到这种重载是不加提示地进行，事情就不太妙了。
在这个问题上，这样一个Sleep重命名宏可以在一定程序上解释为什么在不同的环境中最终调用的函数不同；具体哪个函数被调用取决于不同的调用处由特定的类型所触发的重载决议。有时候调用的是我们的函数，有时则是库。结果是不确定的。
（2）宏不管类型
Sleep重命名宏的意图是改变一个全局非成员函数的函数名。不幸的是，这个宏改变所有它所遇到 的Sleep名字。如果有一个名为Sleep的全局变量，那么就连它的名字也会被不加提示地改变。
（3）宏不管作用域
准则：避免使用宏。永远不要写一个名字为常见词或缩写的宏，连想都别这么想。
准则：尽量使用名字空间来封装名字。
请采用良好的封装形式。这不仅仅是因为封装能够产生更好的设计，更是因为它能够帮助你抵御未曾料到的危险性。宏是封装的天敌，因为就算是宏的定义者也无法控制宏的实际作用范围。C++中的有力工具之一就是名字空间和类，它们可以帮助管理程序中的那些应当相互无关的部分，并将它们之间的相互依赖性降到最低，适当地使用它们以及其他的一些C++设施来改善封装，不仅可以产生出更好地设计，也提供了保护伞。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第32条 小小的拼写错误？鬼画符似的语言以及其他奇怪奇形怪状的东西
“??/”会被转换为“\”
而后者放在一行的末尾作用相当于将接下来的一行“粘贴”到这一行的末尾。

三字符组（trigraph）是指三个字符组成的转义符，比如 ??/ = \，??! = ~。类似地，还有双字符组，如:> = ]。参见第33条。

#include <iostream>
using namespace std;

int main()
{
	//??/
	cout << numeric_limits<unsigned char>::digits << endl;
	cout << numeric_limits<unsigned int>::digits << endl;
}
输出还是8和32

2. 在编译下面这段代码时，一个符合标准的C++编译器会报告多少个不同的错误
//示例32-2
struct X
{
	static bool f(int* p)
	{
		return p && 0[p] and not p[1:>>p[2];
	};
};
简单地答案就是：零。这段代码完全合法并且符合标准。
逐一来考虑那些可能会有问题的表达式，看看为什么说它们实际上都是合法的：
1)0[p]其实和p[0]一样，都是合法的表达式。在C（和C++）中，形如x[y]的表达式，只要x和y的其中一个是指针而另一个是整型值，它的意义就相当于*(x+y)。这里0[p]和p[0]意思相同，因为它们分别等同于*(0+p)和*(p+0)。
2)and和not都是有效和关键字，它们分别是&&和!的替代形式。
3)“:>”也是合法的。它是“]”的双字符写法。于是表达式的最后一部分就被解释成了“p[1] > p[2]”。
#include <iostream>
using namespace std;

int main()
{
	int intArr[5] = {0};
	cout << intArr[0:> << endl;
}
（VS2010编译不通过？？？
d:\program files\vc projects\learningtest\learningtest\main.cpp(7): error C2143: 语法错误 : 缺少“]”(在“:”的前面)）
4)成员函数声明结尾的多余分号是完全无害的。C++类定义语法允许空的成员声明（一个单独的分号）出现在任何地方。例如下面就是一个完全合法的不含任何成员的类完全合法声明：
class X{;;;;;;;;;;;;;;;;;;};
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第33条 操作符，无处不在的操作符
背景知识：什么是贪婪匹配，它在C++编译器中起什么作用。
“贪婪匹配（max munch）”原则是说，编译器在将源代码中的字符解析成一个个的（token）时，会使用一种贪婪匹配算法，也就是说会尽可能让一个标记包含更多的字符。因此“>>”会被解析成一个标记，从而其意义也就成了流提取操作符，而不会被解析成两个“>”，即便是对于下面这段代码也是如此：
template<class T = X<Y>>//最后的“>>”被解析为单个token，编译错误！
这也正是为什么在写上面的代码时必须如下增加一个空格的原因：
template<class T = X<Y> >
类似的，“>>>”会被解释成一个“>>”后跟一个“>”，而不是一个“>”后跟一个“>>”。
1. 在一个合法的C++程序中，如果中间不用空格隔开，最多可以将多少个加号（+）放到一起。
我们可以建立一个源文件，其中包含任意长度的“+”序列，直到达到编译器所能处理的极限为止（例如达到了编译器所能处理的源文件的最大行长度）。
如果序列中包含偶数个“+”号，那它就会被解释成“++ ++ ++ ++…++”，即由多个“++”组成的序列。要让这个序列正确工作并具有合法的语义，只需定义一个可级联的、具有用户自定义前缀++操作符的类即可，例如：
//示例33-1(a)
class A
{
public:
	A& operator++() {return *this;}
};
现在就可以这样写（如果真的想这么做）：
A a;
++++++a;//含义为：++ ++ ++ a;
它的意思是：
a.operator++().operator++().operator++();
那么，如果序列中包含奇数个“+”号，序列将会被解释成“++ ++ ++...++ +”，即一系列“++”后跟着一个“+”作为结尾。要使其能正确工作，只需为我们的类添加一个operator+()重载。如：
//示例33-1(b)
class A
{
public:
	A& operator+() {return *this;}
	A& operator++() {return *this;}
};
现在就可以写如下形式的代码了：
A a;
+++++++a;//含义为：++ ++ ++ + a;
它的意思是
a.operator+().operator++().operator++().operator++();
这个技巧非常简单，对于其他操作符来说要创建超长的序列似乎有点挑战性，不过仍然是可能的。
2. 类似的，如果不用空格隔开，且注释中的不算，那么一个合法的C++程序中最多能包含多少个连续的以下字符
（a）&
（b）<
（c）|
创建一个如下所示的辅助类：
//示例33-2
class A
{
public:
	void operator&&(int) {}
	void operator<<(int) {}
	void operator||(int) {}
};
typedef void (A::*F)(int);
（a）&
答案：5个。
显然“&&”是合法的，“&&&”合法也可以（第三个&看成取地址符）。需要让“&&&&”合法，关键是要看到可以将第二个“&&”看作是操作符调用，而让前面的“&&”成为操作符调用之外的什么东西的“结尾”。考虑到这一点，第一个&&可以作为一个名字的结尾，明确地说就是一个函数名的结尾。因此，我们所需要的就是这样一个&&操作符：它能够接受一个指向其他&&操作符的指针作为其第一个参数：
void operator&&(F, A) {}//这是一个全局的operator&&重载，与&A::operator&&不同
这么一来可以写：
&A::operator&&&&a;//&& &&
它的意思是：
operator&&(&A::operator&&, a);
这是所能写出的偶数个&最长序列了，因为“&&&&&&”肯定不合法。因为它将被解释为“&& && &&”，就算可以再次将第一个&&作为某个函数名的一部分，也无法将最后的那个&&作为某个名字的开始，因为最终必须会导致两个二元&&操作符连在一起，这是非法的。
还可以再多加一个&符号，“&&&&&”意思是“&& && &”：
&A::operator&&&&&a;//&& && &
使用了进行取址操作的内建&操作符，上面代码相当于：
operator&&(&::operator&&, &a);//此时全局operator&&重载为：void operator&&(F, A*) {}
来看（b）和（c）：
这两个答案都是：4个。
重复前面手法：
void operator<<(F, A) {}
void operator||(F, A) {}
这么一来可以写：
&A::operator<<<<a;//意为“<< <<”
&A::operator||||a;//意为“|| ||”
意思分别为：
operator<<(&A::operator<<, a);
operator||(&A::operator||, a);
这是最长序列了。这一次无法再加入一个额外的“<”或“|”来得到一个五字符地序列，因为并不存在一元的“<”或“|”操作符。

附加题
在一个合法的C++程序中，一行中最多可以有多少个连续的问号（?）
对于问题来说，正确的答案应当是3，例如：
1???-0:0;
这个问题是惟一一个不遵守“贪婪匹配”原则的。3个连续的问题并非被解析成“??”和“?”。因为“??-”凑巧是一个三字符组，而后者在源文件处理的早期就被替换掉了（在编译器进行优化之前，甚至是在处理预处理指令之前）。参见第32条。三字符组的出现是为了某些非常规的源代码字符提供替代写法（它们是：#、\、^、[、]、|、{、}和~）。如果你的键盘上很不巧没有这些字符键，三字符组就有用武之地了。
因此，对于本例来说，远在编译器进行任何标记化工作之前，三字符组“??-”就被替换成“~”，因此上面那些语句就变成了：
1?~0:0;
它被标记化为：
1 ? ~0 : 0;
其含义为：
1 ? (~0) : 0;

小结
三字符组是从C语言继承过来的一个特性，它们在现实当中很少被用到。写本书时，一些编译器默认都不打开三字符组支持，其中就有一个编译器的文档这样来描述这个选项：“支持不合需要的、极少使用的ANSI三字符组特性”。这一说法真是中肯之极！
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第34条 索引表
1. 谁会受益于清晰易懂的代码
简而言之，对所有人都有好处。
首先，清晰的代码更易于调试，也因为清晰，所以代码在第一时间的也就少很多，编写清晰的代码也至少可以让你的生活更轻松一些（相关案例，请参见第27条示例27-2 的讨论）。此外，当一个月或一年之后重读你的代码时（如果代码当初没问题并投入了实际使用，这一环节通常是免不了的），你就会发现更容易“重拾”那些清晰的代码，明白代码都干了些什么。
再看看有利于别人的方面：代码维护者也将获益于代码的清晰性和可读性。毕竟，要将代码维护好首先得“投入”（grok，意指深入而完整地理解，还包含有理解代码本身内存的工作方式、代码的副作用以及代码与其他子系统的交互方式的意思）代码。总而言之，在没有完全理解一段代码的情况下就贸然去修改它，太容易引入新的错误。清晰、可理解的代码更容易让人投入其中。
最重要一点是，由于以上这些原因，你的最终用户将利益于清晰、可理解的代码：这种代码从一开始错误就很少；更容易被正确地维护，而且在维护过程中也不至于引入同样多的错误。
准则：一般来说，优先考虑编写清晰、正确的代码。
2. 以下代码展示了在已有容器中创建索引表的一种有趣有用的惯用法。如需要更详细的解释，请参考其原文。
评价这段代码并找出：
（a）像无效语法或不可移植的风格习惯之类的“机械”错误。
（b）在风格上可以做哪些改进，使代码的清晰度、重用性和可维护性都得到改善。
//sort_idxtbl(...)的作用是排列一个索引数组
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

template<class RAIter>
struct sort_idxtbl_pair
{
	RAIter it;
	int i;
	bool operator<(const sort_idxtbl_pair& s)
	{
		return (*it) < (*(s.it));
	}
	void set(const RAIter& it_, int i_)
	{
		it = it_;
		i = i_;
	}
	sort_idxtbl_pair() {}
};

template<class RAIter>
void sort_idxtbl(RAIter first, RAIter last, int* pidxtbl)
{
	int iDst = last - first;
	typedef vector<sort_idxtbl_pair<RAIter> > V;
	V v(iDst);
	int i = 0;
	RAIter it = first;
	V::iterator vit = v.begin();
	for (i = 0; it < last; ++it, ++vit, ++i)
	{
		(*vit).set(it, i);//把待排序了数字和它的位置绑定在一起
	}
	sort(v.begin(), v.end());//这里排序将比较sort_idxtbl_pair<RAIter>对象，会调用这个对象的重载成员函数operator<，这是与非成员函数operator<（或函数对象）相对的方法
	int* pi = pidxtbl;
	vit = v.begin();
	for (; vit < v.end(); ++pi, ++vit)
	{
		*pi = (*vit).i;//排好序的数字对应的位置赋值给索引表pidxtbl
	}
}

int main()
{
	int ai[10] = {15, 12, 13, 14, 18, 11, 10, 17, 16, 19};
	cout << "###############" << endl;
	vector<int> vecai(ai, ai + 10);
	int aidxtbl[10];
	sort_idxtbl(vecai.begin(), vecai.end(), aidxtbl);
	for (int i = 0; i < 10; ++i)
	{
		cout << "i = " << i
			<< ", aidxtbl[i] = " << aidxtbl[i]
			<< ", ai[aidxtbl[i]] = " << ai[aidxtbl[i]]
			<< endl;
	}
	cout << "################" << endl;
}
输出如下：
###############
i = 0, aidxtbl[i] = 6, ai[aidxtbl[i]] = 10
i = 1, aidxtbl[i] = 5, ai[aidxtbl[i]] = 11
i = 2, aidxtbl[i] = 1, ai[aidxtbl[i]] = 12
i = 3, aidxtbl[i] = 2, ai[aidxtbl[i]] = 13
i = 4, aidxtbl[i] = 3, ai[aidxtbl[i]] = 14
i = 5, aidxtbl[i] = 0, ai[aidxtbl[i]] = 15
i = 6, aidxtbl[i] = 8, ai[aidxtbl[i]] = 16
i = 7, aidxtbl[i] = 7, ai[aidxtbl[i]] = 17
i = 8, aidxtbl[i] = 4, ai[aidxtbl[i]] = 18
i = 9, aidxtbl[i] = 9, ai[aidxtbl[i]] = 19
################

请允许我重复一遍：这些代码展示了一种有趣且有用的惯用法。我常常发现必须以不同的方式访问相同的容器，例如按照不同的排序准则来看待同一容器中的元素。所以说这样的方法的确是很用的：以一个主容器（譬如vector<Employee>）保存实际数据，以若干副容器保存指向主容器中元素的迭代器，这样一来我们就能支持各式各样的访问方式（例如，set<vector<Employee>::iterator, Funct>，其中Funct是用以间接比较Employee对象的仿函数，于是就可以产生不同于对象在vector中物理存储顺序的排序）。

更正“机械”错误
（a）像无效语法或不可移植的风格习惯之类的“机械”错误。
（1）正确拼写标准库头文件名。
（2）正确地定义main函数。main()这种无修饰的main函数原型从来都不是标准C++风格的，虽然它也可以作为一个合法的编译器扩展特性（前提是编译器得给出警告）。这种main函数原型在C99之前是有效的，因为当时的C里面允许所谓的“隐式int声明”，但这在C++（C++里从来就不允许隐式int）和C99中都是非标准的。在C++标准中，请参见：
--3.6.1/2 节：可移植代码必须将main定义为int main()或int main(int, char*[])两种形式中的一种。
--7/7 节脚注78和7.1.5/2 节脚注80：隐式int是被禁止的。
--附录C（兼容性），对7.1.5/4 注释：明确指出main()这种形式在C++中无效的，必须写作int main()。
准则：不要依赖隐式int，这不是符合标准的可移植的C++。特别地，“void main()”或“main()”从来就不是标准C++写法，虽然仍有很多编译器将它们作为扩展加以支持。
（3）永远记得#include所需要的类型定义的头文件。这个程序使用了cout和endl但却没有#include<iostream>。可以在原作者的系统上工作是因为C++标准头文件会互相#include，但不像C，C++并没有指定哪些标准头文件#include哪些其他标准头文件。
在这个案例中，程序中#include<vector>和<algorithm>，而在原来的那个系统上，也许恰好某个头文件间接的#include <iostream>了。这在原代码所使用的特定的库实现上或许是行得通的，甚至在我这恰巧也能正确工作，但它并不是可移植的，而且也不是一种好风格。
（4）遵循More Exceptional C++的39条中关于使用名字空间的原则。就cout和endl而言，程序必须以std::限定它们，或者写作：using std::cout;using std::endl;。不幸的是，忘记名字空间域限定符的情况仍然很普遍。
改进风格
（b）在风格上可以做哪些改进，使代码的清晰度、重用性和可维护性都得到改善。
除了“机械”错误之外，在代码案例中还有些地方，如果让作者来实现，会以不同的方式来完成。首先，要对那个辅助性结构sort_idxtbl_pair做两点评价：
（1）务必保证const正确性。此例中，sort_idxtbl_pair::operator<并不会修改*this，所以它应当被声明为const成员函数。（bool operator<(const sort_idxtbl_pair& s) const {/*...*/}）
准则：确保const正确性。
（2）消除冗余代码。该程序显式地写出了类sort_idxtbl_pair的默认构造函数，然而它却与隐式生成的版本没有丝毫区别，所以可以省去。此外，sort_idxble_pair的两个数据成员本就是公用的，那个set()成员函数虽说可以让设置这两个成员时的语法稍微好看一点，但由于它只在一处调用过，因此就为这好处并不值得引入这一额外的复杂性。（即删除这个成员函数，设置数据成员时直接设置）
准则：避免代码重复和冗余。

下面进入核心函数sort_idxtbl()：
（3）选择有意义且合适的名字。这个案例中，sort_idxtbl是个具有误导性的名字，因为这个函数并不是在对一个索引表进行排序，而是创建了一个索引表。另一方面，代码使用了模板参数名字RAIter来指出这是个随机访问的迭代器（Random Access Iterator），这一点可以得个不错的分数；因为这个随机访问特性正是该版本的代码所必需的（last - first ），所以将模板参数命名为RAIter可以作为一个很好的提示。
准则：选择清晰而有意义的名字。
（4）确保一致性。在sort_idxtbl()中，有时变量是在for循环初始化语句中被置初值的，而有时却不是这样。这就使得代码更难以阅读，这一点带来的好处因人而异。
（5）消除不必要的复杂性。这个函数里面有好几使用了不必要的局部变量。第一，变量iDst被初始化为last - first，但在后面只被使用了一次，可以在使用处直接写last - first来摆脱这种混乱的状况。第二，vector的迭代器vit被创建的地方其实完全可以使用下标索引来代替（没看懂？？？），效果一样，而且代码也会更清晰些。第三，局部变量it被初始化为函数参数first的值，而在此之后first本身就再没被使用过：作者个人更倾向于直接使用函数参数（即便改变参数的值也完全没有问题，因为是按值传递的，即不会影响调用函数的传值），而不是引用另一个名字（即把first都替换成it）。
（6）复用（第一部分）：更多地复用标准库。原先的程序因为复用std::sort而获得高分，这挺不错。但是为什么不采用std::copy而要手工实现最后的循环来完成复制工作。（尝试了一下，copy无法直接把迭代器的内容sort_idxtbl_pair<RAIter>里的i值直接赋值给pidxtbl，所以用transform可以实现，但要写个函数对象实现，如下//或为sort_idxtbl_pair<RAIter>提供一个operator int()的函数，就可以赋值给pidxtble，见小结中的Solution1
template<class RAIter>
class GetValue: public unary_function<sort_idxtbl_pair<RAIter>, int>
{
public:
	int operator()(const sort_idxtbl_pair<RAIter>& s) const
	{
		return s.i;
	}
};

template<class RAIter>
void sort_idxtbl(RAIter first, RAIter last, int* pidxtbl)
{
	int iDst = last - first;
	typedef vector<sort_idxtbl_pair<RAIter> > V;
	V v(iDst);
	int i = 0;
	RAIter it = first;
	V::iterator vit = v.begin();
	for (i = 0; it < last; ++it, ++vit, ++i)
	{
		(*vit).set(it, i);
	}
	sort(v.begin(), v.end());
	//int* pi = pidxtbl;
	//vit = v.begin();
	//for (; vit < v.end(); ++pi, ++vit)
	//{
	//	*pi = (*vit).i;
	//}
	transform(v.begin(), v.end(), pidxtbl, GetValue<RAIter>());
}
）
另外重新做了一个只比std::pair多一个比较函数的专用的sort_idxtbl_pair，没有什么大用。复用代码除了写起来更简单，还使代码更具可读性。谦虚一点，复用已有代码吧。
准则：了解并在任何适当的地方使用（复用）标准库设施，而不是自己去手动实现。
（7）复用（第二部分）：令实现本身更易于被复用（一石二鸟）。原先的代码中除了函数本身之外并没有任何东西是可以直接可复用的。辅助类sort_idxtbl_pair与它的用途捆绑得太紧，不是独立可利用的。
（8）复用（第三部分）：改进函数的原型。原先的函数原型如下：
template<class RAIter>
void sort_idxtbl(RAIter first, RAIter last, int* pidxtbl)
它用一个光秃秃的int*指针指向输出区，而作者通常会避免这样做，更倾向于使用托管的存储空间（比如vector）。不过有一点是明确的：最终用户要能够调用sort_idxtbl并将输出放到一个普通数组或一个vector或是其他什么东西里。很明显，“能够将结果输出到任何容器”的要求正是迭代器的用武之地。
template<class RAIn, class Out>
void sort_idxtbl(RAIn first, RAIn last, Out result)
准则：避免不必要的类型硬编码，从而扩展泛型组件的可复用性。
（9）复用（第四部分），或者叫“尽量使用!=来比较迭代器”：当进行迭代器的比较时，务必使用!=（!=对各种类型的迭代器都可用）而不是<（<只对随机访问迭代器有效），当然除非你真的一定要使用<而且刻意只支持随机访问迭代器。原程序中使用了<来比较迭代器，这对于随机访问迭代器没有问题，而程序的本意也就是创建索引表放入vector和数组中，而这两者都支持随机访问迭代。但是，我们没理由不想让这些功能可以作用在诸如list和set的其他不支持随机访问迭代的容器上。而原代码之所以不能适用于这些容器正是因为使用了<而不是!=来比较迭代器所致。
“在‘将来时态’下编程”。
准则：尽量使用!=而非<来比较迭代器。
（10）除非真的需要旧的值，否则尽量使用前置递增。这里，对于迭代器而言，应当习惯性地使用前置递增（++i），避免后置递增（i++）。诚然，对于原先的代码来说这两种做法或许不会带来本质上的差别，因为vector<T>::iterator很可能是复制开销很小的T*（尽管也许不一定是这样――这是由STL实现决定的），但如果我们要落实第（9）条建议，就不能将眼光局限在vector<T>::iterator上面，况且大多数其他的迭代器都是类类型的，或许其复制开销仍然不算很昂贵，可何必要无谓地引入这一潜在的效率损失呢
准则：尽量选择使用前置递增而非后置递增，除非确实需要使用旧的值。

小结
保持原代码的接口的基础上换一种设计。考虑下面三种改进版本。每一个都有其各自的优点、缺点以及风格偏好，在代码注释中有相应的解释。
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;

//解决方案1：进行了一些基本的清理工作，但仍保留了原先代码的大致结构。代码量缩减至17行，原先有23行。
namespace Solution1
{
	template<class Iter>
	class sort_idxtbl_pair
	{
	public:
		void set(const Iter& it, int i)
		{
			it_ = it;
			i_ = i;
		}
		bool operator<(const sort_idxtbl_pair& other) const
		{
			return *it_ < *other.it_;
		}
		operator int() const
		{
			return i_;
		}
	private:
		Iter it_;
		int i_;
	};

	//绝大多数改动都在该函数中，可以看到，该函数现在只有5行，原先有13行。
	//在每行代码之后，给出了原来的代码以供比较。
	//尽量编写清晰而简洁的代码，要不引入不必要的复杂性和模糊性。
	template<class IterIn, class IterOut>
	void sort_idxtbl(IterIn first, IterIn last, IterOut out)
	{
		std::vector<sort_idxtbl_pair<IterIn> > v(last - first);
		/*int iDst = last - first;
		typedef vector<sort_idxtbl_pair<RAIter> > V;
		V v(iDst);*/

		for (int i = 0; i < last - first; ++i)
		{
			v[i].set(first + i, i);
		}
		/*int i = 0;
		RAIter it = first;
		V::iterator vit = v.begin();
		for (i = 0; it < last; ++it, ++vit, ++i)
		{
			(*vit).set(it, i);
		}*/

		std::sort(v.begin(), v.end());
		
		std::copy(v.begin(), v.end(), out);
		//int* pi = pidxtbl;
		//vit = v.begin();
		//for (; vit < v.end(); ++pi, ++vit)
		//{
		//	*pi = (*vit).i;
		//}
	}
}

//解决方案2：使用std::pair而不是重新发明一个类似pair的辅助类。
//现在代码从原先的23行降到了12行。其中8行的意图是特定于本问题的，剩下4行是可复用于其他情况的。
namespace Solution2
{
	template<class T, class U>
	struct ComparePair1stDeref
	{
		bool operator()(const std::pair<T, U>& lhs, const std::pair<T, U>& rhs) const
		{
			return *lhs.first < *rhs.first;
		}
	};

	template<class IterIn, class IterOut>
	void sort_idxtbl(IterIn first, IterIn last, IterOut out)
	{
		std::vector<std::pair<IterIn, int> > s(last - first);
		for (int i = 0; i < s.size(); ++i)
		{
			s[i] = std::make_pair(first + i, i);
		}
		std::sort(s.begin(), s.end(), ComparePair1stDeref<IterIn, int>());
		for (int i = 0; i < s.size(); ++i, ++out)
		{
			*out = s[i].second;
		}
	}
}

//解决方案3：只是为了展示一些细节方面的替代做法，下面的代码中使用了一个multimap来消除单独的排序步骤，并使用std::transform()来代替手写循环。仍然有13行代码，不过更多代码成为了可复用的。该方案使用了更多空间开销，而且很可能时间开销也更大，因此作者更倾向于使用解决方案2。只不过这个方案展示了寻找问题的替代方案的过程。
namespace Solution3
{
	template<class T>
	struct CompareDeref
	{
		bool operator()(const T& lhs, const T& rhs) const
		{
			return *lhs < *rhs;
		}
	};

	template<class T, class U>
	struct Pair2nd
	{
		const U& operator()(const std::pair<T, U>& a) const
		{
			return a.second;
		}
	};

	template<class IterIn, class IterOut>
	void sort_idxtbl(IterIn first, IterIn last, IterOut out)
	{
		std::multimap<IterIn, int, CompareDeref<IterIn> > v;
		for (int i = 0; first != last; ++i, ++first)
		{
			v.insert(std::make_pair(first, i));
		}
		std::transform(v.begin(), v.end(), out, Pair2nd<IterIn const, int>());//这里的const加或者不加，或者放到IterIn之前，都可以正常编译
	}
}

//测试用例基本没有变动，只不过输出结果被导入到输出迭代器（原来是一个int*）所指的区间（这里是一个vector）中去，同时直接利用ai作为容器。
int main()
{
	int ai[10] = {15, 12, 13, 14, 18, 11, 10, 17, 16, 19};
	cout << "###############" << endl;
	vector<int> vecai(ai, ai + 10);
	vector<int> aidxtbl(10);
	
	//使用另一个名字空间的名字以测试不同的解决方案。
	Solution3::sort_idxtbl(vecai.begin(), vecai.end(), aidxtbl.begin());
	for (int i = 0; i < 10; ++i)
	{
		cout << "i = " << i
			<< ", aidxtbl[i] = " << aidxtbl[i]
		<< ", ai[aidxtbl[i]] = " << ai[aidxtbl[i]]
		<< endl;
	}
	cout << "################" << endl;
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第35条 泛型回调
1. 在设计和编写泛型设施的时候有哪些品质方面的要求，请解释。
泛型代码首先应当是可用的。意味着泛型代码的编写者应当作一些合理且各方面兼顾的考虑，以避免如下三件事情：
（1）避免不恰当的类型限制。例如，假设你编写的是个泛型容器，那么要求容器中的对象具有复制构造函数和不抛异常的析构函数是完全合理的。但默认构造函数和赋值操作符呢，许多有用的类型并没有默认构造函数，而人们又想将它们放入容器中，因此如果我们的容器加上这条限制，就等于将这类（没有默认构造函数的）类型排除掉了。这可不太“泛型”（参见Exceptional C++第11条）
（2）避免不合理的功能限制。好的泛型设计的一部分是选择便于设施被定制或扩展的方法和方式。这在泛型设计中重要的一点应当没什么可意外的，因为同样的原则对于面向对象的类设计来说同样有效。
基于策略的设计是几个重要的技术之一，用它可以设计出具有“可插拔”行为的泛型代码。
（3）避免不合理的单片式设计。
注意到一个词：不合理的。在足够泛型（避免类似“我确信没人会用除char之外的任何类型来实例化它”，就是说支持足够泛型的类型）与过度工程（避免“如果有人想要用这个烤箱LED显示器驱动程序去控制太空船的助推器闭火怎么办”这类妄想症）之间找到合适的点需要良好的判断力。

剖析泛型回调
2. 下面的代码展示了一个用于外覆回调函数的惯用手法，它不但有趣而且真正有用。
template<class T, void (T::*F)()>
class callback
{
public:
	callback(T& t): object(t) {}//将实际的对象赋给T
	void execute() {object.*F();}//调用回调函数
private:
	T& object;
};
风格改进
评价这段代码，指出：
（a）在风格方面可以作哪些改进来更好地贴合习惯的C++用法。
所能找出来的地方：
（1）构造函数应当为explicit。作者或许并不想提供从T到callback<T>的隐式转换。良好设计的类应当避免给它们的用户带来这类潜在问题的可能。因此我们真正想要的更像是这样：
explicit callback(T& t): object(t) {}//将实际的对象赋给T
一处风格问题，它本质上非关设计，而是关于描述：
准则：尽量使用explicit构造函数，除非真的想使该构造函数能够用于类型转换。
（2）（瑕疵）注释有问题。其中的“赋给”一词不恰当，某种程序上带有误导性。更恰当的说法是：在构造函数中，我们是将一个T对象“绑定到”引用t。因此更好的注释应当是“绑定实际的对象”。
explicit callback(T& t): object(t) {}//绑定实际的对象
不过连这句注释也是废话，代码中已经说得明明白白了，最好的做法是干脆把它删掉：
explicit callback(T& t): object(t) {}
（3）execute()成员函数应当为const的。毕竟execute()函数并没有对callback<T>对象的状态进行任何改变。这又是个基本问题：const正确性或许是老生常谈，但它的确是个好习惯。
void execute() const
{
	(object.*F)();//调用回调函数
}
准则：确保const正确性。
（4）（惯用法）execute()函数应该改写成operator()。在C++中，人们习惯于使用函数调用操作符（operator()）来执行一个函数调用式的操作。实际上execute()后面的注释本来就显得有点多余，也没必要，干脆去掉，因为现在代码已经符合人们的习惯，能够完全描述自己了。下面的代码说明了这一点：
void operator()() const
{
	(object.*F)();//调用回调函数
}
你可能会问：如果提供了函数调用操作符，这个类不就成了函数对象了吗。完全正确，既然callback<T>是函数对象，那么或许它也应该是可适配的。
准则：为惯用的函数对象提供operator()，而不是具名的execute()函数。
（5）缺陷：（惯用法）这个回调类应当继承自std::unary_function吗。Effective STL 条款40对可适配性进行了详细讨论，并说明了可适配性为什么是好事。但这里的回调类却不应该继承自std::unary_function，至少目前不能，两点有力的理由：
--首先，它并非一元函数。它不接受任何参数，而一元函数是指接受惟一一个参数的函数（void不算）。
--而且不管怎样从std::unary_function继承都算不上可扩展的做法。后面会看到，回调或许应当能够接受其他类型的函数，取决于其参数个数的不同，某些情况下或许回调根本就无法继承某个来自标准的基类。例如，倘若让回调类为支持三个参数的函数，那么就没有所谓的std::ternary可以作为基类了。
从std::unary_function或std::binary_function进行继承可以为回调类方便地添上一些重要的typedef，约束器以及其他类似的设施需要这些typedef才能工作，但也只有当需要将回调跟这类设施一些使用时，继承才有意义。不过由于这种回调类的物质以及它们被使用的方式，产生这一需要的可能性微乎其微（如果以后人们发现它的单参或双参版本应当可以跟约束器一起使用，那么只要让单参和双参版本分别继承自std::unary_function和std::binary_function即可）。
纠正“机械性”错误及限制
（b）是否有某些“机械性的”限制影响了该设施适用的广泛型性。
（1）考虑通过普通参数来传递回调函数，而不是通过模板参数。非类型的模板参数某种程序上是不常用的，因为它意味着在编译期就严格地将类型确定下来，这几乎肯定不会带来太多好处。换句话说，可以这么写：
template<class T>
class callback
{
public:
	typedef void (T::*Func)();
	callback(T& t, Func func): object(t), f(func) {}//绑定实际的对象
	void operator()() const {(object.*f)();}//调用回调函数
private:
	T& object;
	Func f;
};
现在，注册的回调函数可以在运行期更换了，而且为callback类模板添加一个成员函数以允许用户改变当前回调对象所绑定的成员函数也是极其简单的，而前一个版本的callback就做不到这一点。
准则：将非类型模板参数换成普通的函数参数通常是个好主意，除非它们确实应当是模板参数。（换句话说，除非它们确实必须在编译期就确定下来。）
（试验的编译没通过，该如何修改？？？
#include <iostream>
using namespace std;

template<class T, void (T::*F)()>
class callback
{
public:
	callback(T& t): object(t) {}
	void execute() {object.*F();}
private:
	T& object;
};

class Base
{
public:
	virtual void show()
	{
		cout << "Base::show" << endl;
	}
	virtual ~Base() {}
};

class Derived: public Base
{
public:
	virtual void  show()
	{
		cout << "Derived::show" << endl;
	}
};

int main()
{
	Derived d;
	Base &b = d;
	//b->show();
	callback<Derived, &Derived::show> c(d);
	c.execute();
}

回调函数改为参数构造
#include <iostream>
using namespace std;

template<class T>
class callback
{
public:
	typedef void (T::*Func)();
	callback(T& t, Func func): object(t), f(func) {}
	void operator()() const {(object.*f)();}
private:
	T& object;
	Func f;
};

class Base
{
public:
	virtual void show()
	{
		cout << "Base::show" << endl;
	}
	virtual ~Base() {}
};

class Derived: public Base
{
public:
	virtual void  show()
	{
		cout << "Derived::show" << endl;
	}
};

int main()
{
	Derived d;
	Base &b = d;
	callback<Base> c(b, &Base::show);
	c();//c.operator()();函数对象就可以像函数一样调用
}
输出如下：
Derived::show
）
（2）使其能被放进容器内。如果一个程序想要将某个回调函数对象保留到以后再调用，它很可能会保留多个这类对象。如果想要将这些对象都放进容器（如vector、list）中该，就目前的callback类来说这是不可能的，因为它目前不支持赋值，即不支持operator=。原因是它有一个引用型成员，一旦该引用在构造期被绑定到了某个对象，那么 以后就再也不可能将它重新绑定到其他对象。
指针却没有这一限制。本例中让callback具有一个指针成员是完全安全的，而且这样一来就可以利用编译器默认生成的复制构造函数和复制赋值操作符了：
template<class T>
class callback
{
public:
	typedef void (T::*Func)();
	callback(T&t, Func func): object(&t), f(func) {}//绑定实际的对象
	void operator()() const {(object->*f)();}//调用回调函数
private:
	T* object;
	Func f;
};
这样，可以创建出一个list<callback<Widget> >，让其中的每个callback<Widget>都指向不同的Widget成员函数。而倘若使用原来的callback，只能创建list<callback<Widget, &Widget::SomeFunc> >;其中每个callback调用的都是同一个成员函数。
准则：尽量让你的对象与容器相兼容。特别是，一个对象要想能够被放进标准容器中，就必须是可赋值的。
还可以创建一个包含各种不同类型的对象的成员回调函数的list，这样可以将它们全部记录在一个list中，并在需要时回调它们。这是可以实现的，只需添加一个基类即可。
（3）加入多态能力：为callback类模板提供一个基类。如果想要让读者能够创建list<callbackbase*>（或者list<shared_ptr<callbasebase> >），只需提供下面这个简单的基类：
class callbackbase
{
public:
	virtual void operator()() const {};
	virtual ~callbackbase() = 0 {}
};

template<class T>
class callback: public callbackbase
{
public:
	typedef void (T::*Func)();
	callback(T&t, Func func): object(&t), f(func) {}//绑定到实际对象
	void operator()() const {(object->*f)();}//调用回调函数
private:
	T* object;
	Func f;
};
随时都可以创建一个list<callbackbase*>并多态地调用其各元素的operator()。当然，一个list<shared_ptr<callbackbase> >更好一点。
注意，增加一个基类实质上是一种折中，只不过付出的代价很少：当用基类接口触发派生类中的回调函数时，增加了虚函数转发的开销。这一开销也只有当使用基类接口时才会产生。不需要使用基类接口的代码不用承受这一开销。
准则：考虑为类（模板）加上多态能力，这样类模板的不同实例就可以被替换使用了，不过前提是这一点对类模板来说的确有意义。如果是这样的话，做法是为类模板提供一个基类，这样类模板的任何实例就都会继承自该基类了。
（4）（惯用法，折中）可以为callback类模板增加一个辅助进行类型推导的make_callback()函数。因为用户在用了callback类一阵子之后，可能会发觉每次都在创建callback的临时对象都要给出模板参数比较麻烦，见下：
list<callback<Widget> > l;
l.push_back(callback<Widget>(w, &Widget::SomeFunc));
非得写两次Widget，编译器不知道吗。的确不知道，不过，在只需要像这样一个临时对象的场合，可以帮助编译器获这一信息。换种做法，可以提供一个辅助函数make_callback(...)，这样，用户只需要写：
list<callback<Widget> > l;
l.push_back(make_callback(w, &Widget::SomeFunc));
make_callback()与标准的std::make_pair的工作方式类似。它应当是一个函数模板，因为只有这样编译器才能够推导出参数类型，下面是其定义：
template<typename T>
callback<T> make_callback(T&t, void (T::*f)()) 
{
	return callback<T>(t, f);
}
（5）（折中）增加对其他签名类型的回调函数支持。这个最烫手的山芋留到最后来解决，因为除了void (T::*F)()之外还有很多种类型的函数
准则：不要限制模板，避免对特定的类型（或不那么一般性的类型）进行硬编码。
如果要求所有的回调函数都具有void (T::*)()类型就足够了，那写到这可以了。无缘无故地复杂化一个设计是毫无意义的，如果想要允许callback适应更多类型的回调函数，就得将现在的设计复杂化。
这里简要列出你需要支持的主要特性以及如何支持它们：
首先，是const成员函数。支持const成员函数的最简单办法是提供另一个使用const签名类型的回调类，并记得让它接受/保存目标对象的const引用或指针。
其次是非void类型的返回值。允许返回类型可变的最简单途径是添加另一个模板参数。
其三，支持有参的回调函数。再一次，可以通过添加模板参数来解决，不过别忘了给operator()添加相应函数参数，而且要更细心一点。
记住为每种可能的调用参数个数添加新的模板。

小结
将所有结合在一起，并进行一些纯粹语法上的调整（诸如一致使用typename以及命名习惯和空格习惯等），得到如下代码：
class CallbackBase
{
public:
	virtual void operator()() const { };
	virtual ~CallbackBase() = 0;
};

CallbackBase::~CallbackBase() { }

template<typename T>
class Callback: public CallbackBase
{
public:
	typedef void (T::*F)();
	
	Callback(T&t, F f): t_(&t), f_(f) { }
	void operator()() const {(t_->*f)();}
	
private:
	T* t_;
	F f_;
};

template<typename T>
Callback<T> make_callback(T& t, void (T::*f)())
{
	return Callback<T>(t, f);
}
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第36条 构造式union
1. 什么是union，它们存在的目的是什么
union允许多个对象（不管是类还是内建类型）占用内存中的同一块空间。例如：
//示例36-1
union U
{
	int i;
	float f;
};

U u;
u.i = 42;//没问题，现在u.i处于活跃状态
std::cout << u.i << std::endl;
u.f = 3.14f;//没问题，现在u.f处于活跃状态
std::cout << 2 * u.f << std::endl;
然而，同一时刻只能有其中一个类处于活跃状态，因为毕竟它们共享同一块内存，这块内存在某一特定时刻只能被其中一个对象占据。另外union也只支持某些特定的类型，这就带入了下一个问题：
2. 哪些类型的对象不可以作为union的成员，为什么存在这一限制。请解释。
C++标准：
具有非平凡（non-trivial）构造函数、非平凡复制构造函数、非平凡析构函数或非平凡复制赋值操作符的类的对象和数组不可以作为union的成员。
简单地说，一个类类型要想能被放入union，就必须满足如下要求：
--只可以有编译器生成的构造函数、析构函数以及复制赋值操作符。
--无虚函数或虚基类。
--其所有基类和非静态成员（或数组）都满足以上两点要求。
就这些，不过这些已经排除了相当一部分类型。
如果C++对union不加任何限制，一些糟糕的事情就会乘虚而入。如，考虑如下代码被语言允许会发生什么：
//示例36-2：并非符合标准的C++代码，不过暂且假设它能够通过，看看会发生什么
void f()
{
	union IllegalImmoralAndFattening
	{
		std::string s;
		std::auto_ptr<int> p;
	};
	
	IllegalImmoralAndFattening iiaf;
	iiaf.s = "Hello, world";//s的构造函数被调用了吗
	iiaf.p = new int(4);//p的构造函数被调用了吗
}//s会被析构吗，s应当在这里被析构吗，p被析构吗，p应当在这里被析构吗
正如注释中指出的，如果允许这样的代码就会带来严重的问题。当然我们可以对语言规则进行一些细致的调整，但那顶多只能修补其中的部分问题，况且考虑到避免使用语言进一步复杂化，所以干脆禁止这些有问题或可能滋生问题的操作。
但不要认为union只是早期残留下来的东西。由于union支持数据的重叠式存放，而这一能力在C++乃至现代编程领域仍然是有用的，故而union在节省空间方面或许可以说是最有用的特性。如，C++标准库的某些最高级的实现就利用了union来实现“小型串优化”，“小型串优化”是一项很好的优化方案，它复用了string对象本身内部的内存。下面介绍一下它的理念：对于大型串来说，string对象内部的空间存放的是指向动态分配的缓冲区的指针以及一些系统维护信息（如缓冲区大小）；然而，对于小型串，这些空间被用来直接存放串本身的内部，完全避免了动态内存分配。参见More Exceptional C++的第13条至第16条中更多关于小型串优化技术的讨论。

3. 编写一门脚本语言的动机案例：假设你想要语言支持一个单一的类型，其变量在不同时候可以分别持有整型、string或list。而创建一个union {int i; list<int> l; strings;};又根本行不通（原因见问题1和2）。下面代码给出了一个弥补方案，该方案试图支持将任何类型放进union中的能力。
从积极的角度来看，这篇文件解决了一个实际的问题，而且为了提供一个好的解决方案显然花了不少工夫。但虽然大家的初衷都是好的，但很多程序员最后都误入了歧途。
分配某个类型的缓冲区并使用强制转换来将另一个类型的对象放进来拿出去，这种做法是不符合标准且不可移植的，因为非动态分配的缓冲区（即不是由new或malloc()分配的缓冲区）除了保证能满足其本身类型的对齐要求之外，并不能保证对于其他类型也是正确对齐的。即便这种做法碰巧在某个人使用的编译器上对于某几个特定的类型能够工作，也不能保证对于其他类型（或者同一编译器的下一个版本中的同一类型）也能够工作。Exceptional C++的第30条对此进行了更为详细的讨论，特别是其中一段题为“不顾后果的修改和优化，以及为什么说它们是有害的”的讨论。
为了使该方案可靠的工作，需要采取如下的办法之一：
--借助于max_align手法。
--借助于非标准扩展（例如Gnu的__alignof__）来让该方案能够在支持这类扩展的编译器上可靠地工作。
可以通过（使用malloc()或new）动态分配数组（缓冲区）来绕过这个问题，因为malloc()和new保证它们分配的char缓冲区对于任何类型的对象都是恰当对齐的，只不过这个动态分配的想法仍然是个糟主意（它同样不是类型安全的），更何况原作者写作该类的动机之一就是效率，而采用动态分配的性能开销则抵消了这个好处。一个正确的替代方案是使用boost::any（见下文），boost::any也引入了类似的分配/间接层额外开销，但至少它是正确且安全的。

进入代码
来考虑代码：
#include <list>
#include <string>
#include <iostream>
using namespace std;
总是包含必要的头文件。因为下面的代码中用到了new，所以需要#include <new>（注意：#include <iostream>是必要的，因为在代码的后半部分有一个测试用例会用到输出流）。
#define max(a, b) (a) > (b) ? (a) : (b)
typedef list<int> LIST;
typedef string STRING;
struct MYUNION
{
	MYUNION(): currtype(NONE) {}
	~MYUNION() {cleanup();}
以下代码中的一个经典的机械错误是MYUNION的复制是不安全的，因为编写者忘记了提供合适的复制构造函数和复制赋值操作符。
MYUNION打算用构造函数和析构函数来做些事情，因此它显式提供了这两个函数。这本身并没有任何问题，但问题是仅仅这两个函数是不够的，因为MYUNION所玩的“游戏”的性质决定了复制构造函数和复制赋值操作符也得参与进来，而实际上原来的代码中这两个函数是没有被显式提供出来的。这很糟糕，因为编译器隐式生成的默认复制操作根本无法胜任：它们会按位复制其中的char数组缓冲区，这极有可能带来极不愉快的后果，大多数情况下会直接导致内存错误。下面的例子展示了其危害：
//示例36-3：MYUNION的复制行为是不安全的
{
	MYUNION u1, u2;
	u1.getstring() = "Hello, world";
	u2 = u1;//按位复制u1至u2
}//哎呀，串的内容被两次delete（假设按位复制是有意义的）（这里发生的按位复制会使两个MYUNION的string对象中的指针指向同一块内存，其中存放着“Hello, world”，即所谓的浅复制问题，当这两个string析构的时候就会导致这块内存被释放两次。）
准则：遵守“大三法则”：如果一个类需要自定义的复制构造函数、复制赋值操作符或析构函数中的任一个，那么它往往同时需要这三者。
从这个经典的错误往下，又遇到了一对经典的风格错误：
	enum uniontype {NONE, _INT, _LIST, _STRING};
	uniontype currtype;
	inline int& getint();
	inline LIST& getlist();
	inline STRING& getstring();
以上代码中存在两个风格上的错误。首先，该结构是不可复用的，因为它对特定的类型进行了硬编码。实际上，提出这个方案的作者建议每次需要的时候都通过手动编写这么一个结构。其次，虽说该结构也有着有限的、意料之中的用途，但它的可扩展性或可维护性可不大好。
准则：尽量避免硬编码，因为它往往会（不必要地）令代码变得更脆弱，同时还会限制其灵活性。
另外还有两个问题：首先是currtype没理由放在公用区段，这违背了良好的封装准则，意味着任何用户都可以自由地对它进行篡改，尽管某些改动可能未必是有心的。第二个问题则关系到枚举中使用的名字，后面会讨论。
protected:
这是一个错误：内部实现应当为私有而非受保护的。将它们放在受保护区段的惟一理由是让派生类可以访问到它们，但MYUNION最好还是不要有什么派生类，因为MYUNION进行派生是不是安全的，原因不仅是因为它在内部玩的“不足为外人道”的把戏，还有一个原因就是它缺少虚析构函数。
准则：总是将所有数据成员放在私有区段。惟一的例外是C风格结构，后者的目的并非封装，其所有数据成员都是公用的。
	union
	{
		int i;
		unsigned char buff[max(sizeof(LIST), sizeof(STRING))];
	}U;
	
	void cleanup();
};
主类的定义就是这些。接下来考虑三个平行的访问函数：
inline int& MYUNION::getint()
{
	if (current == _INT)
	{
		return U.i;
	}
	else
	{
		cleanup();
		currtype == _INT;
		return U.i;
	}
}
inline LIST& MYUNION::getlist()
{
	if (currtype == _LIST)
	{
		return *(reinterpret_cast<LIST*>(U.buff));
	}
	else
	{
		cleanup();
		LIST* ptype = new(U.buff) LIST();
		currtype = _LIST:
		return *ptype;
	}
}
inline STRING& MYUNION::getstring()
{
	if (currtype == STRING)
	{
		return *(reinterpret_cast<STRING*>(U.buff));
	}
	else
	{
		cleanup();
		STRING* ptype == new (U.buff) STRING();
		currtype = _STRING;
		return *ptype;
	}
}
准则：（只）写有用的注释。注释不应该表达代码已经表达过的意思，而应该解释代码，以及解释为什么要这样编写这段代码。
更为严肃的，下面还有三个主要问题。首先，函数的编写是不对称的：getlist()或getstring()的第一次使用会默认构造一个相应的对象并将其返回，而getint()的第一次使用却只得到一个未初始化的对象。如果这是故意而为之的，是为了符合int变量不初始化这一通常的语义，那么MYUNION的这一性质或行为就应当在文档中加以注明。但由于实际上这并非有意为之，因此int对象也应当被初始化。例如，如果调用方调用了getint()并试图将得到的值（未初始化）作一份复制，那么结果就是未定义的――并非所有的平台都支持复制任意（无效的）int值，有些平台会在运行期拒绝执行相应的指令。
第二个主要问题是用户无法保证const正确地使用这几个函数。如果确实打算这么编写这几个函数，那么至少为它们中的每一个都提供一个const的重载；这些const版本与它们的非const版本返回同样的东西，只不过加上了const修饰。
准则：确保const正确性。
第三个主要问题就是这种做法是脆弱的，在变化面前显得弱不禁风。它依赖于类型switch，因为在添加或删除它所支持的类型时就得保持所有成员函数的同步改变，这相当麻烦，而且很容易出错。
读到这儿，请考虑一个问题：如果想要为MYUNION添加对某个新类的支持，该对已经发布的代码作哪些改变，请尽量全部罗列出来。
--添加一个新的枚举值；
--添加一个新的成员函数用于访问该类型的对象。
--更新cleanup()函数，让它能够安全地销毁这个新类型的对象；
--将这个新类型纳入max()计算，以确保buff的大小足以容纳这个新类型的对象。
要是忘记了上面的任何一点乃至几点，唔……这正好说明了该方案的维护和扩展有多困难。
最后一个函数：
void MYUNION::cleanup()
{
	switch (currtype)
	{
		case _LIST:
		{
			LIST& ptype = getlist();
			ptype.~LIST();
			break;
		}
		case _STRING:
		{
			STRING& ptype = getstring();
			ptype.~STRING();
			break;
		}
		default:
		{
			break;
		}
		currype = NONE;
	}
}
这段代码一个更大的问题：switch语句中简单地使用了default:break，较好的做法是列出所有的类型（包括int），如果类型未知就引发一个逻辑错误――可以采用断言，也可以抛出一个std::logic_error(...)。
再次申明，类型switch纯粹是有害的。
准则：避免使用类型switch，尽量寻求类型安全性。

危险的名字
最后一个机械性问题没有提到，该问题第一次出现是在下面这行代码中：
enum uniontype {NONE, _INT, _LIST, _STRING};
永远不要创建以下划线开头或其中包含有双下划线的名字（更细一点，规则就是：任何其内部包含了双下划线的名字，如like__this，或者以下划线后跟大写字母开头的名字，如_LikeThis，都是保留的，可以记住这条规则，不过更容易的做法是一概不用前导下划线和含有双下划线的名字），它们是专门为编译器和标准库厂商保留的，之所以是“
专门”是为了让编译器和标准库能够有专属于它们自己的名字，这样它们在使用这类名字时就不会影响到代码。
不要使用像_Names， like__this这样的名字。
准则：永远不要使用保留名字，即以前导下划线开头或含有双下划线的名字。它们是语言为编译器和标准库实现保留的。

寻找一个更好的做法：boost::any
4. 请想出一个更好的办法来实现泛化的variant类型，并对在实现过程中作出的任何折中进行评论和解释。
欲实现这样一个variant类型，一个不错的候选是Boost库中的boost::any，以及与它相关的众多any_cast。一个完全泛化的any的完整实现所需的代码量与上面展示的MYUNION类的代码量差不多，MYUNION的硬编码性质决定了它只能支持一组特定的类型（本例中是int、list<int>和string），而any则是完全泛化的、可扩展的，而且还是类型安全的。
然而，boost::any还是进行了一次折中，即动态分配。boost::any并没有试图通过避免动态内存分配来获得潜在的效率提升，而后者正是原文提到的方案动机之一。
如果开始的解决方案使用单个动态分配的缓冲区来实现，boost::any的额外开销仍然还是比它大，这是因为boost::any每当包含的类型改变时都会重新申请内存，而MYUNION（如果使用动态分配的话）则不然，它在整个生命期内只进行一次动态分配，以后只不过是重复使用分配得来的内存而已。
原文的测试用例如果改用boost::any，则看起来会是下面这样（原来使用MYUNION的代码则被放在后面注释中以供对照）。
any u;//原先是：MYUNION u;
不用手写结构，而是只需直接使用boost::any即可。boost::any只是一个普通类，并非类模板。
//把u当成整型来访问
u = 12345;//原先是：u.getint() = 12345;
赋值操作则显示出了boost::any较之MYUNION更为自然的语法。
cout << "int=" << any_cast<int>(u) << endl;//或者只写int(u)，原先是cout << "int=" << u.getint() << endl;
在int(u)与any_cast<int>(u)中作者更喜欢后者，因为它更一般化（包括它是一个非成员的自由函数），从C++风格的角度来看也更为自然。如果已经知道确切的类型，当然也可以使用更为简洁的转换形式，即int(u)这样的C风格转换。另一方面，MYUNION的get_类型则显得较为脆弱，难于编写和维护等等。
//将u作为一个std::list<int>来访问
u = list<int>();
list<int>& l = *any_cast<list<int> >(&u)//原先是：LIST& list = u.getlist();
l.push_back(5);//同样，list.push_back(5);
l.push_back(10);
l.push_back(15);
作者认为any_cast还可以再改进，以便更容易地通过它来获得引用，这样也还算过得去。（此外，当作用域中模板的名字是list时，不建议使用list作为变量名，这太可能导致表达式的二义性。）
到目前为止，进行了一些可读性和类型支持性/类型安全性方面的改进。剩下来的区别就更小了：
list<int>::iterator it = l.begin();//原先为：LIST::iterator it = list.begin();
while (it != l.end())
{
	cout << "list item=" << *(it) << endl;
	it++;
}//while
//将u当成std::string来访问
u = string("Hello, world!");//原先为：STRING& str = u.getstring();str = "Hello, world!";
再一次，使用boost::any的代码版本比原先的版本要简洁，但也只简洁一点而已。
cout << "string='" << any_cast<string>(u) << "'" << endl;//或者“string(u)”。原先为：cout << "string='" << str.c_str() << "'" << endl;
准则：如果要表示一个variant类型，就目前而言，应当尽量使用boost::any（或某些同样简单的东西）。（实际上，boost上已经加入了一个能在许多编译器上通过编译的variant实现，即Boost.Variant。）
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第37条 分解std::string之一：概观std::string
1. 何谓单片式设计，为什么这种设计是糟糕的，请解释。
认为单个的重量级设施就能够完成所有事情通常是行不通的，毕竟，这个设施并不一定能够做得更多，相反往往做得更少，因为它越是复杂，其应用和适用性就越是狭窄。
特别地，如果一个类总是试图通过成员函数而不是非成员函数来提供功能，甚至在可以用非友元函数来实现而且实现起来并不比成员函数差的情况下也固执地使用成员函数，这个类就掉进了所谓的“单片式设计陷阱”。
--（主要问题）它把可能是独立可用的功能“封锁”在了一个类的内部。有些操作除了可以被这个类使用外或许还可以用在其他类型身上，但由于已经被捆绑在了某个特定类的内部，因此这种可能性也就丧失了，而如果使用非成员函数来实现同样的功能，该功能的适用范围就广多了。
--（次要问题）这种设计可能会阻碍你为一个类扩展出新功能。如果该类的内建功能主要是由（或者仅由）成员函数提供的，从而将此定为该类的惯用法，而扩展的非成员函数不可能遵循它的原始惯用法，因而总是“二等公民”。该类用成员函数来提供它的功能其实就相当于给用户们进行了语义上的陈述，于是用户就会习惯于在使用该类时使用成员调用语法，而扩展功能却做不到这一点。
尽可能将泛型组件分解为一个个的小部件。
准则：尽可能遵循单一职守原则（不论是对于类还是对于函数）。尽可能编写非成员非友元形式的函数。

string基础
2. 列出std::string所有的成员函数。
算上构造函数，std::string拥有不少于103个成员函数。如果这还算不上是“单片式”设计，很难想像还有什么能够称作单片式设计。

小结
尽可能将泛型组件分解为一个个的小部件。
--尽可能遵循单一职守原则（不论是对于类还是对于函数）。
--尽可能编写非成员非友元形式的函数。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第38条 分解std::string之二：重构std::string
Exceptional C++的第31条和34条，讨论了为什么某些非成员函数也是一个类型的接口的正式一分子，以及为什么应当尽量采用非成员非友元形式的函数，其中一条原因就是为了改善封装性。当考虑封装性的时候，应当考虑将函数实现为非成员形式。
因此，当考虑basic_string（或其他任何类）进行操作的函数时，应当尽可能使它们成为非成员非友元函数。因此，下面就是在考察basic_string的成员函数时需要考虑的几点问题：
--如果一个函数必须为成员函数，就使它成为成员函数。如构造函数。
--如果一个函数需要有对类内部的访问权，那么最好将它实现为成员函数。哪些操作需要访问类的内部数据，且如果它们不是成员函数就得通过将它们声明为友元来给它们这个权限，这样的操作通常应当设为成员函数。注意，也有极个别的例外，例如需要允许左边的参数能够是其他类型的操作，此外还有一些像operator<<这样的其签名不允许*this引用作为其第一个参数的操作符；而且即便是这些非友元函数也可以基于（可能是虚）成员函数来实现，不过这样做没多大意义，最好还是老老实实地（也最自然）将它们声明为友元。
--其他任何情况下，尽量写非成员非友元函数。哪些操作被写成非成员非友元函数后照样工作得好好的，这些操作就是，因而它们通常应当被写成非成员函数。将操作写成非成员非友元函数应当是默认做法，应当努力做到这一点。
学会考虑上面这些（以及相关的）问题很重要，因为我们想要尽可能地将函数归到最后一种情况。
关于效率：对于每个函数，会考虑将它实现为非成员非友元函数是否与实现为成员函数一样高效。这算是过早优化吗，一点都不是。考虑效率的主要原因是为了说明basic_string中的多少成员函数在改写为非成员非友元形式之后也照样高效。
不要对过早优化神经过敏，这儿我们并没有掉进这个陷阱，而是在考察basic_string到底有哪些成员函数可以“无损”地实现为非成员非友元形式。

哪些操作必须为成员形式
1. std::string的哪些成员函数必须是成员形式的，为什么。
--构造函数（6）
--析构函数
--赋值操作符（3）
--[]符（2）
这些函数必须是成员函数。因为标准规定，构造函数、析构函数、赋值操作符或者[]操作符都不能是非成员形式。

哪些操作应当为成员形式
2. std::string的哪些操作应当为成员形式的，为什么。

切入正题：可能改写为非成员非友元形式的操作
3. 解释为什么std::string的at()、clear()、empty()和length()这4个成员函数可以在不损失泛型性或可用性、且对std::string的接口的其他部分没有影响的前提下改写成非成员非友元形式。

好处：
（1）简单性。将它们写成非成员函数允许编写和维护更少的代码。可以只编写empty()一次就可以，不非要重复编写basic_string::empty()、vector::empty()、list::empty()等等。甚至对每个新的符合STL要求的容器也不用重复的编码。使用非成员非友元形式的函数，一次写就，永不操心。
注意，以上优点也有其局限性。一方面，有些函数，如at()，是无法给出单一复杂度的保证的，因为不同容器的at()复杂度本就不同：map的at()复杂度是对数时间的（log(N)），vector的at()复杂度是常数时间的。另一方面或许并非所有或将来出现的容器都会支持泛化的自由函数所期望它们具有的接口。如刚才所示，empty()的简单的非成员实现对于那些不提供size()成员函数的容器无法工作，这类容器或许提供了足够的功能，但接口的形式却有所不同（如函数名字不同），遇到这样的容器，只有对empty()进行相应的特化或重载。
（2）一致性。避免了不同容器的成员算法之间、以及一个算法的成员与非成员版本之间毫无理由的不一致性。如果需要可定制行为，对非成员模板进行特化或重载应当能够达到目的。
（3）封装性。改善了封装性。
缺点，与优点相比显得微不足道：
第一个潜在的缺点是名字空间污染。
第二是一一致性问题。
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第39条 分解std::string之三：给std::string瘦身
//------------------------------------------------------------------------------------------------
//Exceptional C++ Style 第40条 分解std::string之四：再论std::string
准则：永远不要使用那些在写缓冲区时不进行越界检查的函数（例如strcpy、sprintf等）或那些可能不会为C风格串加上结束符的函数（例如strncpy、basic_string::copy等）。它们非但是潜伏的威胁，更是明显而迫在眉睫的安全灾难――缓冲区溢出攻击永远都是黑客和恶意代码编写者钟情的武器。
准则：尽可能遵守单一职守原则。尽可能编写非成员非友元形式的函数。
//------------------------------------------------------------------------------------------------
//Head First 第1章 设计模式入门
设计原则：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。换句话说，如果每次新的需求一来，都会使某方面的代码发生变化，那么就可以确定，这部分的代码需要被抽出来，和其他稳定的代码的所区分。
这个原则的另一种思考方式：把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不是影响不需要变化的其他部分。

分开变化和不会变化的部分

设计原则：针对接口编程，而不是针对实现编程。

设计原则：多用组合，少用继承。使用组合建立系统具有很大的弹性，不仅可将算法簇封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象，符合正确的接口标准即可。

策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

有一些面向对象原则，适用于所有模式。当你无法找到适当的模式解决问题时，采用这些原则可以帮助你。建立可维护的OO系统，要诀就在于随时想到系统以后可能需要的变化以及应付变化的原则。

OO基础：抽象、封装、多态、继承
OO原则：封装变化；多用组合，少用继承；针对接口编程，不针对实现编程
OO模式：策略模式――。。。
阅读本书时，时时刻刻要思考着：模式如何仰赖基础与原则。

良好的OO设计必须具备可复用、可扩充、可维护三个特性。

模式不是代码，而是针对设计问题的通用解决方案。你把它们应用到特定的应用中。
大多数的模式和原则，都着眼于软件变化的主题。
大多数的模式都允许系统局部改变独立于其他部分。
常把系统中，会变化的部分抽出来封装。

//这里的例子和《大话设计模式》里的桥接模式一样；如果单纯的说策略模式的话，则Duck作为具体类，将FlyBehavior和QuackBehavior作为组合对象，即是策略模式。
//Duck.h
#ifndef __DUCK_H__
#define __DUCK_H__
#include "boost/shared_ptr.hpp"

class FlyBehavior;
class QuackBehavior;

class Duck
{
public:
	Duck(boost::shared_ptr<FlyBehavior> pFlyBehavior, boost::shared_ptr<QuackBehavior> pQuackBehavior);
	virtual ~Duck();
	void swim();
	void performFly();
	void performQuack();
	virtual void display() = 0;

	void setFlyBehavior(boost::shared_ptr<FlyBehavior> fb);
	void setQuackBehavior(boost::shared_ptr<QuackBehavior> qb);
private:
	boost::shared_ptr<FlyBehavior> pFlyBehavior_;
	boost::shared_ptr<QuackBehavior> pQuackBehavior_;
};

class MallardDuck: public Duck
{
public:
	MallardDuck();
	virtual void display();
};

class ModelDuck: public Duck
{
public:
	ModelDuck();
	virtual void display();
};

#endif

//Duck.cpp
#include <iostream>
#include "Duck.h"
#include "FlyBehavior.h"
#include "QuackBehavior.h"

Duck::Duck( boost::shared_ptr<FlyBehavior> pFlyBehavior, boost::shared_ptr<QuackBehavior> pQuackBehavior ):
pFlyBehavior_(pFlyBehavior), pQuackBehavior_(pQuackBehavior)
{

}

Duck::~Duck()
{

}

void Duck::swim()
{
	std::cout << "All ducks float, even decoys!" << std::endl;
}

void Duck::performFly()
{
	pFlyBehavior_->fly();
}

void Duck::performQuack()
{
	pQuackBehavior_->quack();
}

void Duck::setFlyBehavior( boost::shared_ptr<FlyBehavior> fb )
{
	pFlyBehavior_ = fb;
}

void Duck::setQuackBehavior( boost::shared_ptr<QuackBehavior> qb )
{
	pQuackBehavior_ = qb;
}

//Problems!
//MallardDuck::MallardDuck(): Duck(boost::shared_ptr<FlyBehavior>(new FlyWithWings()), boost::shared_ptr<QuackBehavior>(new Quack()))
MallardDuck::MallardDuck(): Duck(boost::shared_ptr<FlyBehavior>(), boost::shared_ptr<QuackBehavior>())
{
	Duck::setFlyBehavior(boost::shared_ptr<FlyBehavior>(new FlyWithWings()));
	Duck::setQuackBehavior(boost::shared_ptr<QuackBehavior>(new Quack()));
}

void MallardDuck::display()
{
	std::cout << "I am a real mallard duck." << std::endl;
}

ModelDuck::ModelDuck(): Duck(boost::shared_ptr<FlyBehavior>(), boost::shared_ptr<QuackBehavior>())
{
	Duck::setFlyBehavior(boost::shared_ptr<FlyBehavior>(new FlyNoWay()));
	Duck::setQuackBehavior(boost::shared_ptr<QuackBehavior>(new Quack()));
}

void ModelDuck::display()
{
	std::cout << "I am a model duck." << std::endl;
}

//FlyBehavior.h
#ifndef __FLYBEHAVIOR_H__
#define __FLYBEHAVIOR_H__

class FlyBehavior
{
public:
	virtual ~FlyBehavior();
	virtual void fly() = 0;
};

class FlyWithWings: public FlyBehavior
{
public:
	virtual void fly();
};

class FlyNoWay: public FlyBehavior
{
public:
	virtual void fly();
};

class FlyRocketPowered: public FlyBehavior
{
public:
	virtual void fly();
};

#endif

//FlyBehavior.cpp
#include <iostream>
#include "FlyBehavior.h"

FlyBehavior::~FlyBehavior()
{

}

void FlyWithWings::fly()
{
	std::cout << "I am flying!" << std::endl;
}

void FlyNoWay::fly()
{
	std::cout << "I can't fly." << std::endl;
}

void FlyRocketPowered::fly()
{
	std::cout << "I am flying with a rocket!" << std::endl;
}

//QuackBehavior.h
#ifndef __QUACKBEHAVIOR_H__
#define __QUACKBEHAVIOR_H__

class QuackBehavior
{
public:
	virtual ~QuackBehavior();
	virtual void quack() = 0;
};

class Quack: public QuackBehavior
{
public:
	virtual void quack();
};

class MuteQuack: public QuackBehavior
{
public:
	virtual void quack();
};

class Squeak: public QuackBehavior
{
public:
	virtual void quack();
};

#endif

//QuackBehavior.cpp
#include <iostream>
#include "QuackBehavior.h"

QuackBehavior::~QuackBehavior()
{

}

void Quack::quack()
{
	std::cout << "Quack~" << std::endl;
}

void MuteQuack::quack()
{
	std::cout << "<< Silence >>" << std::endl;
}

void Squeak::quack()
{
	std::cout << "Squeak~" << std::endl;
}

//main.cpp
#include <iostream>
#include "Duck.h"
#include "FlyBehavior.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main ()
{
	boost::shared_ptr<Duck> mallard(new MallardDuck());
	mallard->display();
	mallard->swim();
	mallard->performFly();
	mallard->performQuack();

	boost::shared_ptr<Duck> modelDuck(new ModelDuck());
	modelDuck->display();
	modelDuck->swim();
	modelDuck->performFly();
	modelDuck->setFlyBehavior(boost::shared_ptr<FlyBehavior>(new FlyRocketPowered()));
	modelDuck->performFly();
}
输出如下：
I am a real mallard duck.
All ducks float, even decoys!
I am flying!
Quack~
I am a model duck.
All ducks float, even decoys!
I can't fly.
I am flying with a rocket!
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//Head First 第2章 观察者模式--让你的对象知悉现况
出版者+订阅者=观察者模式
如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事了，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。

定义观察者模式
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因此新值而更新。实现观察者模式的方法不只一种，但是以包含Subject与Observer接口的类设计的做法最常见。

设计原则：为了交互对象之间的松耦合设计而努力。
松耦合的设计之所以能让我们建立弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

这里的观察者模式提供了两种通知观察者的方法，一种是推（push）方法，即把Subject的状态通过update(arg1, arg2...)传送给观察者，第二种是拉（pull）数据，Subject单纯的调update()，由观察者通过Subject的get()接口自己去取相应需要的状态（Head First P67）。或者同时提供以上两种方法供观察者用。
也可以定义update(Subject*)中带有主题的函数，以便观察者知道是哪个主题通知它，从而取得对应主题的状态（可想像为一家订了多份报纸，每份报纸会送到多家）。

在Subject中增加一个setChanged()方法用来标记状态已经改变的事实，好让notifyObservers()知道当它被调用时应该更新观察者。如果调用notifyObservers()之前没有先调用setChanged()，观察者就“不会”被通知。看一看Observable内部，以了解这一切：
setChanged()
{
	changed = true;//setChanged()方法将changed标志设为true。
}

notifyObservers(Object arg)
{
	if (changed)
	{
		for every observer on the list
		{
			call update(this, arg);//notifyObservers()只会在changed标为“true”时通知观察者。
		}
		changed = false;//在通知观察者之后，把changed标志设回false。
	}
}

notifyObservers()
{
	notifyObservers(null);//
}
这样做有其必要性。setChanged()方法可以让你在更新观察者时，有更多的弹性，你可以更适当地通知观察者。比如说，如果没有setChanged()访求，气象站测量是如此敏锐，以至于温度计读数每十分之一度就会更新，这会造成WeatherData对象持续不断地通知观察者，我们并不希望看到这样的事情发生。如果我们希望以上才更新，就可以在温度差距到达半度时，调用setChanged()，进行有效的更新。
你也许不会经常用到此功能，但是把这样的功能准备好，当需要时马上就可以使用。总之，你需要调用setChanged()，以便通知开始运转。如果此功能在某些地方对你有帮助，你可能也需要clearChanged()方法，将changed状态设置回false。另外也有一个hasChanged()方法，告诉你changed标志的当前状态。

观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）。
有多个观察者时，不可以依赖特定的通知次序。
有必要的话，可以实现自己的Observable（可观察者，即主题Subject），这并不难，不要害怕。（这是对Java来说的，C++应该都要自己实现。。。）

//这个例子用的是push数据的方法
//Observer.h
#ifndef __OBSERVER_H__
#define __OBSERVER_H__

class Observer
{
public:
	virtual ~Observer();
	virtual void update(float temperature, float humidity, float pressure) = 0;
	virtual void display() = 0;
};

class Subject;

class CurrentConditionsDisplay: public Observer
{
public:
	CurrentConditionsDisplay(Subject* weatherData);
	virtual void update(float temperature, float humidity, float pressure);
	virtual void display();

private:
	float temperature_;
	float humidity_;
	Subject* weatherData_;
};

#endif

//Observer.cpp
#include <iostream>
#include "Observer.h"
#include "Subject.h"

Observer::~Observer()
{

}

//保存对Subject的引用，构造完成似乎用不着了。的确如此，但是以后我们可能想取消注册，如果已经有了对Subject的引用会比较方便。
CurrentConditionsDisplay::CurrentConditionsDisplay(Subject* weatherData): temperature_(0), humidity_(0), weatherData_(weatherData)
{
	weatherData_->registerObserver(this);
}

void CurrentConditionsDisplay::update( float temperature, float humidity, float pressure )
{
	temperature_ = temperature;
	humidity_ = humidity;
	display();
}

void CurrentConditionsDisplay::display()
{
	std::cout << "Current conditions: " << temperature_ << "F degrees and " << humidity_ << "% humidity." << std::endl;
}

//Subject.h
#ifndef __SUBJECT_H__
#define __SUBJECT_H__
#include <list>
//#include "boost/shared_ptr.hpp"

class Observer;

class Subject
{
public:
	virtual ~Subject();
	virtual void registerObserver(Observer* o) = 0;
	virtual void removeObserver(Observer* o) = 0;
	virtual void notifyObserver() = 0;
};

class WeatherData: public Subject
{
public:
	WeatherData();
	virtual void registerObserver(Observer* o);
	virtual void removeObserver(Observer* o);
	virtual void notifyObserver();

	void measurementsChanged();
	void setMeasurements(float temperature, float humidity, float pressure);
private:
	std::list<Observer*> observersList_;
	float temperature_;
	float humidity_;
	float pressure_;
};

#endif

//Subject.cpp
#include "Subject.h"
#include "Observer.h"

Subject::~Subject()
{

}

void WeatherData::registerObserver(Observer* o)
{
	observersList_.push_back(o);
}

void WeatherData::removeObserver(Observer* o)
{
	observersList_.remove(o);
}

void WeatherData::notifyObserver()
{
	for (std::list<Observer*>::iterator iter = observersList_.begin(); iter != observersList_.end(); ++iter)
	{
		(*iter)->update(temperature_, humidity_, pressure_);
	}
}

WeatherData::WeatherData(): observersList_(), temperature_(0), humidity_(0), pressure_(0)
{

}

void WeatherData::measurementsChanged()
{
	notifyObserver();
}

void WeatherData::setMeasurements( float temperature, float humidity, float pressure )
{
	temperature_ = temperature;
	humidity_ = humidity;
	pressure_ = pressure;
	measurementsChanged();
}

//WeatherStation.h
#ifndef __WEATHERSTATION_H__
#define __WEATHERSTATION_H__

class WeatherStation
{
public:
	static void main();
};

#endif

//WeatherStation.cpp
#include "WeatherStation.h"
#include "Subject.h"
#include "Observer.h"

void WeatherStation::main()
{
	WeatherData* weatherData = new WeatherData();
	CurrentConditionsDisplay currentConditionsDisplay(weatherData);
	weatherData->setMeasurements(80, 65, 30.4f);
	weatherData->setMeasurements(82, 70, 29.2f);
	weatherData->setMeasurements(78, 90, 29.2f);

	delete weatherData;
}

//main.cpp
#include <iostream>
#include "WeatherStation.h"
using namespace std;

int main ()
{
	WeatherStation::main();
}
输出如下：
Current conditions: 80F degrees and 65% humidity.
Current conditions: 82F degrees and 70% humidity.
Current conditions: 78F degrees and 90% humidity.
请按任意键继续. . .

//这个例子用的是pull数据的方法
//Observer.h
#ifndef __OBSERVER_H__
#define __OBSERVER_H__
class Subject;

class Observer
{
public:
	virtual ~Observer();
	virtual void update(Subject* subject) = 0;
	virtual void display() = 0;
};

class CurrentConditionsDisplay: public Observer
{
public:
	CurrentConditionsDisplay(Subject* weatherData);
	virtual void update(Subject* subject);//这里传入的是Subject本身对象，好让观察者知道是哪个主题通知它的；另外如果想要把push和pull方式结合的话，这里可以这样定义virtual void update(Subject* subject, float temperature, float humidity, float pressure);
	virtual void display();

private:
	float temperature_;
	float humidity_;
	Subject* weatherData_;
};

#endif

//Observer.cpp
#include <iostream>
#include "Observer.h"
#include "Subject.h"

Observer::~Observer()
{

}

CurrentConditionsDisplay::CurrentConditionsDisplay(Subject* weatherData): temperature_(0), humidity_(0), weatherData_(weatherData)//, pressure_(0)
{
	weatherData_->registerObserver(this);
}

void CurrentConditionsDisplay::update(Subject* subject)//改变update()方法，增加Subject对象作为参数；如前所述，还可以增加push数据作为参数（如可变参数来实现）
{
	if (typeid(*subject) == typeid(WeatherData))//在update()中，先确定可观察者属于WeatherData类型，然后利用getter方法获取温度和温度测量值，最后调用display()。
	{
		if (WeatherData* weatherData = dynamic_cast<WeatherData*>(subject))//利用dynamic_cast来向下转型，如转型失败，则返回0指针，不会进入。
		{
			temperature_ = weatherData->getTemperature();
			humidity_ = weatherData->getHumidity();
			display();
		}
	}
}

void CurrentConditionsDisplay::display()
{
	std::cout << "Current conditions: " << temperature_ << "F degrees and " << humidity_ << "% humidity." << std::endl;
}

//Subject.h
#ifndef __SUBJECT_H__
#define __SUBJECT_H__
#include <list>
//#include "boost/shared_ptr.hpp"

class Observer;

class Subject
{
public:
	virtual ~Subject();
	virtual void registerObserver(Observer* o) = 0;
	virtual void removeObserver(Observer* o) = 0;
	virtual void notifyObserver() = 0;
};

class WeatherData: public Subject
{
public:
	WeatherData();
	virtual void registerObserver(Observer* o);
	virtual void removeObserver(Observer* o);
	virtual void notifyObserver();

	void measurementsChanged();
	void setMeasurements(float temperature, float humidity, float pressure);
	void setChanged();
	float getTemperature();
	float getHumidity();
	float getPressure();
private:
	std::list<Observer*> observersList_;
	float temperature_;
	float humidity_;
	float pressure_;
	bool changed_;
};

#endif

//Subject.cpp
#include "Subject.h"
#include "Observer.h"

Subject::~Subject()
{

}

void WeatherData::registerObserver(Observer* o)
{
	observersList_.push_back(o);
}

void WeatherData::removeObserver(Observer* o)
{
	observersList_.remove(o);
}

void WeatherData::notifyObserver()
{
	if (changed_)
	{
		for (std::list<Observer*>::iterator iter = observersList_.begin(); iter != observersList_.end(); ++iter)
		{
			//(*iter)->update(temperature_, humidity_, pressure_);这是原来push的做法
			(*iter)->update(this);//这是pull的做法，把当前对象传递给观察者
		}
		changed_ = false;
	}

}

WeatherData::WeatherData(): observersList_(), temperature_(0), humidity_(0), pressure_(0), changed_(false)
{

}

void WeatherData::measurementsChanged()
{
	setChanged();//在调用notifyObserver()之前，要先调用setChanged()来指示状态已经改变
	notifyObserver();
}

void WeatherData::setMeasurements( float temperature, float humidity, float pressure )
{
	temperature_ = temperature;
	humidity_ = humidity;
	pressure_ = pressure;
	measurementsChanged();
}

void WeatherData::setChanged()
{
	changed_ = true;
}

float WeatherData::getTemperature()//这个不是新方法，只是因为要使用“拉”的做法，所以才提醒你有这些方法。观察者会利用这些方法取得WeatherData对象的状态。
{
	return temperature_;
}

float WeatherData::getHumidity()
{
	return humidity_;
}

float WeatherData::getPressure()
{
	return pressure_;
}

//WeatherStation.h
#ifndef __WEATHERSTATION_H__
#define __WEATHERSTATION_H__

class WeatherStation
{
public:
	static void main();
};

#endif

//WeatherStation.cpp
#include "WeatherStation.h"
#include "Subject.h"
#include "Observer.h"

void WeatherStation::main()
{
	WeatherData* weatherData = new WeatherData();
	CurrentConditionsDisplay currentConditionsDisplay(weatherData);
	weatherData->setMeasurements(80, 65, 30.4f);
	weatherData->setMeasurements(82, 70, 29.2f);
	weatherData->setMeasurements(78, 90, 29.2f);

	delete weatherData;
}

//main.cpp
#include <iostream>
#include "WeatherStation.h"
using namespace std;

int main ()
{
	WeatherStation::main();
}
输出和之前一样，如下：
Current conditions: 80F degrees and 65% humidity.
Current conditions: 82F degrees and 70% humidity.
Current conditions: 78F degrees and 90% humidity.
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//Head First 第3章 装饰者模式--装饰对象
个人理解：装饰模式就是在派生类中把抽象类的接口委托给组合对象的接口，同时在这个派生类接口函数中加入派生类自己特有的工作。
本章可以称为“给爱用继承的人一个全新的设计眼界”。
设计原则：类应该对扩展开发，对修改关闭。

认识装饰者模式
采用不一样的做法：以饮料为主体，然后在运行时以调料来“装饰”（decorate）饮料。比方说，如果顾客想要摩卡和奶泡深焙咖啡，那么，要做的是：
1)拿一个深焙咖啡（DarkRoast）对象
2)以摩卡（Mocha）对象装饰它
3)以奶泡（Whip）对象装饰它
4)调用cost()方法，并依赖委托（delegate）将调料的价钱加上去。

为顾客算钱时。通过调用最外圈装饰者（Whip）的cost()就可以办得到。Whip的cost()会先委托它装饰的对象（也就是Mocha）计算出价钱，然后再加上奶泡的价钱。
1)首先，调用最外圈装饰者Whip的cost()
2)Whip调用Mocha的cost()
3)Mocha调用DarkRoast的cost()
4)DarkRoast返回它的价钱0.99
5)Mocha在DarkRoast的结果上，加上自己的价钱0.2 ，返回新的价钱1.19
6)Whip在Mocha的返回结果上加上自己的价钱0.1 ，然后返回最后结果1.29

目前所知道的一切：
--装饰者和被装饰者对象有相同的超类型。
--可以用一个或多个装饰者包装一个对象。
--既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）场合，可以用装饰过的对象代替它。
--装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。（关键点！）
--对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。

定义装饰者模式
装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

装饰者和被装饰者必须是一样的类型，就是有共同的超类，这是相当关键的地方，这里，利用继承达到“类型匹配”，而不是利用继承获得“行为”。
装饰者与组件组合，就是在加入新的行为，所得到的新行为，并不是继承自超类，而是由组合对象得来的。
继承抽象类，是为了有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。

了解了装饰者的工作原理，以后当使用别人的大量装饰API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。
有时候会在设计中加入大量的小类，这偶尔会导致别人不容易了解其设计方式。

//drink.h
#ifndef __DRINK_H__
#define __DRINK_H__
#include <string>
#include "boost/shared_ptr.hpp"

class Beverage
{
public:
	virtual ~Beverage();
	virtual std::string getDescription() const = 0;
	virtual double getCost() const = 0;
};

class DarkRoast: public Beverage
{
public:
	DarkRoast();
	virtual ~DarkRoast();
	virtual std::string getDescription() const;
	virtual double getCost() const;
private:
	std::string description_;
	double cost_;
};

//没看出来这个抽象装饰类有啥用啊？应该是为了给具体装饰类作抽象用的吧，在这个例子中，三个具体装饰类没有抽出公共的内容，所以该抽象装饰类没有什么作用
class CondimentDecorator: public Beverage
{
public:
	virtual ~CondimentDecorator();
};

class Mocha: public CondimentDecorator
{
public:
	Mocha(boost::shared_ptr<Beverage> beverage);
	virtual ~Mocha();
	virtual std::string getDescription() const;
	virtual double getCost() const;
private:
	boost::shared_ptr<Beverage> beverage_;
	std::string description_;
	double cost_;
};

class Whip: public CondimentDecorator
{
public:
	Whip(boost::shared_ptr<Beverage> beverage);
	virtual ~Whip();
	virtual std::string getDescription() const;
	virtual double getCost() const;
private:
	boost::shared_ptr<Beverage> beverage_;
	std::string description_;
	double cost_;
};

#endif

//drink.cpp
#include "drink.h"

Beverage::~Beverage()
{

}

DarkRoast::DarkRoast(): description_("Dark Roast"), cost_(10.00)
{

}

DarkRoast::~DarkRoast()
{

}

std::string DarkRoast::getDescription() const
{
	return description_;
}


double DarkRoast::getCost() const
{
	return cost_;
}


CondimentDecorator::~CondimentDecorator()
{

}


Mocha::Mocha(boost::shared_ptr<Beverage> beverage): beverage_(beverage), description_("Mocha"), cost_(1.10)
{

}


Mocha::~Mocha()
{

}

std::string Mocha::getDescription() const
{
	return beverage_->getDescription() + ", " + description_;
}

double Mocha::getCost() const
{
	return beverage_->getCost() + cost_;
}


Whip::Whip(boost::shared_ptr<Beverage> beverage): beverage_(beverage), description_("Whip"), cost_(2.50)
{

}

Whip::~Whip()
{

}

std::string Whip::getDescription() const
{
	return beverage_->getDescription() + ", " + description_;
}

double Whip::getCost() const
{
	return beverage_->getCost() + cost_;
}

//main.cpp
#include <iostream>
#include "drink.h"
#include "boost/shared_ptr.hpp"
using namespace std;

int main()
{
	boost::shared_ptr<Beverage> darkRoast(new DarkRoast);
	//boost::shared_ptr<CondimentDecorator> cD1(new Mocha(darkRoast));
	//boost::shared_ptr<CondimentDecorator> cD2(new Mocha(cD1));
	//boost::shared_ptr<CondimentDecorator> cD3(new Whip(cD2));
	//cout << cD3->getDescription() << endl;
	//cout << cD3->getCost() << endl;
	darkRoast.reset(new Mocha(darkRoast));
	darkRoast.reset(new Mocha(darkRoast));
	darkRoast.reset(new Whip(darkRoast));
	cout << darkRoast->getDescription() << endl;
	cout << darkRoast->getCost() << endl;
}
输出如下：
Dark Roast, Mocha, Mocha, Whip
14.7
//------------------------------------------------------------------------------------------------
//Head First 第4章 工厂模式--烘烤OO的精华
当看到“new”，就会想到“具体”
当使用“new”时，你的确是在实例化一个具体类，所以用的确实是实现，而不是接口。
当有一群相关的具体类时，通常会写出这样的代码：
Duck duck;
if (picnic)
{
	duck = new MallardDuck();
}
else if (hunting)
{
	duck = new DecoyDuck();
}
else if (inBathTub)
{
	duck = new RubberDuck();
}
有一大堆不同的鸭子类，但是必须等到运行时，才知道该实例化哪一个。
（在公司看到可以写一个工厂类，用map把key与实例化的类关联起来，然后通过工厂类提供的set函数默认增加几个已知的类，再将已知的几种生成为单例类，这样可以实现新增一个类而不用修改已有代码，而只通过set函数把新增的类增加到map里即可。说白了就是一个几行的映射生成相应的对象类，非常好的方法！！！搜索“OsDiscriminator.h”）
针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。如果代码是针对接口而写，那么通过多态，它可以与作任何新类实现该接口。

现在将创建对象移到orderPizza()之外，要把创建比萨的代码移到另一个对象中，由这个新对象专职创建比萨。
我们称这个新对象为“工厂”。
工厂（factory）处理创建对象的细节。一旦有了SimplePizzaFactory，orderPizza()就变成此对象的客户。当需要比萨时，就叫比萨工厂做一个。现在orderPizza()方法只关心从工厂得到了一个比萨，而这个比萨实现了Pizza接口，它可以调用prepare()、bake()、cut()、box()来分别进行准备、烧烤、切片、装盒。

Java中：再提醒一次：在设计模式中，所谓的“实现一个接口”并“不一定”表示“写一个类，并利用implement关键词来实现某个Java接口”。“实现一个接口”泛指“实现某个超类型（可以是类或接口）的某个方法”。
工厂模式可以理解为：建造一个分工厂（继承抽象工厂类的派生类），这个分工厂用总厂（抽象工厂类）的方法（或改进方法），造出该分工厂特有的产品（继承了总厂抽象产品类的派生产品）。

工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

问：工厂方法和创建者是否总是抽象的
答：不，可以定义一个默认的工厂方法来产生某些具体的产品，这么一来，即便创建者没有任何子类，依然可以创建产品。
问：每个商店基于传入的类型制造出不同各类的比萨。是否所有的具体创建者都必须如此，能不能只创建一种比萨。
答：这里所采用的方式称为“参数化工厂方法”。它可以根据传入的参数创建不同的对象。然而，工厂经常只产生一种对象，不需要参数化。模式的这两种形式都是有效的。

依赖倒置原则（Dependency Inversion Principle）
设计原则：要依赖抽象，不要依赖具体类。

在应用工厂方法之后，你将注意到，高层组件（也就是PizzaStore）和低层组件（也就是这些比萨）都依赖了Pizza抽象。想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。
在依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。看看P141的图，你会注意到低层组件现在竟然依赖高层的抽象。同样地，高层组件现在也依赖相同的抽象。前几页所绘制的依赖图是由上而下的，现在却倒置了，而且高层与低层模块现在都依赖这个抽象。
倒置你的思考方式

几个指导方针帮助你遵循此原则：
下面的指导方针，能帮你避免在OO设计中违反依赖倒置原则：
--变量不可以持有具体类的引用。如果使用new，就会持有具体类的引用，你可以改用工厂来避开这样的做法。
--不要让类派生自具体类。如果派生自具体类，你就会依赖具体类，请派生自一个抽象（接口或抽象类）。
--不要覆盖基类中已实现的方法。如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。
如果深入体验这些方针，将这些方针内化成你思考的一部分，那么在设计时，你将知道何时有足够的理由违反这样的原则。比方说，如果有一个不像是会改变的类，那么在代码中直接实例化具体类也就没什么大碍。我们平常还不是在程序中不假思索地就实例化字符串对象吗，就没有违反这个原则吗。当然有，可以这么做是因为字符串不可能改变。
另一方面，如果有个类可能改变，你可以采用一些好技巧（例如工厂方法）来封装改变。

定义抽象工厂模式：
抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

工厂方法模式就是用各个具体工厂类f1、f2、f3（每一个具体工厂类确切知道自己返回的是什么具体产品类）返回一个抽象类A的派生类A1、A2、A3，并且返回类型都为A，可以让高层对象操纵抽象对象A，而不用管其具体类型是什么。
抽象工厂模式就是用各个具体工厂类f1、f2、f3（每一个具体工厂类确切知道自己返回的是什么具体产品类）返回多个抽象类A、B、C、D的派生类（A1、B1、C1、D1）、（A2、B2、C2、D2）、（A3、B3、C3、D3），并且返回类型都为A、B、C、D，可以让高层对象操纵抽象对象A、B、C、D，而不用管其具体类型是什么。同时A、B、C、D几个类型组合起来才是一个完整的产品类（可以缺少其中某几个，某个具体产品类知道自己由哪几个类型组成，或者具体工厂类知道该产品由哪几个类型组成）。

比较工厂方法和抽象工厂
工厂方法：提供一个抽象接口来创建“一个产品”。通过工厂方法，每个区域都有自己的个体工厂，他们都知道如何制作适合该区域的比萨。由每个子类来“决定”实例化哪个“具体类”。产品子类由工厂方法实例化。
抽象工厂：提供一个抽象接口用来创建一个产品家族。每个具体子类都创建一个家族的产品。负责在抽象工厂中产品的方法，通常是以“工厂方法”来实现的。每个原料都代表着一个产品，而这个产品是由抽象工厂的工厂方法产生的。
在本章，多加了两个工具到你的工具箱中：工厂方法和抽象工厂。这两种模式都是将对象创建的过程封装起来，以便将代码从具体类解耦。

//简单工厂
//Pizza.h
#ifndef __PIZZA_H__
#define __PIZZA_H__

class Pizza
{
public:
	virtual ~Pizza();
	virtual void prepare() = 0;
	virtual void bake() = 0;
	virtual void cut() = 0;
	virtual void box() = 0;
};

class CheesePizza: public Pizza
{
public:
	virtual void prepare();
	virtual void bake();
	virtual void cut();
	virtual void box();
};

class ClamPizza: public Pizza
{
public:
	virtual void prepare();
	virtual void bake();
	virtual void cut();
	virtual void box();
};
#endif

//Pizza.cpp
#include <iostream>
#include "Pizza.h"

Pizza::~Pizza()
{

}

void CheesePizza::prepare()
{
	std::cout << "Prepare cheese pizza." << std::endl;
}

void CheesePizza::bake()
{
	std::cout << "Bake cheese pizza." << std::endl;
}

void CheesePizza::cut()
{
	std::cout << "Cut cheese pizza." << std::endl;
}

void CheesePizza::box()
{
	std::cout << "Box cheese pizza." << std::endl;
}

void ClamPizza::prepare()
{
	std::cout << "Prepare clam pizza." << std::endl;
}

void ClamPizza::bake()
{
	std::cout << "Bake clam pizza." << std::endl;
}

void ClamPizza::cut()
{
	std::cout << "Cut clam pizza." << std::endl;
}

void ClamPizza::box()
{
	std::cout << "Box clam pizza." << std::endl;
}

//SimplePizzaFactory.h
#ifndef __SIMPLEPIZZAFACTORY_H__
#define __SIMPLEPIZZAFACTORY_H__
#include <memory>
#include <string>

class Pizza;

class SimplePizzaFactory
{
public:
	std::auto_ptr<Pizza> createPizza(const std::string& type);
};

#endif

//SimplePizzaFactory.cpp
#include "SimplePizzaFactory.h"
#include "Pizza.h"

std::auto_ptr<Pizza> SimplePizzaFactory::createPizza( const std::string& type )
{
	if ("Cheese" == type)
	{
		return std::auto_ptr<Pizza>(new CheesePizza);
	}
	else if ("Clam" == type)
	{
		return std::auto_ptr<Pizza>(new ClamPizza);
	}
	else
	{
		return std::auto_ptr<Pizza>();
	}
}

//PizzaStore.h
#ifndef __PIZZASTORE_H__
#define __PIZZASTORE_H__
#include <memory>
#include <string>
#include "boost/shared_ptr.hpp"
#include "Pizza.h"

class Pizza;

class SimplePizzaFactory;

class PizzaStore
{
public:
	PizzaStore(boost::shared_ptr<SimplePizzaFactory> factory);
	std::auto_ptr<Pizza> orderPizza(const std::string& type);
private:
	boost::shared_ptr<SimplePizzaFactory> factory_;
};
#endif

//PizzaStore.cpp
#include "PizzaStore.h"
#include "SimplePizzaFactory.h"
#include "Pizza.h"

PizzaStore::PizzaStore( boost::shared_ptr<SimplePizzaFactory> factory ): factory_(factory)
{

}

std::auto_ptr<Pizza> PizzaStore::orderPizza( const std::string& type )
{
	std::auto_ptr<Pizza> pizza(factory_->createPizza(type));
	if (0 != pizza.get())
	{
		pizza->prepare();
		pizza->bake();
		pizza->cut();
		pizza->box();
	}
	return pizza;
}

//main.cpp
#include <iostream>
#include "PizzaStore.h"
#include "SimplePizzaFactory.h"
using namespace std;

int main ()
{
	PizzaStore pizzaStore(boost::shared_ptr<SimplePizzaFactory>(new SimplePizzaFactory));
	pizzaStore.orderPizza("Cheese");
}
输出如下：
Prepare cheese pizza.
Bake cheese pizza.
Cut cheese pizza.
Box cheese pizza.
请按任意键继续. . .

//由简单工厂改为工厂模式
//Pizza.h
#ifndef __PIZZA_H__
#define __PIZZA_H__
#include <vector>
#include <string>

class Pizza
{
public:
	Pizza(const std::string& name, const std::string& dough, const std::string& sauce);
	virtual ~Pizza() = 0;//如果需要为基类所的成员函数定义默认实现，又不想实例化基类，那么就可以为析构函数定义为纯虚函数
	virtual void prepare();
	virtual void bake();
	virtual void cut();
	virtual void box();

	std::string getName() const;
protected:
	std::string name_;
	std::string dough_;
	std::string sauce_;
	std::vector<std::string> toppings_;
};

class NYStyleCheesePizza: public Pizza
{
public:
	NYStyleCheesePizza();
};

class ChicagoStyleCheesePizza: public Pizza
{
public:
	ChicagoStyleCheesePizza();
	virtual void cut();
};

#endif

//Pizza.cpp
#include <iostream>
#include <algorithm>
#include <iterator>
#include "Pizza.h"

Pizza::Pizza( const std::string& name, const std::string& dough, const std::string& sauce ):
name_(name), dough_(dough), sauce_(sauce), toppings_()
{

}

Pizza::~Pizza()
{

}

void Pizza::prepare()
{
	std::cout << "Preparing " + name_ + "\n"
		<< "Tossing dough...\n"
		<< "Adding sauce...\n"
		<< "Adding toppings: \n";
	std::cout << "	";
	copy(toppings_.begin(), toppings_.end(), std::ostream_iterator<std::string>(std::cout, " "));
	std::cout << std::endl;
}

void Pizza::bake()
{
	std::cout << "Bake for 25 minutes as 350." << std::endl;
}

void Pizza::cut()
{
	std::cout << "Cutting the pizza into diagonal slices." << std::endl;
}

void Pizza::box()
{
	std::cout << "Place pizza in official PizzaStore box." << std::endl;
}

std::string Pizza::getName() const
{
	return name_;
}

NYStyleCheesePizza::NYStyleCheesePizza():
Pizza("NY Style Sauce and Cheese Pizza", "Thin Crust Dough", "Marinara Sauce")
{
	toppings_.push_back("Grated Reggiano Cheese");
}

ChicagoStyleCheesePizza::ChicagoStyleCheesePizza():
Pizza("Chicago Style Deep Dish Cheese Pizza", "Extra Thick Crust Dough", "Plum Tomato Sauce")
{
	toppings_.push_back("Shredded Mozzarella Cheese");
}

void ChicagoStyleCheesePizza::cut()
{
	std::cout << "Cutting the pizza into square slices." << std::endl;
}

//PizzaStore.h
#ifndef __PIZZASTORE_H__
#define __PIZZASTORE_H__
#include <memory>
#include <string>

class Pizza;

class PizzaStore
{
public:
	virtual ~PizzaStore();
	std::auto_ptr<Pizza> orderPizza(const std::string& type);
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type) = 0;
};

class NYPizzaStore: public PizzaStore
{
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type);
};

class ChicagoPizzaStore: public PizzaStore
{
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type);
};
#endif

//PizzaStore.cpp
#include "PizzaStore.h"
#include "Pizza.h"

PizzaStore::~PizzaStore()
{

}

//感觉这里有点像模板方法模式，只不过目的不一样，这里是为了创建对象。与以前所看到的工厂方法模式不一样的是：以前的工厂方法模式直接返回一个对象，这里说白了也是返回一个对象，所不同的是在返回对象的基础上包装了一下，调用了pizza的四个成员函数而已
std::auto_ptr<Pizza> PizzaStore::orderPizza( const std::string& type )
{
	std::auto_ptr<Pizza> pizza(createPizza(type));
	if (0 != pizza.get())
	{
		pizza->prepare();
		pizza->bake();
		pizza->cut();
		pizza->box();
	}
	return pizza;
}

std::auto_ptr<Pizza> NYPizzaStore::createPizza( const std::string& type )
{
	if ("Cheese" == type)//如果这里不想做这些判断，则像“//如此理解面向对象”里所使用的方法，创建一个map，来得到相应对象
	{
		return std::auto_ptr<Pizza>(new NYStyleCheesePizza);
	}
	//NYStyleClamPizza and etc.
	else
	{
		return std::auto_ptr<Pizza>();
	}
}

std::auto_ptr<Pizza> ChicagoPizzaStore::createPizza( const std::string& type )
{
	if ("Cheese" == type)
	{
		return std::auto_ptr<Pizza>(new ChicagoStyleCheesePizza);
	}
	//ChicagoStyleClamPizza and etc.
	else
	{
		return std::auto_ptr<Pizza>();
	}
}

//PizzaTestDrive.h
#ifndef __PIZZATESTDRIVE_H__
#define __PIZZATESTDRIVE_H__

class PizzaTestDrive
{
public:
	static void main();
};

#endif

//PizzaTestDrive.cpp
#include <iostream>
#include "PizzaTestDrive.h"
#include "PizzaStore.h"
#include "Pizza.h"

void PizzaTestDrive::main()
{
	std::auto_ptr<PizzaStore> nyStore(new NYPizzaStore);
	std::auto_ptr<PizzaStore> chicagoStore(new ChicagoPizzaStore);
	
	std::auto_ptr<Pizza> pizza = nyStore->orderPizza("Cheese");
	std::cout << "Ethan ordered a " + pizza->getName() + ".\n";

	pizza = chicagoStore->orderPizza("Cheese");
	std::cout << "Joel ordered a " + pizza->getName() + ".\n";
}

//main.cpp
#include <iostream>
#include "PizzaTestDrive.h"
using namespace std;

int main ()
{
	PizzaTestDrive::main();
}
输出如下：
Preparing NY Style Sauce and Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings:
        Grated Reggiano Cheese
Bake for 25 minutes as 350.
Cutting the pizza into diagonal slices.
Place pizza in official PizzaStore box.
Ethan ordered a NY Style Sauce and Cheese Pizza.
Preparing Chicago Style Deep Dish Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings:
        Shredded Mozzarella Cheese
Bake for 25 minutes as 350.
Cutting the pizza into square slices.
Place pizza in official PizzaStore box.
Joel ordered a Chicago Style Deep Dish Cheese Pizza.
请按任意键继续. . .

//--增加原料的抽象工厂方法模式
//Ingredient.h
#ifndef __INGREDIENT__H__
#define __INGREDIENT__H__
#include <string>

class Dough
{
public:
	Dough(const std::string& name);
	virtual ~Dough() = 0;
	std::string getName() const;
private:
	std::string name_;
};

class ThinCrustDough: public Dough
{
public:
	ThinCrustDough();
};

class ExtraThickCrustDough: public Dough
{
public:
	ExtraThickCrustDough();
};

class Sauce
{
public:
	Sauce(const std::string& name);
	virtual ~Sauce() = 0;
	std::string getName() const;
private:
	std::string name_;
};

class MarinaraSauce: public Sauce
{
public:
	MarinaraSauce();
};

class PlumTomatoSauce: public Sauce
{
public:
	PlumTomatoSauce();
};

class Cheese
{
public:
	Cheese(const std::string& name);
	virtual ~Cheese() = 0;
	std::string getName() const;
private:
	std::string name_;
};

class ReggianoCheese: public Cheese
{
public:
	ReggianoCheese();
};

class MozzarellaCheese: public Cheese
{
public:
	MozzarellaCheese();
};

class Clam
{
public:
	Clam(const std::string& name);
	virtual ~Clam() = 0;
	std::string getName() const;
private:
	std::string name_;
};

class FreshClam: public Clam
{
public:
	FreshClam();
};

class FrozenClam: public Clam
{
public:
	FrozenClam();
};
#endif

//Ingredient.cpp
#include "Ingredient.h"

Dough::Dough( const std::string& name ): name_(name)
{

}

Dough::~Dough()
{

}

std::string Dough::getName() const
{
	return name_;
}

ThinCrustDough::ThinCrustDough(): Dough("Thin Crust Dough")
{

}

ExtraThickCrustDough::ExtraThickCrustDough(): Dough("Extra Thick Crust Dough")
{

}

Sauce::Sauce( const std::string& name ): name_(name)
{

}

Sauce::~Sauce()
{

}

std::string Sauce::getName() const
{
	return name_;
}

MarinaraSauce::MarinaraSauce(): Sauce("Marinara Sauce")
{

}

PlumTomatoSauce::PlumTomatoSauce(): Sauce("Plum Tomato Sauce")
{

}

Cheese::Cheese( const std::string& name ): name_(name)
{

}

Cheese::~Cheese()
{

}

std::string Cheese::getName() const
{
	return name_;
}

ReggianoCheese::ReggianoCheese(): Cheese("Grated Reggiano Cheese")
{

}

MozzarellaCheese::MozzarellaCheese(): Cheese("Shredded Mozzarella Cheese")
{

}

Clam::Clam( const std::string& name ): name_(name)
{

}

Clam::~Clam()
{

}

std::string Clam::getName() const
{
	return name_;
}

FreshClam::FreshClam(): Clam("Fresh Clam")
{

}

FrozenClam::FrozenClam(): Clam("Frozen Clam")
{

}

//PizzaIngredientFactory.h
#ifndef __PIZZAINGREDIENTFACTORY_H__
#define __PIZZAINGREDIENTFACTORY_H__
#include <memory>

class Dough;
class Sauce;
class Cheese;
class Clam;

class PizzaIngredientFactory
{
public:
	virtual ~PizzaIngredientFactory();
	virtual std::auto_ptr<Dough> createDough() = 0;
	virtual std::auto_ptr<Sauce> createSauce() = 0;
	virtual std::auto_ptr<Cheese> createCheese() = 0;
	virtual std::auto_ptr<Clam> createClam() = 0;
};

class NYPizzaIngredientFactory: public PizzaIngredientFactory
{
public:
	virtual std::auto_ptr<Dough> createDough();
	virtual std::auto_ptr<Sauce> createSauce();
	virtual std::auto_ptr<Cheese> createCheese();
	virtual std::auto_ptr<Clam> createClam();
};

class ChicagoIngredientFactory: public PizzaIngredientFactory
{
public:
	virtual std::auto_ptr<Dough> createDough();
	virtual std::auto_ptr<Sauce> createSauce();
	virtual std::auto_ptr<Cheese> createCheese();
	virtual std::auto_ptr<Clam> createClam();
};
#endif

//PizzaIngredientFactory.cpp
#include "PizzaIngredientFactory.h"
#include "Ingredient.h"

PizzaIngredientFactory::~PizzaIngredientFactory()
{

}

std::auto_ptr<Dough> NYPizzaIngredientFactory::createDough()
{
	return std::auto_ptr<Dough>(new ThinCrustDough);
}

std::auto_ptr<Sauce> NYPizzaIngredientFactory::createSauce()
{
	return std::auto_ptr<Sauce>(new MarinaraSauce);
}

std::auto_ptr<Cheese> NYPizzaIngredientFactory::createCheese()
{
	return std::auto_ptr<Cheese>(new ReggianoCheese);
}

std::auto_ptr<Clam> NYPizzaIngredientFactory::createClam()
{
	return std::auto_ptr<Clam>(new FreshClam);
}

std::auto_ptr<Dough> ChicagoIngredientFactory::createDough()
{
	return std::auto_ptr<Dough>(new ExtraThickCrustDough);
}

std::auto_ptr<Sauce> ChicagoIngredientFactory::createSauce()
{
	return std::auto_ptr<Sauce>(new PlumTomatoSauce);
}

std::auto_ptr<Cheese> ChicagoIngredientFactory::createCheese()
{
	return std::auto_ptr<Cheese>(new MozzarellaCheese);
}

std::auto_ptr<Clam> ChicagoIngredientFactory::createClam()
{
	return std::auto_ptr<Clam>(new FrozenClam);
}

//Pizza.h
#ifndef __PIZZA_H__
#define __PIZZA_H__
#include <string>
#include <memory>

class Dough;
class Sauce;
class Cheese;
class Clam;

class PizzaIngredientFactory;

class Pizza
{
public:
	Pizza();
	virtual ~Pizza();
	virtual void prepare() = 0;
	virtual void bake();
	virtual void cut();
	virtual void box();

	void setName(const std::string name);
	std::string getName() const;
protected:
	std::string name_;
	std::auto_ptr<Dough> dough_;
	std::auto_ptr<Sauce> sauce_;
	std::auto_ptr<Cheese> cheese_;
	std::auto_ptr<Clam> clam_;
};

class CheesePizza: public Pizza
{
public:
	CheesePizza(std::auto_ptr<PizzaIngredientFactory> ingredientFactory);
	virtual void prepare();
private:
	std::auto_ptr<PizzaIngredientFactory> ingredientFactory_;
};

class ClamPizza: public Pizza
{
public:
	ClamPizza(std::auto_ptr<PizzaIngredientFactory> ingredientFactory);
	virtual void prepare();
private:
	std::auto_ptr<PizzaIngredientFactory> ingredientFactory_;
};

#endif

//Pizza.cpp
#include <iostream>
#include <algorithm>
#include <iterator>
#include "Pizza.h"
#include "Ingredient.h"
#include "PizzaIngredientFactory.h"

Pizza::Pizza():
name_(""), dough_(), sauce_(), cheese_(), clam_()
{

}

Pizza::~Pizza()
{

}

void Pizza::bake()
{
	std::cout << "Bake for 25 minutes as 350." << std::endl;
}

void Pizza::cut()
{
	std::cout << "Cutting the pizza into diagonal slices." << std::endl;
}

void Pizza::box()
{
	std::cout << "Place pizza in official PizzaStore box." << std::endl;
}

std::string Pizza::getName() const
{
	return name_;
}

void Pizza::setName(const std::string name)
{
	name_ = name;
}

CheesePizza::CheesePizza( std::auto_ptr<PizzaIngredientFactory> ingredientFactory ):
ingredientFactory_(ingredientFactory)
{

}

void CheesePizza::prepare()
{
	std::cout << "Preparing " + name_ + "\n";
	dough_ = ingredientFactory_->createDough();
	sauce_ = ingredientFactory_->createSauce();
	cheese_ = ingredientFactory_->createCheese();
	std::cout << "Dough: " + dough_->getName() + "\n";
	std::cout << "Sauce: " + sauce_->getName() + "\n";
	std::cout << "Cheese: " + cheese_->getName() + "\n";
}

ClamPizza::ClamPizza( std::auto_ptr<PizzaIngredientFactory> ingredientFactory ):
ingredientFactory_(ingredientFactory)
{

}

void ClamPizza::prepare()
{
	std::cout << "Preparing " + name_ << std::endl;
	dough_ = ingredientFactory_->createDough();
	sauce_ = ingredientFactory_->createSauce();
	cheese_ = ingredientFactory_->createCheese();
	clam_ = ingredientFactory_->createClam();
	std::cout << "Dough: " + dough_->getName() + "\n";
	std::cout << "Sauce: " + sauce_->getName() + "\n";
	std::cout << "Cheese: " + cheese_->getName() + "\n";
	std::cout << "Clam: " + clam_->getName() + "\n";
}

//PizzaStore.h
#ifndef __PIZZASTORE_H__
#define __PIZZASTORE_H__
#include <memory>
#include <string>

class Pizza;

class PizzaStore
{
public:
	virtual ~PizzaStore();
	std::auto_ptr<Pizza> orderPizza(const std::string& type);
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type) = 0;
};

class NYPizzaStore: public PizzaStore
{
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type);
};

class ChicagoPizzaStore: public PizzaStore
{
private:
	virtual std::auto_ptr<Pizza> createPizza(const std::string& type);
};
#endif

//PizzaStore.cpp
#include "PizzaStore.h"
#include "Pizza.h"
#include "PizzaIngredientFactory.h"

PizzaStore::~PizzaStore()
{

}

std::auto_ptr<Pizza> PizzaStore::orderPizza( const std::string& type )
{
	std::auto_ptr<Pizza> pizza(createPizza(type));
	if (0 != pizza.get())
	{
		pizza->prepare();
		pizza->bake();
		pizza->cut();
		pizza->box();
	}
	return pizza;
}

std::auto_ptr<Pizza> NYPizzaStore::createPizza( const std::string& type )
{
	std::auto_ptr<Pizza> pizza;
	std::auto_ptr<PizzaIngredientFactory> ingredientFactory(new NYPizzaIngredientFactory);
	if ("Cheese" == type)
	{
		pizza.reset(new CheesePizza(ingredientFactory));
		pizza->setName("New York Style Cheese Pizza");
	}
	else if ("Clam" == type)
	{
		pizza.reset(new ClamPizza(ingredientFactory));
		pizza->setName("New York Style Clam Pizza");
	}
	return pizza;
}

std::auto_ptr<Pizza> ChicagoPizzaStore::createPizza( const std::string& type )
{
	std::auto_ptr<Pizza> pizza;
	std::auto_ptr<PizzaIngredientFactory> ingredientFactory(new ChicagoIngredientFactory);
	if ("Cheese" == type)
	{
		pizza.reset(new CheesePizza(ingredientFactory));
		pizza->setName("Chicago Style Cheese Pizza");
	}
	else if ("Clam" == type)
	{
		pizza.reset(new ClamPizza(ingredientFactory));
		pizza->setName("Chicago Style Clam Pizza");
	}
	return pizza;
}

//PizzaTestDrive.h
#ifndef __PIZZATESTDRIVE_H__
#define __PIZZATESTDRIVE_H__

class PizzaTestDrive
{
public:
	static void main();
};

#endif
//PizzaTestDrive.cpp
#include <iostream>
#include "PizzaTestDrive.h"
#include "PizzaStore.h"
#include "Pizza.h"

void PizzaTestDrive::main()
{
	std::auto_ptr<PizzaStore> nyStore(new NYPizzaStore);
	std::auto_ptr<PizzaStore> chicagoStore(new ChicagoPizzaStore);
	
	std::auto_ptr<Pizza> pizza = nyStore->orderPizza("Cheese");
	std::cout << "Ethan ordered a " + pizza->getName() + ".\n";

	pizza = nyStore->orderPizza("Clam");
	std::cout << "Lily ordered a " + pizza->getName() + ".\n";

	pizza = chicagoStore->orderPizza("Cheese");
	std::cout << "Joel ordered a " + pizza->getName() + ".\n";

	pizza = chicagoStore->orderPizza("Clam");
	std::cout << "Jane ordered a " + pizza->getName() + ".\n";
}

//main.cpp
#include <iostream>
#include "PizzaTestDrive.h"
using namespace std;

int main ()
{
	PizzaTestDrive::main();
}
输出如下：
Preparing New York Style Cheese Pizza
Dough: Thin Crust Dough
Sauce: Marinara Sauce
Cheese: Grated Reggiano Cheese
Bake for 25 minutes as 350.
Cutting the pizza into diagonal slices.
Place pizza in official PizzaStore box.
Ethan ordered a New York Style Cheese Pizza.
Preparing New York Style Clam Pizza
Dough: Thin Crust Dough
Sauce: Marinara Sauce
Cheese: Grated Reggiano Cheese
Clam: Fresh Clam
Bake for 25 minutes as 350.
Cutting the pizza into diagonal slices.
Place pizza in official PizzaStore box.
Lily ordered a New York Style Clam Pizza.
Preparing Chicago Style Cheese Pizza
Dough: Extra Thick Crust Dough
Sauce: Plum Tomato Sauce
Cheese: Shredded Mozzarella Cheese
Bake for 25 minutes as 350.
Cutting the pizza into diagonal slices.
Place pizza in official PizzaStore box.
Joel ordered a Chicago Style Cheese Pizza.
Preparing Chicago Style Clam Pizza
Dough: Extra Thick Crust Dough
Sauce: Plum Tomato Sauce
Cheese: Shredded Mozzarella Cheese
Clam: Frozen Clam
Bake for 25 minutes as 350.
Cutting the pizza into diagonal slices.
Place pizza in official PizzaStore box.
Jane ordered a Chicago Style Clam Pizza.
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//Head First 第5章 单件模式--独一无二的对象
单件模式给了我们一个全局的访问点，和全局变量一样方便，又没有全局变量的缺点。举例来说：如果将对象赋值给一个全局变量，那么你必须在程序一开始就创建好对象，万一这个对象非常耗费资源，而程序在这次的执行过程中又一直没用到它，就形成浪费了。利用单件模式，可以在需要时才创建对象。

定义单件模式
单件模式：确保一个类只有一个实例，并提供一个全局访问点。
--我们正在把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。要想取得单件实例，通过单件类是唯一的途径。
--我们也提供对这个实例的全局访问点：当你需要实例时，向类查询，它会返回单个实例。前面的例子利用延迟实例化的方式创建单件，这种做法对资源敏感的对象特别重要。
getInstance()方法是静态的，这意味着它是一个类方法，所以可以在代码的任何地方使用Singleton.getInstance()访问它。这和访问全局变量一样简单，只是多了一个优点：单件可以延迟实例化。

Java里处理多线程
只要把getInstance()变成同步（synchronized）方法，多线程灾难几乎就可以轻易解决了
public static synchronized Singleton getInstance()//通过增加synchronized关键字到getInstance()方法中，迫使每个线程在进入这个方法之前，要先等候别的线程离开该方法。就是说，不会有两个线程可以同时进入这个方法。
{
	if (uniqueInstance == null)
	{
		uniqueInstance = new Singleton();
	}
	return uniqueInstance;
	//其他有用的方法
}
这个可解决问题。但是同步会降低性能。而比所想象的还要严重一些的是：只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好uniqueInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。

能够改善多线程吗
为了要符合大多数Java应用程序，我们需要确保单件模式能在多线程的状况下正常工作。但是似乎同步getInstance()的做法将拖垮性能，可以有一些选择……
1. 如果getInstance()的性能对应用程序不是很关键，就什么都别做
如果你的应用程序可以接受getInstance()造成的额外负担，就忘了这件事吧。同步getInstance()的方法既简单又有效。但必须知道，同步一个方法可能造成程序执行效率下降100倍。因此，如果将getInstance()的程序使用在频繁运行的地方，你可能就得重新考虑了。
2. 使用“急切”创建实例，而不用延迟实例化的做法
如果应用程序问题创建并使用单件实例，或者在创建和运行时方面的负担不太繁重，你可能想要急切（eagerly，与延迟实例化相对）创建此单件，如下所示：
public class Singleton
{
	private static Singleton uniqueInstance = new Singleton();//在静态初始化器（static initializer）中创建单件。这段代码保证了线程安全（thread safe）。C++中也可以使用同样的方法定义静态变量，这样这个类的静态数据成员就会在程序运行初始将该成员初始化。
	private Singleton() {}
	public static Singleton getInstance()
	{
		return uniqueInstance;//已经有实例了，直接使用它。
	}
}
利用这个做法，我们依赖JVM在加载这个类时马上创建唯一的单件实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定先创建此实例。

//C++中代码类似，如下：
#include <iostream>
using namespace std;

class Singleton
{
public:
	static Singleton& getInstance()
	{
		return instance_;
	}
	void setValue(int val)
	{
		value_ = val;
	}
	int getValue()
	{
		return value_;
	}
private:
	Singleton(): value_(0) {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
	static Singleton instance_;//这里是改动点
	int value_;
};

Singleton Singleton::instance_;//这里是改动点

void main()
{
	Singleton& s1 = Singleton::getInstance();
	s1.getValue();
	s1.setValue(5);
	cout << s1.getValue() << endl;
	Singleton& s2 = Singleton::getInstance();
	cout << s2.getValue() << endl;
}
3. 用“双重检查加锁”，在getInstance()中减少使用同步（大话设计模式中提到的双重锁定，搜“双重锁定”）
利用双重检查加锁（double-checked locking），首先检查是否实例已经创建了，如果尚未创建，“才”进行同步。这样一来，只有第一次会同步，这正是我们想要的。
如果性能是你关心的重点，这个做法可以帮你大大地减少getInstance()的时间耗费。

问：难道我不能创建一个类，把所有的方法和变量都定义为静态的，把类直接当做一个单件
答：如果你的类自给自足，而且不依赖于复杂的初始化，那么你可以这么做。但是，因为静态初始化的控制权是在Java手上，这么做可能导致混乱，特别是当有许多类牵涉其中的时候（Effective C++条款04 确定对象初始化 中提到的不同编译单元静态对象的初始化次序问题）。这么做常常会千奇百怪一些微妙的、不容易发现的和初始化的次序有关的bug。除非你有绝对的必要使用类的单件，否则还是建议使用对象的单件，比较保险。

问：我想把单件类当成超类，设计出子类，但是我遇到了问题：究竟可以不可以继承单件类
答：继承单件类会遇到一个问题，就是构造器是私有的。不能用私有构造器来扩展类。所以必须把单件的构造器改成公开的或受保护的。但是这么一来就不算是“真正的”单件了，因为别的类也可以实例化它。
如果你果真把构造器的访问权限改了，还有另一个问题会出现。单件的实现是利用静态变量，直接继承会导致所有的派生类共享同一个实例变量，这可能不是你想要的。所以，想要让子类能工作顺利，基类必须实现注册表（Registry）功能。
在这么做之前，你得想想，继承单件能带来什么好处。就和大多数的模式一样，单件不一定适合设计进入一个库中。而且，任何现有的类，都可以轻易地加上一些代码支持单件模式。最后，如果你的应用程序大量地使用了单件模式，那么你可能需要再好好地检查你的设计。因为通常适合使用单件模式的机会不多。

问：我还是不了解为何全局变量比单件模式差。
答：在Java中，全局变量基本上就是对对象的静态引用。在这样的情况下使用全局变量会有一些缺点，我们已经提到了其中的一个：急切实例化VS.延迟实例化。
但是我们要记住这个模式的目的：确保类只有一个实例并提供全局访问。全局变量可以提供全局访问，但是不能确保只有一个实例。全局变量也会变相鼓励开发人员，用许多全局变量指向许多小对象来造成命名空间（namespace）的污染。单件不鼓励这样的现象，但单件仍然可能被滥用。

--在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量。
--确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程的问题（我们必须认定所有的程序都是多线程的）。
--小心，你如果使用多个类加载器，可能导致单件失效而产生多个实例。
//------------------------------------------------------------------------------------------------
//Head First 第6章 命令模式--封装调用
定义命令模式
命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
仔细看这个定义。我们知道一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进这个对象中。这个对象只暴露出一个execute()方法，当此方法被调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute()方法，请求的目的就能达到。

在遥控器中，我们不想每次都检查是否某个插槽都加载了命令。比方说，在这个onButtonWasPushed()方法中，我们可能需要这样的代码：
public void onButtonWasPushed(int slot)
{
	if (onCommands[slot] != NULL)
	{
		onCommands[slost].execute();
	}
}
所以，要避免上述的做法，实现一个不做事情的命令：
public class NoCommand implements Command
{
	public void execute() { } 
}
这么一来，在RemoteControl构造器上，我们将每个插槽都预先指定成NoCommand对象，以便确定每个插槽永远都有命令对象。
所以在测试的输出中，没有被明确指定命令的插槽，其命令将是默认的NoCommand对象。

模式荣誉奖：NoCommand对象是一个空对象（null object）的例子。当你不想返回一个有意义的对象时，空对象就很有用。客户也可以将处理null的责任转移到空对象。举例来说，遥控器不可能一出厂就设置了有意义的命令对象，所以提供了NoCommand对象作为代用器，当调用它的execute()方法时，这种对象什么事情都不做。
在许多设计模式中，都会看到空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式。
（组合模式中叶子节点的成员函数add()/remove()也是空实现）

如果想要一个按钮执行一组命令：
--或者将Invoker中每个按钮的命令设置为vector<Command>，然后每次按一个按钮时，依次执行每个命令的execute()，《大话设计模式》中命令模式中的Waiter就是如此设计的；
--或者继承Command类，另写一个MacroCommand类，它有一个vector<Command>的对象，而在这个命令类的execute()函数中，依次调用每个Command的.execute()。这样在Invoker看来，还是执行了一个命令的.execute()，而实际这个宏命令是一组具体命令的集合，依次执行每一个具体命令的.execute()。这个方法真是好！！！

问：如何能够实现多层次的撤销操作，换句话说，我希望能够按下撤销按钮多次，撤销到很早以前的状态。
答：好问题，其实这相当容易做到，不要只是记录最后一次被执行的命令，而使用一个堆栈记录操作过程的每一个命令（即每次execute就将此次操作记录放入堆栈中）。然后，不管什么时候按下了撤销按钮，你都可以从堆栈中取出最上层的命令，然后调用它的undo()方法。（这个堆栈的设置应该是在Invoker类中，将每次操作记录下来，而在Command类中，只实现undo()成员函数，它只需要实现自己的一次撤销功能即可，具体该调用哪个Command的undo()功能该由Invoker类来记录并调用。）

命令模式的更多用途：队列请求
工作队列类和进行计算的对象之间完全是解耦的。工作队列对象不在乎到底做些什么，它们只知道取出命令对象，然后调用其execute()方法。类似的，它们只要是实现命令模式的对象，就可以放入队列里，当线程可用时，就调用此对象的execute()方法。
命令模式的更多用途：日志请求
某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。通过新增两个方法（store()、load()在Command类中），命令模式就能够支持这一点（那是不是上面所说的多层撤销也可以把堆栈写在Command类中？？？）。在Java中，我们可以利用对象的序列化（Serialization）实现这些方法，但是一般认为序列化最好还是只用在对象持久化上（persistence）。
当我们执行命令的时候，将历史记录储存在磁盘中。一旦系统死机，就可以将命令对象重新加载，并成批地依次调用这些对象的execute()方法。
这种日志的方式对于遥控器来说没有意义，然而，有许多调用大型数据结构的动作的应用无法在每次改变发生时被快速地存储。通过使用记录日志，我们可以将上次检查点（checkpoint）之后的所有操作记录下来，如果系统出状况，从检查点开始应用这些操作。比方说，对于电子表格应用，可能想要实现的错误恢复方式是将电子表格的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。对更高级的应用而言，这些技巧可以被扩展应用到事务（transaction）处理中，也就是说，一整群操作必须全部进行完成，或者没有进行任何的操作。

命令模式允许我们将动作封装成命令对象，这样一来就可以随心所欲地储存、传递和调用它们。
--命令模式将发出请求的对象和执行请求的对象解耦。
--在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作。
--调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用。
--调用者可以接受命令当做参数，甚至在运行时动态地进行。
--命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态。
--宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。
--命令也可以用来实现日志和事务系统。

//简单的测试
//ElectricalEquipment.h
#ifndef __ELECTRICALEQUIPMENT_H__
#define __ELECTRICALEQUIPMENT_H__

class Light
{
public:
	void on();
	void off();
};

class GarageDoor
{
public:
	void up();
	void down();
};

#endif

//ElectricalEquipment.cpp
#include <iostream>
#include "ElectricalEquipment.h"

void Light::on()
{
	std::cout << "Light is on." << std::endl;
}

void Light::off()
{
	std::cout << "Light is off." << std::endl;
}

void GarageDoor::up()
{
	std::cout << "Garage door is open." << std::endl;
}

void GarageDoor::down()
{
	std::cout << "Garage door is closed." << std::endl;
}

//Command.h
#ifndef __COMMAND_H__
#define __COMMAND_H__
#include "boost/shared_ptr.hpp"

class Command
{
public:
	virtual ~Command();
	virtual void excute() = 0;//Command为所有命令声明了一个接口。调用命令对象的execute()方法，就可以让接收者进行相关的动作。这个接口也具备一个undo()方法，稍后会介绍这个方法。
};

class Light;

class LightOnCommand: public Command//这个ConcreteCommand定义了动作和接收者之间的绑定关系。调用者只要调用execute()就可以发出请求，然后由ConcreteCommand调用接收者的一个或多个动作。
{
public:
	LightOnCommand(boost::shared_ptr<Light> pLight);
	virtual void excute();
private:
	boost::shared_ptr<Light> pLight_;//接收者知道如何进行必要的工作，实现这个请求。任何类都可以当接收者。
};

class GarageDoor;

class GarageDoorOpenCommand: public Command
{
public:
	GarageDoorOpenCommand(boost::shared_ptr<GarageDoor> pGarageDoor);
	virtual void excute();
private:
	boost::shared_ptr<GarageDoor> pGarageDoor_;
};

#endif

//Command.cpp
#include "Command.h"
#include "ElectricalEquipment.h"

Command::~Command()
{

}

LightOnCommand::LightOnCommand( boost::shared_ptr<Light> pLight ): pLight_(pLight)
{

}

void LightOnCommand::excute()//这个execute()方法会调用接收者的动作，以满足请求。
{
	pLight_->on();
}

GarageDoorOpenCommand::GarageDoorOpenCommand( boost::shared_ptr<GarageDoor> pGarageDoor ):
pGarageDoor_(pGarageDoor)
{

}

void GarageDoorOpenCommand::excute()
{
	pGarageDoor_->up();
}

//SimpleRemoteControl.h
#ifndef	__SIMPLEREMOTECONTROL_H__
#define __SIMPLEREMOTECONTROL_H__
#include "boost/shared_ptr.hpp"

class Command;

class SimpleRemoteControl
{
public:
	SimpleRemoteControl();
	void setCommand(boost::shared_ptr<Command>& command);
	void buttonWasPressed();
private:
	boost::shared_ptr<Command> slot_;
};

#endif

//SimpleRemoteControl.cpp
#include "SimpleRemoteControl.h"
#include "Command.h"

SimpleRemoteControl::SimpleRemoteControl(): slot_()
{

}

void SimpleRemoteControl::setCommand( boost::shared_ptr<Command>& command )
{
	slot_ = command;
}

void SimpleRemoteControl::buttonWasPressed()
{
	slot_->excute();
}

//RemoteControlTest.h
#ifndef __REMOTECONTROLTEST_H__
#define __REMOTECONTROLTEST_H__

class RemoteControlTest
{
public:
	static void main();
};

#endif

//RemoteControlTest.cpp
#include "boost/shared_ptr.hpp"
#include "RemoteControlTest.h"
#include "ElectricalEquipment.h"
#include "Command.h"
#include "SimpleRemoteControl.h"

void RemoteControlTest::main()
{
	SimpleRemoteControl remote;//这个调用者持有一个（或多个）命令对象，并在某个时间点调用命令对象的excute()方法，将请求付诸实行。
	
	boost::shared_ptr<Light> pLight(new Light);
	boost::shared_ptr<Command> lightOn(new LightOnCommand(pLight));//客户负责创建一个ConcreteCommand，并设置其接收者，即Light类型对象pLight为接收者，它负责做具体的事情。

	boost::shared_ptr<GarageDoor> pGarageDoor(new GarageDoor);
	boost::shared_ptr<Command> garageDoorOpen(new GarageDoorOpenCommand(pGarageDoor));

	remote.setCommand(lightOn);
	remote.buttonWasPressed();
	
	remote.setCommand(garageDoorOpen);
	remote.buttonWasPressed();
}

//main.cpp
#include <iostream>
#include "RemoteControlTest.h"
using namespace std;

int main ()
{
	RemoteControlTest::main();
}
输出如下：
Light is on.
Garage door is open.
请按任意键继续. . .

//较复杂的测试
//ElectricalEquipment.h
#ifndef __ELECTRICALEQUIPMENT_H__
#define __ELECTRICALEQUIPMENT_H__
#include <string>

class Light
{
public:
	Light(const std::string& place);
	void on();
	void off();
private:
	std::string place_;
};

class GarageDoor
{
public:
	GarageDoor(const std::string& place);
	void up();
	void down();
private:
	std::string place_;
};

class Stereo
{
public:
	Stereo(const std::string& place);
	void on();
	void off();
	void setCd();
	void setDvd();
	void setRadio();
	void setVolume(int val);
private:
	std::string place_;
};

class CeilingFan
{
public:
	CeilingFan(const std::string& place);
	void on();
	void off();
private:
	std::string place_;
};

#endif

//ElectricalEquipment.cpp
#include <iostream>
#include "ElectricalEquipment.h"

Light::Light( const std::string& place ): place_(place)
{

}

void Light::on()
{
	std::cout << place_ + " light is on." << std::endl;
}

void Light::off()
{
	std::cout << place_ + " light is off." << std::endl;
}

GarageDoor::GarageDoor( const std::string& place ): place_(place)
{

}

void GarageDoor::up()
{
	std::cout << "Garage door is open." << std::endl;
}

void GarageDoor::down()
{
	std::cout << "Garage door is closed." << std::endl;
}

Stereo::Stereo( const std::string& place ): place_(place)
{

}

void Stereo::on()
{
	std::cout << place_ + " stereo is on." << std::endl;
}

void Stereo::off()
{
	std::cout << place_ + " stereo is off." << std::endl;
}

void Stereo::setCd()
{
	std::cout << place_ + " stereo is set for CD input." << std::endl;
}

void Stereo::setDvd()
{
	std::cout << place_ + " stereo is set for DVD input." << std::endl;
}

void Stereo::setRadio()
{
	std::cout << place_ + " stereo is set for Radio input." << std::endl;
}

void Stereo::setVolume(int val)
{
	std::cout << place_ + " stereo volume set to " << val << "." << std::endl;
}

CeilingFan::CeilingFan( const std::string& place ): place_(place)
{

}

void CeilingFan::on()
{
	std::cout << place_ + " ceiling fan is on." << std::endl;
}

void CeilingFan::off()
{
	std::cout << place_ + " ceiling fan is off." << std::endl;
}

//Command.h
#ifndef __COMMAND_H__
#define __COMMAND_H__
#include "boost/shared_ptr.hpp"

class Command
{
public:
	virtual ~Command();
	virtual void execute() = 0;
};

class NoCommand: public Command
{
public:
	virtual void execute();
};

class Light;

class LightOnCommand: public Command
{
public:
	LightOnCommand(boost::shared_ptr<Light> pLight);
	virtual void execute();
private:
	boost::shared_ptr<Light> pLight_;
};

class LightOffCommand: public Command
{
public:
	LightOffCommand(boost::shared_ptr<Light> pLight);
	virtual void execute();
private:
	boost::shared_ptr<Light> pLight_;
};

class GarageDoor;

class GarageDoorOpenCommand: public Command
{
public:
	GarageDoorOpenCommand(boost::shared_ptr<GarageDoor> pGarageDoor);
	virtual void execute();
private:
	boost::shared_ptr<GarageDoor> pGarageDoor_;
};

class GarageDoorClosedCommand: public Command
{
public:
	GarageDoorClosedCommand(boost::shared_ptr<GarageDoor> pGarageDoor);
	virtual void execute();
private:
	boost::shared_ptr<GarageDoor> pGarageDoor_;
};

class Stereo;

class StereoOnWithCdCommand: public Command
{
public:
	StereoOnWithCdCommand(boost::shared_ptr<Stereo> pStereo);
	virtual void execute();
private:
	boost::shared_ptr<Stereo> pStereo_;
};

class StereoOffWithCdCommand: public Command
{
public:
	StereoOffWithCdCommand(boost::shared_ptr<Stereo> pStereo);
	virtual void execute();
private:
	boost::shared_ptr<Stereo> pStereo_;
};

class CeilingFan;

class CeilingFanOnCommand: public Command
{
public:
	CeilingFanOnCommand(boost::shared_ptr<CeilingFan> pCeilingFan);
	virtual void execute();
private:
	boost::shared_ptr<CeilingFan> pCeilingFan_;
};

class CeilingFanOffCommand: public Command
{
public:
	CeilingFanOffCommand(boost::shared_ptr<CeilingFan> pCeilingFan);
	virtual void execute();
private:
	boost::shared_ptr<CeilingFan> pCeilingFan_;
};

#endif

//Command.cpp
#include "Command.h"
#include "ElectricalEquipment.h"

Command::~Command()
{

}

LightOnCommand::LightOnCommand( boost::shared_ptr<Light> pLight ): pLight_(pLight)
{

}

void LightOnCommand::execute()
{
	pLight_->on();
}

LightOffCommand::LightOffCommand( boost::shared_ptr<Light> pLight ): pLight_(pLight)
{

}

void LightOffCommand::execute()
{
	pLight_->off();
}

GarageDoorOpenCommand::GarageDoorOpenCommand( boost::shared_ptr<GarageDoor> pGarageDoor ):
pGarageDoor_(pGarageDoor)
{

}

void GarageDoorOpenCommand::execute()
{
	pGarageDoor_->up();
}

void NoCommand::execute()
{

}

GarageDoorClosedCommand::GarageDoorClosedCommand( boost::shared_ptr<GarageDoor> pGarageDoor ):
pGarageDoor_(pGarageDoor)
{

}

void GarageDoorClosedCommand::execute()
{
	pGarageDoor_->down();
}

StereoOnWithCdCommand::StereoOnWithCdCommand( boost::shared_ptr<Stereo> pStereo ): pStereo_(pStereo)
{

}

void StereoOnWithCdCommand::execute()
{
	pStereo_->on();
	pStereo_->setCd();
	pStereo_->setVolume(11);
}

StereoOffWithCdCommand::StereoOffWithCdCommand( boost::shared_ptr<Stereo> pStereo ): pStereo_(pStereo)
{

}

void StereoOffWithCdCommand::execute()
{
	pStereo_->off();
}

CeilingFanOnCommand::CeilingFanOnCommand( boost::shared_ptr<CeilingFan> pCeilingFan ): pCeilingFan_(pCeilingFan)
{

}

void CeilingFanOnCommand::execute()
{
	pCeilingFan_->on();
}

CeilingFanOffCommand::CeilingFanOffCommand( boost::shared_ptr<CeilingFan> pCeilingFan ): pCeilingFan_(pCeilingFan)
{

}

void CeilingFanOffCommand::execute()
{
	pCeilingFan_->off();
}

//RemoteControl.h
#ifndef	__REMOTECONTROL_H__
#define __REMOTECONTROL_H__
#include <vector>
#include <string>
#include "boost/shared_ptr.hpp"

class Command;

class RemoteControl
{
public:
	RemoteControl();
	void setCommand(int slot, boost::shared_ptr<Command>& onCommand, boost::shared_ptr<Command>& offCommand);
	void onButtonWasPressed(int slot);
	void offButtonWasPressed(int slot);
	std::string getAllCommandsString();
private:
	const int slotsNumber_;
	std::vector<boost::shared_ptr<Command> > onCommandsVec_;
	std::vector<boost::shared_ptr<Command> > offCommandsVec_;
};

#endif

//RemoteControl.cpp
#include <algorithm>
#include <sstream>
#include <typeinfo>
#include "RemoteControl.h"
#include "Command.h"

RemoteControl::RemoteControl(): slotsNumber_(7), onCommandsVec_(slotsNumber_), offCommandsVec_(slotsNumber_)
{
	fill(onCommandsVec_.begin(), onCommandsVec_.end(), boost::shared_ptr<Command>(new NoCommand));
	fill(offCommandsVec_.begin(), offCommandsVec_.end(), boost::shared_ptr<Command>(new NoCommand));
}

void RemoteControl::setCommand( int slot, boost::shared_ptr<Command>& onCommand, boost::shared_ptr<Command>& offCommand )
{
	onCommandsVec_[slot] = onCommand;
	offCommandsVec_[slot] = offCommand;
}

void RemoteControl::onButtonWasPressed( int slot )
{
	onCommandsVec_[slot]->execute();
}

void RemoteControl::offButtonWasPressed( int slot )
{
	offCommandsVec_[slot]->execute();
}

std::string RemoteControl::getAllCommandsString()
{
	std::string commandsString("\n------ Remote Control ------\n");
	for (int i = 0; i < slotsNumber_; ++i)
	{
		std::stringstream ss;
		ss << "[slot " << i << "] " << typeid(*onCommandsVec_[i].get()).name() << "    "
			<< typeid(*offCommandsVec_[i].get()).name() << "\n";
		commandsString.append(ss.str());
	}
	return commandsString;
}

//RemoteControlTest.h
#ifndef __REMOTECONTROLTEST_H__
#define __REMOTECONTROLTEST_H__

class RemoteControlTest
{
public:
	static void main();
};

#endif

//RemoteControlTest.cpp
#include "boost/shared_ptr.hpp"
#include "RemoteControlTest.h"
#include "ElectricalEquipment.h"
#include "Command.h"
#include "RemoteControl.h"

void RemoteControlTest::main()
{
	RemoteControl remoteControl;
	
	boost::shared_ptr<Light> pLivingRoomLight(new Light("Living Room"));
	boost::shared_ptr<Light> pKitchenLight(new Light("Kitchen"));
	boost::shared_ptr<CeilingFan> pCeilingFan(new CeilingFan("Living Room"));
	boost::shared_ptr<GarageDoor> pGarageDoor(new GarageDoor(""));
	boost::shared_ptr<Stereo> pStereo(new Stereo("Living Room"));
	
	boost::shared_ptr<Command> pLiveingRoomLightOn(new LightOnCommand(pLivingRoomLight));
	boost::shared_ptr<Command> pLiveingRoomLightOff(new LightOffCommand(pLivingRoomLight));
	boost::shared_ptr<Command> pKitchenLightOn(new LightOnCommand(pKitchenLight));
	boost::shared_ptr<Command> pKitchenLightOff(new LightOffCommand(pKitchenLight));

	boost::shared_ptr<Command> pCeilingFanOn(new CeilingFanOnCommand(pCeilingFan));
	boost::shared_ptr<Command> pCeilingFanOff(new CeilingFanOffCommand(pCeilingFan));

	boost::shared_ptr<Command> garageDoorOpen(new GarageDoorOpenCommand(pGarageDoor));
	boost::shared_ptr<Command> garageDoorClosed(new GarageDoorClosedCommand(pGarageDoor));

	boost::shared_ptr<Command> pStereoOn(new StereoOnWithCdCommand(pStereo));
	boost::shared_ptr<Command> pStereoOff(new StereoOffWithCdCommand(pStereo));

	remoteControl.setCommand(0, pLiveingRoomLightOn, pLiveingRoomLightOff);
	remoteControl.setCommand(1, pKitchenLightOn, pKitchenLightOff);
	remoteControl.setCommand(2, pCeilingFanOn, pCeilingFanOff);
	remoteControl.setCommand(3, pStereoOn, pStereoOff);

	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.onButtonWasPressed(0);
	remoteControl.offButtonWasPressed(0);
	remoteControl.onButtonWasPressed(1);
	remoteControl.offButtonWasPressed(1);
	remoteControl.onButtonWasPressed(2);
	remoteControl.offButtonWasPressed(2);
	remoteControl.onButtonWasPressed(3);
	remoteControl.offButtonWasPressed(3);
}

//main.cpp
#include <iostream>
#include "RemoteControlTest.h"
using namespace std;

int main ()
{
	RemoteControlTest::main();
}
输出如下：

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class LightOnCommand    class LightOffCommand
[slot 2] class CeilingFanOnCommand    class CeilingFanOffCommand
[slot 3] class StereoOnWithCdCommand    class StereoOffWithCdCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand

Living Room light is on.
Living Room light is off.
Kitchen light is on.
Kitchen light is off.
Living Room ceiling fan is on.
Living Room ceiling fan is off.
Living Room stereo is on.
Living Room stereo is set for CD input.
Living Room stereo volume set to 11.
Living Room stereo is off.
请按任意键继续. . .

//带撤销功能的命令模式，一个是电灯的最简单状态的撤销，一个是保存状态的电扇转速的撤销
//ElectricalEquimpent.h
#ifndef __ELECTRICALEQUIPMENT_H__
#define __ELECTRICALEQUIPMENT_H__
#include <string>

class Light
{
public:
	Light(const std::string& place);
	void on();
	void off();
private:
	std::string place_;
};

class GarageDoor
{
public:
	GarageDoor(const std::string& place);
	void up();
	void down();
private:
	std::string place_;
};

class Stereo
{
public:
	Stereo(const std::string& place);
	void on();
	void off();
	void setCd();
	void setDvd();
	void setRadio();
	void setVolume(int val);
private:
	std::string place_;
};

class CeilingFan
{
public:
	enum RotateSpeed{OFF, LOW, MEDIUM, HIGH};

	CeilingFan(const std::string& place);
	void high();
	void medium();
	void low();
	void off();
	int getSpeed();
private:
	std::string place_;
	RotateSpeed speed_;
};

#endif

//ElectricalEquimpent.cpp
#include <iostream>
#include "ElectricalEquipment.h"

Light::Light( const std::string& place ): place_(place)
{

}

void Light::on()
{
	std::cout << place_ + " light is on." << std::endl;
}

void Light::off()
{
	std::cout << place_ + " light is off." << std::endl;
}

GarageDoor::GarageDoor( const std::string& place ): place_(place)
{

}

void GarageDoor::up()
{
	std::cout << "Garage door is open." << std::endl;
}

void GarageDoor::down()
{
	std::cout << "Garage door is closed." << std::endl;
}

Stereo::Stereo( const std::string& place ): place_(place)
{

}

void Stereo::on()
{
	std::cout << place_ + " stereo is on." << std::endl;
}

void Stereo::off()
{
	std::cout << place_ + " stereo is off." << std::endl;
}

void Stereo::setCd()
{
	std::cout << place_ + " stereo is set for CD input." << std::endl;
}

void Stereo::setDvd()
{
	std::cout << place_ + " stereo is set for DVD input." << std::endl;
}

void Stereo::setRadio()
{
	std::cout << place_ + " stereo is set for Radio input." << std::endl;
}

void Stereo::setVolume(int val)
{
	std::cout << place_ + " stereo volume set to " << val << "." << std::endl;
}

CeilingFan::CeilingFan( const std::string& place ): place_(place), speed_(OFF)
{

}

void CeilingFan::off()
{
	speed_ = OFF;
	std::cout << place_ + " ceiling fan is off." << std::endl;
}

void CeilingFan::high()
{
	speed_ = HIGH;
	std::cout << place_ + " ceiling fan is high." << std::endl;
}

void CeilingFan::medium()
{
	speed_ = MEDIUM;
	std::cout << place_ + " ceiling fan is medium." << std::endl;
}

void CeilingFan::low()
{
	speed_ = LOW;
	std::cout << place_ + " ceiling fan is low." << std::endl;
}

int CeilingFan::getSpeed()
{
	return speed_;
}

//Command.h
#ifndef __COMMAND_H__
#define __COMMAND_H__
#include <list>
#include "boost/shared_ptr.hpp"

class Command
{
public:
	virtual ~Command();
	virtual void execute() = 0;
	virtual void undo() = 0;
};

class NoCommand: public Command
{
public:
	virtual void execute();
	virtual void undo();
};

class Light;

class LightOnCommand: public Command
{
public:
	LightOnCommand(boost::shared_ptr<Light> pLight);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<Light> pLight_;
};

class LightOffCommand: public Command
{
public:
	LightOffCommand(boost::shared_ptr<Light> pLight);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<Light> pLight_;
};

class GarageDoor;

class GarageDoorOpenCommand: public Command
{
public:
	GarageDoorOpenCommand(boost::shared_ptr<GarageDoor> pGarageDoor);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<GarageDoor> pGarageDoor_;
};

class GarageDoorClosedCommand: public Command
{
public:
	GarageDoorClosedCommand(boost::shared_ptr<GarageDoor> pGarageDoor);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<GarageDoor> pGarageDoor_;
};

class Stereo;

class StereoOnWithCdCommand: public Command
{
public:
	StereoOnWithCdCommand(boost::shared_ptr<Stereo> pStereo);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<Stereo> pStereo_;
};

class StereoOffWithCdCommand: public Command
{
public:
	StereoOffWithCdCommand(boost::shared_ptr<Stereo> pStereo);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<Stereo> pStereo_;
};

class CeilingFan;

class CeilingFanHighCommand: public Command
{
public:
	CeilingFanHighCommand(boost::shared_ptr<CeilingFan> pCeilingFan);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<CeilingFan> pCeilingFan_;
	int preSpeed_;
};

class CeilingFanMediumCommand: public Command
{
public:
	CeilingFanMediumCommand(boost::shared_ptr<CeilingFan> pCeilingFan);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<CeilingFan> pCeilingFan_;
	int preSpeed_;
};

class CeilingFanOffCommand: public Command
{
public:
	CeilingFanOffCommand(boost::shared_ptr<CeilingFan> pCeilingFan);
	virtual void execute();
	virtual void undo();
private:
	boost::shared_ptr<CeilingFan> pCeilingFan_;
	int preSpeed_;
};

class MacroCommand: public Command
{
public:
	MacroCommand(std::list<boost::shared_ptr<Command> >& commandList);
	virtual void execute();
	virtual void undo();
private:
	std::list<boost::shared_ptr<Command> > commandList_;
};

#endif

//Command.cpp
#include "Command.h"
#include "ElectricalEquipment.h"

Command::~Command()
{

}

LightOnCommand::LightOnCommand( boost::shared_ptr<Light> pLight ): pLight_(pLight)
{

}

void LightOnCommand::execute()
{
	pLight_->on();
}

void LightOnCommand::undo()
{
	pLight_->off();
}

LightOffCommand::LightOffCommand( boost::shared_ptr<Light> pLight ): pLight_(pLight)
{

}

void LightOffCommand::execute()
{
	pLight_->off();
}

void LightOffCommand::undo()
{
	pLight_->on();
}

GarageDoorOpenCommand::GarageDoorOpenCommand( boost::shared_ptr<GarageDoor> pGarageDoor ):
pGarageDoor_(pGarageDoor)
{

}

void GarageDoorOpenCommand::execute()
{
	pGarageDoor_->up();
}

void GarageDoorOpenCommand::undo()
{
	pGarageDoor_->down();
}

void NoCommand::execute()
{

}

void NoCommand::undo()
{

}

GarageDoorClosedCommand::GarageDoorClosedCommand( boost::shared_ptr<GarageDoor> pGarageDoor ):
pGarageDoor_(pGarageDoor)
{

}

void GarageDoorClosedCommand::execute()
{
	pGarageDoor_->down();
}

void GarageDoorClosedCommand::undo()
{
	pGarageDoor_->up();
}

StereoOnWithCdCommand::StereoOnWithCdCommand( boost::shared_ptr<Stereo> pStereo ): pStereo_(pStereo)
{

}

void StereoOnWithCdCommand::execute()
{
	pStereo_->on();
	pStereo_->setCd();
	pStereo_->setVolume(11);
}

void StereoOnWithCdCommand::undo()
{
	pStereo_->off();
}

StereoOffWithCdCommand::StereoOffWithCdCommand( boost::shared_ptr<Stereo> pStereo ): pStereo_(pStereo)
{

}

void StereoOffWithCdCommand::execute()
{
	pStereo_->off();
}

void StereoOffWithCdCommand::undo()
{
	pStereo_->on();
}

CeilingFanOffCommand::CeilingFanOffCommand( boost::shared_ptr<CeilingFan> pCeilingFan ): 
pCeilingFan_(pCeilingFan), preSpeed_(0)
{

}

void CeilingFanOffCommand::execute()
{
	preSpeed_ = pCeilingFan_->getSpeed();
	pCeilingFan_->off();
}

void CeilingFanOffCommand::undo()
{
	if (preSpeed_ == CeilingFan::HIGH)
	{
		pCeilingFan_->high();
	}
	else if (preSpeed_ == CeilingFan::MEDIUM)
	{
		pCeilingFan_->medium();
	}
	else if (preSpeed_ == CeilingFan::LOW)
	{
		pCeilingFan_->low();
	}
	else if (preSpeed_ == CeilingFan::OFF)
	{
		pCeilingFan_->off();
	}
}

CeilingFanHighCommand::CeilingFanHighCommand( boost::shared_ptr<CeilingFan> pCeilingFan ): 
pCeilingFan_(pCeilingFan), preSpeed_(0)
{

}

void CeilingFanHighCommand::execute()
{
	preSpeed_ = pCeilingFan_->getSpeed();
	pCeilingFan_->high();
}

void CeilingFanHighCommand::undo()
{
	if (preSpeed_ == CeilingFan::HIGH)
	{
		pCeilingFan_->high();
	}
	else if (preSpeed_ == CeilingFan::MEDIUM)
	{
		pCeilingFan_->medium();
	}
	else if (preSpeed_ == CeilingFan::LOW)
	{
		pCeilingFan_->low();
	}
	else if (preSpeed_ == CeilingFan::OFF)
	{
		pCeilingFan_->off();
	}
}

CeilingFanMediumCommand::CeilingFanMediumCommand( boost::shared_ptr<CeilingFan> pCeilingFan ):
pCeilingFan_(pCeilingFan), preSpeed_(0)
{

}

void CeilingFanMediumCommand::execute()
{
	preSpeed_ = pCeilingFan_->getSpeed();
	pCeilingFan_->medium();
}

void CeilingFanMediumCommand::undo()
{
	if (preSpeed_ == CeilingFan::HIGH)
	{
		pCeilingFan_->high();
	}
	else if (preSpeed_ == CeilingFan::MEDIUM)
	{
		pCeilingFan_->medium();
	}
	else if (preSpeed_ == CeilingFan::LOW)
	{
		pCeilingFan_->low();
	}
	else if (preSpeed_ == CeilingFan::OFF)
	{
		pCeilingFan_->off();
	}
}

MacroCommand::MacroCommand( std::list<boost::shared_ptr<Command> >& commandList ):
commandList_(commandList)
{

}

void MacroCommand::execute()
{
	for (std::list<boost::shared_ptr<Command> >::iterator iter = commandList_.begin(); iter != commandList_.end(); ++iter)
	{
		(*iter)->execute();
	}
}

void MacroCommand::undo()
{
	for (std::list<boost::shared_ptr<Command> >::iterator iter = commandList_.begin(); iter != commandList_.end(); ++iter)
	{
		(*iter)->undo();
	}
}

//RemoteControl.h
#ifndef	__REMOTECONTROL_H__
#define __REMOTECONTROL_H__
#include <vector>
#include <string>
#include "boost/shared_ptr.hpp"

class Command;

class RemoteControl
{
public:
	RemoteControl();
	void setCommand(int slot, boost::shared_ptr<Command>& onCommand, boost::shared_ptr<Command>& offCommand);
	void onButtonWasPressed(int slot);
	void offButtonWasPressed(int slot);
	void undoButtonWasPressed();
	std::string getAllCommandsString();
private:
	const int slotsNumber_;
	std::vector<boost::shared_ptr<Command> > onCommandsVec_;
	std::vector<boost::shared_ptr<Command> > offCommandsVec_;
	boost::shared_ptr<Command> undoCommand_;
};

#endif

//RemoteControl.cpp
#include <algorithm>
#include <sstream>
#include <typeinfo>
#include "RemoteControl.h"
#include "Command.h"

RemoteControl::RemoteControl(): 
slotsNumber_(7), onCommandsVec_(slotsNumber_), offCommandsVec_(slotsNumber_), undoCommand_(new NoCommand)
{
	fill(onCommandsVec_.begin(), onCommandsVec_.end(), boost::shared_ptr<Command>(new NoCommand));
	fill(offCommandsVec_.begin(), offCommandsVec_.end(), boost::shared_ptr<Command>(new NoCommand));
}

void RemoteControl::setCommand( int slot, boost::shared_ptr<Command>& onCommand, boost::shared_ptr<Command>& offCommand )
{
	onCommandsVec_[slot] = onCommand;
	offCommandsVec_[slot] = offCommand;
}

void RemoteControl::onButtonWasPressed( int slot )
{
	onCommandsVec_[slot]->execute();
	undoCommand_ = onCommandsVec_[slot];
}

void RemoteControl::offButtonWasPressed( int slot )
{
	offCommandsVec_[slot]->execute();
	undoCommand_ = offCommandsVec_[slot];
}


void RemoteControl::undoButtonWasPressed()
{
	undoCommand_->undo();
}

std::string RemoteControl::getAllCommandsString()
{
	std::string commandsString("\n------ Remote Control ------\n");
	std::stringstream ss;
	for (int i = 0; i < slotsNumber_; ++i)
	{
		ss << "[slot " << i << "] " << typeid(*onCommandsVec_[i].get()).name() << "    "
			<< typeid(*offCommandsVec_[i].get()).name() << "\n";
	}
	ss << "[undo] " << typeid(*undoCommand_.get()).name() << "\n";
	commandsString.append(ss.str());
	return commandsString;
}

//RemoteControlTest.h
#ifndef __REMOTECONTROLTEST_H__
#define __REMOTECONTROLTEST_H__

class RemoteControlTest
{
public:
	static void main();
};

#endif

//RemoteControlTest.cpp
#include <list>
#include "boost/shared_ptr.hpp"
#include "RemoteControlTest.h"
#include "ElectricalEquipment.h"
#include "Command.h"
#include "RemoteControl.h"

void RemoteControlTest::main()
{
	RemoteControl remoteControl;
	
	boost::shared_ptr<Light> pLivingRoomLight(new Light("Living Room"));
	boost::shared_ptr<CeilingFan> pCeilingFan(new CeilingFan("Living Room"));
	
	boost::shared_ptr<Command> pLiveingRoomLightOn(new LightOnCommand(pLivingRoomLight));
	boost::shared_ptr<Command> pLiveingRoomLightOff(new LightOffCommand(pLivingRoomLight));

	boost::shared_ptr<Command> pCeilingFanHigh(new CeilingFanHighCommand(pCeilingFan));
	boost::shared_ptr<Command> pCeilingFanMedium(new CeilingFanMediumCommand(pCeilingFan));
	boost::shared_ptr<Command> pCeilingFanOff(new CeilingFanOffCommand(pCeilingFan));

	remoteControl.setCommand(0, pLiveingRoomLightOn, pLiveingRoomLightOff);
	remoteControl.setCommand(1, pCeilingFanMedium, pCeilingFanOff);
	remoteControl.setCommand(2, pCeilingFanHigh, pCeilingFanOff);

	//std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.onButtonWasPressed(0);
	remoteControl.offButtonWasPressed(0);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.undoButtonWasPressed();

	remoteControl.offButtonWasPressed(0);
	remoteControl.onButtonWasPressed(0);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.undoButtonWasPressed();

	remoteControl.onButtonWasPressed(1);
	remoteControl.offButtonWasPressed(1);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.undoButtonWasPressed();

	remoteControl.onButtonWasPressed(2);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.undoButtonWasPressed();


	boost::shared_ptr<GarageDoor> pGarageDoor(new GarageDoor(""));
	boost::shared_ptr<Stereo> pStereo(new Stereo("Living Room"));

	boost::shared_ptr<Command> garageDoorOpen(new GarageDoorOpenCommand(pGarageDoor));
	boost::shared_ptr<Command> garageDoorClosed(new GarageDoorClosedCommand(pGarageDoor));

	boost::shared_ptr<Command> pStereoOn(new StereoOnWithCdCommand(pStereo));
	boost::shared_ptr<Command> pStereoOff(new StereoOffWithCdCommand(pStereo));

	std::list<boost::shared_ptr<Command> > commandOnList;
	commandOnList.push_back(garageDoorOpen);
	commandOnList.push_back(pStereoOn);

	std::list<boost::shared_ptr<Command> > commandOffList;
	commandOffList.push_back(garageDoorClosed);
	commandOffList.push_back(pStereoOff);

	boost::shared_ptr<Command> macroOnCommand(new MacroCommand(commandOnList));
	boost::shared_ptr<Command> macroOffCommand(new MacroCommand(commandOffList));

	remoteControl.setCommand(3, macroOnCommand, macroOffCommand);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.onButtonWasPressed(3);
	std::cout << remoteControl.getAllCommandsString() << std::endl;
	remoteControl.offButtonWasPressed(3);
}

//main.cpp
#include <iostream>
#include "RemoteControlTest.h"
using namespace std;

int main ()
{
	RemoteControlTest::main();
}
输出如下：
Living Room light is on.
Living Room light is off.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class NoCommand    class NoCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class LightOffCommand

Living Room light is on.
Living Room light is off.
Living Room light is on.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class NoCommand    class NoCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class LightOnCommand

Living Room light is off.
Living Room ceiling fan is medium.
Living Room ceiling fan is off.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class NoCommand    class NoCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class CeilingFanOffCommand

Living Room ceiling fan is medium.
Living Room ceiling fan is high.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class NoCommand    class NoCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class CeilingFanHighCommand

Living Room ceiling fan is medium.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class MacroCommand    class MacroCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class CeilingFanHighCommand

Garage door is open.
Living Room stereo is on.
Living Room stereo is set for CD input.
Living Room stereo volume set to 11.

------ Remote Control ------
[slot 0] class LightOnCommand    class LightOffCommand
[slot 1] class CeilingFanMediumCommand    class CeilingFanOffCommand
[slot 2] class CeilingFanHighCommand    class CeilingFanOffCommand
[slot 3] class MacroCommand    class MacroCommand
[slot 4] class NoCommand    class NoCommand
[slot 5] class NoCommand    class NoCommand
[slot 6] class NoCommand    class NoCommand
[undo] class MacroCommand

Garage door is closed.
Living Room stereo is off.
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//Head First 第7章 适配器模式与外观模式--随遇而安
Duch的quack()被调用时，适配器咯咯叫，fly()被调用时，适配器飞行了五次。testDuck()方法根本不知道，这其实是一只假装成鸭子的火鸡！
客户是依据目标接口实现的；
适配器实现了目标接口，并持有被适配者的实例；（火鸡适配器实现了目标接口，并引用一个被适配者。）
被适配者接口。（火鸡就是被适配者。）
客户使用适配器的过程如下：
1. 客户通过目标接口调用适配器的方法对适配器发出请求。
2. 适配器使用被适配者接口把请求换成被适配者的一个或多个调用接口。
3. 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。
请注意：客户和被适配者是解耦的，一个不知道另一个。

问：一个适配器需要做多少“适配”的工作，如果我需要实现一个很大的目标接口，似乎有“很多”工作要做。
答：的确如此。实现一个适配器所需要进行的工作，的确和目标接口的大小成正比。如果不用适配器，你就必须改写客户端的代码来调用这个新的接口，将会花许多力气来做大量的调查工作和代码改写工作。相比之下，提供一个适配器表，将所有的改变封装在一个类中，是比较好的做法。
问：一个适配器只能够封装一个类吗
答：适配器模式的工作是将一个接口转换成另一个。虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者。你也可能遇到一些状况，需要让一个适配器包装多个被适配者。
这涉及另一个模式，被称为外观模式（Facade Pattern），人们常常将外观模式和适配器模式混为一谈，稍后将对此详细说明。

当需要同时支持新旧接口时，可以创建一个双向的适配器，就必须实现所涉及的两个接口。这样，这个适配器可以当做旧的接口，或者当做新的接口使用。

定义适配器模式
适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
这个模式可以通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。
客户只看到目标接口，适配器实现目标接口，适配器与被适配者组合，所有的请求都委托给被适配者。
这个适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者：这种做法还有额外的优点，那就是，被适配者的任何子类，都可以搭配着适配器使用。
注意，这个模式是如何把客户和接口绑定起来，而不是和实现绑定起来的。我们可以使用数个适配器，每一个都负责转换不同组的后台类。或者，也可以加上新的实现，只要它们遵守目标接口就可以。

对象和类的适配器
有两种适配器：对象适配器和类适配器。
对象适配器是使用组合来适配被适配者，类适配器是继承被适配者和目标类。
对象适配器和类适配器唯一的差别就在于类适配器继承了Target和Adaptee。而对象适配器利用组合的方式将请求传送给被适配者。

类适配器：客户认识他正在和鸭子沟通，目标是鸭子类，是客户在其上调用方法的类。通过扩展两个类（鸭子和火鸡），适配器使得火鸡可以响应对鸭子的请求。火鸡类没有鸭子的方法，但是适配器可以将对鸭子方法的调用，转接到调用火鸡方法。（这里对鸭子方法的调用，转接到调用火鸡方法）
对象适配器：客户认为他正在和鸭子沟通，就如同类适配器目标是鸭子类，这是客户所调用的方法。适配器实现了鸭子的接口，但它收到方法调用时，会委托给火鸡。感谢适配器，火鸡（被适配者）会接到客户作用于鸭子接口上的调用。

对象适配器：使用组合，不仅可以适配某个类，也可以适配该类的任何子类。
类适配器：做不到这一点，只能够采用某个特定的被适配类。但是有一个很大的优点，就是：不需要重新实现整个被适配者。必要的时候，也可以覆盖被适配者的行为，因为它利用继承的方式。

外观模式：它改变接口的原因是为了简化接口。它将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观。

问：如果外观封装了子系统的类，那么需要低层功能的客户如何接触这些类
答：外观没有“封装”子系统的类，外观只提供简化的接口。所以客户如果觉得有必要，依然可以直接使用子系统的类。这是外观模式一个很好的特征，提供简化的接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用。
问：除了能够提供一个比较简单的接口之外，外观模式还有其他的优点吗
答：外观模式也允许你将客户实现从任何子系统中解耦。比方说，你想要升级你的家族影院，采用全新的和以前不一样接口组件。如果当初你的客户代码是针对外观而不是针对子系统编写的，现在你就不需要改变客户代码，只需要修改外观代码（而且有可能厂商会提供新版的外观代码）。外观不只是简化了接口，也将客户从组件的子系统中解耦。
问：我可不可以这样说，适配器模式和外观模式之间的差异在于：适配器包装一个类，而外观可以代表许多类
答：不对！适配器模式将一个或多个类接口变成客户所期望的一个接口。虽然大多数教科书所采用的例子中适配器只适配一个类，但是你可以适配许多类来提供一个接口让客户编码。类似地，一个外观也可以只针对一个拥有复杂接口的类提供简化的接口。两种模式的差异，不在于它们“包装”了几个类，而是在于它们的意图。适配器模式的意图是，“改变”接口符合客户的期望；而外观模式的意图是，提供子系统的一个简化接口。外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同接口。

定义外观模式
想要使用外观模式，我们创建了一个接口简化而统一的类，用来包装系统中的一个或多个复杂的类。外观模式允许我们让客户和子系统之间避免紧耦合。
外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
这很容易理解，但是请务必记得模式的意图。这个定义清楚地告诉我们，外观的意图是要提供一个简单的接口，好让一个子系统更易于使用。从这个模式的类图可以感受到这一点。

“最少知识”原则
设计原则：最少知识原则：只和你的密友谈话。
这是说，当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。
这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要花许多成本维护，也会因为太复杂而不容易被其他人了解。

如何不要赢得太多的朋友和影响太多的对象
这个原则提供了一些方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：
--该对象本身
--被当做方法的参数而传递进来的对象
--此方法所创建或实例化的任何对象
请注意，上述三个方针告诉我们，如果某对象是调用其他的方法的返回结果，不要调用该对象的方法！
--对象的任何组件
把“组件”想象成被实例变量所引用的任何对象，换句话说，把这想象成是“有一个”（HAS-A）关系。

这听起来有些严厉，如果调用从另一个调用中返回的对象的方法，会有什么害处呢。如果我们这样做，相当于向另一个对象的子部分发请求（而增加我们直接认识的对象数目）。在这些情况下，原则要我们改为要求该对象为我们做出请求，这我们就不需要认识该对象的组件了（让我们的朋友圈子维持在最小的状态）。比方说：
public float getTemp()//不采用这个原则
{
	//这里我们从气象站取得了温度计（thermometer）对象，然后再从温度计对象取得温度
	Thermometer thermometer = station.getThermometer();
	return thermometer.getTemperature();
}

public float getTemp()//采用这个原则
{
	return station.getTemperature();//应用此原则时，我们在气象站中加进一个方法，用来向温度计请求温度。这可以减少我们所依赖的类的数目。
}

将方法调用保持在界限内
这是一个汽车类，展示调用方法的各种做法，同时还能够遵守最少知识原则：
public class Car
{
	Engine engine;//这是类的一个组件，我们能够调用它的方法。
	//其他实例变量
	public Car()
	{
		//初始化发动机
	}
	public void start(Key key)
	{
		Doors doors = new Doors();//在这里创建了一个新的对象，它的方法可以被调用
		boolean authorized = key.turns();//被当做参数传进来的对象，其方法可以被调用
		if (authorized)
		{
			engine.start();//可以调用对象组件的方法
			updateDashboardDisplay();//可以调用同一个对象内的本地方法（local method）
			doors.lock();//可以调用你所创建或实例化的对象的方法
		}
	}
	public void updateDashboardDisplay()
	{
		//更新显示
	}
}

问：采用最少知识原则有什么缺点吗
答：是的，虽然这个原则减少了对象之间的依赖，研究显示这会减少软件的维护成本；但是采用这个原则也会导致更多的“包装”类被制造出来，以处理和其他组件的沟通，这可能会导致复杂度和开发时间的增加，并降低运行时的性能。

--当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。
--当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。
--适配器改变接口以符合客户的期望。
--外观将客户从一个复杂的子系统中解耦。
--实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。
--实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。
--适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。
--完全可以为一个子系统实现一个以上的外观。
--适配器将一个对象包装起来以改为其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。

//适配器模式练习
//Duck.h
#ifndef __DUCK_H__
#define __DUCK_H__

class Duck
{
public:
	virtual ~Duck();
	virtual void quack() = 0;
	virtual void fly() = 0;
};

class Mallard: public Duck
{
public:
	virtual void quack();
	virtual void fly();
};
#endif

//Duck.cpp
#include <iostream>
#include "Duck.h"

Duck::~Duck()
{

}

void Mallard::quack()
{
	std::cout << "Quack." << std::endl;
}

void Mallard::fly()
{
	std::cout << "I'm flying." << std::endl;
}

//Turkey.h
#ifndef __TURKEY_H__
#define __TURKEY_H__

class Turkey
{
public:
	virtual ~Turkey();
	virtual void gobble() = 0;
	virtual void fly() = 0;
};

class WildTurkey: public Turkey
{
public:
	virtual void gobble();
	virtual void fly();
};
#endif

//Turkey.cpp
#include <iostream>
#include "Turkey.h"

Turkey::~Turkey()
{

}

void WildTurkey::gobble()
{
	std::cout << "Gobble, gobble." << std::endl;
}

void WildTurkey::fly()
{
	std::cout << "I'm flying a short distance." << std::endl;
}

//TurkeyAdapter.h
#ifndef __TURKEYADAPTER_H__
#define __TURKEYADAPTER_H__
#include "Duck.h"

//class Duck;//TurkeyAdapter继承了类Duck，则一定要知道Duck类的完整声明，只有一个Duck的前向声明是不够的
class Turkey;

class TurkeyAdapter: public Duck
{
public:
	TurkeyAdapter(Turkey& turkey);
	virtual void quack();
	virtual void fly();
private:
	Turkey& turkey_;
};
#endif

//TurkeyAdapter.cpp
#include "TurkeyAdapter.h"
#include "Turkey.h"
#include "Duck.h"

TurkeyAdapter::TurkeyAdapter( Turkey& turkey ): turkey_(turkey)
{

}

void TurkeyAdapter::quack()
{
	turkey_.gobble();
}

void TurkeyAdapter::fly()
{
	for (int i = 0; i < 5; ++i)
	{
		turkey_.fly();
	}
}

//DuckTestDrive.h
#ifndef __DUCKTESTDRIVE_H__
#define __DUCKTESTDRIVE_H__

class Duck;

class DuckTestDrive
{
public:
	static void main();
private:
	static void testDuck(Duck& duck);//静态成员函数调用的函数必须也是静态函数。而如果在静态成员函数static void main();中定义了一个DuckTestDrive的对象，该对象调用的成员函数可以是任何静态或非静态函数，如Head First 第12章的duckSimulator.simulate(duckFactory);调用方法。
};
#endif

//DuckTestDrive.cpp
#include <iostream>
#include "DuckTestDrive.h"
#include "Duck.h"
#include "Turkey.h"
#include "TurkeyAdapter.h"

void DuckTestDrive::main()
{
	Mallard mallard;
	WildTurkey wildTurkey;
	TurkeyAdapter turkeyAdapter(wildTurkey);
	std::cout << "The Turkey say:\n";
	wildTurkey.gobble();
	wildTurkey.fly();

	std::cout << "\nThe Duck says:\n";
	testDuck(mallard);
	
	std::cout << "\nThe TurkeyAdapter says:\n";
	testDuck(turkeyAdapter);//quack()被调用时，适配器咯咯叫；fly()被调用时，适配器飞行了五次。testDuck()方法根本不知道，这其实是一只假装成鸭子的火鸡。
}

void DuckTestDrive::testDuck( Duck& duck )
{
	duck.quack();
	duck.fly();
}

//main.cpp
#include <iostream>
#include "DuckTestDrive.h"
using namespace std;

int main() 
{
	DuckTestDrive::main();
}
输出如下：
The Turkey say:
Gobble, gobble.
I'm flying a short distance.

The Duck says:
Quack.
I'm flying.

The TurkeyAdapter says:
Gobble, gobble.
I'm flying a short distance.
I'm flying a short distance.
I'm flying a short distance.
I'm flying a short distance.
I'm flying a short distance.
请按任意键继续. . .

//------------------------------------------------------------------------------------------------
//Head First 第8章 模板方法模式--封装算法
模板方法中，算法内的每一个步骤都被一个方法代表了。某些方法是由这个类（也就是超类）处理的，某些方法则是由子类处理的。需要由子类提供的方法，必须在超类中声明为抽象。
模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
在算法内的某些地方，该模板方法控制了算法。它让子类能够提供某些步骤的实现。
模板方法基类专注在算法本身，而由子类提供完整的实现。

定义模板方法模式
模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
这个模板是用来创建一个算法的模板。什么是模板，模板是一个方法。更具体地说，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供部分实现。

模板方法可以有“默认不做事的方法”，我们称这种方法为“hook”（钩子）。子类可以视情况决定要不要覆盖它们。
对模板方法进行挂钩
钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。有了钩子，子类能够决定要不要覆盖方法。如果不提供自己的方法，抽象类提供一个默认的实现。
钩子有好几种用途，先看其中一个：
public abstract class CaffeineBeverageWithHood
{
	void prepareRecipe()
	{
		boilWater();
		brew();
		pourInCup();
		if (customerWantsCondiments())//加上了一个小小的条件语句，而该条件是否成立，是由一个具体方法customerWantsCondiments()决定的。如果顾客“想要”调料，只有这时我们才调用addCondiments()。
		{
			addCondiments();
		}
	}
	abstract void brew();
	abstract void addCondiments();
	void boilWater()
	{
		System.out.println("Boiling water");
	}
	void pourInCup()
	{
		System.out.println("Pouring into cup");
	}
	boolean customerWantsCondiments()//在这里定义了一个方法，（通常）是空的缺省实现。这个方法只会返回true，不做别的事。这就是一个钩子，子类可以覆盖这个方法，但不见得一定要这么做。
	{
		return true;
	}
}
使用钩子
为了使用钩子，在子类中覆盖它。在这里，钩子控制了咖啡因饮料是否执行某部分算法；说得更明确一些，就是饮料中是否要加进调料。
如果得知顾客是否想要调料，覆盖派生类，获取用户输入即可。

我反倒认为询问顾客的这类功能应该让所有的子类共用，不是吗。我们同意你的算法，但是你必须承认，这个例子实在很酷，钩子竟然能够作为条件控制，影响抽象类中的算法流程，实在很不赖吧。

问：当我创建一个模板方法时，怎能才能知道什么时候该使用抽象方法，什么时候使用钩子呢
答：当你的子类“必须”提供算法中某个方法或步骤的实现时，就使用抽象方法。如果算法的这个部分是可选的，就用钩子。如果是钩子的话，子类可以选择实现这个钩子，但并不强制这么做。
问：使用钩子真正的目的是什么
答：钩子有几种用法。如前所说，钩子可以让子类实现算法中可选部分，或者在钩子对于子类的实现并不重要的时候，子类可以对此钩子置之不理。钩子的另一个用法，是让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤作出反应。比方说，名为justBeOrderedList()的钩子方法允许子类在内部列表重新组织后执行某些动作（例如在屏幕上重新显示数据）。如刚刚看到的，钩子也可以让子类有能力为其抽象类作一些决定。
问：子类必须实现抽象类中的所有方法吗
答：是的，每一个具体的子类都必须定义所有的抽象方法，并为模板方法算法中未定义步骤提供完整的实现。
问：似乎我应该保持抽象方法的数目越少越好，否则，在子类中实现这些方法将会很麻烦。
答：当你在写模板方法的时候，心里要随时记得这一点。想要做到这一点，可以让算法内的步骤不要切割得太细，但是如果步骤太少的话，会比较没有弹性，所以要看情况折衷。
也请记住，某些步骤是可选的，所以你可以将这些步骤实现成钩子，而不是实现成抽象方法，这样就可以让抽象类的子类的负荷减轻。

好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。
在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们会调用你”。
低层组件可以参与计算。但是高层组件控制何时以及如何让低层组件参与。低层组件绝对不可以直接调用高层组件。

好莱坞原则和模板方法
当我们设计模板方法模式时，我们告诉子类：不要调用我们，我们会调用你。
CaffeineBeverage是我们的高层组件，它能够控制冲泡法的算法，只有在需要子类实现某个方法时，才调用子类。
饮料的客户代码只依赖CaffeineBeverage抽象，而不依赖具体的Tea或Coffee，这可以减少整个系统的依赖。

问：好莱坞原则和依赖倒置原则（第4章）之间的关系如何
答：依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。而好莱坞原则是用在创建框架或组件上的一种技巧，好让低层组件能够被挂钩进计算中，而且又不会让高层组件依赖低层组件。两者的目标都是在于解耦，但是依赖倒置原则更加注重如何在设计中避免依赖。
好莱坞原则教我们一个技巧，创建一个有弹性的设计，允许低层结构能够互相操作，而又防止其他类太依赖它们。

貌似sort算法等可以传入函数的算法都属于模板方法模式，整个排序的框架由算法提供，具体的排序原则可以由调用者提供。
问：这真的是一个模板方法模式吗，还是你的想像力太丰富了
答：这个模式的重点在于提供一个算法，并让子类实现某些步骤，而数组的排序做法很明显地并非如此。荒野中的模板并非总是如同教科书例子一般地中规中矩，为了符合当前的环境和实现的约束它们总是要被适当地修改。通常我们无法设计一个类继承Java数组，而sort()方法希望能够适用于所有的数组（每个数组都是不同的类）。所以它们定义了一个静态的方法，而由排序的对象内的每个元素自行提供比较大小的算法部分。
所以，这虽然不是教科书上的模板方法，但它的实现仍然符合模板方法模式的精神。再者，由于不需要继承数组就可以使用这个算法，这样使得排序变得更有弹性、更有用。
问：排序的实现实际上看起来更像是策略模式，而不是模板方法模式。为什么要将它归为模式方法
答：之所以这么认为，可能是因为策略模式使用对象组合。在某种程序上，你是对的――我们使用数组对象排序我们的数组，这部分和策略模式非常相似。但是在策略模式中，你所组合的类实现了整个算法。数组所实现的排序算法并不完整，它需要一个类填补compareTo()方法的实现。因此，我们认为这更像模板方法。

我们最新的原则提醒你，由超类主控一切，当我们需要的时候，自然会去调用子类，这就跟好莱坞一样。

--模板方法的抽象类可以定义具体方法、抽象方法和钩子。
--抽象方法由子类实现。
--钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要覆盖它。
--为了防止子类改变模板方法中的算法，可以将模板方法声明为final。
--好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块。
--策略模式和模板方法模式都封装算法，一个用组合，一个用继承。
--工厂方法是模板方法的一个特殊版本。

//CaffeineBeverage.h
#ifndef __CAFFEINEBEVERAGE_H__
#define __CAFFEINEBEVERAGE_H__

class CaffeineBeverage
{
public:
	virtual ~CaffeineBeverage();
	void prepareRecipe();
private:
	virtual void brew() = 0;
	virtual void addCondiments() = 0;
	void boilWater();
	void pourInCup();

	virtual bool customerWantsCondiments();//
};

class Tea: public CaffeineBeverage
{
private:
	virtual void brew();
	virtual void addCondiments();
};

class Coffee: public CaffeineBeverage
{
private:
	virtual void brew();
	virtual void addCondiments();
};

class CoffeeWithHook: public CaffeineBeverage
{
private:
	virtual void brew();
	virtual void addCondiments();
	virtual bool customerWantsCondiments();
};
#endif

//CaffeineBeverage.cpp
#include <iostream>
#include <string>
#include <cctype>
#include "CaffeineBeverage.h"

CaffeineBeverage::~CaffeineBeverage()
{

}

void CaffeineBeverage::prepareRecipe()
{
	boilWater();
	brew();
	pourInCup();
	if (customerWantsCondiments())
	{
		addCondiments();
	}
}

void CaffeineBeverage::boilWater()
{
	std::cout << "Boiling water." << std::endl;
}

void CaffeineBeverage::pourInCup()
{
	std::cout << "Pouring into cup." << std::endl;
}

bool CaffeineBeverage::customerWantsCondiments()
{
	return true;
}

void Tea::brew()
{
	std::cout << "Steeping the tea." << std::endl;
}

void Tea::addCondiments()
{
	std::cout << "Adding Lemon." << std::endl;
}

void Coffee::brew()
{
	std::cout << "Dripping Coffee through filter." << std::endl;
}

void Coffee::addCondiments()
{
	std::cout << "Adding Sugar and Milk." << std::endl;
}

void CoffeeWithHook::brew()
{
	std::cout << "Dripping Coffee through filter." << std::endl;
}

void CoffeeWithHook::addCondiments()
{
	std::cout << "Adding Sugar and Milk." << std::endl;
}

bool CoffeeWithHook::customerWantsCondiments()
{
	std::string answer;
	std::cout << "Would you like sugar and milk in your coffee (y/n)?" << std::endl;
	std::cin >> answer;
	return 'y' == tolower(answer.at(0)) ? true : false;
}

//BeverageTestDrive.h
#ifndef __BEVERAGETESTDRIVE_H__
#define __BEVERAGETESTDRIVE_H__

class BeverageTestDrive
{
public:
	static void main();
};
#endif

//BeverageTestDrive.cpp
#include <iostream>
#include <memory>
#include "BeverageTestDrive.h"
#include "CaffeineBeverage.h"

void BeverageTestDrive::main()
{
	std::auto_ptr<CaffeineBeverage> pTea(new Tea);
	std::auto_ptr<CaffeineBeverage> pCoffee(new CoffeeWithHook);
	
	std::cout << "Making Tea:\n";
	pTea->prepareRecipe();

	std::cout << "\nMaking Coffee:\n";
	pCoffee->prepareRecipe();	
}

//main.cpp
#include <iostream>
#include "BeverageTestDrive.h"
using namespace std;

int main() 
{
	BeverageTestDrive::main();
}
输出如下：
Making Tea:
Boiling water.
Steeping the tea.
Pouring into cup.
Adding Lemon.

Making Coffee:
Boiling water.
Dripping Coffee through filter.
Pouring into cup.
Would you like sugar and milk in your coffee (y/n)?
y
Adding Sugar and Milk.
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//Head First 第9章 迭代器与组合模式--管理良好的集合
当我们说“集合”（collection）的时候，我们指的是一群对象。其存储方式可以是各式各样的数据结构，例如：列表、数组、散列表，无论用什么方式存储，一律可以视为是集合，有时候也被称为聚合（aggregate）。
请注意，迭代器让我们能够遍历聚合中的每个元素，而不会去强迫聚合必须提供方法，让我们在它的元素中游走。我们也可以在聚合的外面实现迭代器：换句话说，我们封装了遍历。
煎饼屋和餐厅菜单都实现了新的createIterator()方法，它们负责为各自的菜单项实现创建迭代器。

新菜单项接口，具备一个新的方法createIterator()。
现在女执行只需要关心菜单和迭代器这两个接口。
将女招待从菜单的实现中解耦了，所以现在我们可以利用迭代器来遍历菜单项，而无需知道菜单项列表是如何实现的。
煎饼屋菜单和餐厅菜单都实现了菜单接口，也就是说，它们都必须实现createIterator()方法。每个具体的菜单都要负责建立适当的具体迭代器。
餐厅菜单的createIterator()方法会返回一个餐厅菜单迭代器，这种迭代器需要遍历菜单项数组。每个菜单都要负责创建适当的具体迭代器类。

定义迭代器模式
迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
迭代器模式让我们游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。
这很有意义：这个模式给你提供了一种方法，可以顺序访问一个聚合对象中的元素，而又不用知道内部是如何表示的。在设计中使用迭代器的影响是明显的：如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码和这些聚合搭配，使用――如同前面的printMenu()方法一样，只要有了迭代器这个方法根本不管菜单项究竟是由数组还是由ArrayList（或者其他能创建迭代器的东西）来保存的。
另一个对你的设计造成重要影响的，是迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面（也就是管理对象集合），而不必去理会遍历的事情。

单一责任
如果我们允许我们的聚合实现它们内部的集合，以及相关的操作和遍历的方法，又会如何。我们知道这会增加聚合中的方法个数，但又怎样。为什么这么做不好。
想知道为什么，首先需要认清楚，当我们允许一个类不但要完成自己的事情（管理某种聚合），还同时要担负更多的责任（例如遍历）时，我们就给了这个类两个变化的原因。两个，没错：如果这个集合改变的话，这个类也必须改变；如果我们遍历的方式改变的话，这个类也必须跟着改变。所以，我们的老朋友“改变”又成了我们设计原则的中心：
设计原则：一个类应该只有一个引起变化的原因。
类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。这个原则告诉我们尽量让每个类保持单一责任。

内聚（cohesion）这个术语用来度量一个类或模块紧密达到单一目的或责任。
当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的低内聚类更容易维护。

定义组合模式
组合模式：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和组合对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。

书上的例子在基类中提供了所有函数的默认操作，抛出不支持操作的异常，而叶节点和Node节点对于不支持的操作则不提供实现。这需要客户端调用时注意不能调用不支持的操作，这与《大话设计模式》中不支持的操作提供空实现不同。

可以这么说，组合模式以单一责任设计原则换取透明性（transparency）。通过让组件的内容同时包含一些管理子节点和叶节点的操作，客户就可以将组合与叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的。
现在，我们在MenuComponent类中同时具有两种类型的操作。因为客户有机会对一个元素做一些不恰当或是没有意义的操作（例如试图把菜单加到菜单项），所以我们失去了一些“安全性”。这是设计上的抉择；当然也可以采用另一种方向的设计，将责任区分开来放在不同的接口中。这么一来，设计就比较安全，但我们也因此失去了透明性，客户的代码将必须用条件语句和instanceof操作符处理不同类型的节点。

空迭代器
到底什么是空迭代器（NullIterator）呢。这么说好了：菜单项内没什么可以遍历的，那实现菜单项的createIterator()方法有两种选择：
选择一：
--返回null，让createIterator()方法返回null，如果这么做，客户代码就需要条件语句来判断返回值是否为null。
选择二：
--返回一个迭代器，而这个迭代器的hasNext()永远返回false
这似乎是一个更好的方案。依然返回一个迭代器，客户不用担心返回值是否为null。等于创建了一个迭代器，其作用是“没作用”。

try/catch是一种错误处理的方法，而不是程序逻辑的方法。如果不这么做，还可以在调用isVergetarian()方法前，用instanceof来检查菜单项的运行时类型，以确定它是菜单项。这这么做，就会因为无法统一处理菜单和菜单项而失去透明性。
也可以改写Menu的isVegetarian()方法，让它返回false。这提供了一个简单的解决方案，同时也保持了透明性。

//Menu.h
#ifndef __MENU_H__
#define __MENU_H__
#include <string>
#include <vector>
#include "boost/shared_ptr.hpp"

class MenuItem;
class MenuIterator;

class PancakeHouseMenu
{
public:
	PancakeHouseMenu();
	void addItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	boost::shared_ptr<MenuIterator> createIterator();
private:
	std::vector<boost::shared_ptr<MenuItem> > menuItemVector_;

};

class DinerMenu
{
public:
	DinerMenu();
	void addItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	boost::shared_ptr<MenuIterator> createIterator();
private:
	boost::shared_ptr<MenuItem> generateMenuItem();
	enum {MAX_ITEMS_ = 6};
	int numberOfItems_;
	boost::shared_ptr<MenuItem> menuItems_[MAX_ITEMS_];
};
#endif

//Menu.cpp
#include <iostream>
#include <algorithm>
#include "MenuItem.h"
#include "Menu.h"
#include "MenuIterator.h"

DinerMenu::DinerMenu(): numberOfItems_(0)
{
	//std::fill(menuItems_, menuItems_ + MAX_ITEMS_, generateMenuItem());//第三个参数的语法居然可以通过？都不知道怎么通过的，下次写个测试用例
	addItem("Vegetarian BLT", "(Fakin') Bacon with lettuce & tomato on whole wheat", true, 2.99);
	addItem("BLT", "Bacon with lettuce & tamato on whole wheat", false, 2.99);
	addItem("Soup of the day", "Soup of the day, with a side of potato salad", false, 3.29);
	addItem("Hotdog", "A hot dog, with saurkraut, relish, onions, topped with cheese", false, 3.05);
}

boost::shared_ptr<MenuItem> DinerMenu::generateMenuItem()
{
	return boost::shared_ptr<MenuItem>();
}

void DinerMenu::addItem( const std::string& name, const std::string& description, bool vegetarian, double price )
{
	if (numberOfItems_ >= MAX_ITEMS_)
	{
		std::cout << "Sorry, menu is full! Can't add item to menu." << std::endl;
		return;
	}
	boost::shared_ptr<MenuItem> pMenuItem(new MenuItem(name, description, vegetarian, price));
	menuItems_[numberOfItems_++] = pMenuItem;
}

boost::shared_ptr<MenuIterator> DinerMenu::createIterator()
{
	return boost::shared_ptr<MenuIterator>(new DinerMenuIterator(menuItems_, numberOfItems_));
}

PancakeHouseMenu::PancakeHouseMenu()
{
	addItem("K&B's Pancake Breakfast", "Pancakes with scrambled eggs, and toast", true, 2.99);
	addItem("Regular Pancake Breakfast", "Pancakes with fried eggs, sausage", false, 2.99);
	addItem("Blueberry Pancakes", "Pancakes made with fresh blueberries", true, 3.49);
	addItem("Waffles", "Waffles, with your choice of blueberries or strawberries", true, 3.59);
}

void PancakeHouseMenu::addItem( const std::string& name, const std::string& description, bool vegetarian, double price )
{
	menuItemVector_.push_back(boost::shared_ptr<MenuItem>(new MenuItem(name, description, vegetarian, price)));
}

boost::shared_ptr<MenuIterator> PancakeHouseMenu::createIterator()
{
	return boost::shared_ptr<MenuIterator>(new PancakeHouseMenuIterator(menuItemVector_));
}

//MenuItem.h
#ifndef __MENUITEM_H__
#define __MENUITEM_H__
#include <string>

class MenuItem
{
public:
	MenuItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	std::string getName();
	std::string getDescription();
	double getPrice();
	bool isVegetarian();
private:
	std::string name_;
	std::string description_;
	bool vegetarian_;
	double price_;
};
#endif

//MenuItem.cpp
#include "MenuItem.h"

MenuItem::MenuItem( const std::string& name, const std::string& description, bool vegetarian, double price ):
name_(name), description_(description), vegetarian_(vegetarian), price_(price)
{

}

std::string MenuItem::getName()
{
	return name_;
}

std::string MenuItem::getDescription()
{
	return description_;
}

double MenuItem::getPrice()
{
	return price_;
}

bool MenuItem::isVegetarian()
{
	return vegetarian_;
}

//MenuIterator.h
#ifndef __MENUITERATOR_H__
#define __MENUITERATOR_H__
#include <vector>
#include "boost/shared_ptr.hpp"

class MenuItem;

class MenuIterator
{
public:
	virtual ~MenuIterator();
	virtual boost::shared_ptr<MenuItem> next() = 0;
	virtual bool hasNext() = 0;
};

class PancakeHouseMenuIterator: public MenuIterator
{
public:
	PancakeHouseMenuIterator(std::vector<boost::shared_ptr<MenuItem> >& menuItemVector);
	virtual boost::shared_ptr<MenuItem> next();
	virtual bool hasNext();
private:
	std::vector<boost::shared_ptr<MenuItem> >& menuItemVector_;
	std::vector<boost::shared_ptr<MenuItem> >::iterator iter_;
};

class DinerMenuIterator: public MenuIterator//Iterator need to be created again when Menu is changed
{
public:
	DinerMenuIterator(boost::shared_ptr<MenuItem>* bPtrMenuItemArr, int currentMenuItemNumber);
	virtual boost::shared_ptr<MenuItem> next();
	virtual bool hasNext();
private:
	boost::shared_ptr<MenuItem>* bPtrMenuItemArr_;
	int currentMenuItemNumber_;
	//int menuItemArrLength_;
	int position_;

};
#endif

//MenuIterator.cpp
#include "MenuIterator.h"

MenuIterator::~MenuIterator()
{

}

PancakeHouseMenuIterator::PancakeHouseMenuIterator( std::vector<boost::shared_ptr<MenuItem> >& menuItemVector ):
menuItemVector_(menuItemVector), iter_(menuItemVector_.begin())
{

}

boost::shared_ptr<MenuItem> PancakeHouseMenuIterator::next()
{
	return *(iter_++);
}

bool PancakeHouseMenuIterator::hasNext()
{
	if (menuItemVector_.end() != iter_)
	{
		return true;
	}
	else
	{
		return false;
	}
}

DinerMenuIterator::DinerMenuIterator( boost::shared_ptr<MenuItem>* bPtrMenuItemArr, int currentMenuItemNumber ):
bPtrMenuItemArr_(bPtrMenuItemArr), currentMenuItemNumber_(currentMenuItemNumber), position_(0)
{

}

boost::shared_ptr<MenuItem> DinerMenuIterator::next()
{
	return bPtrMenuItemArr_[position_++];
}

bool DinerMenuIterator::hasNext()
{
	if (position_ >= currentMenuItemNumber_)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//Waitress.h
#ifndef __WAITRESS_H__
#define __WAITRESS_H__
#include "boost/shared_ptr.hpp"

class PancakeHouseMenu;
class DinerMenu;
class MenuIterator;

class Waitress
{
public:
	Waitress(PancakeHouseMenu& pancakeHouseMenu, DinerMenu& dinerMenu);
	void printMenu();
private:
	void printMenu(boost::shared_ptr<MenuIterator> pMenuIterator);
	PancakeHouseMenu& rPancakeHouseMenu_;
	DinerMenu& rDinerMenu_;
};
#endif

//Waitress.cpp
#include <iostream>
#include "Waitress.h"
#include "Menu.h"
#include "MenuIterator.h"
#include "MenuItem.h"

Waitress::Waitress( PancakeHouseMenu& pancakeHouseMenu, DinerMenu& dinerMenu ):
rPancakeHouseMenu_(pancakeHouseMenu), rDinerMenu_(dinerMenu)
{

}

void Waitress::printMenu()
{
	boost::shared_ptr<MenuIterator> pancakeIterator(rPancakeHouseMenu_.createIterator());
	boost::shared_ptr<MenuIterator> dinerIterator(rDinerMenu_.createIterator());
	std::cout << "Menu\n---\nBreakfast\n";
	printMenu(pancakeIterator);
	std::cout << "\nLunch\n";
	printMenu(dinerIterator);
}

void Waitress::printMenu( boost::shared_ptr<MenuIterator> pMenuIterator )
{
	while (pMenuIterator->hasNext())
	{
		boost::shared_ptr<MenuItem> pMenuItem(pMenuIterator->next());
		std::cout << pMenuItem->getName() + ", "
			<< pMenuItem->getPrice() << " -- "
			<< pMenuItem->getDescription() << std::endl;
	}
}

//MenuTestDrive.h
#ifndef __MENUTESTDRIVE_H__
#define __MENUTESTDRIVE_H__

class MenuTestDrive
{
public:
	static void main();
};
#endif

//MenuTestDrive.cpp
#include "MenuTestDrive.h"
#include "Menu.h"
#include "Waitress.h"

void MenuTestDrive::main()
{
	PancakeHouseMenu pancakeHouseMenu;
	DinerMenu dinerMenu;
	Waitress waitress(pancakeHouseMenu, dinerMenu);
	waitress.printMenu();
}

//main.cpp
#include <iostream>
#include "MenuTestDrive.h"
using namespace std;

int main() 
{
	MenuTestDrive::main();
}
输出如下：
Menu
---
Breakfast
K&B's Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs, and toast
Regular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage
Blueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries
Waffles, 3.59 -- Waffles, with your choice of blueberries or strawberries

Lunch
Vegetarian BLT, 2.99 -- (Fakin') Bacon with lettuce & tomato on whole wheat
BLT, 2.99 -- Bacon with lettuce & tamato on whole wheat
Soup of the day, 3.29 -- Soup of the day, with a side of potato salad
Hotdog, 3.05 -- A hot dog, with saurkraut, relish, onions, topped with cheese
请按任意键继续. . .

//继续修改，将PancakeMenu和DinerMenu修改为继承自一个抽象基类Menu
//Menu.h
#ifndef __MENU_H__
#define __MENU_H__
#include <string>
#include <vector>
#include "boost/shared_ptr.hpp"

class MenuItem;
class MenuIterator;

class Menu
{
public:
	virtual ~Menu();
	virtual boost::shared_ptr<MenuIterator> createIterator() = 0;
};

class PancakeHouseMenu: public Menu
{
public:
	PancakeHouseMenu();
	void addItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	virtual boost::shared_ptr<MenuIterator> createIterator();
private:
	std::vector<boost::shared_ptr<MenuItem> > menuItemVector_;

};

class DinerMenu: public Menu
{
public:
	DinerMenu();
	void addItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	virtual boost::shared_ptr<MenuIterator> createIterator();
private:
	boost::shared_ptr<MenuItem> generateMenuItem();
	enum {MAX_ITEMS_ = 6};
	int numberOfItems_;
	boost::shared_ptr<MenuItem> menuItems_[MAX_ITEMS_];//这里演示了用数组保存智能指针实现保存动态对象。之前More Effective C++讲过，不要在数组中保存动态对象，无法取得该对象的正确大小。用智能指针可以解决这个问题。
};
#endif

//Menu.cpp
#include <iostream>
#include <algorithm>
#include "MenuItem.h"
#include "Menu.h"
#include "MenuIterator.h"

Menu::~Menu()
{

}

DinerMenu::DinerMenu(): numberOfItems_(0)
{
	//std::fill(menuItems_, menuItems_ + MAX_ITEMS_, generateMenuItem());
	addItem("Vegetarian BLT", "(Fakin') Bacon with lettuce & tomato on whole wheat", true, 2.99);
	addItem("BLT", "Bacon with lettuce & tamato on whole wheat", false, 2.99);
	addItem("Soup of the day", "Soup of the day, with a side of potato salad", false, 3.29);
	addItem("Hotdog", "A hot dog, with saurkraut, relish, onions, topped with cheese", false, 3.05);
}

boost::shared_ptr<MenuItem> DinerMenu::generateMenuItem()
{
	return boost::shared_ptr<MenuItem>();
}

void DinerMenu::addItem( const std::string& name, const std::string& description, bool vegetarian, double price )
{
	if (numberOfItems_ >= MAX_ITEMS_)
	{
		std::cout << "Sorry, menu is full! Can't add item to menu." << std::endl;
		return;
	}
	boost::shared_ptr<MenuItem> pMenuItem(new MenuItem(name, description, vegetarian, price));
	menuItems_[numberOfItems_++] = pMenuItem;
}

boost::shared_ptr<MenuIterator> DinerMenu::createIterator()
{
	return boost::shared_ptr<MenuIterator>(new DinerMenuIterator(menuItems_, numberOfItems_));
}

PancakeHouseMenu::PancakeHouseMenu()
{
	addItem("K&B's Pancake Breakfast", "Pancakes with scrambled eggs, and toast", true, 2.99);
	addItem("Regular Pancake Breakfast", "Pancakes with fried eggs, sausage", false, 2.99);
	addItem("Blueberry Pancakes", "Pancakes made with fresh blueberries", true, 3.49);
	addItem("Waffles", "Waffles, with your choice of blueberries or strawberries", true, 3.59);
}

void PancakeHouseMenu::addItem( const std::string& name, const std::string& description, bool vegetarian, double price )
{
	menuItemVector_.push_back(boost::shared_ptr<MenuItem>(new MenuItem(name, description, vegetarian, price)));
}

boost::shared_ptr<MenuIterator> PancakeHouseMenu::createIterator()
{
	return boost::shared_ptr<MenuIterator>(new PancakeHouseMenuIterator(menuItemVector_));
}

//MenuItem.h
#ifndef __MENUITEM_H__
#define __MENUITEM_H__
#include <string>

class MenuItem
{
public:
	MenuItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	std::string getName();
	std::string getDescription();
	double getPrice();
	bool isVegetarian();
private:
	std::string name_;
	std::string description_;
	bool vegetarian_;
	double price_;
};
#endif

//MenuItem.cpp
#include "MenuItem.h"

MenuItem::MenuItem( const std::string& name, const std::string& description, bool vegetarian, double price ):
name_(name), description_(description), vegetarian_(vegetarian), price_(price)
{

}

std::string MenuItem::getName()
{
	return name_;
}

std::string MenuItem::getDescription()
{
	return description_;
}

double MenuItem::getPrice()
{
	return price_;
}

bool MenuItem::isVegetarian()
{
	return vegetarian_;
}

//MenuIterator.h
#ifndef __MENUITERATOR_H__
#define __MENUITERATOR_H__
#include <vector>
#include "boost/shared_ptr.hpp"

class MenuItem;

class MenuIterator
{
public:
	virtual ~MenuIterator();
	virtual boost::shared_ptr<MenuItem> next() = 0;
	virtual bool hasNext() = 0;
};

class PancakeHouseMenuIterator: public MenuIterator
{
public:
	PancakeHouseMenuIterator(std::vector<boost::shared_ptr<MenuItem> >& menuItemVector);
	virtual boost::shared_ptr<MenuItem> next();
	virtual bool hasNext();
private:
	std::vector<boost::shared_ptr<MenuItem> >& menuItemVector_;
	std::vector<boost::shared_ptr<MenuItem> >::iterator iter_;
};

class DinerMenuIterator: public MenuIterator//Iterator need to be created again when Menu is changed
{
public:
	DinerMenuIterator(boost::shared_ptr<MenuItem>* bPtrMenuItemArr, int currentMenuItemNumber);
	virtual boost::shared_ptr<MenuItem> next();
	virtual bool hasNext();
private:
	boost::shared_ptr<MenuItem>* bPtrMenuItemArr_;
	int currentMenuItemNumber_;
	//int menuItemArrLength_;
	int position_;

};
#endif

//MenuIterator.cpp
#include "MenuIterator.h"

MenuIterator::~MenuIterator()
{

}

PancakeHouseMenuIterator::PancakeHouseMenuIterator( std::vector<boost::shared_ptr<MenuItem> >& menuItemVector ):
menuItemVector_(menuItemVector), iter_(menuItemVector_.begin())
{

}

boost::shared_ptr<MenuItem> PancakeHouseMenuIterator::next()
{
	return *(iter_++);
}

bool PancakeHouseMenuIterator::hasNext()
{
	return menuItemVector_.end() != iter_;
}

DinerMenuIterator::DinerMenuIterator( boost::shared_ptr<MenuItem>* bPtrMenuItemArr, int currentMenuItemNumber ):
bPtrMenuItemArr_(bPtrMenuItemArr), currentMenuItemNumber_(currentMenuItemNumber), position_(0)
{

}

boost::shared_ptr<MenuItem> DinerMenuIterator::next()
{
	return bPtrMenuItemArr_[position_++];
}

bool DinerMenuIterator::hasNext()
{
	return position_ < currentMenuItemNumber_;
}

//Waitress.h
#ifndef __WAITRESS_H__
#define __WAITRESS_H__
#include "boost/shared_ptr.hpp"

class Menu;
class MenuIterator;

class Waitress
{
public:
	Waitress(Menu& pancakeHouseMenu, Menu& dinerMenu);
	void printMenu();
private:
	void printMenu(boost::shared_ptr<MenuIterator> pMenuIterator);
	Menu& rPancakeHouseMenu_;
	Menu& rDinerMenu_;
};
#endif

//Waitress.cpp
#include <iostream>
#include "Waitress.h"
#include "Menu.h"
#include "MenuIterator.h"
#include "MenuItem.h"

Waitress::Waitress( Menu& pancakeHouseMenu, Menu& dinerMenu ):
rPancakeHouseMenu_(pancakeHouseMenu), rDinerMenu_(dinerMenu)
{

}

void Waitress::printMenu()
{
	boost::shared_ptr<MenuIterator> pancakeIterator(rPancakeHouseMenu_.createIterator());
	boost::shared_ptr<MenuIterator> dinerIterator(rDinerMenu_.createIterator());
	std::cout << "Menu\n---\nBreakfast\n";
	printMenu(pancakeIterator);
	std::cout << "\nLunch\n";
	printMenu(dinerIterator);
}

void Waitress::printMenu( boost::shared_ptr<MenuIterator> pMenuIterator )
{
	while (pMenuIterator->hasNext())
	{
		boost::shared_ptr<MenuItem> pMenuItem(pMenuIterator->next());
		std::cout << pMenuItem->getName() + ", "
			<< pMenuItem->getPrice() << " -- "
			<< pMenuItem->getDescription() << std::endl;
	}
}

//MenuTestDrive.h
#ifndef __MENUTESTDRIVE_H__
#define __MENUTESTDRIVE_H__

class MenuTestDrive
{
public:
	static void main();
};
#endif

//MenuTestDrive.cpp
#include "MenuTestDrive.h"
#include "Menu.h"
#include "Waitress.h"

void MenuTestDrive::main()
{
	PancakeHouseMenu pancakeHouseMenu;
	DinerMenu dinerMenu;
	Waitress waitress(pancakeHouseMenu, dinerMenu);
	waitress.printMenu();
}

//main.cpp
#include <iostream>
#include "MenuTestDrive.h"
using namespace std;

int main() 
{
	MenuTestDrive::main();
}
输出同上。
这个修改带来了什么好处：两个菜单类，都实现了Menu接口，女招待可以利用接口（而不是具体类）引用每一个菜单对象。这样，通过，“针对接口编程，而不针对实现编程”，可以减少女招待和具体类之间的依赖。
这个新的菜单接口有一个方法，createIterator()。此方法是由煎饼屋菜单和餐厅菜单实现的。每个菜单类都必须负责提供适当的具体迭代器。

//组合模式
//MenuComponent.h
#ifndef	__MENU_COMPONENT_H__
#define __MENU_COMPONENT_H__
#include <string>
#include "boost/shared_ptr.hpp"

class MenuIterator;

class MenuComponent
{
public:
	virtual ~MenuComponent() = 0;
	virtual void add(boost::shared_ptr<MenuComponent> pMenuComponent);
	virtual void remove(boost::shared_ptr<MenuComponent> pMenuComponent);
	virtual boost::shared_ptr<MenuComponent> getChild(unsigned int i);
	virtual std::string getName();
	virtual std::string getDescription();
	virtual double getPrice();
	virtual bool isVegetarian();
	virtual void print();
	virtual boost::shared_ptr<MenuIterator> createIterator(); 
};
#endif

//MenuComponent.cpp
#include <stdexcept>
#include "MenuComponent.h"

MenuComponent::~MenuComponent()
{

}

void MenuComponent::add( boost::shared_ptr<MenuComponent> pMenuComponent )
{
	throw std::logic_error("Unsupported Operation Exception.");
}

void MenuComponent::remove( boost::shared_ptr<MenuComponent> pMenuComponent )
{
	throw std::logic_error("Unsupported Operation Exception.");
}

boost::shared_ptr<MenuComponent> MenuComponent::getChild( unsigned int i )
{
	throw std::logic_error("Unsupported Operation Exception.");
}

std::string MenuComponent::getName()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

std::string MenuComponent::getDescription()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

double MenuComponent::getPrice()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

bool MenuComponent::isVegetarian()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

void MenuComponent::print()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

boost::shared_ptr<MenuIterator> MenuComponent::createIterator()
{
	throw std::logic_error("Unsupported Operation Exception.");
}

//Menu.h
#ifndef __MENU_H__
#define __MENU_H__
#include <string>
#include <list>
#include "MenuComponent.h"
#include "boost/shared_ptr.hpp"

class Menu: public MenuComponent
{
public:
	Menu(const std::string& name, const std::string& description);
	virtual void add(boost::shared_ptr<MenuComponent> pMenuComponent);
	virtual void remove(boost::shared_ptr<MenuComponent> pMenuComponent);
	virtual boost::shared_ptr<MenuComponent> getChild(unsigned int i);
	virtual std::string getName();
	virtual std::string getDescription();
	virtual void print();
	virtual boost::shared_ptr<MenuIterator> createIterator();
private:
	std::list<boost::shared_ptr<MenuComponent> > menuComponentList_;
	std::string name_;
	std::string description_;
};

#endif

//Menu.cpp
#include <iostream>
#include <algorithm>
#include <functional>
#include "Menu.h"
#include "MenuIterator.h"

Menu::Menu( const std::string& name, const std::string& description ):
name_(name), description_(description)
{
	
}

void Menu::add( boost::shared_ptr<MenuComponent> pMenuComponent )
{
	menuComponentList_.push_back(pMenuComponent);
}

void Menu::remove( boost::shared_ptr<MenuComponent> pMenuComponent )
{
	menuComponentList_.remove(pMenuComponent);
}

boost::shared_ptr<MenuComponent> Menu::getChild( unsigned int i )
{
	std::list<boost::shared_ptr<MenuComponent> >::iterator iter(menuComponentList_.begin());
	if (menuComponentList_.size() < i)
	{
		iter = menuComponentList_.end();
	}
	else
	{
		advance(iter, i - 1);
	}
	return *iter;
}

std::string Menu::getName()
{
	return name_;
}

std::string Menu::getDescription()
{
	return description_;
}

void Menu::print()
{
	std::cout << "\n" + getName() << ", " + getDescription() << "\n----------------------------\n";
	//for_each(menuComponentList_.begin(), menuComponentList_.end(), std::mem_fun(&MenuComponent::print));
	for (std::list<boost::shared_ptr<MenuComponent> >::iterator iter = menuComponentList_.begin(); iter != menuComponentList_.end(); ++iter)
	{
		(*iter)->print();
	}
}

boost::shared_ptr<MenuIterator> Menu::createIterator()
{
	boost::shared_ptr<MenuIterator> pListMenuIterator(new ListMenuIterator(menuComponentList_));
	return boost::shared_ptr<MenuIterator>(new CompositeMenuIterator(pListMenuIterator));
}

//MenuItem.h
#ifndef __MENUITEM_H__
#define __MENUITEM_H__
#include <string>
#include "MenuComponent.h"

class MenuItem: public MenuComponent
{
public:
	MenuItem(const std::string& name, const std::string& description, bool vegetarian, double price);
	virtual std::string getName();
	virtual std::string getDescription();
	virtual double getPrice();
	virtual bool isVegetarian();
	virtual void print();
	virtual boost::shared_ptr<MenuIterator> createIterator(); 
private:
	std::string name_;
	std::string description_;
	bool vegetarian_;
	double price_;
};
#endif

//MenuItem.cpp
#include <iostream>
#include "MenuItem.h"
#include "MenuIterator.h"

MenuItem::MenuItem( const std::string& name, const std::string& description, bool vegetarian, double price ):
name_(name), description_(description), vegetarian_(vegetarian), price_(price)
{

}

std::string MenuItem::getName()
{
	return name_;
}

std::string MenuItem::getDescription()
{
	return description_;
}

double MenuItem::getPrice()
{
	return price_;
}

bool MenuItem::isVegetarian()
{
	return vegetarian_;
}

void MenuItem::print()
{
	std::cout << "    " + getName();
	if (isVegetarian())
	{
		std::cout << "(v)";
	}
	std::cout << ", " << getPrice() << "\n        -- " + getDescription() << std::endl;
}

boost::shared_ptr<MenuIterator> MenuItem::createIterator()
{
	return boost::shared_ptr<MenuIterator>(new NullMenuIterator);
}

//MenuIterator.h
#ifndef __MENUITERATOR_H__
#define __MENUITERATOR_H__
#include <list>
#include <stack>
#include "boost/shared_ptr.hpp"

class MenuComponent;

class MenuIterator
{
public:
	virtual ~MenuIterator();
	virtual boost::shared_ptr<MenuComponent> next() = 0;
	virtual bool hasNext() = 0;
};

class ListMenuIterator: public MenuIterator
{
public:
	ListMenuIterator(std::list<boost::shared_ptr<MenuComponent> >& menuItemList);
	virtual boost::shared_ptr<MenuComponent> next();
	virtual bool hasNext();
private:
	std::list<boost::shared_ptr<MenuComponent> >& menuItemList_;
	std::list<boost::shared_ptr<MenuComponent> >::iterator iter_;
};

class CompositeMenuIterator: public MenuIterator
{
public:
	CompositeMenuIterator(boost::shared_ptr<MenuIterator> pMenuIterator);
	virtual boost::shared_ptr<MenuComponent> next();
	virtual bool hasNext();
private:
	std::stack<boost::shared_ptr<MenuIterator> > menuIteratorStack_;
};

class NullMenuIterator: public MenuIterator
{
public:
	virtual boost::shared_ptr<MenuComponent> next();
	virtual bool hasNext();
};
#endif

//MenuIterator.cpp
#include <typeinfo>
#include "MenuIterator.h"
#include "Menu.h"

MenuIterator::~MenuIterator()
{

}

ListMenuIterator::ListMenuIterator( std::list<boost::shared_ptr<MenuComponent> >& menuItemList ):
menuItemList_(menuItemList), iter_(menuItemList_.begin())
{

}

boost::shared_ptr<MenuComponent> ListMenuIterator::next()
{
	return *(iter_++);
}

bool ListMenuIterator::hasNext()
{
	return menuItemList_.end() != iter_;
}

CompositeMenuIterator::CompositeMenuIterator( boost::shared_ptr<MenuIterator> pMenuIterator ):
menuIteratorStack_()
{
	menuIteratorStack_.push(pMenuIterator);
}

boost::shared_ptr<MenuComponent> CompositeMenuIterator::next()
{
	if (hasNext())
	{
		boost::shared_ptr<MenuIterator> pMenuIterator = menuIteratorStack_.top();
		boost::shared_ptr<MenuComponent> pMenuComponent = pMenuIterator->next();
		if (typeid(Menu) == typeid(*pMenuComponent.get()))
		{
			menuIteratorStack_.push(pMenuComponent->createIterator());
		}
		return pMenuComponent;
	}
	else
	{
		return boost::shared_ptr<MenuComponent>();
	}
}

bool CompositeMenuIterator::hasNext()
{
	if (menuIteratorStack_.empty())
	{
		return false;
	}
	else
	{
		boost::shared_ptr<MenuIterator> pMenuIterator = menuIteratorStack_.top();
		if (!pMenuIterator->hasNext())
		{
			menuIteratorStack_.pop();
			return hasNext();
		}
		else
		{
			return true;
		}
	}
}

boost::shared_ptr<MenuComponent> NullMenuIterator::next()
{
	return boost::shared_ptr<MenuComponent>();
}

bool NullMenuIterator::hasNext()
{
	return false;
}

//Waitress.h
#ifndef __WAITRESS_H__
#define __WAITRESS_H__
#include "boost/shared_ptr.hpp"

class MenuComponent;

class Waitress
{
public:
	Waitress(boost::shared_ptr<MenuComponent> allMenus);
	void setNewMenu(boost::shared_ptr<MenuComponent> allMenus);
	void printMenu();
	void printVegetarianMenu();
private:
	boost::shared_ptr<MenuComponent> pAllMenus_;
};
#endif

//Waitress.cpp
#include <iostream>
#include <exception>
#include "Waitress.h"
#include "MenuComponent.h"
#include "MenuIterator.h"

Waitress::Waitress( boost::shared_ptr<MenuComponent> allMenus ): pAllMenus_(allMenus)
{

}

//利用迭代器来遍历组件内的每个项。MenuComponent是在“内部”自行处理遍历
void Waitress::printMenu()
{
	pAllMenus_->print();
}

void Waitress::setNewMenu( boost::shared_ptr<MenuComponent> allMenus )
{
	pAllMenus_ = allMenus;
}

//外部迭代器，所以有许多需要追踪的事情。外部迭代器必须维护它在遍历中的位置，以便外部客户可以通过调用hasNext()和next()来驱动遍历。代码也必须维护组合递归结构的位置。
void Waitress::printVegetarianMenu()//这个函数的实现有点问题，多于一次的MenuItem会被遍历两次
{
	boost::shared_ptr<MenuIterator> pMenuIterator = pAllMenus_->createIterator();
	std::cout << "\nVegetarian Menu\n---------------------------------\n";
	while (pMenuIterator->hasNext())
	{
		boost::shared_ptr<MenuComponent> pMenuComponent = pMenuIterator->next();
		try
		{
			if (pMenuComponent->isVegetarian())
			{
				pMenuComponent->print();
			}
		}
		catch (std::exception&)
		{

		}
	}
}

//MenuTestDrive.h
#ifndef __MENUTESTDRIVE_H__
#define __MENUTESTDRIVE_H__

class MenuTestDrive
{
public:
	static void main();
};
#endif

//MenuTestDrive.cpp
#include "boost/shared_ptr.hpp"
#include "MenuTestDrive.h"
#include "Waitress.h"
#include "MenuComponent.h"
#include "Menu.h"
#include "MenuItem.h"

void MenuTestDrive::main()
{
	boost::shared_ptr<MenuComponent> pancakeHouseMenu(new Menu("Pancake House Menu", "Breakfast"));
	boost::shared_ptr<MenuComponent> dinerMenu(new Menu("Diner Menu", "Lunch"));
	boost::shared_ptr<MenuComponent> cafeMenu(new Menu("Cafe Menu", "Dinner"));
	boost::shared_ptr<MenuComponent> dessertMenu(new Menu("Dessert Menu", "Dessert of course!"));

	boost::shared_ptr<MenuComponent> allMenus(new Menu("All Menus", "All menus combined"));

	allMenus->add(pancakeHouseMenu);
	allMenus->add(dinerMenu);
	allMenus->add(cafeMenu);

	pancakeHouseMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("K&B's Pancake Breakfast", "Pancakes with scrambled eggs, and toast", true, 2.99)));
	pancakeHouseMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Regular Pancake Breakfast", "Pancakes with fried eggs, sausage", false, 2.99)));
	pancakeHouseMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Blueberry Pancakes", "Pancakes made with fresh blueberries", true, 3.49)));
	pancakeHouseMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Waffles", "Waffles, with your choice of blueberries or strawberries", true, 3.59)));

	dinerMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Vegetarian BLT", "(Fakin') Bacon with lettuce & tomato on whole wheat", true, 2.99)));
	dinerMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("BLT", "Bacon with lettuce & tamato on whole wheat", false, 2.99)));
	dinerMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Soup of the day", "Soup of the day, with a side of potato salad", false, 3.29)));
	dinerMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Hotdog", "A hot dog, with saurkraut, relish, onions, topped with cheese", false, 3.05)));
	
	dessertMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Apple Pie", "Apple pie with a falkey crust, topped with vanilla ice cream", true, 1.59)));
	dessertMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Pasta", "Spaghetti with Marinara Sauce, and a slice of sourdough bread", true, 3.89)));
	dinerMenu->add(dessertMenu);

	cafeMenu->add(boost::shared_ptr<MenuComponent>(new MenuItem("Veggie Burger and Air Fries", "Veggie burger on a whole wheat bun, lettuce, tomato, and fries", true, 3.99)));

	Waitress waitress(allMenus);
	waitress.printMenu();

	allMenus->remove(pancakeHouseMenu);
	waitress.printMenu();

	waitress.setNewMenu(allMenus->getChild(1));
	waitress.printMenu();

	waitress.printVegetarianMenu();
}

//main.cpp
#include <iostream>
#include "MenuTestDrive.h"
using namespace std;

int main() 
{
	MenuTestDrive::main();
}
输出如下：

All Menus, All menus combined
----------------------------

Pancake House Menu, Breakfast
----------------------------
    K&B's Pancake Breakfast(v), 2.99
        -- Pancakes with scrambled eggs, and toast
    Regular Pancake Breakfast, 2.99
        -- Pancakes with fried eggs, sausage
    Blueberry Pancakes(v), 3.49
        -- Pancakes made with fresh blueberries
    Waffles(v), 3.59
        -- Waffles, with your choice of blueberries or strawberries

Diner Menu, Lunch
----------------------------
    Vegetarian BLT(v), 2.99
        -- (Fakin') Bacon with lettuce & tomato on whole wheat
    BLT, 2.99
        -- Bacon with lettuce & tamato on whole wheat
    Soup of the day, 3.29
        -- Soup of the day, with a side of potato salad
    Hotdog, 3.05
        -- A hot dog, with saurkraut, relish, onions, topped with cheese

Dessert Menu, Dessert of course!
----------------------------
    Apple Pie(v), 1.59
        -- Apple pie with a falkey crust, topped with vanilla ice cream
    Pasta(v), 3.89
        -- Spaghetti with Marinara Sauce, and a slice of sourdough bread

Cafe Menu, Dinner
----------------------------
    Veggie Burger and Air Fries(v), 3.99
        -- Veggie burger on a whole wheat bun, lettuce, tomato, and fries

Vegetarian Menu
---------------------------------
    K&B's Pancake Breakfast(v), 2.99
        -- Pancakes with scrambled eggs, and toast
    Blueberry Pancakes(v), 3.49
        -- Pancakes made with fresh blueberries
    Waffles(v), 3.59
        -- Waffles, with your choice of blueberries or strawberries
    Vegetarian BLT(v), 2.99
        -- (Fakin') Bacon with lettuce & tomato on whole wheat
    Apple Pie(v), 1.59
        -- Apple pie with a falkey crust, topped with vanilla ice cream
    Pasta(v), 3.89
        -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
    Apple Pie(v), 1.59
        -- Apple pie with a falkey crust, topped with vanilla ice cream
    Pasta(v), 3.89
        -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
    Veggie Burger and Air Fries(v), 3.99
        -- Veggie burger on a whole wheat bun, lettuce, tomato, and fries

All Menus, All menus combined
----------------------------

Diner Menu, Lunch
----------------------------
    Vegetarian BLT(v), 2.99
        -- (Fakin') Bacon with lettuce & tomato on whole wheat
    BLT, 2.99
        -- Bacon with lettuce & tamato on whole wheat
    Soup of the day, 3.29
        -- Soup of the day, with a side of potato salad
    Hotdog, 3.05
        -- A hot dog, with saurkraut, relish, onions, topped with cheese

Dessert Menu, Dessert of course!
----------------------------
    Apple Pie(v), 1.59
        -- Apple pie with a falkey crust, topped with vanilla ice cream
    Pasta(v), 3.89
        -- Spaghetti with Marinara Sauce, and a slice of sourdough bread

Cafe Menu, Dinner
----------------------------
    Veggie Burger and Air Fries(v), 3.99
        -- Veggie burger on a whole wheat bun, lettuce, tomato, and fries

Diner Menu, Lunch
----------------------------
    Vegetarian BLT(v), 2.99
        -- (Fakin') Bacon with lettuce & tomato on whole wheat
    BLT, 2.99
        -- Bacon with lettuce & tamato on whole wheat
    Soup of the day, 3.29
        -- Soup of the day, with a side of potato salad
    Hotdog, 3.05
        -- A hot dog, with saurkraut, relish, onions, topped with cheese

Dessert Menu, Dessert of course!
----------------------------
    Apple Pie(v), 1.59
        -- Apple pie with a falkey crust, topped with vanilla ice cream
    Pasta(v), 3.89
        -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
请按任意键继续. . .

//------------------------------------------------------------------------------------------------
//Head First 第10章 状态模式--事物的状态
新的设计
计划是这样的：不要维护现有的代码，重写它以便于将状态对象封装在各自的类中，然后在动作发生时委托给当前状态。
遵照设计原则，最后得到一个容易维护的设计，要做的事情是：
1. 首先，定义一个State接口，在这个接口内，糖果机的每个动作都有一个对应的方法。
2. 然后为机器中的每个状态实现状态类。这些类将负责在对应的状态下进行机器的行为。
3. 最后，摆脱旧的条件代码，取而代之的方式是，将动作委托到状态类。

定义状态接口和类
首先，创建一个State接口，所有的状态都必须实现这个接口：状态的接口里的方法直接映射到糖果机上可能发生的动作。
然后将设计中的每个状态都封装成一个类，每个都实现State接口。

现在有一个糖果机的实现，它在结构上和前一个版本差异颇大，功能上却是一样的。通过从结构上改变实现，已经做到以下几点。
--将每个状态的行为局部化到它自己的类中。
--将容易产生问题的if语句删除，以方便日后的维护。
--让每一个状态“对修改关闭”，让糖果机“对扩展开发”，因为可以加入新的状态类。
--创建一个新的代码基和类结构，这更能映射万能公司的图，而且晚容易阅读和理解。
当动作被调用时，它就会被委托到当前的状态。

定义状态模式
状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
这个描述中的第一部分附有相当多的聚少离多，因为这个模式将状态封装成为独立的类，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态而改变。糖果机提供了一个很好的例子，当糖果机是在NoQuarterState或HasQuarterState两种不同的状态时，投入25分钱，就会得到不同的行为（机器接受25分钟和机器拒绝25分钱）。
定义中的第二部分，一个对象“看起来好像修改了它的类”，从客户的视角来看：如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。实际上，你知道我们是在使用组合通过简单引用不同的状态对象来造成类改变的假象。

Context（上下文）是一个类，它可以拥有一些内部状态。在我们的例子中，GumballMachine就是这个Context。不管是什么时候，只要有人调用Context的request()方法，它就会被委托到状态来处理。
State接口定义了一个所有具体状态的共同接口：任何状态都实现这个相同的接口，这样一来，状态之间可以互相替换。
ConcreteState（具体状态）处理来自Context的请求。每一个ConcreteState都提供了它自己对于请求的实现。所以，当Context改变状态时行为也跟着改变。

策略模式和这张类图是一模一样的。是的，类图是一样的，但是这两个模式的差别在于它们的“意图”。
以状态模式而言，我们将一群行为封装在状态对象中，Context的行为随时可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出context内部的状态，因此，context的行为也会跟着改变。但是context的客户对于状态对象了解不多，甚至是浑然不觉。
而以策略模式而言，客户通常主动指定Context所要组合的策略对象是哪一个。固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个Context对象来说，通常都只有一个最适当的策略对象。
一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很困难。有了策略模式，你可以通过组合不同的对象来改变行为。
我们把状态模式想成是不用在Context中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过在Context内简单地改变状态对象来改变Context的行为。

问：在GumballMachine中，状态决定了下一个状态应该是什么。ConcreteState总是决定接下来的状态是什么吗
答：不，并非总是如此，Context也可以决定状态转换的流向。
一般来讲，当状态转换是固定的时候，就适合放在Context中；然而，当转换是动态的时候，通常就会放在状态类中（例如，在GumballMachine中，由运行时糖果的数据来决定状态要转换到NoQuarter还是SoldOut）。将状态转换放在状态类中的缺点是：状态类之间产生了依赖。在我们的GumballMchine实现中，我们通过使用Context上的getter方法把依赖减到最小，而不是显式硬编码具体状态类。
请注意，在做这个决策的时候，也等于是在为另一件事情做决策：当系统进货时，究竟哪个类是对修改封装（Context还是状态类）的。
问：客户会直接和状态交互吗
答：不会。状态是用在Context中来代表它的内部状态以及行为的，所以只有Context才会对状态提出请求。客户不会直接改变Context的状态。全盘了解状态是Context的工作，客户根本不了解，所以不会直接和状态联系。
问：如果在我的程序中Context有许多实例，这些实例之间可以共享状态对象吗
答：是的，绝对可以，事实上这是很常见的做法。但唯一的前提是，你的状态对象不能持有它们自己的内部状态（如果有内部状态，则所有Context对象持有的状态对象内部状态都一样了）；否则就不能共享。
想要共享状态，你需要把每个状态都指定到静态的实例变量中。如果你的状态需要利用到Context中的方法或者实例变量，你还必须在每个hanlder()方法内传入一个context的引用。
问：状态模式类图显示State是一个抽象类，但你不是使用接口实现糖果机状态的吗
答：是的。如果我们没有共同的功能可以放进抽象类中，就会使用接口（Java中的接口和抽象类）。在你实现状态模式时，很可能想使用抽象类。这么一来，当你以后需要在抽象类中加入新的方法时就很容易，不需要打破具体状态的实现。

//State.h
#ifndef __STATE_H__
#define __STATE_H__

class GumballMachine;

class State
{
public:
	virtual ~State();
	virtual void insertQuarter() = 0;
	virtual void ejectQuater() = 0;
	virtual void turnCrank() = 0;
	virtual void dispense() = 0;
};

class NoQuarterState: public State
{
public:
	NoQuarterState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class HasQuarterState: public State
{
public:
	HasQuarterState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class SoldState: public State//This is a temporary state
{
public:
	SoldState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class SoldOutState: public State
{
public:
	SoldOutState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

#endif

//State.cpp
#include "State.h"
#include "GumballMachine.h"
#include "boost/shared_ptr.hpp"

State::~State()
{

}

NoQuarterState::NoQuarterState( GumballMachine* gumballMachine ): 
gumballMachine_(gumballMachine)
{

}

void NoQuarterState::insertQuarter()
{
	std::cout << "You inserted a quarter." << std::endl;
	gumballMachine_->setState(gumballMachine_->getHasQuarterState());
}

void NoQuarterState::ejectQuater()
{
	std::cout << "You haven't inserted a quarter." << std::endl;
}

void NoQuarterState::turnCrank()
{
	std::cout << "You turned, but there's no quarter." << std::endl;
}

void NoQuarterState::dispense()
{
	std::cout << "You need to pay first." << std::endl;
}

HasQuarterState::HasQuarterState( GumballMachine* gumballMachine ): 
gumballMachine_(gumballMachine)
{

}

void HasQuarterState::insertQuarter()
{
	std::cout << "You can't insert another quarter." << std::endl;
}

void HasQuarterState::ejectQuater()
{
	std::cout << "Quarter returned." << std::endl;
	gumballMachine_->setState(gumballMachine_->getNoQuaterState());
}

void HasQuarterState::turnCrank()
{
	std::cout << "You turned..." << std::endl;
	gumballMachine_->setState(gumballMachine_->getSoldState());
}

void HasQuarterState::dispense()
{
	std::cout << "No gumball dispense." << std::endl;
}

SoldState::SoldState( GumballMachine* gumballMachine ):
gumballMachine_(gumballMachine)
{

}

void SoldState::insertQuarter()
{
	std::cout << "Please wait, we're already giving you a gumball." << std::endl;
}

void SoldState::ejectQuater()
{
	std::cout << "Sorry, you already turned the crank." << std::endl;
}

void SoldState::turnCrank()
{
	std::cout << "Turning twice doesn't get you another gumball." << std::endl;
}

void SoldState::dispense()
{
	gumballMachine_->releaseBall();
	if (gumballMachine_->getCount() > 0)
	{
		gumballMachine_->setState(gumballMachine_->getNoQuaterState());
	}
	else
	{
		std::cout << "Oops, out of gumballs." << std::endl;
		gumballMachine_->setState(gumballMachine_->getSoldOutState());
	}
}

SoldOutState::SoldOutState( GumballMachine* gumballMachine ):
gumballMachine_(gumballMachine)
{

}

void SoldOutState::insertQuarter()
{
	std::cout << "You can't insert a quarter, the machine is sold out." << std::endl;
}

void SoldOutState::ejectQuater()
{
	std::cout << "You can't eject, you haven't insert a quarter yet." << std::endl;
}

void SoldOutState::turnCrank()
{
	std::cout << "You turned, but there are no gumballs." << std::endl;
}

void SoldOutState::dispense()
{
	std::cout << "No gumball dispense." << std::endl;
}

//GumballMachine.h
#ifndef __GUMBALLMACHINE_H__
#define __GUMBALLMACHINE_H__
#include "boost/shared_ptr.hpp"

class State;

class GumballMachine
{
public:
	GumballMachine(int numberGumballs);
	void insertQuarter();
	void ejectQuater();
	void turnCrank();

	void setState(boost::shared_ptr<State> state);
	void releaseBall();
	int getCount() const;
	boost::shared_ptr<State> getHasQuarterState() const;
	boost::shared_ptr<State> getNoQuaterState() const;
	boost::shared_ptr<State> getSoldOutState() const;
	boost::shared_ptr<State> getSoldState() const;
private:
	void setAllStates();

	boost::shared_ptr<State> soldOutState_;
	boost::shared_ptr<State> noQuarterState_;
	boost::shared_ptr<State> hasQuarterState_;
	boost::shared_ptr<State> soldState_;
	
	boost::shared_ptr<State> state_;
	int count_;
};

#endif

//GumballMachine.cpp
#include "GumballMachine.h"
#include "State.h"

//这里用这个构造函数，会报warning，
//d:\program files\vc projects\learningtest\learningtest\gumballmachine.cpp(5): warning C4355: “this”: 用于基成员初始值设定项列表
//感觉是在构造列表中，GumballMachine的数据成员还在构造中，这时候对象GumballMachine还是不完整的，就已经要用这个对象this去构造四个状态对象了，所以会有警告，经试验，还是可以正常运行的
//GumballMachine::GumballMachine( int numberGumballs ):
//count_(numberGumballs), soldOutState_(new SoldOutState(this)), noQuarterState_(new NoQuarterState(this)),
//	hasQuarterState_(new HasQuarterState(this)), soldState_(new SoldState(this)), state_(soldOutState_)
//{
//	if (count_ > 0)
//	{
//		state_ = noQuarterState_;
//	}
//}
//这是新写的构造函数，先将所有成员构造好，再用setAllStates()函数去重新设置所有状态成员的值
GumballMachine::GumballMachine( int numberGumballs ):
count_(numberGumballs), soldOutState_(), noQuarterState_(),
	hasQuarterState_(), soldState_(), state_()
{
	setAllStates();
	if (count_ > 0)
	{
		state_ = noQuarterState_;
	}
}

boost::shared_ptr<State> GumballMachine::getHasQuarterState() const
{
	return hasQuarterState_;
}

boost::shared_ptr<State> GumballMachine::getNoQuaterState() const
{
	return noQuarterState_;
}

boost::shared_ptr<State> GumballMachine::getSoldOutState() const
{
	return soldOutState_;
}

boost::shared_ptr<State> GumballMachine::getSoldState() const
{
	return soldState_;
}

void GumballMachine::setState( boost::shared_ptr<State> state )
{
	state_ = state;
}

void GumballMachine::releaseBall()
{
	std::cout << "A gumball comes rolling out of slot..." << std::endl;
	//if ()
	--count_;
}

int GumballMachine::getCount() const
{
	return count_;
}

void GumballMachine::insertQuarter()//这些动作很容易实现，我们只是委托到当前状态
{
	state_->insertQuarter();
}

void GumballMachine::ejectQuater()
{
	state_->ejectQuater();
}

void GumballMachine::turnCrank()
{
	state_->turnCrank();
	state_->dispense();//我们不需要在GumballMachine中准备一个dispense()的动作方法，因为这只是一个内部的动作，用户不可以直接要求机器发放糖果。但我们是在状态对象的turnCrank()方法中调用dispense()方法的。
}

void GumballMachine::setAllStates()
{
	soldOutState_.reset(new SoldOutState(this));
	hasQuarterState_.reset(new HasQuarterState(this));
	noQuarterState_.reset(new NoQuarterState(this));
	soldState_.reset(new SoldState(this));
	state_ = soldOutState_;
}

//main.cpp
#include <iostream>
#include "State.h"
#include "GumballMachine.h"
using namespace std;

int main ()
{
	GumballMachine gumballMachine(3);
	gumballMachine.ejectQuater();
	gumballMachine.turnCrank();
	gumballMachine.insertQuarter();
	gumballMachine.insertQuarter();
	gumballMachine.turnCrank();
	gumballMachine.turnCrank();
}

//增加一个WinnerState后的代码，变化点HasQuarterState的turnCrank()函数修改了可以转到WinnerState，新增了WinnerState，GumballMachine增加了winnerState_的状态，以及相应的getter函数。
//State.h
#ifndef __STATE_H__
#define __STATE_H__

class GumballMachine;

class State
{
public:
	virtual ~State();
	virtual void insertQuarter() = 0;
	virtual void ejectQuater() = 0;
	virtual void turnCrank() = 0;
	virtual void dispense() = 0;
};

class NoQuarterState: public State
{
public:
	NoQuarterState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class HasQuarterState: public State
{
public:
	HasQuarterState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class SoldState: public State//This is a temporary state
{
public:
	SoldState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class SoldOutState: public State
{
public:
	SoldOutState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

class WinnerState: public State//This is a temporary state
{
public:
	WinnerState(GumballMachine* gumballMachine);
	virtual void insertQuarter();
	virtual void ejectQuater();
	virtual void turnCrank();
	virtual void dispense();
private:
	GumballMachine* gumballMachine_;
};

#endif

//State.cpp
#include <ctime>
#include "State.h"
#include "GumballMachine.h"
#include "boost/shared_ptr.hpp"

State::~State()
{

}

NoQuarterState::NoQuarterState( GumballMachine* gumballMachine ): 
gumballMachine_(gumballMachine)
{

}

void NoQuarterState::insertQuarter()
{
	std::cout << "You inserted a quarter." << std::endl;
	gumballMachine_->setState(gumballMachine_->getHasQuarterState());
}

void NoQuarterState::ejectQuater()
{
	std::cout << "You haven't inserted a quarter." << std::endl;
}

void NoQuarterState::turnCrank()
{
	std::cout << "You turned, but there's no quarter." << std::endl;
}

void NoQuarterState::dispense()
{
	std::cout << "You need to pay first." << std::endl;
}

HasQuarterState::HasQuarterState( GumballMachine* gumballMachine ): 
gumballMachine_(gumballMachine)
{

}

void HasQuarterState::insertQuarter()
{
	std::cout << "You can't insert another quarter." << std::endl;
}

void HasQuarterState::ejectQuater()
{
	std::cout << "Quarter returned." << std::endl;
	gumballMachine_->setState(gumballMachine_->getNoQuaterState());
}

void HasQuarterState::turnCrank()
{
	std::cout << "You turned..." << std::endl;
	srand(static_cast<unsigned>(time(NULL)));//增加随机数产生器，产生10%赢的机会
	unsigned winner = rand() % 10;
	if (0 == winner && gumballMachine_->getCount() > 1)//决定这个顾客是否赢了，如果赢了，并且有足够糖果的话，就进入WinnerState状态，否则进入SoldState状态
	{
		gumballMachine_->setState(gumballMachine_->getWinnerState());
	}
	else
	{
		gumballMachine_->setState(gumballMachine_->getSoldState());
	}
}

void HasQuarterState::dispense()
{
	std::cout << "No gumball dispense." << std::endl;
}

SoldState::SoldState( GumballMachine* gumballMachine ):
gumballMachine_(gumballMachine)
{

}

void SoldState::insertQuarter()
{
	std::cout << "Please wait, we're already giving you a gumball." << std::endl;
}

void SoldState::ejectQuater()
{
	std::cout << "Sorry, you already turned the crank." << std::endl;
}

void SoldState::turnCrank()
{
	std::cout << "Turning twice doesn't get you another gumball." << std::endl;
}

void SoldState::dispense()
{
	gumballMachine_->releaseBall();
	if (gumballMachine_->getCount() > 0)
	{
		gumballMachine_->setState(gumballMachine_->getNoQuaterState());
	}
	else
	{
		std::cout << "Oops, out of gumballs!" << std::endl;
		gumballMachine_->setState(gumballMachine_->getSoldOutState());
	}
}

SoldOutState::SoldOutState( GumballMachine* gumballMachine ):
gumballMachine_(gumballMachine)
{

}

void SoldOutState::insertQuarter()
{
	std::cout << "You can't insert a quarter, the machine is sold out." << std::endl;
}

void SoldOutState::ejectQuater()
{
	std::cout << "You can't eject, you haven't insert a quarter yet." << std::endl;
}

void SoldOutState::turnCrank()
{
	std::cout << "You turned, but there are no gumballs." << std::endl;
}

void SoldOutState::dispense()
{
	std::cout << "No gumball dispense." << std::endl;
}

WinnerState::WinnerState( GumballMachine* gumballMachine ):
gumballMachine_(gumballMachine)
{

}

void WinnerState::insertQuarter()
{
	std::cout << "Please wait, we're already giving you a gumball." << std::endl;
}

void WinnerState::ejectQuater()
{
	std::cout << "Sorry, you already turned the crank." << std::endl;
}

void WinnerState::turnCrank()
{
	std::cout << "Turning twice doesn't get you another gumball." << std::endl;
}

void WinnerState::dispense()
{
	std::cout << "YOU'RE A WINNER! You get two gumballs for your quarter." << std::endl;
	gumballMachine_->releaseBall();
	if (0 == gumballMachine_->getCount())
	{
		std::cout << "Sorry, there is only one gumball for your quarter." << std::endl;
		gumballMachine_->setState(gumballMachine_->getSoldOutState());
	}
	else
	{
		gumballMachine_->releaseBall();
		if (0 == gumballMachine_->getCount())
		{
			std::cout << "Oops, out of gumballs!" << std::endl;
			gumballMachine_->setState(gumballMachine_->getSoldOutState());
		}
		else
		{
			gumballMachine_->setState(gumballMachine_->getNoQuaterState());
		}
	}
}

//GumballMachine.h
#ifndef __GUMBALLMACHINE_H__
#define __GUMBALLMACHINE_H__
#include "boost/shared_ptr.hpp"

class State;

class GumballMachine
{
public:
	GumballMachine(int numberGumballs);
	void insertQuarter();
	void ejectQuater();
	void turnCrank();

	void setState(boost::shared_ptr<State> state);
	void releaseBall();
	int getCount() const;
	void refill(int numberGumballs);
	boost::shared_ptr<State> getHasQuarterState() const;
	boost::shared_ptr<State> getNoQuaterState() const;
	boost::shared_ptr<State> getSoldOutState() const;
	boost::shared_ptr<State> getSoldState() const;
	boost::shared_ptr<State> getWinnerState() const;
private:
	void setAllStates();

	boost::shared_ptr<State> soldOutState_;
	boost::shared_ptr<State> noQuarterState_;
	boost::shared_ptr<State> hasQuarterState_;
	boost::shared_ptr<State> soldState_;
	boost::shared_ptr<State> winnerState_;
	
	boost::shared_ptr<State> state_;
	int count_;
};

#endif

//GumballMachine.cpp
#include "GumballMachine.h"
#include "State.h"

GumballMachine::GumballMachine( int numberGumballs ):
count_(numberGumballs), soldOutState_(), noQuarterState_(),
	hasQuarterState_(), soldState_(), winnerState_(), state_()
{
	setAllStates();
	if (count_ > 0)
	{
		state_ = noQuarterState_;
	}
}

boost::shared_ptr<State> GumballMachine::getHasQuarterState() const
{
	return hasQuarterState_;
}

boost::shared_ptr<State> GumballMachine::getNoQuaterState() const
{
	return noQuarterState_;
}

boost::shared_ptr<State> GumballMachine::getSoldOutState() const
{
	return soldOutState_;
}

boost::shared_ptr<State> GumballMachine::getSoldState() const
{
	return soldState_;
}

boost::shared_ptr<State> GumballMachine::getWinnerState() const
{
	return winnerState_;
}

void GumballMachine::setState( boost::shared_ptr<State> state )
{
	state_ = state;
}

void GumballMachine::releaseBall()
{
	std::cout << "A gumball comes rolling out of slot..." << std::endl;
	--count_;
}

int GumballMachine::getCount() const
{
	return count_;
}

void GumballMachine::insertQuarter()
{
	state_->insertQuarter();
}

void GumballMachine::ejectQuater()
{
	state_->ejectQuater();
}

void GumballMachine::turnCrank()
{
	state_->turnCrank();
	state_->dispense();
}

void GumballMachine::setAllStates()
{
	soldOutState_.reset(new SoldOutState(this));
	hasQuarterState_.reset(new HasQuarterState(this));
	noQuarterState_.reset(new NoQuarterState(this));
	soldState_.reset(new SoldState(this));
	winnerState_.reset(new WinnerState(this));
	state_ = soldOutState_;
}

void GumballMachine::refill( int numberGumballs )//新增的refill函数，
{
	if (numberGumballs > 0)
	{
		if (0 == count_)//感觉这里应该加上这个判断，当前count_为0时，才需要重置；否则像书上P428示例，任何情况下都重置的话，很有可能hasQuarterState_状态下，把别人的钱给清掉了
		{
			state_ = noQuarterState_;
		}
		count_ = numberGumballs;
	}
}

//main.cpp未变
输出如下：
You haven't inserted a quarter.
You turned, but there's no quarter.
You need to pay first.
You inserted a quarter.
You can't insert another quarter.
You turned...
YOU'RE A WINNER! You get two gumballs for your quarter.
A gumball comes rolling out of slot...
A gumball comes rolling out of slot...
Oops, out of gumballs!
You turned, but there are no gumballs.
No gumball dispense.
请按任意键继续. . .

《Head First》的例子中Context中的所有状态都保存在该对象中，在需要的时候进行重新设置；而在《大话设计模式》和《23种设计模式》中，Context对象中只有一个state_，它的每一个新状态都是new出来的，并且在切换到下一个状态时先将当前状态释放掉。个人感觉《Head First》中的方法更好，减少了状态对象的重复构造和析构。

问：为什么需要WinnerState，为什么不直接在SoldState中发放两颗糖果
答：这是一个好问题。这两个几乎一样，唯一的差别在于，WinnerState状态会发放两颗糖果。当然可以将发放两颗糖果的代码放在SoldState中，这么做有缺点，等于是将两个状态用一个状态类来代码。这样你牺牲了状态类的清晰易懂来减少一些冗余代码。你也应该考虑到前面的章节中所学到的原则：一个类，一个责任。将WinnerState状态的责任放进SoldState状态中，等于是让SoldState状态具有两个责任。

待改进的地方：
--在售出糖果和赢家状态中，有许多重复的代码。必须把这部分清理一下。可以把State设计成抽象类，然后把方法的默认行为放在其中。毕竟，像是“你已经投入25分钟”这类的消息，不会被顾客看见。所以，所有的“错误响应”行为都可以写得具有通用性。并放在抽象的State类中供子类继承。
--dispense()方法即便是在没有25分钱时曲柄被转动的情况下也总是会被调用。我们可以修改这部分，做法是让turnCrank()返回一个布尔值，或者引入异常。
--状态转换的所有智能被放在状态类中，这可能导致什么问题。要将逻辑移进糖果机中吗，这有什么优缺点
--你会实例化许多的GumballMachine对象吗，如果是的话，你可能想要将状态的实例移到静态的实例变量中共享。这需要对GumballMachine和State做怎么样的改变（将GumballMachine的内部状态成员设置为static）

--状态模式允许一个对象基于内部状态而拥有不同的行为。
--和程序状态机（PSM）不同，状态模式用类代表状态。
--Context会将行为委托给当前状态对象。
--通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。
--状态模式和策略模式有相同的类图，但是它们的意图不同。
--策略模式通常会用行为或算法来配置Context类。
--状态模式允许Context随着状态的改变而改变行为。
--状态转换可以由State类或Context类控制。
--使用状态模式通常会导致设计中类的数目大量增加。
--状态类可以被多个Context实例共享。
//------------------------------------------------------------------------------------------------
//Head First 第11章 代理模式--控制对象的访问
代理要做的：控制和管理访问
在开始编码之前，要先收集需求。
远程代理的角色
远程代码好比“远程对象的本地代表”。所谓“远程对象”，是一种对象，活在不同的Java虚拟机（JVM）堆中（更一般的说法为，在不同的地址空间运行的远程对象）。所谓“本地代码”，这是一种可以由本地方法调用的对象，其行为会转发到远程对象中。
代理可以假装自己是远程对象，但其实只是一个中间的角色。糖果监视器是客户对象，它以为沟通的对象是真正的糖果机，但真正与它沟通的是代理，再由代理通过网络和真正的糖果机沟通。
远程对象才是真东西，它拥有真正做事的一些方法。
你的客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆的“代理”对象上的方法，再由代理处理所有网络通信的低层细节。

假如我们想要设计一个系统，能够调用本地对象，然后将每个请求转发到远程对象上进行。我们需要一些辅助对象，帮我们真正进行沟通。这些辅助对象使客户就像在调用本地对象的方法（事实也是如此）一样。客户调用客户辅助对象上的方法，仿佛客户辅助对象就是真正的服务。客户辅助对象再负责为我们转发这些请求。
换句话说，客户对象以为它调用的是远程服务上的方法因为客户辅助对象乔装成服务对象，假装自己有客户所要调用的方法。
但客户辅助对象不是真正的远程服务。虽然操作看起来很像（因为具有服务所宣称的相同的方法），但是并不真正拥有客户所期望的方法逻辑。客户辅助对象会联系服务器，传递方法调用信息（例如，方法名称、变量等），然后等待服务器的返回。
在服务器端，服务辅助对象从客户辅助对象中接收请求（透过Socket连接），将调用的信息解包，然后调用真正服务对象上的真正方法。所以，对于服务对象来说，调用是本地的，来自服务辅助对象，而不是远程客户。
服务辅助对象从服务中得到返回值，将它打包，然后运回到客户辅助对象（通过网络Socket的输出流），客户辅助对象对信息解包，最后将返回值交给客户对象。

定义代理模式
代理模式：为另一个对象提供一个替身或点位符以控制对这个对象的访问。

在糖果机的例子中，代理控制了对远程对象的访问。代理之所以需要控制访问，是因为我们的客户（监视器）不知道如何和远程对象沟通。从某个方面来看，远程代理控制访问，好帮我们处理网络上的细节。代理模式有许多变体，而这些变体几乎都和“控制访问”的做法有关。几种代理控制访问的方式：
--远程代理控制访问远程对象
--虚拟代理控制访问创建开销大的资源
--保护代理基于权限控制对资源的访问

使用代理模式创建代表（representative）对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

Subject，它为RealSubject和Proxy提供了接口。通过实现同一接口，Proxy在RealSubject出现的地方取代它。
RealSubject是真正做事的对象，它是被proxy代理和控制访问的对象。
Proxy持有RealSubject的引用。在某些例子中，Proxy还会负责RealSubject对象的创建与销毁。客户和RealSubject的交互都必须通过Proxy。因为Proxy和RealSubject实现相同的接口（Subject），所以任何用到RealSubject的地方，都可以用Proxy取代。Proxy也控制了对RealSubject的访问，在某些情况下，我们可能需要这样的控制。这些情况包括RealSubject是远程的对象、RealSubject创建开销大，或RealSubject需要被保护。

准备虚拟代理（Virtual Proxy）
远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。
虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。

虚拟代理可以代理Icon，管理背景的加载，并在加载未完成时显示“CD封面加载中，请稍候......”，一旦加载完成，代理就把显示的职责委托给Icon。

问：我要如何让客户使用代理，而不是真正的对象
答：一个常用的技巧是提供一个工厂，实例化并返回主题。因为这是在工厂方法内发生的，我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。

保护代理

--代理在结构上类似装饰者，但是目的不同。
--装饰者模式为对象加上行为，而代理则是控制访问。
//------------------------------------------------------------------------------------------------
//Head First 第12章 复合模式--模式的模式
模式通常被一起使用，并被组合在同一个设计解决方案中。
复合模式在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题。

//Quackable.h
#ifndef __QUACKABLE_H__
#define __QUACKABLE_H__

class Quackable
{
public:
	virtual ~Quackable();
	virtual void quack() = 0;
};

class MallardDuck: public Quackable
{
public:
	virtual void quack();
};

class RedHeadDuck: public Quackable
{
public:
	virtual void quack();
};

class DuckCall: public Quackable
{
public:
	virtual void quack();
};

class RubberDuck: public Quackable
{
public:
	virtual void quack();
};
#endif

//Quackable.cpp
#include <iostream>
#include "Quackable.h"

Quackable::~Quackable()
{

}

void MallardDuck::quack()
{
	std::cout << "Quack" << std::endl;
}

void RedHeadDuck::quack()
{
	std::cout << "Quack" << std::endl;
}

void DuckCall::quack()
{
	std::cout << "Kwak" << std::endl;
}

void RubberDuck::quack()
{
	std::cout << "Squeak" << std::endl;
}

//DuckSimulator.h
#ifndef __DUCKSIMULATOR_H__
#define __DUCKSIMULATOR_H__
#include <memory>

class Quackable;

class DuckSimulator
{
public:
	static void main();
private:
	void simulate();
	void simulate(std::auto_ptr<Quackable>& duck);
};
#endif

//DuckSimulator.cpp
#include <iostream>
#include "DuckSimulator.h"
#include "Quackable.h"

void DuckSimulator::main()
{
	DuckSimulator duckSimulator;
	duckSimulator.simulate();
}

void DuckSimulator::simulate()
{
	std::auto_ptr<Quackable> mallardDuck(new MallardDuck());
	std::auto_ptr<Quackable> redHeadDuck(new RedHeadDuck());
	std::auto_ptr<Quackable> duckCall(new DuckCall());
	std::auto_ptr<Quackable> rubberDuck(new RubberDuck());

	std::cout << "Duck Simulator:" << std::endl;

	simulate(mallardDuck);
	simulate(redHeadDuck);
	simulate(duckCall);
	simulate(rubberDuck);
}

void DuckSimulator::simulate( std::auto_ptr<Quackable>& duck )
{
	duck->quack();
}

//main.cpp
#include <iostream>
#include "DuckSimulator.h"
using namespace std;

int main ()
{
	DuckSimulator::main();
}
输出如下：
Duck Simulator:
Quack
Quack
Kwak
Squeak
请按任意键继续. . .

//新增了Goose，希望也可以像鸭子一样叫，用适配器模式
//Goose.h
#ifndef __GOOSE_H__
#define __GOOSE_H__
#include <memory>
#include "Quackable.h"

class Goose
{
public:
	void honk();
};

class GooseAdapter: public Quackable
{
public:
	GooseAdapter(std::auto_ptr<Goose> pGoose);
	virtual void quack();
private:
	std::auto_ptr<Goose> pGoose_;
};
#endif

//Goose.cpp
#include <iostream>
#include "Goose.h"

void Goose::honk()
{
	std::cout << "Honk" << std::endl;
}

GooseAdapter::GooseAdapter( std::auto_ptr<Goose> pGoose ): pGoose_(pGoose)
{

}

void GooseAdapter::quack()
{
	pGoose_->honk();
}

//DuckSimulator.cpp
#include <iostream>
#include "DuckSimulator.h"
#include "Quackable.h"
#include "Goose.h"

void DuckSimulator::main()
{
	DuckSimulator duckSimulator;
	duckSimulator.simulate();
}

void DuckSimulator::simulate()
{
	std::auto_ptr<Quackable> mallardDuck(new MallardDuck());
	std::auto_ptr<Quackable> redHeadDuck(new RedHeadDuck());
	std::auto_ptr<Quackable> duckCall(new DuckCall());
	std::auto_ptr<Quackable> rubberDuck(new RubberDuck());
	
	std::auto_ptr<Goose> goose(new Goose());//新增
	std::auto_ptr<Quackable> gooseDuck(new GooseAdapter(goose));//新增

	std::cout << "Duck Simulator:" << std::endl;

	simulate(mallardDuck);
	simulate(redHeadDuck);
	simulate(duckCall);
	simulate(rubberDuck);
	simulate(gooseDuck);//新增
}

void DuckSimulator::simulate( std::auto_ptr<Quackable>& duck )
{
	duck->quack();
}
输出如下：
Duck Simulator:
Quack
Quack
Kwak
Squeak
Honk
请按任意键继续. . .

//要统计鸭子叫的次数，并且不改变现在代码，用装饰模式，为Quackable类增加计数功能
//Quackable.h
#include <memory>

class QuickCounter: public Quackable
{
public:
	QuickCounter(std::auto_ptr<Quackable> pDuck);
	virtual void quack();
	static int getQuacks();
private:
	std::auto_ptr<Quackable> pDuck_;
	static int numberOfDucks_;
};

//Quackable.cpp
QuickCounter::QuickCounter( std::auto_ptr<Quackable> pDuck ): pDuck_(pDuck)
{

}

void QuickCounter::quack()
{
	pDuck_->quack();
	++numberOfDucks_;
}

int QuickCounter::getQuacks()
{
	return numberOfDucks_;
}

int QuickCounter::numberOfDucks_ = 0;

//DuckSimulator.cpp
void DuckSimulator::simulate()
{
	std::auto_ptr<Quackable> mallardDuck(new QuickCounter(std::auto_ptr<Quackable>(new MallardDuck())));//感觉这种初始化方式不好，像是Effective C++中所述的在函数入参中调用new？？？
	std::auto_ptr<Quackable> redHeadDuck(new QuickCounter(std::auto_ptr<Quackable>(new RedHeadDuck())));
	std::auto_ptr<Quackable> duckCall(new QuickCounter(std::auto_ptr<Quackable>(new DuckCall())));
	std::auto_ptr<Quackable> rubberDuck(new QuickCounter(std::auto_ptr<Quackable>(new RubberDuck())));
	
	std::auto_ptr<Goose> goose(new Goose());
	std::auto_ptr<Quackable> gooseDuck(new GooseAdapter(goose));

	std::cout << "Duck Simulator:" << std::endl;

	simulate(mallardDuck);
	simulate(redHeadDuck);
	simulate(duckCall);
	simulate(rubberDuck);
	simulate(gooseDuck);

	std::cout << "The ducks quacked " << QuickCounter::getQuacks() << " times." << std::endl;
}
输出如下：
Duck Simulator:
Quack
Quack
Kwak
Squeak
Honk
The ducks quacked 4 times.
请按任意键继续. . .

至此，你必须装饰对象来获得被装饰过的行为
没错，包装对象的问题就是这样：有包装才有效果，没包装就没有效果。
为什么不将创建鸭子的程序集中在一个地方呢。换句话说，让我们将创建和装饰的部分包装起来吧。

我们需要工厂产生鸭子！
//AbstractDuckFactory.h
#ifndef __ABSTRACTDUCKFACTORY_H__
#define __ABSTRACTDUCKFACTORY_H__
#include <memory>

class Quackable;

class AbstractDuckFactory
{
public:
	virtual std::auto_ptr<Quackable> createMallardDuck() = 0;
	virtual std::auto_ptr<Quackable> createRedHeadDuck() = 0;
	virtual std::auto_ptr<Quackable> createDuckCall() = 0;
	virtual std::auto_ptr<Quackable> createRubberDuck() = 0;
};

class DuckFactory: public AbstractDuckFactory//DuckFactory扩展抽象工厂
{
public:
	//每个方法创建一个产品：一种特定种类的Quackable。模拟器并不知道实际的产品是什么，只知道它实现了Quackable接口。
	virtual std::auto_ptr<Quackable> createMallardDuck();
	virtual std::auto_ptr<Quackable> createRedHeadDuck();
	virtual std::auto_ptr<Quackable> createDuckCall();
	virtual std::auto_ptr<Quackable> createRubberDuck();
};

class CountingDuckFactory: public AbstractDuckFactory//CountingDuckFactory也扩展自抽象工厂
{
public:
	//每个方法都会先用叫声计数装饰者将Quackable包装起来。模拟器并不知道有何不同，只知道它实现了Quackable接口。但是巡逻员可以因此放心，所有的叫声都会被计算进去。
	virtual std::auto_ptr<Quackable> createMallardDuck();
	virtual std::auto_ptr<Quackable> createRedHeadDuck();
	virtual std::auto_ptr<Quackable> createDuckCall();
	virtual std::auto_ptr<Quackable> createRubberDuck();
};

#endif

//AbstractDuckFactory.cpp
#include "AbstractDuckFactory.h"
#include "Quackable.h"

std::auto_ptr<Quackable> DuckFactory::createMallardDuck()
{
	return std::auto_ptr<Quackable>(new MallardDuck());
}

std::auto_ptr<Quackable> DuckFactory::createRedHeadDuck()
{
	return std::auto_ptr<Quackable>(new RedHeadDuck());
}

std::auto_ptr<Quackable> DuckFactory::createDuckCall()
{
	return std::auto_ptr<Quackable>(new DuckCall());
}

std::auto_ptr<Quackable> DuckFactory::createRubberDuck()
{
	return std::auto_ptr<Quackable>(new RubberDuck());
}

std::auto_ptr<Quackable> CountingDuckFactory::createMallardDuck()
{
	return std::auto_ptr<Quackable>(new QuickCounter(std::auto_ptr<Quackable>(new MallardDuck())));
}

std::auto_ptr<Quackable> CountingDuckFactory::createRedHeadDuck()
{
	return std::auto_ptr<Quackable>(new QuickCounter(std::auto_ptr<Quackable>(new RedHeadDuck())));
}

std::auto_ptr<Quackable> CountingDuckFactory::createDuckCall()
{
	return std::auto_ptr<Quackable>(new QuickCounter(std::auto_ptr<Quackable>(new DuckCall())));
}

std::auto_ptr<Quackable> CountingDuckFactory::createRubberDuck()
{
	return std::auto_ptr<Quackable>(new QuickCounter(std::auto_ptr<Quackable>(new RubberDuck())));
}

//DuckSimulator.h
#ifndef __DUCKSIMULATOR_H__
#define __DUCKSIMULATOR_H__
#include <memory>

class AbstractDuckFactory;
class Quackable;

class DuckSimulator
{
public:
	static void main();
private:
	void simulate(std::auto_ptr<AbstractDuckFactory>& duckFactory);
	void simulate(std::auto_ptr<Quackable>& duck);
};
#endif

//DuckSimulator.cpp
#include <iostream>
#include "DuckSimulator.h"
#include "Quackable.h"
#include "Goose.h"
#include "AbstractDuckFactory.h"

void DuckSimulator::main()
{
	DuckSimulator duckSimulator;
	std::auto_ptr<AbstractDuckFactory > duckFactory(new CountingDuckFactory());//首先，我们创建工厂，准备把它传入simulate()方法。
	duckSimulator.simulate(duckFactory);
}

void DuckSimulator::simulate(std::auto_ptr<AbstractDuckFactory>& duckFactory)//simulate()方法需要一个AbstractDuckFactory参数，利用它创建鸭子，而不是直接实例化鸭子。
{
	std::auto_ptr<Quackable> mallardDuck(duckFactory->createMallardDuck());
	std::auto_ptr<Quackable> redHeadDuck(duckFactory->createRedHeadDuck());
	std::auto_ptr<Quackable> duckCall(duckFactory->createDuckCall());
	std::auto_ptr<Quackable> rubberDuck(duckFactory->createRubberDuck());
	
	std::auto_ptr<Goose> goose(new Goose());
	std::auto_ptr<Quackable> gooseDuck(new GooseAdapter(goose));

	std::cout << "Duck Simulator:" << std::endl;

	simulate(mallardDuck);
	simulate(redHeadDuck);
	simulate(duckCall);
	simulate(rubberDuck);
	simulate(gooseDuck);

	std::cout << "The ducks quacked " << QuickCounter::getQuacks() << " times." << std::endl;
}

void DuckSimulator::simulate( std::auto_ptr<Quackable>& duck )
{
	duck->quack();
}
输出跟上次一样。

巡逻员又想管理一群鸭子。
我们需要将鸭子视为一个集合，甚至是子集合（subcollection），为了满足巡回员想管理鸭子家族的要求，如果我们下一次命令，就能让整个集合的鸭子听命行事，就太好了。组合模式可以帮我们。

组合模式允许我们像对待单个对象一样对待对象集合。因为要用到组合模式，组合（菜单）节点需要用容器管理节点，所以std::auto_ptr不能使用了，改为boost::shared_ptr。
//完整代码
//Quackable.h
#ifndef __QUACKABLE_H__
#define __QUACKABLE_H__
#include <list>
#include "boost/shared_ptr.hpp"

class Quackable
{
public:
	virtual ~Quackable();
	virtual void quack() = 0;
	virtual void add(boost::shared_ptr<Quackable> pDuck);
};

class MallardDuck: public Quackable
{
public:
	virtual void quack();
};

class RedHeadDuck: public Quackable
{
public:
	virtual void quack();
};

class DuckCall: public Quackable
{
public:
	virtual void quack();
};

class RubberDuck: public Quackable
{
public:
	virtual void quack();
};

class QuickCounter: public Quackable
{
public:
	QuickCounter(boost::shared_ptr<Quackable> pDuck);
	virtual void quack();
	static int getQuacks();
private:
	boost::shared_ptr<Quackable> pDuck_;
	static int numberOfDucks_;
};

class Flock: public Quackable
{
public:
	virtual void quack();
	void add(boost::shared_ptr<Quackable> pDuck);
private:
	std::list<boost::shared_ptr<Quackable> > duckList_;
};

#endif

//Quackable.cpp
#include <iostream>
#include "Quackable.h"

Quackable::~Quackable()
{

}

void Quackable::add( boost::shared_ptr<Quackable> pDuck )
{

}

void MallardDuck::quack()
{
	std::cout << "Quack" << std::endl;
}

void RedHeadDuck::quack()
{
	std::cout << "Quack" << std::endl;
}

void DuckCall::quack()
{
	std::cout << "Kwak" << std::endl;
}

void RubberDuck::quack()
{
	std::cout << "Squeak" << std::endl;
}

QuickCounter::QuickCounter( boost::shared_ptr<Quackable> pDuck ): pDuck_(pDuck)
{

}

void QuickCounter::quack()
{
	pDuck_->quack();
	++numberOfDucks_;
}

int QuickCounter::getQuacks()
{
	return numberOfDucks_;
}

int QuickCounter::numberOfDucks_ = 0;


void Flock::add( boost::shared_ptr<Quackable> pDuck )
{
	duckList_.push_back(pDuck);
}

void Flock::quack()
{
	for (std::list<boost::shared_ptr<Quackable> >::iterator iter =duckList_.begin(); iter != duckList_.end(); ++iter)
	{
		(*iter)->quack();
	}
}

//Goose.h
#ifndef __GOOSE_H__
#define __GOOSE_H__
#include "boost/shared_ptr.hpp"
#include "Quackable.h"

class Goose
{
public:
	void honk();
};

class GooseAdapter: public Quackable
{
public:
	GooseAdapter(boost::shared_ptr<Goose> pGoose);
	virtual void quack();
private:
	boost::shared_ptr<Goose> pGoose_;
};
#endif

//Goose.cpp
#include <iostream>
#include "Goose.h"

void Goose::honk()
{
	std::cout << "Honk" << std::endl;
}

GooseAdapter::GooseAdapter( boost::shared_ptr<Goose> pGoose ): pGoose_(pGoose)
{

}

void GooseAdapter::quack()
{
	pGoose_->honk();
}

//AbstractDuckFactory.h
#ifndef __ABSTRACTDUCKFACTORY_H__
#define __ABSTRACTDUCKFACTORY_H__
#include "boost/shared_ptr.hpp"

class Quackable;

class AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck() = 0;
	virtual boost::shared_ptr<Quackable> createRedHeadDuck() = 0;
	virtual boost::shared_ptr<Quackable> createDuckCall() = 0;
	virtual boost::shared_ptr<Quackable> createRubberDuck() = 0;
};

class DuckFactory: public AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck();
	virtual boost::shared_ptr<Quackable> createRedHeadDuck();
	virtual boost::shared_ptr<Quackable> createDuckCall();
	virtual boost::shared_ptr<Quackable> createRubberDuck();
};

class CountingDuckFactory: public AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck();
	virtual boost::shared_ptr<Quackable> createRedHeadDuck();
	virtual boost::shared_ptr<Quackable> createDuckCall();
	virtual boost::shared_ptr<Quackable> createRubberDuck();
};

#endif

//AbstractDuckFactory.cpp
#include "AbstractDuckFactory.h"
#include "Quackable.h"

boost::shared_ptr<Quackable> DuckFactory::createMallardDuck()
{
	return boost::shared_ptr<Quackable>(new MallardDuck());
}

boost::shared_ptr<Quackable> DuckFactory::createRedHeadDuck()
{
	return boost::shared_ptr<Quackable>(new RedHeadDuck());
}

boost::shared_ptr<Quackable> DuckFactory::createDuckCall()
{
	return boost::shared_ptr<Quackable>(new DuckCall());
}

boost::shared_ptr<Quackable> DuckFactory::createRubberDuck()
{
	return boost::shared_ptr<Quackable>(new RubberDuck());
}

boost::shared_ptr<Quackable> CountingDuckFactory::createMallardDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new MallardDuck())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createRedHeadDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new RedHeadDuck())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createDuckCall()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new DuckCall())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createRubberDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new RubberDuck())));
}

//DuckSimulator.h
#ifndef __DUCKSIMULATOR_H__
#define __DUCKSIMULATOR_H__
#include "boost/shared_ptr.hpp"

class AbstractDuckFactory;
class Quackable;

class DuckSimulator
{
public:
	static void main();
private:
	void simulate(boost::shared_ptr<AbstractDuckFactory>& duckFactory);
	void simulate(boost::shared_ptr<Quackable>& duck);
};
#endif

//DuckSimulator.cpp
#include <iostream>
#include "DuckSimulator.h"
#include "Quackable.h"
#include "Goose.h"
#include "AbstractDuckFactory.h"

void DuckSimulator::main()
{
	DuckSimulator duckSimulator;
	boost::shared_ptr<AbstractDuckFactory > duckFactory(new CountingDuckFactory());
	duckSimulator.simulate(duckFactory);
}

void DuckSimulator::simulate(boost::shared_ptr<AbstractDuckFactory>& duckFactory)
{
	//和之前一样，创建所有的Quackable对象
	boost::shared_ptr<Quackable> redHeadDuck(duckFactory->createRedHeadDuck());
	boost::shared_ptr<Quackable> duckCall(duckFactory->createDuckCall());
	boost::shared_ptr<Quackable> rubberDuck(duckFactory->createRubberDuck());
	boost::shared_ptr<Quackable> gooseDuck(new GooseAdapter(boost::shared_ptr<Goose>(new Goose())));

	std::cout << "Duck Simulator: With Composite - Flocks" << std::endl;
	//先创建一个Flock，然后把许多Quackable塞给它。这个Flock是主群
	boost::shared_ptr<Quackable> flockOfDucks(new Flock());//这里为了在simulate(boost::shared_ptr<Quackable>& duck)中传入Flock对象，必须把flockOfDucks声明为boost::shared_ptr<Quackable>。因为boost::shared_ptr<Flock>无法转换到boost::shared_ptr<Quackable>，虽然Flock是公有继承自Quackable。为了达到这个目的，必须要为Quackable对象增加add虚函数（而不是纯虚函数），为了使改动最小，Quackable该add虚函数提供了默认的空实现。另外有三个折衷方案，1、simulate(boost::shared_ptr<Quackable>& duck)函数改为simulate(boost::shared_ptr<Flock>& duck)；2、simulate(boost::shared_ptr<Quackable>& duck)改为simulate(Quackable& duck)；3、simulate(boost::shared_ptr<Quackable>& duck)改为simulate(Quackable* duck)。感觉这三个方案都不太好：1、改为Flock后，对外接口就变了，不符合之前的呈现；2、改为对象引用&，则所有工厂函数的创建都要改为非指针对象，而且非指针对象构造析构代价太大；3、改为raw指针，需要自己管理指针的创建和删除，太麻烦，而且也不安全。（Head First里，Jave用的方法是2）有没有更好的办法了？？？
	flockOfDucks->add(redHeadDuck);
	flockOfDucks->add(duckCall);
	flockOfDucks->add(rubberDuck);
	flockOfDucks->add(gooseDuck);

	boost::shared_ptr<Quackable> flockOfMallards(new Flock());//然后创建一个新的绿头鸭群
	//这里在第一次写的时候，写的是new MallardDuck()，而不是工厂创建出来的装饰对象，所以鸭子叫声没有统计进去
	boost::shared_ptr<Quackable> mallardOne(duckFactory->createMallardDuck());//创建绿头小家族
	boost::shared_ptr<Quackable> mallardTwo(duckFactory->createMallardDuck());
	boost::shared_ptr<Quackable> mallardThree(duckFactory->createMallardDuck());
	boost::shared_ptr<Quackable> mallardFour(duckFactory->createMallardDuck());

	flockOfMallards->add(mallardOne);//加入绿头鸭群
	flockOfMallards->add(mallardTwo);
	flockOfMallards->add(mallardThree);
	flockOfMallards->add(mallardFour);

	flockOfDucks->add(flockOfMallards);//将绿头鸭群加入主群

	std::cout << "\nDuck Simulator: Whole Flock Simulation:" << std::endl;
	simulate(flockOfDucks);

	std::cout << "\nDuck Simulator: Mallard Flock Simulation:" << std::endl;
	simulate(flockOfMallards);

	std::cout << "The ducks quacked " << QuickCounter::getQuacks() << " times." << std::endl;
}

void DuckSimulator::simulate( boost::shared_ptr<Quackable>& duck )
{
	duck->quack();
}

//main.cpp
#include <iostream>
#include "DuckSimulator.h"
using namespace std;

int main ()
{
	DuckSimulator::main();
}
输出如下：
Duck Simulator: With Composite - Flocks

Duck Simulator: Whole Flock Simulation:
Quack
Kwak
Squeak
Honk
Quack
Quack
Quack
Quack

Duck Simulator: Mallard Flock Simulation:
Quack
Quack
Quack
Quack
The ducks quacked 11 times.
请按任意键继续. . .

安全性VS透明性
在组合模式章节中，组合（菜单）和叶节点（菜单项）具有一组相同的方法，其中包括了add()方法。就因为有一组相同的方法，我们才能在菜单项上调用不起作用的方法（像通过调用add()来在菜单项内加入一些东西）。这么设计的好处是，叶节点和组合之间是“透明的”。客户根本不用客究竟是组合还是叶节点，客户只是调用两者的同一个方法。
但是在这里，我们决定把组合维护孩子的方法和叶节点分开，也就是说，我们打算只让Flock具有add()方法。我们知道给一个Duck添加某些东西是无意义的。这样的设计比较“安全”，你不会调用无意义的方法，但是透明性比较差。现在，客户如果想调用add()，得先确定该Quackable对象是Flock才行。
在OO设计的过程中，折衷一直都是免不了的，在创建你自己的组合时，你需要考虑这些。

呱呱叫学家想观察个别鸭子的行为
//完整代码
//首先，需要一个Observable接口。
//QuackObservable.h
#ifndef __QUACKOBSERVABLE_H__
#define __QUACKOBSERVABLE_H__
#include <list>
#include <string>
#include "boost/shared_ptr.hpp"

class Observer;

//任何想被观察的Quackable都必须实现QuackObservable接口
class QuackObservable//这就是观察者模式中的Subject，被观察的抽象对象，所有要被观察的具体对象都需要继承此类，因此让Quackable继承此类，所有的具体类就继承了此抽象对象
{
public:
	virtual ~QuackObservable();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver) = 0;//具有注册观察者的方法，任何实现了Observer接口的对象都可以监听呱呱叫。如呱呱叫学家Quackologist实现了Observer接口，他就可以监听呱呱叫了
	virtual void notifyObservers() = 0;
	virtual std::string getName() = 0;
};

//Observable实现了所有必要的功能，只要把它插进一个类，就可以让该类将工作委托给Observable
//Observable必须实现QuackObservable，因为它们具有一组相同的方法，QuackObservable会将这些方法的调用转给Observable的方法
class Observable: public QuackObservable//这里增加了一个中间委托类，本来每一个Quackable的对象都需要自己实现registerObserver()、notifyObservers()的功能，并且增加list对象，保存观察者。但是为了简化操作，每一个Quackable对象通过组合方式增加一个Observable对象，将如上的函数和成员变量都委托给Observable来实现，类似pImpl的实现。
{
public:
	Observable(QuackObservable* pDuck);//构造函数中，传进了QuackObservable。下面的notify()方法，当通知发生时，观察者把些对象传过去，好让观察者知道是哪个对象在呱呱叫（调用getName）
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::list<boost::shared_ptr<Observer> > observers_;
	QuackObservable* pDuck_;
};

#endif

//QuackObservable.cpp
#include "QuackObservable.h"
#include "Observer.h"

QuackObservable::~QuackObservable()
{

}

void Observable::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	observers_.push_back(pObserver);
}

void Observable::notifyObservers()
{
	for (std::list<boost::shared_ptr<Observer> >::iterator iter = observers_.begin(); iter != observers_.end(); ++iter)
	{
		(*iter)->update(pDuck_);
	}
}

Observable::Observable( QuackObservable* pDuck ): pDuck_(pDuck)
{

}

std::string Observable::getName()
{
	return "";
}

//Observer.h
#ifndef __OBSERVER_H__
#define __OBSERVER_H__

class QuackObservable;

class Observer//观察者，只有一个方法，就是update()。这需要传入正在呱呱叫的对象（QuackObservable）。
{
public:
	virtual ~Observer();
	virtual void update(QuackObservable* pDuck) = 0;//这里的QuackObservable即被观察的Subject对象
};

class Quackologist: public Observer//Quackologist实现了Observer接口，可以监听呱呱叫
{
	virtual void update(QuackObservable* pDuck);
};

#endif

//Observer.cpp
#include <iostream>
//#include <typeinfo>
#include "Observer.h"
#include "QuackObservable.h"

Observer::~Observer()
{

}

void Quackologist::update( QuackObservable* pDuck )
{
	//std::cout << "Quackologist: " << typeid(*pDuck).name() << " just quacked." << std::endl;
	std::cout << "Quackologist: " << pDuck->getName() << " just quacked." << std::endl;
}

//整合Observable辅助类和Quackable类
//我们只是要确定Quackable类和Observable组合在一起的，并且它们知道怎样来委托工作。

//Quackable.h
#ifndef __QUACKABLE_H__
#define __QUACKABLE_H__
#include <list>
#include <string>
#include "boost/shared_ptr.hpp"
#include "QuackObservable.h"

//确定所有的Quackable都实现此接口，所以干脆让Quackable扩展（Jave的说法，extends）此接口
class Quackable: public QuackObservable
{
public:
	virtual ~Quackable();
	virtual void quack() = 0;
	virtual void add(boost::shared_ptr<Quackable> pDuck);
};

class Observer;

class MallardDuck: public Quackable
{
public:
	MallardDuck();
	virtual void quack();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::string name_;
	boost::shared_ptr<Observable> pObservable_;//上面所讲的委托对象，所有注册和通知工作都委托给Observable对象去做。每个Quackable都有一个Observable实例变量。
};

class RedHeadDuck: public Quackable
{
public:
	RedHeadDuck();
	virtual void quack();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::string name_;
	boost::shared_ptr<Observable> pObservable_;
};

class DuckCall: public Quackable
{
public:
	DuckCall();
	virtual void quack();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::string name_;
	boost::shared_ptr<Observable> pObservable_;
};

class RubberDuck: public Quackable
{
public:
	RubberDuck();
	virtual void quack();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::string name_;
	boost::shared_ptr<Observable> pObservable_;
};

class QuickCounter: public Quackable
{
public:
	QuickCounter(boost::shared_ptr<Quackable> pDuck);
	virtual void quack();
	static int getQuacks();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	boost::shared_ptr<Quackable> pDuck_;
	static int numberOfDucks_;
	//boost::shared_ptr<Observable> pObservable_;//装饰者QuickCounter不需要有观察者，它的注册和通知都是委托给pDuck_来做的
};

class Flock: public Quackable
{
public:
	virtual void quack();
	void add(boost::shared_ptr<Quackable> pDuck);
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::list<boost::shared_ptr<Quackable> > duckList_;
};

#endif

//Quackable.cpp
#include <iostream>
#include "Quackable.h"

Quackable::~Quackable()
{

}

void Quackable::add( boost::shared_ptr<Quackable> pDuck )
{

}

void MallardDuck::quack()
{
	std::cout << "Quack" << std::endl;
	notifyObservers();//当我们呱呱叫时，需要让观察者知道。
}

MallardDuck::MallardDuck(): name_("Mallard Duck"), pObservable_()
{
	pObservable_.reset(new Observable(this));//构造器中，创建一个Observable，并传入一个MallardDuck对象的引用
}
//若改成在初始化列表中用this初始化pObservable_，如下，则会报一个警告：
//1>d:\program files\vc projects\learningtest\learningtest\quackable.cpp(20): warning C4355: “this”: 用于基成员初始值设定项列表
//MallardDuck::MallardDuck(): name_("Mallard Duck"), pObservable_(new Observable(this))
//{
//}

//接下来两个是QuackObservable方法，我们只是委托给辅助类进行。
void MallardDuck::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	pObservable_->registerObserver(pObserver);
}

void MallardDuck::notifyObservers()
{
	pObservable_->notifyObservers();
}

std::string MallardDuck::getName()
{
	return name_;
}

void RedHeadDuck::quack()
{
	std::cout << "Quack" << std::endl;
	notifyObservers();
}

RedHeadDuck::RedHeadDuck(): name_("RedHead Duck"), pObservable_()
{
	pObservable_.reset(new Observable(this));
}

void RedHeadDuck::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	pObservable_->registerObserver(pObserver);
}

void RedHeadDuck::notifyObservers()
{
	pObservable_->notifyObservers();
}

std::string RedHeadDuck::getName()
{
	return name_;
}

void DuckCall::quack()
{
	std::cout << "Kwak" << std::endl;
	notifyObservers();
}

DuckCall::DuckCall(): name_("Duck Call"), pObservable_()
{
	pObservable_.reset(new Observable(this));
}

void DuckCall::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	pObservable_->registerObserver(pObserver);
}

void DuckCall::notifyObservers()
{
	pObservable_->notifyObservers();
}

std::string DuckCall::getName()
{
	return name_;
}

void RubberDuck::quack()
{
	std::cout << "Squeak" << std::endl;
	notifyObservers();
}

RubberDuck::RubberDuck(): name_("Rubber Duck"), pObservable_()
{
	pObservable_.reset(new Observable(this));
}

void RubberDuck::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	pObservable_->registerObserver(pObserver);
}

void RubberDuck::notifyObservers()
{
	pObservable_->notifyObservers();
}

std::string RubberDuck::getName()
{
	return name_;
}

QuickCounter::QuickCounter( boost::shared_ptr<Quackable> pDuck ): pDuck_(pDuck)//, pObservable_()
{
	//pObservable_.reset(new Observable(this));
}

void QuickCounter::quack()
{
	pDuck_->quack();
	++numberOfDucks_;
	//notifyObservers();//不需要通知，通知交由被装饰对象pDuck_->quack()去做
}

int QuickCounter::getQuacks()
{
	return numberOfDucks_;
}

void QuickCounter::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	//pObservable_->registerObserver(pObserver);//不需要装饰者类QuackCounter去注册，注册交由被装饰对象pDuck_去做
	pDuck_->registerObserver(pObserver);
}
}

void QuickCounter::notifyObservers()
{
	//pObservable_->notifyObservers();//不需要装饰者类QuackCounter去通知，通知交由被装饰对象pDuck_去做
	pDuck_->notifyObservers();
}

std::string QuickCounter::getName()
{
	return pDuck_->getName();
}

int QuickCounter::numberOfDucks_ = 0;


void Flock::add( boost::shared_ptr<Quackable> pDuck )
{
	duckList_.push_back(pDuck);
}

void Flock::quack()
{
	for (std::list<boost::shared_ptr<Quackable> >::iterator iter =duckList_.begin(); iter != duckList_.end(); ++iter)
	{
		(*iter)->quack();
	}
}

//当你向Flock注册观察者时，其实等于是向Flock“内”的所有Quackable注册，不管是一只鸭子还是另一群
void Flock::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	for (std::list<boost::shared_ptr<Quackable> >::iterator iter =duckList_.begin(); iter != duckList_.end(); ++iter)
	{
		(*iter)->registerObserver(pObserver);//遍历Flock内的所有Quackable，把调用委托给每个Quackable。如果Quackable是另一个Flock，做同样的事。
	}
}

void Flock::notifyObservers()//每个Quackable都负责自己通知观察者，这样，Flock就不必操心了。当Flock将quack()委托给内部的每一个Quackable时，就是调用此方法的时机。
{
	//for (std::list<boost::shared_ptr<Quackable> >::iterator iter =duckList_.begin(); iter != duckList_.end(); ++iter)
	//{
	//	(*iter)->notifyObservers();
	//}
}

std::string Flock::getName()//这里的Flock不需要getName，因此给了空实现
{
	return "";
}

//Goose.h
#ifndef __GOOSE_H__
#define __GOOSE_H__
#include <string>
#include "boost/shared_ptr.hpp"
#include "Quackable.h"

class Goose
{
public:
	Goose();
	void honk();
	std::string getName();
private:
	std::string name_;
};

class GooseAdapter: public Quackable
{
public:
	GooseAdapter(boost::shared_ptr<Goose> pGoose);
	virtual void quack();
	virtual void registerObserver(boost::shared_ptr<Observer> pObserver);
	virtual void notifyObservers();
	virtual std::string getName();
private:
	std::string name_;
	boost::shared_ptr<Goose> pGoose_;
	boost::shared_ptr<Observable> pObservable_;
};
#endif

//Goose.cpp
#include <iostream>
#include "Goose.h"

void Goose::honk()
{
	std::cout << "Honk" << std::endl;
}

Goose::Goose(): name_("Goose")
{

}

std::string Goose::getName()
{
	return name_;
}

GooseAdapter::GooseAdapter( boost::shared_ptr<Goose> pGoose ): pGoose_(pGoose), pObservable_()
{
	pObservable_.reset(new Observable(this));
}

void GooseAdapter::quack()
{
	pGoose_->honk();
	notifyObservers();
}

void GooseAdapter::registerObserver( boost::shared_ptr<Observer> pObserver )
{
	pObservable_->registerObserver(pObserver);
}

void GooseAdapter::notifyObservers()
{
	pObservable_->notifyObservers();
}

std::string GooseAdapter::getName()
{
	return pGoose_->getName();
}

//AbstractDuckFactory.h，没变与之前一样
#ifndef __ABSTRACTDUCKFACTORY_H__
#define __ABSTRACTDUCKFACTORY_H__
#include "boost/shared_ptr.hpp"

class Quackable;

class AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck() = 0;
	virtual boost::shared_ptr<Quackable> createRedHeadDuck() = 0;
	virtual boost::shared_ptr<Quackable> createDuckCall() = 0;
	virtual boost::shared_ptr<Quackable> createRubberDuck() = 0;
};

class DuckFactory: public AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck();
	virtual boost::shared_ptr<Quackable> createRedHeadDuck();
	virtual boost::shared_ptr<Quackable> createDuckCall();
	virtual boost::shared_ptr<Quackable> createRubberDuck();
};

class CountingDuckFactory: public AbstractDuckFactory
{
public:
	virtual boost::shared_ptr<Quackable> createMallardDuck();
	virtual boost::shared_ptr<Quackable> createRedHeadDuck();
	virtual boost::shared_ptr<Quackable> createDuckCall();
	virtual boost::shared_ptr<Quackable> createRubberDuck();
};

#endif

//AbstractDuckFactory.cpp
#include "AbstractDuckFactory.h"
#include "Quackable.h"

boost::shared_ptr<Quackable> DuckFactory::createMallardDuck()
{
	return boost::shared_ptr<Quackable>(new MallardDuck());
}

boost::shared_ptr<Quackable> DuckFactory::createRedHeadDuck()
{
	return boost::shared_ptr<Quackable>(new RedHeadDuck());
}

boost::shared_ptr<Quackable> DuckFactory::createDuckCall()
{
	return boost::shared_ptr<Quackable>(new DuckCall());
}

boost::shared_ptr<Quackable> DuckFactory::createRubberDuck()
{
	return boost::shared_ptr<Quackable>(new RubberDuck());
}

boost::shared_ptr<Quackable> CountingDuckFactory::createMallardDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new MallardDuck())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createRedHeadDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new RedHeadDuck())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createDuckCall()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new DuckCall())));
}

boost::shared_ptr<Quackable> CountingDuckFactory::createRubberDuck()
{
	return boost::shared_ptr<Quackable>(new QuickCounter(boost::shared_ptr<Quackable>(new RubberDuck())));
}

//DuckSimulator.h
#ifndef __DUCKSIMULATOR_H__
#define __DUCKSIMULATOR_H__
#include "boost/shared_ptr.hpp"

class AbstractDuckFactory;
class Quackable;

class DuckSimulator
{
public:
	static void main();
private:
	void simulate(boost::shared_ptr<AbstractDuckFactory>& duckFactory);
	void simulate(boost::shared_ptr<Quackable>& duck);
};
#endif

//DuckSimulator.cpp
#include <iostream>
#include "DuckSimulator.h"
#include "Quackable.h"
#include "Goose.h"
#include "AbstractDuckFactory.h"
#include "Observer.h"

void DuckSimulator::main()
{
	DuckSimulator duckSimulator;
	boost::shared_ptr<AbstractDuckFactory > duckFactory(new CountingDuckFactory());
	duckSimulator.simulate(duckFactory);
}

void DuckSimulator::simulate(boost::shared_ptr<AbstractDuckFactory>& duckFactory)
{
	boost::shared_ptr<Quackable> redHeadDuck(duckFactory->createRedHeadDuck());
	boost::shared_ptr<Quackable> duckCall(duckFactory->createDuckCall());
	boost::shared_ptr<Quackable> rubberDuck(duckFactory->createRubberDuck());
	boost::shared_ptr<Quackable> gooseDuck(new GooseAdapter(boost::shared_ptr<Goose>(new Goose())));

	std::cout << "Duck Simulator: With Composite - Flocks" << std::endl;

	boost::shared_ptr<Quackable> flockOfDucks(new Flock());
	flockOfDucks->add(redHeadDuck);
	flockOfDucks->add(duckCall);
	flockOfDucks->add(rubberDuck);
	flockOfDucks->add(gooseDuck);

	boost::shared_ptr<Quackable> flockOfMallards(new Flock());
	boost::shared_ptr<Quackable> mallardOne(duckFactory->createMallardDuck());
	boost::shared_ptr<Quackable> mallardTwo(duckFactory->createMallardDuck());
	boost::shared_ptr<Quackable> mallardThree(duckFactory->createMallardDuck());
	boost::shared_ptr<Quackable> mallardFour(duckFactory->createMallardDuck());

	flockOfMallards->add(mallardOne);
	flockOfMallards->add(mallardTwo);
	flockOfMallards->add(mallardThree);
	flockOfMallards->add(mallardFour);

	flockOfDucks->add(flockOfMallards);

	boost::shared_ptr<Observer> quackologist(new Quackologist());
	flockOfDucks->registerObserver(quackologist);//在这里所需要做需要做的事就是创建一个Quackologist，把它注册成为一个群的观察者。
	std::cout << "\nDuck Simulator: Whole Observer:" << std::endl;
	simulate(flockOfDucks);

	std::cout << "The ducks quacked " << QuickCounter::getQuacks() << " times." << std::endl;
}

void DuckSimulator::simulate( boost::shared_ptr<Quackable>& duck )
{
	duck->quack();
}

//main.cpp
#include <iostream>
#include "DuckSimulator.h"
using namespace std;

int main ()
{
	DuckSimulator::main();
}
输出如下：
Duck Simulator: With Composite - Flocks

Duck Simulator: Whole Observer:
Quack
Quackologist: RedHead Duck just quacked.
Kwak
Quackologist: Duck Call just quacked.
Squeak
Quackologist: Rubber Duck just quacked.
Honk
Quackologist: Goose just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
The ducks quacked 7 times.
请按任意键继续. . .

问：这就是复合模式
答：不， 这只是一群模式携手合作。所谓的复合模式，是指一群模式被结合起来使用，以解决一般性问题。我们很快就会看到Model-View-Controller（模型-视图-控制器）复合模式。它是由数个模式结合起来而形成的新模式，一再地被用于解决许多设计问题。

我们做了什么
--我们从一大堆Quackable开始……
--有一只鹅出现了，它希望自己像一个Quackable。
所以我们利用适配器模式，将鹅适配成Quackable。现在你就可以调用鹅适配器的quack()方法让鹅咯咯叫。
--然后，呱呱叫学家决定要计算呱呱叫声的次数。
所以我们使用装饰者模式，添加了一个名为QuackCounter的装饰者。它用来追踪quack()被调用的次数，并将调用委托给它所装饰的Quackable对象。
--但是呱呱叫学家担心他们忘了加上QuackCounter装饰者。
所以我们使用抽象工厂模式创建鸭子。从此以后，当他们需要鸭子时，就直接跟工厂要，工厂会给他们装饰过的鸭子。（别忘了，如果他们想取得没装饰的鸭子，用另一个鸭子工厂就可以！）
--又是鸭子，又是鹅，又是quackable的……我们有管理上的困扰。
所以我们需要使用组合模式，将许多quackable集结成一个群。这个模式也允许群中有群，以便让呱呱叫学家来管理鸭子家族。我们在实现中通过使用ArrayList（C++中为list）中的java.util的迭代器而使用了迭代器模式。
--当任何呱呱声响起时，呱呱叫学家都希望能被告知。
所以我们使用观察者模式，让呱呱叫学家注册成为观察者。现在，当听听声响起时，呱呱叫学家就会被通知了。在这个实现中，再度用到了迭代器。呱呱叫学家不仅可以当某个鸭子的观察者，甚至可以当一整群的观察者。
《Head First》P525的分析
我们有两类Quackable，一类是鸭子，另一类是有鸭子叫声的东西：像GooseAdapter、Flock、QuackCounter。其中GooseAdapter包装鹅，让鹅看起来像是Quackable；Flock是Quackable的组合，QuackCounter为Quackable添加行为。

戴着模式的眼镜看MVC
学会MVC最好的方法就是看看它是由哪些模式共同组成的。
先从模型开始。模型利用“观察者”让控制器和视图可以随最新的状态改变而更新。另一方面，视图和控制器则实现了“策略模式”。控制器是视图的行为，如果你希望有不同的行为，可以直接换一个控制器。视图内部使用组合模式来管理窗口、按钮以及其他显示组件。

--MVC是复合模式，结合了观察者模式、策略模式和组合模式。
--模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。
--控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。
--视图使用组合模式实现用户界面，用户界面通过组合了嵌套的组件，像面板、框架和按钮。
--这些模式携手合作，把MVC模型的三层解耦，这样可以保持设计干净又有弹性。
--适配器模式用来将新的模型适配成已有的视图和控制器。
--Model 2 是MVC在Web上的应用。
--在Model 2 中，控制器实现成Servlet，而JSP/HTML实现视图。
//------------------------------------------------------------------------------------------------
//Head First 第13章 与设计模式相处--真实世界中的模式
定义设计模式
模式：是在某情境（context）下，针对某问题的某种解决方案。

--创建型模式：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。
Singletion/Factory Method/Abstract Factory/Prototype/Builder
--行为型模式：涉及到类和对象如何交互及分配职责。
Template Method/Interpreter/Chain of Responsibility/Mediator/Visitor/Iterator/Command/Memento/Observer/State/Strategy
--结构型模式：可以让你把类或对象组合到更大的结构中（以建立新的结构或新的功能）。
Decorator/Flyweight/Composite/Adapter/Proxy/Facade/Bridge

用模式思考
--保持简单
首先，当你设计时，尽可能地用最简单的方式解决问题。你的目标应该是简单，而不是“如何在这个问题中应用模式”。千万不要认为：如何没有使用模式解决某个问题，就不是经验丰富的开发人员。如果你能够保持简单的设计，那么你将会得到其他开发人员的欣赏和尊敬。正确的说法是，为了要让你的设计简单且有弹性，有时候使用模式是最好的方法。

--你知道何时需要模式……
有一种情况，即便有更简单的解决方案，仍然想要使用模式，这种情况就是：你预期系统在未来会发生改变。找出你的设计中会改变的区域，通常这是需要模式的迹象。但是务必要确定一件事：加入模式是要应对可能发生的实际改变，而不是假想的改变。
并非只有在设计是才考虑引进模式，在重构（refactoring）时也要这样做。

--重构的时间就是模式的时间
重构是通过改变你的代码来改进它的组织方式的过程。目标是要改善其结构，而不是其行为。这是一个很好的时机，可以重新检查你的设计来看看是否能够利用模式让它拥有更好的结构。比方说，代码内如果充满了条件语句，可能意味着需要使用状态模式，或者意味着，应该利用工厂模式将这些具体的依赖消除掉。

--拿掉你所不需要的，不要害怕将一个设计模式从你的设计中删除。
当你的系统变得非常复杂，而且并不需要预留任何弹性的时候，就不要使用模式。换句话说，也就是当一个较简单的解决方案比使用模式更恰当的时候。

--如果你现在不需要，就别做
如果你今天在设计中实际的需要去支持改变，就采用模式处理这个改变吧。然而，如果说理由只是假想的，就不要添加这个模式，因为这只会将你的系统越搞越复杂，而且很可能你永远都不会需要它。

当你确信你的设计中有一个问题需要解决的时候，或者当你确信未来的需要可能会改变时，都可以采用模式。

警告：过度使用设计模式可能导致代码被过度工程化。应该总是用最简单的解决方案完成工作，并在真正需要模式的地方才使用它。

为实际需要的扩展使用模式。不要只是为了假想的需要而使用模式。
简单才是王道。如果你不用模式就能设计出更简单的方案，那就去干吧。
模式是工具而不是规则，需要被适当地调整以符合你的需求。

反模式：告诉你如何采用一个不好的解决方案解决一个问题。
反模式告诉我们为什么不好的解决方案会有吸引力。
//------------------------------------------------------------------------------------------------
//Head First 附录A 剩下的模式
桥接
使用桥接模式（Bridge Pattern）不只改变你的实现，也改变你的抽象。

为何使用桥接模式
桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变。
优点：
--将实现予以解耦，让它和界面之间不再永久绑定。
--抽象和实现可以独立扩展，不会影响到对方。
--对于“具体的抽象类”所做的改变，不会影响到客户。
用途和缺点：
--适合使用在需要跨越多个平台的图形和窗口系统上。
--当需要用不同的方式改变接口和实现时，桥接模式很好用。
--缺点是增加了复杂度。

//--
生成器
使用生成器模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。

为何使用生成器模式
迭代器模式，将迭代的过程封装进入一个独立的对象中，并向客户隐藏集合的内部表现。这里也是采取相同的想法：将旅游规划的创建过程，封装到一个对象中（称此对象为生成器），然后让客户调用生成器为它创建旅游规划。

优点：
--将一个复杂对象的创建过程封装起来。
--允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）。
--向客户隐藏产品内部的表现。
--产品的实现可以被替换，因为客户只看到一个抽象的接口。
用途和缺点：
--经常被用来创建组合结构。
--与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识。

//--
责任链
当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式（Chain of Responsibility Pattern）

如何使用责任链模式
通过责任链模式，你可以为某个请求创建一个对象链。每个对象依序检查此请求，并对其进行处理，或者将它传给链中的下一个对象。

责任链的优点
--将请求的发送者和接受者解耦。
--可以简化你的对象，因为它不需要知道链的结构。
--通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任。
用途和缺点
--经常被使用在窗口系统中，处理鼠标和键盘之类的事件。
--并不保证请求一定会被执行；如果没有任何对象处理它的话，你可能会落到链尾端之外（这可以是优点也可以是缺点）。
--可能不容易观察运行时的特征，有碍于除错。

//--
蝇量
如想让某个类的一个实例能用来提供许多“虚拟实例”，就使用蝇量模式（Flyweight Pattern）。

为何使用蝇量模式
只用一个树实例和一个客户对象来维护“所有”树的状态。这就是蝇量模式。
所有树的状态，代表所有虚拟树对象，储存在TreeManager中的二维数组内；另外有下Tree对象，是一个单独的没有状态的树对象。

优点
--减少运行时对象实例的个数，节省内存。
--将许多“虚拟”对象的状态集中管理。
用途和缺点
--当一个类有许多的实例，而这些实例能被同一个方法控制的时候，我们就可以使用蝇量模式。
--蝇量模式的缺点在于，一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为。

//--
解释器
使用解释器模式（Interpreter Pattern）为语言创建解释器。

如何实现解释器
想要解释这种语言，就调用每个表达式类型的interpret()方法。此方法需要传入一个上下文（Context）――也就是我们正在解析的语言字符串输入流――然后进行比对并采取适当的动作。

优点
--将每一个语法规则表示成一个类，方便于实现语言。
--因为语法由许多类表示，所以你可以轻易地改变或扩展此语言。
--通过在类结构中加入新的方法，可以在解释的同时增加新的行为，例如打印格式的美化或者进行复杂的程序验证。
用途和缺点
--当你需要实现一个简单的语言时，使用解释器。
--当你有一个简单的语法，而且简单比效率更重要时，使用解释器。
--可以处理脚本语言和编程语言。
--当语法规则的数目太大时，这个模式可能会变得非常繁杂。在这种情况下，使用解析器/编译器的产生器可能会更合适。

//--
中介者
使用中介者模式（Mediator Pattern）来集中相关对象之间复杂的沟通和控制方式。

中介者在行动……
在这个系统中加入一个中介者，一切都变得简单了。
--每个对象都会在自己的状态改变时，告诉中介者。
--每个对象都会对中介者所发出的请求作为回应。

在没有中介者的情况下，所有的对象都需要认识其他对象，也就是说，对象之间是紧耦合的。有了中介者之后，对象之间彻底解耦。

中介者内包含了整个系统的控制逻辑。当其装置需要一个新的规则时，或者是一个新的装置被加入系统内，其所有需要用到的逻辑也都被加进了中介者内。

优点
--通过将对象彼此解耦，可以增加对象的复用性。
--通过将控制逻辑集中，可以简化系统维护。
--可以让对象之间所传递的消息变得简单而且大幅减少。

用途和缺点
--中介者常常被用来协调相关的GUI组件。
--中介者模式的缺点是，如果设计不当，中介者对象本身会变得过于复杂。

//--
备忘录
当你需要让对象返回之前的状态时（例如，你的用户请求“撤销”），就使用备忘录模式（MementoPattern）。

使用备忘录
备忘录模式有两个目标：
--储存系统关键对象的重要状态。
--维护关键对象的封装。

优点
--将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。
--保持关键对象的数据封装。
--提供了容易实现的恢复能力。

用途和缺点
--备忘录用于储存状态。
--使用备忘录的缺点：储存和恢复状态的过程可能相当耗时。
--在Java系统中，其实可以考虑使用序列化（serialization？？？）机制储存系统的状态。

//--
原型
当创建给定类的实例的过程很昂贵或很复杂，就使用原型模式（Prototype Pattern）。

原型模式允许你通过复制现有的实例来创建新的实例（在Java中，这通常意味着使用clone()方法，或者反序列化）。这个模式的重要在于，客户的代码在不知道要实例化何种特定类的情况下，可以制造出新的实例。

优点
--向客户隐藏制造新实例的复杂性。
--提供让客户能够产生未知类型对象的选项。
--在某些环境下，复制对象比创建对象更有效。

用途和缺点
--在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。
--使用原型模式的缺点：对象的复制有时相当复杂。

//--
访问者
当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式（Visitor Pattern）。

访问者必须参观组合内的每个元素，这样的功能是在导游（Traverser）对象中，访问者通过导游的引导，收集组合中所有对象的状态。一旦状态被收集了，客户就可以让访问者对状态进行各种操作。当需要新的功能时，只要加强访问者即可。

优点
--允许你对组合结构加入新的操作，而无需改变结构本身。
--想要加入新的操作，相对容易。
--访问者所进行的操作，其代码是集中在一起的。

用途和缺点
--当采用访问者模式的时候，就会打破组合类的封装。
--因为游走的功能牵涉其中，所以对组合结构的改变就更加困难。
//------------------------------------------------------------------------------------------------
//算法导论 第2章 算法入门
//2.1 插入排序 Page10，时间代价Θ(n*n)
//插入扑克一样，每次把新来的一个对象找到它应该所在的对应位置
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;

void insertionSort(int* intArray, int length)
{
	for (int j = 1; j < length; ++j)
	{
		int key = *(intArray + j);
		int i = j - 1;
		//while ((i >= 0) && (*(intArray + i) < key))即可变成升序排序
		while ((i >= 0) && (*(intArray + i) > key))//每个对象都插入到比它小的最后一个对象后
		{
			*(intArray + i + 1) = *(intArray + i);
			*(intArray + i) = key;
			--i;
		}
	}
}

int main()
{
	int intArray[6] = {5, 2, 4, 6, 1, 3};
	insertionSort(intArray, 6);
	copy(intArray, intArray + 6, ostream_iterator<int>(cout, " "));
}

//2.3.1 分治法 Page17 
//合并排序--算法里的inplace_merge
分解：将n个元素分成各含n/2 个元素的子序列；
解决：用合并排序法对两个子序列递归地排序；
合并：合并两个已排序的子序列以得到排序结果。
Merge过程的时间代码为Θ(n)，n=r-p+1 是待合并的元素个数。
//合并排序中的合并两个有序序列的算法
#include <iostream>
#include <algorithm>
#include <vector>
#include <ctime>
using namespace std;

void myInplaceMergeAlg(int* intArray, int p, int q, int r)
{
	int n1 = q - p + 1;
	int n2 = r - q;
	vector<int> sortedIntVec1(intArray + p, intArray + q + 1);
	vector<int> sortedIntVec2(intArray + q + 1, intArray + r + 1);
	int i = 0, j = 0;
	for (int k = p; k <= r; ++k)
	{
		if (i == n1)
		{
			*(intArray + k) = sortedIntVec2.at(j);
			++j;
		}
		else if (j == n2)
		{
			*(intArray + k) = sortedIntVec1.at(i);
			++i;
		}
		else if (sortedIntVec1.at(i) <= sortedIntVec2.at(j))
		{
			*(intArray + k) = sortedIntVec1.at(i);
			++i;
		}
		else
		{
			*(intArray + k) = sortedIntVec2.at(j);
			++j;
		}
	}
}

int main () 
{
	srand ( unsigned ( time (NULL) ) );

	vector<int> intVec(10);
	int n = 0;
	generate(intVec.begin(), intVec.end(), [&] () {return ++n;});
	random_shuffle(intVec.begin(), intVec.end());
	
	sort(intVec.begin(), intVec.begin() + 4);
	sort(intVec.begin() + 4, intVec.end());
	
	for_each(intVec.begin(), intVec.end(), [] (int n) {cout << n << " ";});

	cout << endl;
	//inplace_merge(intVec.begin(), intVec.begin() + 4, intVec.end());
	myInplaceMergeAlg(&intVec[0], 0, 3, 9);//效果同inplace_merge

	for_each(intVec.begin(), intVec.end(), [] (int n) {cout << n << " ";});
	return 0;
}

//合并排序算法，这里写了两个重载的merge_sort
//第一个是用的容器作为入参，中间构造了很多容器的局部变量，并且使用的算法是merge
//第二个是用的迭代器作为入参，省去了构造容器变量，使用的算法是inplace_merge
#include <iostream>
#include <algorithm>
#include <vector>
#include <ctime>
using namespace std;

typedef vector<int> IntContainer;

//use algorithm to implement Merge_Sort
void merge_Sort(IntContainer& ic)
{
	if (ic.size() == 1)
	{
		return;
	}
	else
	{
		int halfSize = ic.size() / 2;
		IntContainer ic1(ic.begin(), ic.begin() + halfSize);
		IntContainer ic2(ic.begin() + halfSize, ic.end());
		merge_Sort(ic1);
		merge_Sort(ic2);
		merge(ic1.begin(), ic1.end(), ic2.begin(), ic2.end(), ic.begin());
	}
}

void merge_Sort(IntContainer::iterator firstIter, IntContainer::iterator secondIter)
{
	if (distance(firstIter, secondIter) == 1)
	{
		return;
	}
	else
	{
		int halfSize = distance(firstIter, secondIter) / 2;
		merge_Sort(firstIter, firstIter + halfSize);
		merge_Sort(firstIter + halfSize, secondIter);
		inplace_merge(firstIter, firstIter + halfSize, secondIter);
	}
}

int main () 
{
	srand ( unsigned ( time (NULL) ) );

	vector<int> intVec(10);
	int n = 0;
	generate(intVec.begin(), intVec.end(), [&] () {return ++n;});
	random_shuffle(intVec.begin(), intVec.end());
	
	for_each(intVec.begin(), intVec.end(), [] (int n) {cout << n << " ";});

	cout << endl;
	//merge_Sort(intVec);
	merge_Sort(intVec.begin(), intVec.end());

	for_each(intVec.begin(), intVec.end(), [] (int n) {cout << n << " ";});
	return 0;
}

//合并排序的运行时间为Θ(nlgn)，在最坏情况下要比插入排序（其运行时间为Θ(n*n)）好。

//冒泡排序（bubblesort）算法，重复地交换相邻的两个反序元素
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;

void bubbleSort(int* intArray, int length)
{
	for (int i = 0; i < length; ++i)
	{
		for (int j = length - 1; j > i; --j)
		{
			if (*(intArray + j - 1) > *(intArray + j))
			{
				iter_swap(intArray + j - 1, intArray + j);
			}
		}
	}
}

int main()
{
	int intArray[6] = {5, 2, 4, 6, 1, 3};
	bubbleSort(intArray, 6);
	copy(intArray, intArray + 6, ostream_iterator<int>(cout, " "));
}
//------------------------------------------------------------------------------------------------
//算法导论 第3章 函数的增长
3.1 渐近记号
Θ记号
Θ(g(n))的定义需要每个成员f(n)∈Θ(g(n))都是渐近非负，也就是说当n足够大时f(n)是非负值（渐近正函数则是当n足够大时总为正值）。这就要求函数g(n)本身也必须是渐近非负的，否则集合Θ(g(n))就是空集。因此，假定Θ记号中用到的每个函数都是渐近非负的。
一般来说，对任何一个多项式p(n)=∑i=0 -> d (ai*n的i次方)，其中ai是常数并且ad>0, 有p(n)=Θ(n的d次方)
因为任意一个常数都是0次的多项式，帮可以把任何常函数表示成Θ(n的0次方)或Θ(1)。后一种表示略有点越规使用了，因为从中看不出什么变量趋于无穷。我们将经常使用Θ(1)表示一个常数或某变量的常函数。

当我们说一个算法的运行时间（无修饰语）是Ω(g(n))时，是指对每一个n值，无论取该规模下什么样的输入，该输入上的运行时间都至少是一个常数乘上g(n)（当n足够大时）。

o记号
O记号所提供的渐近上界可能是也可能不是渐近紧确的。我们使用o记号来表示非渐近紧确的上界。
O记号与o记号的定义是类似的。主要区别在于对f(n)=O(g(n))，办0<=f(n)<=cg(n)对某个常数c>0 成立；但对f(n)=o(g(n))，界0<=f(n)<=cg(n)对所有常数c>0 成立。从直觉上看，在o表示中当n趋于无穷时，函数f(n)相对于g(n)来说就不重要了，即lim n->∞ f(n)/g(n)=0 。
某些作者将这个极限作为o记号的定义；本书中给出的定义同样也限定匿名函数必须是渐近非负的。

ω记号 P30
ω记号来表示非渐近紧确的下界。
关系f(n)=ω(g(n))意味着lim n->∞ f(n)/g(n)=∞
如果这个极限存在。也就是说当n趋于无穷时，f(n)相对g(n)来说变得任意大了。

函数间的比较性质 P30

三分性：对两个实数a和b，下列三种情况恰有一种成立：a<b, a=b, a>b。P31 
但并不是所有的函数都是渐近可比较的。即，对于两个函数f(n)和g(n)，可能f(n)=O(g(n))和f(n)=Ω(g(n))都不成立。

指数式
n的b次方=o(a的n次方)，因此，任何底大于1的指数函数比任何多项式函数增长得更快
自然对数e 2.71828 P33
对数 P33
任意正的多项函数都比多项对数函数增长得快。
阶乘 P34
函数迭代 P34
多重对数函数是一种增长很慢的函数，很少会遇到一个使lg*n>5 的输入规模n。 P34
斐波那契数 黄金分割律，共轭数。斐波那契数从指数形式增长。 P35
//------------------------------------------------------------------------------------------------
//算法导论 第4章 递归式 P38
代换法、递归树方法、主方法
4.1 代换法 P38
4.2 递归树方法 P40
4.3 主方法 P43
定理4.1 (主定理) P44

在算法分析中，通常只需要分析时间复杂度的渐进行为，即分析出运行时间的渐进确界。
于是，渐进大于可以这样理解：设g(n)渐进大于f(n)
则存在数c>0和n0，使得对于任意 n >= n0 有 c*g(n) >= f(n).
多项式大于定义如下：
存在常数c>0,c1>0,c2>0，使得
c1 * f(n) * n ^ c <= g(n) <= c2*f(n)*n^c
它是一种更强的渐进大于。
譬如说：
n多项式大于n^(log 4 3)
取 c = 1 - log 4 3即可满足多项式大于定义。
但是nlogn仅仅渐进大于n
因为对于任意c>0,均有logn < n^c(由洛必达法则可知)。
主方法的第三种情况要求是多项式大于，故T(n) = 2 * T(n/2) + nlgn不能应用主方法

4.4 主定理的证明 P45
//------------------------------------------------------------------------------------------------
//算法导论 第5章 概率分析和随机算法 P54
随机排列数组 P59
对特定的输入序列随机排序，可以达到输入序列随机的效果，以进行分析期望
算法库中的random_shuffle可以达到此效果

产生随机排列的一个更好方法是原地排列给定的数列。程序RANDOMIZE-IN-PLACE在O(n)时间内完成。在第i次迭代时，元素A[i]是从元素A[i]到A[n]中随机选取的。第i次迭代之后，A[i]保持不变。

5.4.2 球与盒子 P64
赠券收集者问题，意思是一个人如果想要集齐b种不同赠券中的每一种，大约要有blnb张随机得到的赠券才能成功。
//------------------------------------------------------------------------------------------------
第二部分 排序和排序统计学
//算法导论 第6章 堆排序 P73
运行时间O(nlgn)。它是一种原地排序算法：在任何时候，数组中只有常数个元素存储在输入数组以外。可以结合合并排序和插入的优点。
6.1 堆 P73
堆数据结构是一种数组对象。
两种：最大堆（大根堆）和最小堆（小根堆）.
在堆排序算法中，使用的是最大堆。最小堆通常在构造优先队列时使用。
具有n个元素的堆是基于一棵完全二叉树的，因而其高度为0(lgn)。堆结构上的一些基本操作的运行时间至多与树的高度正正比，为O(lgn)。
五个基本过程：
--MAX-HEAPLIFY过程，其运行时间为O(lgn)，是保持最大堆性质的关键
--BUILD-MAX-HEAP过程，以线性时间运行，可以在无序的输入数组基础上构造出最大堆
--HEAPSORT过程，运行时间为O(nlgn)，对一个数组原地进行排序
--MAX-HEAP-INSERT，HEAP-EXTRACT-MAX，HEAP-INCREASE-KEY和HEAP-MAXIMUM过程的运行时间为O(lgn)，可以让堆结构作为优先队列使用。

6.2 保持堆的性质
MAX-HEAPIFY是对最大堆进行操作的重要的子程序。输入为一个数组A和下标i。当MAX-HEAPIFY被调用时，假定以LEFT(i)和RIGHT(i)为根的两棵二叉树都是最大堆，但这时A[i]可能小于其子女，这样就违反了最大堆性质。MAX-HEAPIFY让A[i]在最大堆中“下降”，使以i为根的子树成为最大堆。P75
T(n)=O(lgn)，就是说，MAX-HEAPIFY作用于一个高度为h的结点所需地运行时间为O(h)。
//参考书上的算法写的MAX-HEAPIFY函数
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

void max_Heapify(vector<int>& intVector, int i)
{
	int left_i = 2 * i;
	int right_i = left_i + 1;
	
	int heap_size = intVector.size() - 1;
	
	//obtain the largest index
	int largest = i;
	if ((left_i <= heap_size) && (intVector[left_i] > intVector[i]))
	{
		largest = left_i;
	}
	if ((right_i <= heap_size) && (intVector[right_i] > intVector[largest]))
	{
		largest = right_i;
	}

	//exchange and iterate
	if (largest != i)
	{
		swap(intVector[i], intVector[largest]);
		max_Heapify(intVector, largest);
	}
}

int main()
{
	int intArray[11] = {-1, 16, 4, 10, 14, 7, 9, 3, 2, 8, 1};
	vector<int> intVector(intArray, intArray + 11);
	max_Heapify(intVector, 2);
	copy(intVector.begin() + 1, intVector.end(), ostream_iterator<int>(cout, " "));
}
输出如下：
16 14 10 8 7 9 3 2 4 1

6.3 建堆 P76
可以自底向上地用MAX-HEAPIFY来将一个数组A[1..n]（此处n=length[A]）变成一个最大堆。由练习6.1-7 可知，子数组A[(n/2 向下取整)..n]中的元素都是树中的叶子，因此每个都可看作是只含一个元素的堆。过程BUILD-MAX-HEAP对树中的每一个其他结点都调用一次MAX-HEAPIFY。
//参考书上的算法写的BUILD-MAX-HEAP函数
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

void max_Heapify(vector<int>& intVector, int i)
{
	int left_i = 2 * i;
	int right_i = left_i + 1;
	
	int heap_size = intVector.size() - 1;
	
	//obtain the largest index
	int largest = i;
	if ((left_i <= heap_size) && (intVector[left_i] > intVector[i]))
	{
		largest = left_i;
	}
	if ((right_i <= heap_size) && (intVector[right_i] > intVector[largest]))
	{
		largest = right_i;
	}

	//exchange and iterate
	if (largest != i)
	{
		swap(intVector[i], intVector[largest]);
		max_Heapify(intVector, largest);
	}
}

void build_Max_Heap(vector<int>& intVector)
{
	int length = intVector.size() - 1;
	for (int i = length/2; i > 0; --i)
	{
		max_Heapify(intVector, i);
	}
}

int main()
{
	int intArray[11] = {-1, 4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
	vector<int> intVector(intArray, intArray + 11);
	build_Max_Heap(intVector);
	copy(intVector.begin() + 1, intVector.end(), ostream_iterator<int>(cout, " "));
}
输出如下：
16 14 10 8 7 9 3 2 4 1

BUILD-MAX-HEAP运行时间的一个简单上界：每次调用MAX-HEAPIFY的时间为O(lgn)，共有O(n)次调用，故运行时间是O(nlgn)。这个办尽管是对的，但从渐近意义上讲不够紧确。P77
更紧确界的分析依赖于这样的性质：一个n元素堆的高度为（lgn的向下取整），并且在任意高度h上，至多有（(n/2^(h+1))的向上取整）个结点。
于是，BUILD-MAX-HEAP的运行时间的界为O(n)。
这说明可以在线性时间内，将一个无序数组建成一个最大堆。
可以用于BUILD-MAX-HEAP类似的方式，利用过程BUILD-MIN-HEAP来建立最小堆，只是第3行要用调用MIN-HEAPIFY来替代调用MAX-HEAPIFY。BUILD-MIN-HEAP可以在线性时间内，将一个无序线性数组建成一个最小堆。
//改进的算法，把heap_size作为参数传入max_Heapify和build_Max_Heap，为后面的堆排序算法使用提供控制入口
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

void max_Heapify(vector<int>& intVector, int i, int heap_size)
{
	int left_i = 2 * i;
	int right_i = left_i + 1;
	
	//int heap_size = intVector.size() - 1;
	
	//obtain the largest index
	int largest = i;
	if ((left_i <= heap_size) && (intVector[left_i] > intVector[i]))
	{
		largest = left_i;
	}
	if ((right_i <= heap_size) && (intVector[right_i] > intVector[largest]))
	{
		largest = right_i;
	}

	//exchange and iterate
	if (largest != i)
	{
		swap(intVector[i], intVector[largest]);
		max_Heapify(intVector, largest, heap_size);
	}
}

void build_Max_Heap(vector<int>& intVector)
{
	int length = intVector.size() - 1;
	for (int i = length/2; i > 0; --i)
	{
		max_Heapify(intVector, i, length);//这里输入了一个length参数，用于界定heap_size大小
	}
}

int main()
{
	int intArray[11] = {-1, 4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
	vector<int> intVector(intArray, intArray + 11);
	build_Max_Heap(intVector);
	copy(intVector.begin() + 1, intVector.end(), ostream_iterator<int>(cout, " "));
}

6.4 堆排序算法 P78
堆排序算法先用BUILD-MAX-HEAP将输入数组A[1..n]（此处n=length[A]）构造成一个最大堆。因为数组中最大元素在根A[1]，则可以通过把它与A[n]互换来达到最终正确的位置。现在如果从堆中“去掉”结点n（通过减小heap-size[A]），可以很容易地将A[1..n-1]建成最大堆。原来根的子女仍是最大堆，而新的根元素可能违背了最大堆性质。这时调用MAX-HEAPIFY(A,1)就可以保持这一性质，在A[1..(n-1)]中构造出最大堆。堆排序算法不断重复这个过程，堆的大小由n-1 一直降到2。
HEAPSORT过程的时间代价为O(nlgn)。其中调用BUILD-MAX-HEAP的时间为O(n)，n-1 次MAX-HEAPIFY调用中每一次的时间代价为O(lgn)。

#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

void max_Heapify(vector<int>& intVector, int i, int heap_size)
{
	int left_i = 2 * i;
	int right_i = left_i + 1;
	
	//int heap_size = intVector.size() - 1;
	
	//obtain the largest index
	int largest = i;
	if ((left_i <= heap_size) && (intVector[left_i] > intVector[i]))
	{
		largest = left_i;
	}
	if ((right_i <= heap_size) && (intVector[right_i] > intVector[largest]))
	{
		largest = right_i;
	}

	//exchange and iterate
	if (largest != i)
	{
		swap(intVector[i], intVector[largest]);
		max_Heapify(intVector, largest, heap_size);
	}
}

void build_Max_Heap(vector<int>& intVector)
{
	int length = intVector.size() - 1;
	for (int i = length/2; i > 0; --i)
	{
		max_Heapify(intVector, i, length);
	}
}

void heapSort(vector<int>& intVector)
{
	build_Max_Heap(intVector);//构造最大堆
	int length = intVector.size() - 1;
	int heap_size = length;
	for (int i = length; i > 1; --i)
	{
		swap(intVector[1], intVector[i]);//将最大值与最后一位交换
		max_Heapify(intVector, 1, --heap_size);//此时根结点由原来的最大值换成了最后一位的值了，需要用max_Heapify来保持最大堆
	}
}

int main()
{
	int intArray[11] = {-1, 4, 1, 3, 2, 16, 9, 10, 14, 8, 7};
	vector<int> intVector(intArray, intArray + 11);
	heapSort(intVector);
	copy(intVector.begin() + 1, intVector.end(), ostream_iterator<int>(cout, " "));
}
输出如下：
1 2 3 4 7 8 9 10 14 16

6.5 优先级队列 P80
实际中，快速排序（第7章）的一个好的实现往往优于堆排序。堆数据结构还是有着很大的用处。一个很常见的应用：作为高效的优先级队列（priority queue。如堆一样，队列也有两种：最大优先级队列和最小优先级队列。
优先级队列是一种用来维护由一组元素构成的集合S的数据结构。这一组元素中的每一个都有一个关键字key。一个最大优先级队列支持以下操作：
INSERT(S, x)：把元素x插入集合S。这一操作可写为S←S∪{x}。
MAXIMUM(S)：返回S中具有最大关键字的元素。
EXTRACT-MAX(S)：去掉并返回S中的具有最大关键字的元素。
INCREASE-KEY(S, x, k)：将元素x的关键字的值增加到k，这里k值不能小于x的原关键字的值。

最大优先级队列的一个应用是在一台分时计算机上进行作业调度。
最小优先级队列支持的操作包括INSERT，MINIMUM，EXTRACT-MIN和DECREASE-KEY。这种队列可被用在基于事件驱动的模拟器中。在这种应用中，队列中的各项是要模拟的事件，每一个都有一个发生时间作为其关键字。事件模拟要按照各事件发生时间的顺序进行。模拟程序在每一步都使用EXTRACT-MIN来选择下一个模拟的事件。

总之，一个堆可以在O(lgn)时间内，支持大小为n的集合上的任意优先队列操作。
//基于堆排序实现的最大优先级队列类PriorityQueue
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <string>
using namespace std;

class PriorityQueue
{
public:
	typedef vector<int> QueueContainer;

public:
	PriorityQueue(): queueContainer_(1, minInteger_), heapSize_(0) 
	{
	}
	
	//用Θ(1)时间实现了MAXIMUM操作
	int maximum()
	{
		ifQueueIsEmpty();
		return queueContainer_[1];
	}
	
	//与heapSort程序中for循环体很相似，原先是把最大值与最后一个值互换，现在把最大值换到最后的操作改为不操作（其实互换也没什么问题，反正会将heapSize减1，最后一位存的值已经是无用值了）。
	//运行时间为O(lgn)，除了时间代价为O(lgn)的MAX-HEAPIFY外，只有很少的固定量的工作。
	int extract_Max()
	{
		ifQueueIsEmpty();
		int max = queueContainer_[1];
		queueContainer_[1] = queueContainer_[heapSize_--];
		max_Heapify(queueContainer_, 1, heapSize_);
		return max;
	}

	//关键字值需要增加的元素由对应数组的下标i来标识。该过程首先将元素A[i]的关键字值更新为新的值。增大了A[i]的关键字，可能违反最大堆性质，所以采用了类似于2.1节INSERTION-SORT的插入循环的方式，在从本结点往根结点移动的路径上，为新增大的关键字寻找合适的位置。移动过程中，此元素不断地与其父母相比，如果此元素的关键字较大，则交换他们的关键字且继续移动。当元素的关键字小于其父母时，此时最大堆性质成立，程序终止。
	//在n元堆上，HEAP-INCREASE-KEY的运行时间为O(lgn)，因为被更新的结点到根结点的路径长度为O(lgn)。
	void increase_key(int i, int key)
	{
		ifIncreaseKeyError(i, key);//判断i值是否超过了heapSize以及key值是否大于A[i]。个人感觉如果不进行key值的判断也没什么问题吧，相当于把key值减小而已，这时候只需要调用一次max_heapify即可保持最大堆了。
		queueContainer_[i] = key;
		while (i > 1 && queueContainer_[getParentIndex(i)] < queueContainer_[i])
		{
			swap(queueContainer_[getParentIndex(i)], queueContainer_[i]);
			i = getParentIndex(i);
		}
	}

	//输入是要插入到最大堆A中的新元素的关键字。首先加入一个关键字值为-∞的叶结点来扩展最大堆，然后调用INCREASE-KEY来设置新结点的关键字的正确值，并保持最大堆性质。
	//在包含n个元素的堆上，MAX-HEAP-INSERT的运行时间为O(lgn)。
	void insert(int key)
	{
		increaseHeapSize();
		increase_key(heapSize_, key);
	}

private:
	void ifQueueIsEmpty()
	{
		if (heapSize_ == 0)
		{
			throw string("Queue is empty!");
		}
	}

	void ifIncreaseKeyError(int i, int key)
	{
		if (i > heapSize_)
		{
			throw string("Index is larger than queue length!");
		}
		else if (key < queueContainer_[i])
		{
			throw string("New key is smaller than current key!");
		}
	}

	int getParentIndex(int i)
	{
		return i/2;
	}

	void increaseHeapSize()
	{
		if (++heapSize_ == queueContainer_.size())
		{
			queueContainer_.push_back(minInteger_);
		}
		else
		{
			queueContainer_[heapSize_] = minInteger_;
		}
	}

	void max_Heapify(QueueContainer& intVector, int i, int heap_size)
	{
		int left_i = 2 * i;
		int right_i = left_i + 1;

		//obtain the largest index
		int largest = i;
		if ((left_i <= heap_size) && (intVector[left_i] > intVector[i]))
		{
			largest = left_i;
		}
		if ((right_i <= heap_size) && (intVector[right_i] > intVector[largest]))
		{
			largest = right_i;
		}

		//exchange and iterate
		if (largest != i)
		{
			swap(intVector[i], intVector[largest]);
			max_Heapify(intVector, largest, heap_size);
		}
	}

private:
	QueueContainer queueContainer_;
	int heapSize_;
	static const int minInteger_ = -2147483648;
};

const int PriorityQueue::minInteger_;

int main()
{
	try
	{
		PriorityQueue priorityQueue;
		//cout << priorityQueue.extract_Max() << endl;
		priorityQueue.insert(10);
		priorityQueue.insert(20);
		priorityQueue.insert(30);

		cout << priorityQueue.extract_Max() << endl;
		cout << priorityQueue.maximum() << "\n";

		priorityQueue.insert(0);
		priorityQueue.insert(15);

		priorityQueue.increase_key(1, 30);
	}
	catch (string& e)
	{
		cout << e << endl;
	}

}

//STL算法里提供了关于heap操作的四个函数
// range heap example
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main () {
  int myints[] = {10,20,30,5,15};
  vector<int> v(myints,myints+5);
  vector<int>::iterator it;

  make_heap (v.begin(),v.end());//30,20,15,10,5 默认使用的是<的比较算法，排序成最大堆。这里可以加第三个入参比较函数less<int>()，效果一样。
  cout << "initial max heap   : " << v.front() << endl;

  //如果pop_heap里的元素不是堆，则调用pop_heap将出异常
  pop_heap (v.begin(),v.end()); //20,15,10,5,30 把最大值放到最后一位，便于后续pop操作，所以一般和下一句的pop_back函数一起用
  v.pop_back();//20,15,10,5
  cout << "max heap after pop : " << v.front() << endl;

  //如果push_heap里的元素除了最后一个之外的不是堆，则调用push_heap将出异常
  v.push_back(99); //20,15,10,5,90 新push一个元素进来，表示将要进行push_heap操作，所以一般和下一句push_heap函数一起用
  push_heap (v.begin(),v.end());//90,20,15,10,5 和make_heap (v.begin(),v.end());效果一样，最终生成了一个最大堆，但是元素位置是否完全一样，我不确定，不过应该可以肯定的是：push_heap操作比make_heap更快，否则提供push_heap函数完全没有意义了
  cout << "max heap after push: " << v.front() << endl;

  //如果不是堆，则异常，或者堆构造时的排序算法与sort_heap不同，则异常
  sort_heap (v.begin(),v.end());//5,10,15,20,99 对一个最大堆进行排序，同理肯定比sort排序快

  cout << "final sorted range :";
  for (unsigned i=0; i<v.size(); i++) cout << " " << v[i];

  cout << endl;

  return 0;
}
输出如下：
initial max heap   : 30
max heap after pop : 20
max heap after push: 99
final sorted range : 5 10 15 20 99
请按任意键继续. . .


//如果需要排序成最小堆，则这四个关于heap操作的算法都需要加入参comp，这里用的greater<int>，但是必须四个heap算法都入该比较函数，否则异常
// range heap example
#include <iostream>
#include <algorithm>
#include <vector>
#include <functional>
using namespace std;

int main () {
  int myints[] = {10,20,30,5,15};
  vector<int> v(myints,myints+5);
  vector<int>::iterator it;

  make_heap (v.begin(),v.end(), greater<int>());
  cout << "initial max heap   : " << v.front() << endl;

  pop_heap (v.begin(),v.end(), greater<int>()); 
  v.pop_back();
  cout << "max heap after pop : " << v.front() << endl;

  v.push_back(0); 
  push_heap (v.begin(),v.end(), greater<int>());
  cout << "max heap after push: " << v.front() << endl;

  sort_heap (v.begin(),v.end(), greater<int>());

  cout << "final sorted range :";
  for (unsigned i=0; i<v.size(); i++) cout << " " << v[i];

  cout << endl;

  return 0;
}
输出如下：
initial max heap   : 5
max heap after pop : 10
max heap after push: 0
final sorted range : 30 20 15 10 0
请按任意键继续. . .
//------------------------------------------------------------------------------------------------
//算法导论 第7章 快速排序 P85
快速排序对包含n个数的输入数组，最坏情况运行时间为Θ(n^2)。虽然最坏情况运行时间比较差，但快速排序通过是用于排序的最佳的实用选择，这是因为其平均性能相当好：期望的运行时间为Θ(nlgn)，且Θ(nlgn)记号中隐含的常数因子很小。另外，还能够就地排序。

7.1 快速排序的描述
像合并排序一样，也是基于2.3.1 节介绍的分治模式的。
分解：将A[p..r]划分成两个子数组A[p..q-1]和A[q+1 ..r]，使得A[p..q-1]中的每个元素都小于等于A(q)，而且，小于等于A[q+1 ..r]中的元素。下标q也在这个划分过程中进行计算。
解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1 ..r]排序。
合并：因为两个子数组是就地排序的，将它们的合并不需要操作：整个数组A[p..r]已排序。

//快速排序算法的Partition函数，入参为迭代器
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

typedef int T;
typedef vector<T> IntContainer;
typedef IntContainer::iterator Iter;

Iter quickSortPartition(Iter firstIter, Iter secondIter)
{
	Iter lastValueIter = secondIter - 1;
	T x = *lastValueIter;
	//Iter iterI = firstIter - 1; this is wrong! 对于迭代器的前一个值，是未定义的，不能这么用

	for (Iter iterJ = firstIter; iterJ != lastValueIter; ++iterJ)
	{
		if (*iterJ <= x)
		{
			iter_swap(firstIter++, iterJ);
		}
	}
	iter_swap(firstIter, lastValueIter);
	return firstIter;
}

int main ()
{
	int myints[] = {20,10,40,50,30};
	vector<int> v(myints,myints + 5);
	vector<int>::iterator it = quickSortPartition(v.begin(), v.end());
	cout << *it << endl;
	return 0;
}

//将上述的typedef都改写成模板类型template
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

template<typename Iter_T>
Iter_T quickSortPartition(Iter_T firstIter, Iter_T secondIter)
{
	typedef typename std::iterator_traits<Iter_T>::value_type Value_Type;//value_type获取迭代器所指向的元素类型，即T，reference获取元素的类型引用即T&
	
	Iter_T lastValueIter = secondIter - 1;
	Value_Type x = *lastValueIter;

	for (Iter_T iterJ = firstIter; iterJ != lastValueIter; ++iterJ)
	{
		if (*iterJ <= x)
		{
			iter_swap(firstIter++, iterJ);
		}
	}
	iter_swap(firstIter, lastValueIter);
	return firstIter;
}

int main () {
	int myints[] = {20,10,40,50,30};
	vector<int> v(myints,myints + 5);
	vector<int>::iterator it = quickSortPartition(v.begin(), v.end());
	cout << *it << endl;
	return 0;
}


member	description
difference_type	Type to express the result of subtracting one iterator from another.
value_type	The type of the element the iterator can point to.
pointer	The type of a pointer to an element the iterator can point to.
reference	The type of a reference to an element the iterator can point to.
iterator_category	The iterator category. It can be one of these:
	input_iterator_tag
	output_iterator_tag
	forward_iterator_tag
	bidirectional_iterator_tag
	random_access_iterator_tag
	
member	generic definition	T* specialization	const T* specialization
difference_type	Iterator::difference_type	ptrdiff_t	ptrdiff_t
value_type	Iterator::value_type	T	T
pointer	Iterator::pointer	T*	const T*
reference	Iterator::reference	T&	const T&
iterator_category	Iterator::iterator_category	random_access_iterator_tag	random_access_iterator_tag
参见http://www.cplusplus.com/reference/iterator/iterator_traits/

PARTITION在子数组A[p..r]上的运行时间为Θ(n)，其中n=r-p+1 。

//快速排序算法 QUICKSORT
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <utility>
using namespace std;

template<typename Iter_T>
Iter_T quickSortPartition(Iter_T firstIter, Iter_T secondIter)
{
	typedef typename std::iterator_traits<Iter_T>::value_type Value_Type;
	
	Iter_T lastValueIter = secondIter - 1;
	Value_Type x = *lastValueIter;

	for (Iter_T iterJ = firstIter; iterJ != lastValueIter; ++iterJ)
	{
		if (*iterJ <= x)
		{
			iter_swap(firstIter++, iterJ);
		}
	}
	iter_swap(firstIter, lastValueIter);
	return firstIter;
}

template<typename Iter_T>
void quickSort(Iter_T firstIter, Iter_T secondIter)
{
	if (distance(firstIter, secondIter) == 1 || firstIter == secondIter)//这里的== 1有点问题，如果入参就两个数2，1，则无法排序
	{
		return;
	}
	Iter_T iterQ = quickSortPartition(firstIter, secondIter); //注意：位置q所对应的元素已经划分出来的两个数组的中间元素，不需要再处理。
	quickSort(firstIter, iterQ);
	quickSort(iterQ + 1, secondIter);
}

int main () {
	int myints[] = {2,1,4,5,3};
	vector<int> v(myints,myints + 5);
	quickSort(v.begin(), v.end());
	for_each(v.begin(), v.end(), [] (int i) {cout << i << "\n";});
	return 0;
}

7.2 快速排序的性能 P88
快速排序的运行时间与划分是否对称有关，而后者又与选择了哪一个元素来进行划分有关。如果划分是对称的，那么本算法从渐近意义上来讲，就与合并算法一样快；如果划分是不对称的，那么本算法渐近上就和插入算法一样慢。

最坏情况划分
如果在算法的每一层递归上，划分都是最大程序不对称的，那么算法的运行时间就是Θ(n^2)。即，快速排序算法的最坏情况运行时间并不比插入排序的更好。此外，当输入数组已经完全排好序时，快速排序的运行时间为Θ(n^2)（仍需要每进行1..n, 1.. n-1, 1.. n-2, 1.. n-3, .. , 1.. 2 的遍历），插入排序的运行时间为O(n)（只需要从2 .. n进行遍历一遍即可）

最佳情况划分
在PARTITION可能做的最平衡的划分中，得到的两个子问题的大小都不可能大于n/2 ，其中一个子问题的大小为(n/2 向下取整)，另一个子问题的大小为(n/2 向上取整) - 1 。在这种情况下，快速排序运行的速度要快得多。T(n)=O(nlgn)。由于在每一层递归上，划分的两边都是对称的，因此，从渐近意义上来看，算法运行得就更快了。

平衡的划分
快速排序的平均情况运行时间与其最佳情况运行时间很接近，而不是非常接近于其最坏情况运行时间，可从7.4 节的分析中看到。
任何一种按常数比例进行的划分都会产生深度为Θ(lgn)的递归树，其中每一层的代价为O(n)，因而，每当按照常数比例进行划分时，总的运行时间都是O(nlgn)。

当好、差划分交替分布在各层中时，快速排序的运行时间就如全是好的划分时一样，仍然是O(nlgn)，但是O记号中隐含的常数因子要略大一些。

7.3 快速排序的随机化版本 P90
在5.3 节中，通过显式地对输入进行排列而使算法随机化了。对快速排序也可以这么做，但如果采用一种不同的、称为随机取样（random sampling）的随机化技术的话，可以使得分析更加简单。此方法中，不是始终采用A[r]作为主元，而是从子数组A[p..r]中随机选择一个元素，即将A[r]与从A[p..r]中随机选出的一个元素交换。
对PARTITION和QUICKSORT所做的改动比较小。在新的划分过程中，在真正进行划分之前实现交换。
新的快速排序过程不再调用PARTITION，而是调用RANDOMIZED-PARTITION。

//RANDOMIZED-QUICKSORT算法
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <utility>
#include <ctime>
#include <cstdlib>
using namespace std;

template<typename Iter_T>
Iter_T quickSortPartition(Iter_T firstIter, Iter_T secondIter)
{
	typedef typename std::iterator_traits<Iter_T>::value_type Value_Type;
	
	Iter_T lastValueIter = secondIter - 1;
	Value_Type x = *lastValueIter;

	for (Iter_T iterJ = firstIter; iterJ != lastValueIter; ++iterJ)
	{
		if (*iterJ <= x)
		{
			iter_swap(firstIter++, iterJ);
		}
	}
	iter_swap(firstIter, lastValueIter);
	return firstIter;
}

template<typename Iter_T>
Iter_T randomized_Partition(Iter_T firstIter, Iter_T secondIter)
{
	//get the random i
	int i = rand() % distance(firstIter, secondIter);
	
	Iter_T tempFirstIter = firstIter;
	Iter_T tempSecondIter = secondIter;
	advance(tempFirstIter, i);//advance will change the iterator without return value
	--tempSecondIter;//advance(tempFirstIter, -1) is wrong!
	iter_swap(tempFirstIter, tempSecondIter);//swap A[i] and A[r]

	return quickSortPartition(firstIter, secondIter);
}

template<typename Iter_T>
void randomized_QuickSort(Iter_T firstIter, Iter_T secondIter)
{
	if (firstIter == secondIter)//把distance(firstIter, secondIter) == 1 || 删除
	{
		return;
	}
	Iter_T iterQ = randomized_Partition(firstIter, secondIter);
	randomized_QuickSort(firstIter, iterQ);
	randomized_QuickSort(iterQ + 1, secondIter);
}

int main () 
{
	srand ( unsigned ( time(NULL) ) );

	//int myints[] = {5,3,2,4,1};
	//vector<int> v(myints,myints + 5);
	//randomized_QuickSort(v.begin(), v.end());
	//for_each(v.begin(), v.end(), [] (int i) {cout << i << "\n";});

	char myints[] = {'b','c','d','a','e'};
	vector<char> v(myints,myints + 5);
	randomized_QuickSort(v.begin(), v.end());
	for_each(v.begin(), v.end(), [] (char i) {cout << i << "\n";});
	return 0;
}

7.4 快速排序分析
7.4.1 最坏情况分析 P91
7.2 节中看到，如果快速排序中每一层递归上所做的都是最坏情况划分，则运行时间为Θ(n^2)。
利用代换法（见4.1 节），可以证明快速排序的运行时间为O(n^2)。
7.4.2 期望的运行时间 P92
平均情况运行时间为O(nlgn)。
利用RANDOMIZED-PARTITION，快速排序算法期望的运行时间为O(nlgn)。
//------------------------------------------------------------------------------------------------
//算法导论 第8章 线性时间排序 P97
8.1 排序算法时间的下界 P97
决策树模型 P97
最坏情况下界 P98
定理8.1 任意一个比较排序算法在最坏情况下，都需要做Ω(nlgn)次的比较。
推论8.2 堆排序和合并排序都是渐近最优的比较排序算法。

8.2 计数排序 P98
计数排序假设n个输入元素中的每一个都是介于0到k之间的整数，此处k为某个整数。当k=O(n)时，计数排序的运行时间为Θ(n)。
计数排序假定输入是由一个小范围内的整数组成。
有个问题，如果有某个数字很大，则需要构造一个这么大的数组C，但是其中很多数字都是用不上的
//参考所写的计数排序
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

typedef vector<unsigned int> UIntContainer;

void counting_Sort(UIntContainer& containerA, UIntContainer& containerB, unsigned int k)
{
	UIntContainer containerC(k + 1, 0);//pos 0 will not be used
	
	//C[i]包含等于i的元素个数
	for_each(containerA.begin(), containerA.end(), [&] (unsigned int i)
	{
		containerC[i] += 1;
	});

	//C[i]包含小于或等于i的元素个数
	for (unsigned int i = 1; i <=k; ++i)
	{
		containerC[i] += containerC[i - 1];
	}

	for_each(containerA.rbegin(), containerA.rend(), [&] (unsigned int i)
	{
		containerB[containerC[i] - 1] = i;
		containerC[i] -= 1;
	});
}

int main () 
{
	unsigned int uIntArray[] = {2, 5, 3, 0, 2, 3, 0, 3};
	UIntContainer uIntVecA(uIntArray, uIntArray + 8);
	UIntContainer uIntVecB(uIntVecA.size(), 0);
	unsigned int k = *max_element(uIntVecA.begin(), uIntVecA.end());
	counting_Sort(uIntVecA, uIntVecB, k);
	for_each(uIntVecB.begin(), uIntVecB.end(), [] (unsigned int i) {cout << i << " ";});

	return 0;
}
输出如下：
0 0 2 2 3 3 3 5 请按任意键继续. . .

计数排序的时间代价总的时间是Θ(k+n)。在实践中，当k=O(n)时，常采用计数排序，这时其运行时间为Θ(n)。
计数排序的下界优于8.1 节中证明的Ω(nlgn)，因为它不是个比较排序算法。事实上，其代码根本就不出现输入元素之间的比较。相反，计数排序是用了输入元素的实际值来确定它们在数组中的位置。
计数排序的一个重要性质就是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的次序相同。亦即，两个相同数之间的顺序是这样来规定的，即在输入数组中先出现的，在输出数组中也位于前面。说计数排序的稳定性非常重要，还有另一个原因，即计数排序经常用作基数排序算法的一个子过程。

8.3 基数排序 P100
引理8.3 给定n个d位数，每一个数位可以取k种可能的值。基数排序算法能以Θ(d(n+k))的时间正确地对这些数进行排序。
当d为常数、k=O(n)时，基数排序有线性运行时间。更一般地，在如何将每个关键字分解成若干数位方面，我们有了一定的灵活性。

引理8.4 给定n个b位数和任何正整数r<=b，RADIX-SORT能在Θ((b/r)(n+2^r))时间内正确地对这些数进行排序。

基数排序和快速排序算法，哪一个排序算法更好取决于底层机器的实现特性（如，快速排序通常可以比基数排序更为有效地利用硬件缓存），同时还取决于输入的数据。此外，利用计数排序作为中间稳定排序的基数排序不是原地排序，而很多Θ(nlgn)时间的比较排序算法则可以做到原地排序。因此，当内存容量比较宝贵时，像快速排序这样的原地排序算法可能是更为可取的。
//参考所写的基数排序算法
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <sstream>
using namespace std;

typedef vector<unsigned int> UIntContainer;

string intToString(int num)
{
	stringstream ss;
	ss << num;
	return string(ss.str());
}

void radix_Sort(UIntContainer& uIntContainer, unsigned int d)
{
	//这里用到的方法是把数字转化成字符串，取到特定的位数进行比较
	for (unsigned int i = d; i >= 1; --i)
	{
		stable_sort(uIntContainer.begin(), uIntContainer.end(), [=] (unsigned int lhs, unsigned int rhs) -> bool
		{
			string lhsStr(intToString(lhs));
			string rhsStr(intToString(rhs));
			return lhsStr[i - 1] < rhsStr[i - 1];
			
			//还尝试了用如下按位与的方式，直接获取到对应位数的数字进行比较，没有实现，一个十进制数和二进制与完了之后并不能得到十进制数的对应位数
			//int binaryNumber = static_cast<int>(pow(2.0, i - 1));//i = 1 to d
			//return (lhs & binaryNumber) < (rhs & binaryNumber);
		});
	}
}

int main () 
{
	unsigned int uIntArray[] = {5678, 1234, 9816, 6382, 5282};
	UIntContainer uIntVec(uIntArray, uIntArray + 5);
	radix_Sort(uIntVec, 4);
	for_each(uIntVec.begin(), uIntVec.end(), [] (unsigned int i) {cout << i << "\n";});
	return 0;
}

8.4 桶排序 P102
当桶排序（bucket sort）的输入符合均匀分布时，即可以以线性时间运行。与计数排序类似，桶排序也对输入作了某种假设，因而运行很快。具体来说，计数排序输入是由一个小范围内的整数构成，而桶排序则假设输入由一个随机过程产生，该过程将元素均匀地分布在区间[0,1)上。
//参考写的桶排序算法
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <cassert>
using namespace std;

typedef vector<double> DblContainer;
typedef vector<DblContainer> DblConContaier;

class BucketSortMgr
{
public:
	static void bucket_Sort(DblContainer& containerA)
	{
		size_t n = containerA.size();
		DblConContaier containerB(n);
		
		//把A中的元素构造放入辅助数组B中。辅助数组B来存放链表（桶）
		for_each(containerA.begin(), containerA.end(), [&] (double d) 
		{
			assert(d >= 0 && d < 1 && "Element in A is not between [0, 1)");
			int bucketIndex = static_cast<int>(floor(n * d));//向下取整floor，向上取整ceil
			(containerB[bucketIndex]).push_back(d);
		});//如果不用lambda表达式，要么用函数对象，要么用静态函数

		//对B中的每一个链表进行排序，书中用的是插入排序，在这里其实可以用set存数来简化，则可以省略这一步。
		for_each(containerB.begin(), containerB.end(), [] (DblContainer& doubleContainer) 
		{
			if (!doubleContainer.empty())
			{
				sort(doubleContainer.begin(), doubleContainer.end());
			}
		});

		//最后一步将每一个B中的排好序的链表数据连接输出到原数组A
		DblContainer::iterator iterA = containerA.begin();
		for_each(containerB.begin(), containerB.end(), [&] (DblContainer& doubleContainer) 
		{
			if (!doubleContainer.empty())
			{
				iterA = copy(doubleContainer.begin(), doubleContainer.end(), iterA);//这里返回的拷贝来的最后一个元素的后一个元素
			}
		});
	}
};

int main () 
{
	double doubleArray[] = {0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68};
	DblContainer doubleVec(doubleArray, doubleArray + 10);
	BucketSortMgr::bucket_Sort(doubleVec);
	for_each(doubleVec.begin(), doubleVec.end(), [] (double i) {cout << i << "\n";});
	return 0;
}
输出结果如下：
0.12
0.17
0.21
0.23
0.26
0.39
0.68
0.72
0.78
0.94
请按任意键继续. . .

P104 桶排序的期望运行时间为Θ(n)。于是，整个桶排序算法以线性期望时间运行。
即便输入不符合均匀分布，桶排序也仍然可以以线性时间运行。只要输入满足这样一个性质，即各个桶尺寸的平方和与总的元素数呈线性关系，那么通过式8.1 可知，桶排序仍然能以线性时间运行。
//------------------------------------------------------------------------------------------------
//算法导论 第9章 中位数和顺序统计学 P108
在一个由n个元素组成的集合中，第i个顺序统计量（order statistic）是该集合中第i小的元素。

非形式地说，一个中位数（median）是它所在集合的“中点元素”。当n为奇数时，中位数是唯一的，出现在i=(n+1)/2 处。当n为偶数时，存在两个中位数，分别出现在i=n/2 和i=n/2 + 1 处。不考虑n的奇偶性，中位数问题出现在i=(n+1)/2 的上取整 处（下中位数）和i=(n+1)/2 的上取整 处（上中位数）。简单起见，本书中所用的“中位数”总是指下中位数。

形式化地定义选择问题（selection problem）：
输入：一个包含n个（不同的）数的集合A和一个数i，1<=i<=n。
输出：元素x属于a，它恰大于A中其他的i-1 个元素。

9.1 最小值和最大值 P108
有n个元素的集合中，要做n-1 次比较才能确定其最小元素。为确定最小值（最大值）而做n-1 次比较是必须的，从所执行的比较次数来看，算法MINIMUM是最优的。

同时找出最大值和最小值
只要独立地找出最小值和最大值，各用n-1 次比较，共有2n-2 次比较。
事实上，至多3 * (n/2 的下取整)次比较就足以同时找到最小值和最大值。而是成对地处理元素。将一对输入元素互相比较，然后把较小者和当前最小值比较，把较大者与当前最大值比较，因此每两个元素需要3次比较。

9.2 以期望线性时间做选择
一般选择问题看起来要比找最小值的简单选择问题更难，但两种问题的渐近运行时间却是相同的：都是Θ(n)。
本节介绍用来解决选择问题的分治算法，即RANDOMIZED-SELECT算法，以第7章的快速排序算法为模型。对输入数组进行递归划分。但和快速排序不同的是，快速排序会递归处理划分的两边，而RANDOMIZED-SELECT只处理划分的一边。这一差异在分析中体现出来了：快速排序的期望运行时间是Θ(nlgn)，而RANDOMIZED-SELECT的期望时间为Θ(n)。
//参考所写的随机选择算法
#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <utility>
#include <ctime>
#include <cstdlib>
#include <cassert>
using namespace std;

template<typename Iter_T>
Iter_T quickSortPartition(Iter_T firstIter, Iter_T secondIter)
{
	typedef typename std::iterator_traits<Iter_T>::value_type Value_Type;
	
	Iter_T lastValueIter = secondIter - 1;
	Value_Type x = *lastValueIter;

	for (Iter_T iterJ = firstIter; iterJ != lastValueIter; ++iterJ)
	{
		if (*iterJ <= x)
		{
			iter_swap(firstIter++, iterJ);
		}
	}
	iter_swap(firstIter, lastValueIter);
	return firstIter;
}

template<typename Iter_T>
Iter_T randomized_Partition(Iter_T firstIter, Iter_T secondIter)
{
	//get the random i
	int i = rand() % distance(firstIter, secondIter);

	Iter_T tempFirstIter = firstIter;
	Iter_T tempSecondIter = secondIter;
	advance(tempFirstIter, i);//advance will change the iterator without return value
	--tempSecondIter;//advance(tempFirstIter, -1) is wrong!
	iter_swap(tempFirstIter, tempSecondIter);//swap A[i] and A[r]

	return quickSortPartition(firstIter, secondIter);
}

template<typename Iter_T>
typename std::iterator_traits<Iter_T>::value_type randomized_Select(Iter_T firstIter, Iter_T secondIter, int i)
{
	assert((i >= 1 && i <= distance(firstIter, secondIter)) && "i is not between the length!");
	if (firstIter == secondIter)
	{
		return *firstIter;
	}

	Iter_T iterQ = randomized_Partition(firstIter, secondIter);

	int k = distance(firstIter, iterQ) + 1;

	if (i == k)
	{
		return *iterQ;
	}
	else if (i < k)
	{
		return randomized_Select(firstIter, iterQ, i);
	}
	else
	{
		return randomized_Select(iterQ + 1, secondIter, i - k);
	}
}

int main () 
{
	srand ( unsigned ( time(NULL) ) );

	int myints[] = {5,3,2,4,1};
	vector<int> v(myints,myints + 5);
	cout << randomized_Select(v.begin(), v.end(), 2) << endl;
	
	//char myints[] = {'b','c','d','a','e'};
	//vector<char> v(myints,myints + 5);
	//cout << randomized_Select(v.begin(), v.end(), 2) << endl;

	return 0;
}
输出如下：
2

RANDOMIZED-SELECT的最坏情况运行时间为Θ(n^2)，即便是要选择最小元素也是如此。
在平均情况下，任何顺序统计量（特别是中位数）都可以在线性时间内得到。

9.3 最坏情况线性时间的选择 P112
SELECT的最坏情况运行时间是线性的。T(n)
//------------------------------------------------------------------------------------------------
算法导论 第三部分数据结构 P117
动态集合上的操作
分为两类：查询操作，返回有关集合的信息
修改操作：对集合进行修改
典型操作：
SEARCH(S, k)
INSERT(S, x)
DELETE(S, x)
MINIMUM(S)
MAXIMUM(S)
SUCCESSOR(S, x)
PREDECESSOR(S, x)
查询SUCCESSOR和PREDECESSOR常常被推广应用到具有相同关键字的集合上。对包含n个关键字的集合，通常假设调用MINIMUM一次后再调用n-1 次SUCCESSOR，就可以按序地枚举出该集合中的所有元素。
执行一个集合操作的时间通常是通过作为参数给出的集合的大小来度量的。

//算法导论 第10章 基本数据结构 P119
10.1 栈和队列
都是动态集合，在这种结构中，可以用DELETE操作去掉的元素都是预先规定好的。

10.2 链表 P121
哨兵 P123
哨兵是个哑对象，可以简化边界条件。

10.3 指针和对象的实现 P124
对象的多重数组表示P124
对象的单数组表示P125
分配和释放对象P125
我们把自由对象安排成一个单链表，称为自由表。自由表仅用到next数组，其中存放着表中的next指针。该自由表的头被置于全局变量free中。

10.4 有根树的表示
二叉树 P127

分支数无限制的有根树 P128

树的其他表示 P128
//------------------------------------------------------------------------------------------------
//算法导论 第11章 散列表 P132
11.1 直接寻址表 P132




//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------
