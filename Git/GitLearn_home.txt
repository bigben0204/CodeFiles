参考文档：http://blog.jobbole.com/78960/

//--设置用户名
Ben@DESKTOP-18O9S0P MINGW64 ~
$ git config --global user.name "dingben"

//--设置用户邮箱
Ben@DESKTOP-18O9S0P MINGW64 ~
$ git config --global user.email "464754973@qq.com"

//--进入目录
Ben@DESKTOP-18O9S0P MINGW64 /d
$ cd e:

//--查看路径
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files
$ pwd
/e/Program Files

//--初始化版本库
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository
$ git init
Initialized empty Git repository in E:/Program Files/GitRepository/.git/

//--添加文件
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git add JavaLearn_home.java

//--git commit -m "JavaLearn_home.java提交" 注释内容提交变更
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git commit -m "JavaLearn_home.java提交"
[master (root-commit) 94ee868] JavaLearn_home.java提交
 1 file changed, 11471 insertions(+)
 create mode 100644 JavaLearn_home.java

//--查看git状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
nothing to commit, working directory clean

//--改过文件之后查看状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   JavaLearn_home.java

no changes added to commit (use "git add" and/or "git commit -a")

//--查看修改内容
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git diff JavaLearn_home.java
diff --git a/JavaLearn_home.java b/JavaLearn_home.java
index a99ae2c..a18e71e 100644
--- a/JavaLearn_home.java
+++ b/JavaLearn_home.java
@@ -1,4 +1,7 @@
 //------------------------------------------------------------------------------------------------
+
+
+//------------------------------------------------------------------------------------------------
 //Javaֵ<B4><AB><B5>ݣ<AC><BC><B4><B4><AB><C8><EB><B5><C4><CA><C7><D2><FD><D3>õĸ<B1><B1><BE><A3><AC><D4>ں<AF><CA><FD><C0><EF><BB><E1><B0>Ѹ<C3><D2><FD>
<D3><C3>ָ<CF><F2><B5><BD><D0>µĶ<D4><CF><F3><C9>ϣ<AC><B5><AB><B2><BB><BB><E1>Ӱ<CF>쵽<BA><AF><CA><FD><C8><EB><BF>ڴ<A6><B6><D4><CF><F3>
 public class Test {
        public static void swap(int a, int b) {

//--添加文件到版本提交控制中，可以指定所有修改过的文件.
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git add JavaLearn_home.java //git add .

//--此时再查看状态，可以看到变成了to be committed
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   JavaLearn_home.java

//--可以reset回退add状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git reset JavaLearn_home.java // git reset HEAD readme.txt
Unstaged changes after reset:
M       JavaLearn_home.java

//--还原修改内容到版本控制的最后一个版本，所有修改内容将丢失
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout JavaLearn_home.java //git checkout .

//--显示日志修改内容
$ git log readme.txt
commit 2a9f2079d5a31236a46aa725dc01d3163920321c
Author: dingben <464754973@qq.com>
Date:   Sat Apr 9 21:22:34 2016 +0800

    增加33333333333333333

commit cc11753d4bff2dccfe33960d3458ab7f516f939b
Author: dingben <464754973@qq.com>
Date:   Sat Apr 9 21:18:24 2016 +0800

    modified How are you To 222222222222

commit c245deec64a709f27d8b6adaaf06e3fd346f805e
Author: dingben <464754973@qq.com>
Date:   Sat Apr 9 21:16:13 2016 +0800

    new added of readme.txt

//--增加参数--pretty=oneline 在一行显示
$ git log --pretty=oneline readme.txt
2a9f2079d5a31236a46aa725dc01d3163920321c 增加33333333333333333
cc11753d4bff2dccfe33960d3458ab7f516f939b modified How are you To 222222222222
c245deec64a709f27d8b6adaaf06e3fd346f805e new added of readme.txt

//--回退一个版本对git reset增加参数--hard HEAD^，几个版本就加几个^，如果想回退到最后一个版本就git reset --hard HEAD
$ git reset --hard HEAD^ //回退到前100个版本，git reset  –hard HEAD~100
HEAD is now at cc11753 modified How are you To 222222222222

//--查看所有的版本操作记录
$ git reflog //git reflog readme.txt
cc11753 HEAD@{0}: reset: moving to HEAD^
80f5aa9 HEAD@{1}: commit: add 4444 delete 2nd line
cc11753 HEAD@{2}: reset: moving to HEAD^
2a9f207 HEAD@{3}: commit: 增加33333333333333333
cc11753 HEAD@{4}: commit: modified How are you To 222222222222
c245dee HEAD@{5}: commit: new added of readme.txt
94ee868 HEAD@{6}: commit (initial): JavaLearn_home.java提交

//--版本回退到特定版本号内容
$ git reset --hard 80f5aa9
HEAD is now at 80f5aa9 add 4444 delete 2nd line

//--
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        test.txt

no changes added to commit (use "git add" and/or "git commit -a")

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git add .

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   readme.txt
        new file:   test.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git commit -m "修改readme.txt增加4444444444，新增test.txt"
[master 35bd88d] 修改readme.txt增加4444444444，新增test.txt
 2 files changed, 1 insertion(+)
 create mode 100644 test.txt

//--回退文件修改内容
1.手工修改回原内容

2.使用reset回退到最后一个版本
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git reset --hard HEAD
HEAD is now at 35bd88d 修改readme.txt增加4444444444，新增test.txt

3.使用git checkout -- filename方式
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout -- readme.txt

命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：
1. readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。
2. 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   readme.txt


Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout -- readme.txt //回退到加入暂存区的状态

注意：命令git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。


//--删除文件，rm filename，就是手工删除
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ rm test.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    test.txt

no changes added to commit (use "git add" and/or "git commit -a")

//再使用git checkout 可以回退文件删除状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout test.txt


//如果使用git rm filename，删除文件就可以直接提交commit提交
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git rm test.txt
rm 'test.txt'

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        deleted:    test.txt

//此时可以使用reset --hard HEAD回退状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git reset --hard HEAD
HEAD is now at 35bd88d 修改readme.txt增加4444444444，新增test.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
nothing to commit, working directory clean


//一步一步回退
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git rm test.txt
rm 'test.txt'

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        deleted:    test.txt

//回退到rm filename状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git reset HEAD test.txt
Unstaged changes after reset:
D       test.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    test.txt

no changes added to commit (use "git add" and/or "git commit -a")

//使用checkout 回复rm filename状态
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout test.txt

//删除文件并提交
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git rm test.txt
rm 'test.txt'

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git commit -m "删除test.txt"
[master edf048e] 删除test.txt
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 test.txt

//当删除文件之后，git rm test.txt和git add test.txt可以同样完成test.txt文件的暂存删除状态

//--创建SSH密钥
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ ssh-keygen -t rsa -C "bigben0204@163.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/Ben/.ssh/id_rsa):
Created directory '/c/Users/Ben/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/Ben/.ssh/id_rsa.
Your public key has been saved in /c/Users/Ben/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:XHpObuIIInGPYISDgkMmhdA4YhbN7I5cmbOWD4/5bd8 bigben0204@163.com
The key's randomart image is:
+---[RSA 2048]----+
|+O*              |
|%o.+             |
|@o. o     .      |
|oo *   . o       |
|+.= +   S o      |
|.* O     =       |
|. + O   . +      |
| . + +.+ o.      |
|    ..o.o. E     |
+----[SHA256]-----+

//--远程增加github仓库
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git remote add origin https://github.com/bigben0204/testgit.git

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git push -u origin master
Counting objects: 19, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (19/19), 82.50 KiB | 0 bytes/s, done.
Total 19 (delta 1), reused 0 (delta 0)
To https://github.com/bigben0204/testgit.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.

//之后在本地修改了内容之后，就会提示本地分支比远程的新
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
nothing to commit, working directory clean

//使用git push推送内容到github
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git push //git push origin master
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 318 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/bigben0204/testgit.git
   5c0519f..e7157e1  master -> master

//--将github内容克隆到本地
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git clone https://github.com/bigben0204/hello-world
Cloning into 'hello-world'...
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 7 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (7/7), done.
Checking connectivity... done.

//--查看分支
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch
* master

//--创建分支
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout -b dev
Switched to a new branch 'dev'

git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令
git branch dev //创建分支
git checkout dev //切换分支

//切换到master
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

//合并dev的内容到master
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git merge dev
Updating e7157e1..35b3524
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)

注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

//合并之后删除dev分支
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch -d dev
Deleted branch dev (was 35b3524).

总结创建与合并分支命令如下：
查看分支：git branch
创建分支：git branch name
切换分支：git checkout name
创建+切换分支：git checkout –b name
合并某分支到当前分支：git merge name
删除分支：git branch –d name

//--处理冲突

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git merge branch1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master|MERGING)
$ git status
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use "git push" to publish your local commits)
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

        both modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")

//手工修改掉冲突文件后，再add,commit
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master|MERGING)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master|MERGING)
$ git status
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use "git push" to publish your local commits)
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

nothing to commit, working directory clean

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master|MERGING)
$ git commit -m "conflict fixed"
[master 0961cdf] conflict fixed

//查看分支合并情况
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git log
commit 0961cdf99717877f3b19c31eaa732cd49d0ac741
Merge: 77e144f 7c1edeb
Author: dingben <464754973@qq.com>
Date:   Wed Apr 13 20:47:44 2016 +0800

    conflict fixed

commit 77e144f015e0d0b1357fb65413b3d4cd492fc8bd
Author: dingben <464754973@qq.com>
Date:   Wed Apr 13 20:41:23 2016 +0800

    在master主干上新增内容999999999

commit 7c1edeb9c12cd09e6a9531e87b8e92d7641b3153
Author: dingben <464754973@qq.com>
Date:   Wed Apr 13 20:32:00 2016 +0800

    添加内容888888到branch1

commit 35b35240d86769ec03622f140875dc2592da7786
Author: dingben <464754973@qq.com>
Date:   Wed Apr 13 20:20:27 2016 +0800

    dev分支上增加内容7777

//--分支管理策略
通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：
--创建一个dev分支。
--修改readme.txt内容。
--添加到暂存区。
--切换回主分支(master)。
--合并dev分支，使用命令 git merge –no-ff  -m “注释” dev
--查看历史记录

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git checkout -b dev
Switched to a new branch 'dev'

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ vim readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git commit -m "在dev分支上试验-no-ff选项"
[dev 875b4ac] 在dev分支上试验-no-ff选项
 1 file changed, 1 insertion(+)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 4 commits.
  (use "git push" to publish your local commits)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git merge --no-ff -m "merge with --no-ff" dev
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch -d dev
Deleted branch dev (was 875b4ac).

//可以看到分支信息875b4ac
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git log --graph --pretty=oneline --abbrev-commit
*   eb6bdd6 merge with --no-ff
|\
| * 875b4ac 在dev分支上试验-no-ff选项
|/
*   0961cdf conflict fixed
|\
| * 7c1edeb 添加内容888888到branch1
* | 77e144f 在master主干上新增内容999999999
|/
* 35b3524 dev分支上增加内容7777
* e7157e1 增加test.txt内容
* 5c0519f 再次增加test.txt
* edf048e 删除test.txt
* 35bd88d 修改readme.txt增加4444444444，新增test.txt
* 80f5aa9 add 4444 delete 2nd line
* cc11753 modified How are you To 222222222222
* c245dee new added of readme.txt
* 94ee868 JavaLearn_home.java提交

分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。

//--bug分支
如果在某个分支上的修改没有提交，则所有的分支上都能看到该文件的状态为修改的

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git branch
* dev
  master

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git status
On branch dev
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")

//工作现场隐藏起来
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git stash
Saved working directory and index state WIP on dev: eb6bdd6 merge with --no-ff
HEAD is now at eb6bdd6 merge with --no-ff

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git status
On branch dev
nothing to commit, working directory clean

//省略部分步骤，在issue404分支上修改内容后merge到master上
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git merge --no-ff -m "merge bug fix 404" issue404
Merge made by the 'recursive' strategy.
 readme.txt | 1 +
 1 file changed, 1 insertion(+)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git status
On branch master
Your branch is ahead of 'origin/master' by 8 commits.
  (use "git push" to publish your local commits)
nothing to commit, working directory clean

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch -d issue404
Deleted branch issue404 (was 180cc4a).

//解决完bug后再切换到dev分支来继续干活
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git stash list
stash@{0}: WIP on dev: eb6bdd6 merge with --no-ff

//通过git stash apply stash@{0}来恢复
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git stash apply stash@{0} //不指定stash编号则默认恢复编号最小的一个
On branch dev
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")

//再drop掉无用的stash
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git stash drop //git stash drop stash@{0} 可以指定删除特定的stash，不指定则默认删除编号最小的一个
Dropped refs/stash@{0} (5bff77c803216387298231fd9d27ce65f4c04f8a)

工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：
git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。
另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git stash pop
On branch dev
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (8f8e436cd940d40c462e150e7f2974ef32eb060c)

//--多人协作
当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。

要查看远程库的信息 使用 git remote
要查看远程库的详细信息 使用 git remote –v


Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git remote -v
origin  https://github.com/bigben0204/testgit.git (fetch)
origin  https://github.com/bigben0204/testgit.git (push)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git remote
origin


一：推送分支：
推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：
使用命令 git push origin master
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git push origin master
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (18/18), done.
Writing objects: 100% (18/18), 1.97 KiB | 0 bytes/s, done.
Total 18 (delta 6), reused 0 (delta 0)
To https://github.com/bigben0204/testgit.git
   e7157e1..8dfdaa3  master -> master

如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev
那么一般情况下，那些分支要推送呢？
master分支是主分支，因此要时刻与远程同步。
一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。

//可以在本地dev分支把内容推送到远程的dev分支上
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git push origin dev
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/bigben0204/testgit.git
 * [new branch]      dev -> dev

//但是之后在本地master推送到远程dev，是不会修改dev文件的
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git push origin dev
Everything up-to-date

//在本地dev推送到远程master，也不会更新文件
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git push origin master
Everything up-to-date

//--抓取分支
//git clone时，可以把整个版本信息克隆下来，不过此时只会把master克隆下来
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2 (master)
$ git clone https://github.com/bigben0204/testgit
Cloning into 'testgit'...
remote: Counting objects: 40, done.
remote: Compressing objects: 100% (27/27), done.
remote: Total 40 (delta 9), reused 39 (delta 8), pack-reused 0
Unpacking objects: 100% (40/40), done.
Checking connectivity... done.

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2 (master)
$ cd testgit/

//可以看到只把master分支克隆下来了
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (master)
$ git branch
* master

//可以把创建一个dev分支，并且以远程服务器上的版本内容为蓝本
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (master)
$ git checkout -b dev origin/dev
Branch dev set up to track remote branch dev from origin.
Switched to a new branch 'dev'


//在testgit2/testgit的dev分支下修改readme.txt内容（新增最后一行内容）
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ cat readme.txt
It is a nice day.
Fine, thank you.
4444
444444444
777777777777777
99999999999999
-no-ff learning test
I am developing in testgit2/testgit dev branch.

//提交并推送到远程版本库中
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ git commit -m "在testgit2/testgit文件夹下的dev分支修改readme.txt内容"
[dev da74350] 在testgit2/testgit文件夹下的dev分支修改readme.txt内容
 1 file changed, 1 insertion(+)

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ git log --pretty=oneline readme.txt
da743506bd2dac9bc22101a35ec53062e752a8d8 在testgit2/testgit文件夹下的dev分支修改readme.txt内容
875b4ac59040f0b24bc4914c78f6e6eb9a529332 在dev分支上试验-no-ff选项
77e144f015e0d0b1357fb65413b3d4cd492fc8bd 在master主干上新增内容999999999
35b35240d86769ec03622f140875dc2592da7786 dev分支上增加内容7777
35bd88d3712f2fb929a8fa08301420b639396db5 修改readme.txt增加4444444444，新增test.txt
80f5aa945b8456da7a4019d399a675de3fda1964 add 4444 delete 2nd line
cc11753d4bff2dccfe33960d3458ab7f516f939b modified How are you To 222222222222
c245deec64a709f27d8b6adaaf06e3fd346f805e new added of readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ git push origin dev
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 443 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/bigben0204/testgit
   eb6bdd6..da74350  dev -> dev

//用git pull来将最新的github代码拉到本地
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/testgit2/testgit (dev)
$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/bigben0204/testgit
   da74350..9aba562  dev        -> origin/dev
Updating da74350..9aba562
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)

//在本地另一个人修改同样文件
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ vim readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git commit -m "我在自己分支dev上同样提交readme.txt"
[dev 6dda61b] 我在自己分支dev上同样提交readme.txt
 1 file changed, 1 insertion(+)

//推送到github失败，提示有冲突，同样文件被修改
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git push origin dev
To https://github.com/bigben0204/testgit.git
 ! [rejected]        dev -> dev (fetch first)
error: failed to push some refs to 'https://github.com/bigben0204/testgit.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

//git pull也失败，没有设置远程库关联
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git pull
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (6/6), done.
From https://github.com/bigben0204/testgit
   eb6bdd6..9aba562  dev        -> origin/dev
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> dev

//先设置
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git branch --set-upstream dev origin/dev
The --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to
Branch dev set up to track remote branch dev from origin.

//git pull成功，但是有冲突
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git pull
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.

//查看状态，发现有冲突文件
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev|MERGING)
$ git status
On branch dev
Your branch and 'origin/dev' have diverged,
and have 1 and 2 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

        both modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")


Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev|MERGING)
$ vim readme.txt

//修改完之后再次提交
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev|MERGING)
$ git add readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev|MERGING)
$ git commit -m "merge & fix readme.txt"
[dev 1628f7e] merge & fix readme.txt

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git status
On branch dev
Your branch is ahead of 'origin/dev' by 2 commits.
  (use "git push" to publish your local commits)
nothing to commit, working directory clean

//再次push
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (dev)
$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 766 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/bigben0204/testgit.git
   9aba562..1628f7e  dev -> dev

因此：多人协作工作模式一般是这样的：
首先，可以试图用git push origin branch-name推送自己的修改.
如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。
如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。

//--
Git基本常用命令如下：
mkdir：         XX (创建一个空目录 XX指目录名)
pwd：          显示当前目录的路径。
git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。
git add XX       把xx文件添加到暂存区去。
git commit –m “XX”  提交文件 –m 后面的是注释。
git status        查看仓库状态
git diff  XX      查看XX文件修改了那些内容
git log          查看历史记录
git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本
                     (如果想回退到100个版本，使用git reset –hard HEAD~100 )
cat XX         查看XX文件内容
git reflog       查看历史记录的版本号id
git checkout — XX  把XX文件在工作区的修改全部撤销。
git rm XX          删除XX文件
git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库
git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库
git clone https://github.com/tugenhua0707/testgit  从远程库中克隆
git checkout –b dev  创建dev分支 并切换到dev分支上
git branch  查看当前所有的分支
git checkout master 切换回master分支
git merge dev    在当前的分支上合并dev分支
git branch –d dev 删除dev分支
git branch –D dev 强制删除dev分支
git branch name  创建分支
git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作
git stash list 查看所有被隐藏的文件列表
git stash apply 恢复被隐藏的文件，但是内容不删除
git stash drop 删除文件
git stash pop 恢复文件的同时 也删除文件
git remote 查看远程库的信息
git remote –v 查看远程库的详细信息
git push origin master  Git会把master分支推送到远程库对应的远程分支上

//--删除远程分支，但是删除之后在GitHub上还能看到远程仓
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch -r -d origin/dev
Deleted remote-tracking branch origin/dev (was 1628f7e).

//查看所有分支
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository (master)
$ git branch -a
  dev
* master
  remotes/origin/dev
  remotes/origin/master

//--回退删除的文件，git checkout .或指定完整文件路径git checkout C++/littleProgram_home.cpp
Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository/CodeFiles (master)
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    C++/littleProgram_Windows Socket.cpp
        deleted:    C++/littleProgram_home.cpp

no changes added to commit (use "git add" and/or "git commit -a")

Ben@DESKTOP-18O9S0P MINGW64 /e/Program Files/GitRepository/CodeFiles (master)
$ git checkout .

//--------------------------------------------------------------------------------------------------------------
# 深入理解Git的实现原理 https://www.cnblogs.com/mamingqian/p/9711975.html
3.1 Git数据库
 
我们提到了“Git数据库”，这是什么玩意儿呢？为了能够说清楚Git数据库的概念，我们暂且引入三个Git指令，通过这三个命令，我们就能一探git数据库的究竟。
git init  用于创建一个空的git仓库，或重置一个已存在的git仓库
git hash-object  git底层命令，用于向Git数据库中写入数据
git cat-file  git底层命令，用于查看Git数据库中数据

首先，我们用git init新建一个空的git仓库。（希望小伙伴们可以跟着我的节奏一起来实际操作一下，会加深理解。如果有还没有安装好git工具的同学，请自行百度安装，我不会讲安装的过程。）

我们发现，GitTest目录下，除隐藏目录.git之外，并没有其他文件或文件夹。
 
我们通过find .git命令查看新生成的空git仓库的结构，会发现其中有一个objects文件夹，这就是git数据库的存储位置。

3.1 Git数据库的写入操作
 
紧接着，我们利用git底层命令git hash-object向git数据库中写入一些内容。执行命令：
$ echo "version 1" | git hash-object -w --stdin
83baae61804e65cc73a7201a7252750c76066a30

$ find .git/objects/ -type f
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30

"|"表示这是一条通道命令，意思是把“|”前边的命令的输出作为“|”后边命令的输入。git hash-object -w --stdin 的意思是向git数据库中写入一条数据（-w）,这条数据的内容从标准输入中读取（--stdin）。
 
命令执行后，会返回个长度为40位的hash值，这个hash值是将待存储的数据外加一个头部信息一起做SHA-1校验运算而得的校验和。在git数据库中，它有一个名字，叫做“键值（key）”。相应的，git数据库其实是一个简单的“键值对（key-value）”数据库。事实上，你向该数据库中插入任意类型的内容，它都会返回一个键值。通过返回的键值可以在任意时刻再次检索该内容。
 
此时，我们再次执行find .git/objects/ -type f命令查看objects目录，会发现目录中多出了一个文件，这个文件存储在以新存入数据对应hash值的前2位命名的文件夹内，文件名为hash值的后38位。这就是git数据库的存储方式，一个文件对应一条内容，就是这么简单直接。

3.2 Git数据库的查询操作
 
我们可以通过git cat-file这个git底层命令查看数据库中某一键值对应的数据。执行
 
$ git cat-file -t  83baa
blob

$ git cat-file -p 83baa
version 1
 
其中，-t选项用于查看键值对应数据的类型，-p选项用于查看键值对应的数据内容，83bba为数据键值的简写。
 
由执行结果可见，所查询的键值对应的数据类型为blob，数据内容为“version 1”。blob对象我们称之为数据对象，这是git数据库能够存储的对象类型之一，后面我们还会讲到另外两种对象分别是树（tree）对象和提交（commit）对象。
 
截止到这里，你已经掌握了如何向git数据库里存入内容和取出内容。这很简单但是却意义非凡，因为对git数据库的操作正是git系统的核心——git的版本控制功能就是基于它的对象数据库实现的。在git数据库里，存储着纳入git版本管理的所有文件的所有版本的完整镜像。
 
git这么简单吗？不用怀疑，git就是这么简单，我们已经准确的抓住了它的根本要义——对象数据库。接下来我们会利用git数据库搭建起git的高楼大厦。

3.3 使用Git跟踪文件变更
 
我们明白，所谓跟踪文件变更，只不过是把文件变更过程中的各个状态完整记录下来。
 
我们模拟一次文件变更的过程，看看仅仅利用git的对象数据库能不能实现“跟踪文件变更”的功能。
 
首先，我们执行
 
$ echo "version 1" > file.txt
 
$ git hash-object -w file.txt
83baae61804e65cc73a7201a7252750c76066a30
 
我们把文本“version 1”写入file.txt中，并利用git hash-object -w file.txt命令将其保存入数据库中。如果你足够细心，会发现返回的hash键值和利用echo "version 1" | git hash-object -w --stdin写入数据库时是一致的，这很正常，因为我们写入的内容相同。git hash-object命令在只指定-w选项的时候，会把file.txt文件内容写入数据库。

此时，执行
 
$ find .git/objects -type f

.git/objects/83/baae61804e65cc73a7201a7252750c76066a30

 
会发现.git/objects目录中，依然只有一个文件。可见，git数据库存储文件时，只关心文件内容，与文件的名字无关。

接下来，我们修改file.txt的内容，执行
 
$ echo "version 2" > file.txt
$ git hash-object -w file.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30

 
我们发现，.git/objects下多出了一个文件，这是我们新保存进数据库的file.txt。接下来，我们执行git cat-file搞清楚这两条数据的内容分别是什么。执行
 
$git cat-file -p 83baa
version 1
$git cat-file -p 1f7a7a
version 2
 
我们发现，file.txt的变更过程被完整的记录下来了。

当前的file.txt中保存的内容是“version 2”，如果我们想把文件恢复到修改为“version 2”之前的状态，只需执行
 
$ cat file.txt
version 2
$ git cat-file -p 83baa > file.txt
$ cat file.txt
version 1

file.txt的内容成功恢复到了修改前的状态，变成了“version 1”。这其实就是版本回滚的实质。

3.4 利用树对象（tree object）解决文件名保存和文件组织问题
 
Git利用树对象（tree object）解决文件名保存的问题，树对象也能够将多个文件组织在一起。

Git通过树（tree）对象将数据（blob）对象组织起来，这很类似于一种文件系统——blob对象对应文件内容，tree对象对应文件的目录和节点。一个树（tree）对象包含一条或多条记录，每条记录含有一个指向blob对象或tree对象的SHA-1指针，以及相应的模式、类型、文件名。
 
有了树对象，我们就可以将文件系统任何时间点的状态保存在git数据库中，这是不是很激动人心呢？你的一个复杂的项目可能包含成百上千个文件和文件目录，有了树对象，这一切都不是问题。
 
创建树对象
 
通常，Git根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可以依次记录一系列的树对象。Git的暂存区是一个文件——.git/index。下面，我们通过创建树对象的过程来认识暂存区和树对象。
 
为了创建一个树对象，我们需要通过暂存一些文件来创建一个暂存区。为此我们引入两个命令：
 
git update-index     git底层命令，用于创建暂存区
git ls-files --stage    git底层命令，用于查看暂存区内容
git write-tree            git底层命令，用于将暂存区内容写入一个树对象


我们将file.txt的第一个版本放入暂存区，执行
 
$ find .git/index
find: ‘.git/index’: No such file or directory
$ git update-index --add file.txt
$ find .git/index
.git/index
$ cat .git/index

$ find .git/objects/ -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
$ git ls-files --stage
100644 83baae61804e65cc73a7201a7252750c76066a30 0    file.txt
$ git write-tree
391a4e90ba882dbc9ea93855103f6b1fa6791cf6
$ find .git/objects/ -type f
.git/objects/39/1a4e90ba882dbc9ea93855103f6b1fa6791cf6
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30

分析执行结果：
 
首先，我们注意.git/index文件的变化。在添加file.txt到暂存区前，index文件并不存在，这说明暂存区还没有创建。添加file.txt到暂存区的同时，index文件被创建。
 
其次，我们看git数据库的变化。我们发现在执行git update-index 之后，git数据库并没有改变，依然是只有两条数据。在执行git write-tree之后，git数据库中多出了一条新的记录，键值为391a4e90ba882dbc9ea93855103f6b1fa6791cf6。
 
我们执行git cat-file来查看一下多出来的这条记录是什么内容。执行
 
$ git cat-file -t 391a4e
tree
$ git cat-file -p 391a4e
100644 blob 83baae61804e65cc73a7201a7252750c76066a30    file.txt
 
由执行结果可见，git数据库中新增加的记录是一个tree对象，该tree对象指向一个blob对象，hash键值为
 
83baae61804e65cc73a7201a7252750c76066a30
 
这一个blob对象是之前我们添加进数据库的。

以上我们添加了一个已经存在在git数据库中的文件到暂存区，如果我们新建一个未曾保存到git数据库的文件存入暂存区，进而保存为tree对象，会有什么不同吗？我们试试看。执行
 
$ echo "new file" > new
$ git update-index --add new
$ find .git/objects/ -type f
.git/objects/39/1a4e90ba882dbc9ea93855103f6b1fa6791cf6 #tree对象
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a #blob对象
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 #blob对象
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 #新增的blob对象
$ git write-tree
228e49bb0bf19df94b49c3474f5d4ee55a371fbe #新生成的tree对象键值
$ find .git/objects/ -type f
.git/objects/39/1a4e90ba882dbc9ea93855103f6b1fa6791cf6
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92
.git/objects/22/8e49bb0bf19df94b49c3474f5d4ee55a371fbe #新增的tree对象

$ git ls-files --stage
100644 83baae61804e65cc73a7201a7252750c76066a30 0    file.txt
100644 fa49b077972391ad58037050f2a75f74e3671e92 0    new


 
由执行结果我们可以看到，这一次执行update-index之后，和上次不同，git数据库发生了变化，新增加了一条hash键值为“fa49b0”的数据；暂存区中也多出了文件new的信息。

这说明两个问题：
如果添加git数据库中尚未存储的数据到暂存区，则在执行update-index的时候，会同时把该数据保存到git数据库。
添加文件进入暂存区的操作是追加操作，之前已经加入暂存区的文件依然存在——很多人会有误区，认为变更提交之后，暂存区就清空了。
此时，我们查看新添加的树对象，执行

$ git cat-file -p 228e49
100644 blob 83baae61804e65cc73a7201a7252750c76066a30    file.txt
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new
 
此次write-tree写入数据库的是tree对象包含了两个文件。
 
更进一步，我们是否能将一个子文件夹保存到树对象呢？尝试一下，执行
 
$ mkdir new_dir
$ git update-index --add new_dir
error: new_dir: is a directory - add files inside instead
fatal: Unable to process path new_dir
 
我们发现，无法将一个新建的空文件夹添加到暂存区。错误提示告诉我们，应该将文件将文件夹中的文件加入到暂存区（add files inside instead）。


OK，接下来，我们在新建的文件夹下写入一个文件，再尝试将这一文件加入暂存区。执行
 
$ echo "file in new dir" > new_dir/new
$ git update-index --add new_dir/new
$ git ls-files --stage
100644 83baae61804e65cc73a7201a7252750c76066a30 0    file.txt
100644 fa49b077972391ad58037050f2a75f74e3671e92 0    new
100644 138c554a661371c9c40ae62dfb5d51b48b9b3f6b 0    new_dir/new

$ git write-tree
06564b76e0fcf9f3600fd055265cf2d4c45847a8

$ git cat-file -p 06564b
100644 blob 83baae61804e65cc73a7201a7252750c76066a30    file.txt
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new
040000 tree 8d6bc0bdbba1d28caf4ee66a125169500080e206    new_dir


从执行结果可见，文件夹new_dir对应一个tree对象。

至此，在git数据库中，我们可以完整的记录文件的状态、文件夹的状态；并且可以把多个文件或文件夹组织在一起，记录他们的变更过程。我们离一个完善的版本控制系统似乎已经不远了，而这一切实现起来又是如此简单——我们只是通过几个命令操作git数据库就完成了这些功能。
 
接下来，我们只要把数据库中各个版本的时序关系记录下来，再把对每一个版本更新的注释记录下来，不就完成了一个逻辑简单、功能强大、操作灵活的版本控制系统吗？
 
那么，如何记录版本的时序关系，如何记录版本的更新注释呢？这就要引入另一个git数据对象——提交对象（commit object）。

3.5 利用提交对象（commit object）记录版本间的时序关系和版本注释
 
commit对象能够帮你记录什么时间，由什么人，因为什么原因提交了一个新的版本，这个新的版本的父版本又是谁。
 
git提供了底层命令commit-tree来创建提交对象（commit object），我们需要为这个命令指定一个被提交的树对象的hash键值，以及该提交对象的父提交对象（如果是第一次提交，不需要指定父对象）。
 
我们尝试将之前创建的树对象提交为commit 对象，执行
$ git write-tree
cb0fbcc484a3376b3e70958a05be0299e57ab495
$ git commit-tree cb0fbcc -m "first commit"
7020a97c0e792f340e00e1bb8edcbafcc4dfb60f
$ git cat-file 7020a97
tree cb0fbcc484a3376b3e70958a05be0299e57ab495
author john <john@163.com> 1537961478 +0800
committer john <john@163.com> 1537961478 +0800

first commit
 
在git commit-tree命令中，-m选项用于指定本次提交的注释。
 
我们可以很清楚的看到，一个提交对象包含着所提交版本的树对象hash键值，author和commiter，以及修改和提交的时间，最后是本次提交的注释。
 
其中committer和author是通过git config命令设置的。
 
接下来，修改某个文件，重新创建一个树对象，并将这一树对象提交，作为项目的第二个提交版本。执行
$ echo "new version" > file.txt
$ git update-index file.txt
$ git write-tree
848e967643b947124acacc3a2d6c5a13c549231c
$ git commit-tree 848e96 -p 7020a97 -m "second commit"
e838c8678ef789df84c2666495663060c90975d7
$ git cat-file -p e838c
tree 848e967643b947124acacc3a2d6c5a13c549231c
parent 7020a97c0e792f340e00e1bb8edcbafcc4dfb60f
author john <john@163.com> 1537962442 +0800
committer john <john@163.com> 1537962442 +0800

second commit
 
我们可以按照上述步骤，再提交第三个版本。
 
$ echo "another version" > file.txt
$ git update-index file.txt
$ git write-tree
92867fcc5e0f78c195c43d1de25aa78974fa8103
$ git commit-tree 92867 -p e838c -m "third commit"
491404fa6e6f95eb14683c3c06d10ddc5f8e883f
$ git cat-file -p 49140
tree 92867fcc5e0f78c195c43d1de25aa78974fa8103
parent e838c8678ef789df84c2666495663060c90975d7
author john <john@163.com> 1537963274 +0800
committer john <john@163.com> 1537963274 +0800
 

third commit
 
提交完三个版本，我们通过git log 查看最近一个提交对象的提交记录
 
$ git log 49140
commit 491404fa6e6f95eb14683c3c06d10ddc5f8e883f
Author: john <john@163.com>
Date:   Wed Sep 26 20:01:14 2018 +0800

    third commit

commit e838c8678ef789df84c2666495663060c90975d7
Author: john <john@163.com>
Date:   Wed Sep 26 19:47:22 2018 +0800

    second commit

commit 7020a97c0e792f340e00e1bb8edcbafcc4dfb60f
Author: john <john@163.com>
Date:   Wed Sep 26 19:31:18 2018 +0800

    first commit

 
太神奇了： 就在刚才，我们围绕git数据库，仅凭几个底层数据库操作便完成了一个 Git 提交历史的创建。到此为止，我们已经完全掌握了git的内在逻辑。
 
接触过git的小伙伴会发现，以上我们用到的这些指令在使用git过程中是用不到的。这是为什么呢？因为git对以上这些指令进行了封装，给用户提供了更便捷的操作命令，如add，commit等。
 
每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作是将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。
 
然而，小问题依然存在，截止目前为止，我们对版本和数据对象的操作都是基于hash键值的，这些毫无直观含义的字符串让人很头疼，不会有人愿意一直急着最新提交对应的hash键值的。git不会允许这样的问题存在的，它通过引入“引用（references）”来解决这一问题。
 
3.6 Git的引用
 
Git的引用（references）保存在.git/refs目录下。git的引用类似于一个指针，它指向的是某一个hash键值。
 
创建一个引用实在再简单不过。我们只需把一个git对象的hash键值保存在以引用的名字命名的文件中即可。
 
执行
$ echo "491404fa6e6f95eb14683c3c06d10ddc5f8e883f" > .git/refs/heads/master
$ cat .git/refs/heads/master
491404fa6e6f95eb14683c3c06d10ddc5f8e883f
 
就这样，我们便成功的建立了一个指向最新一个提交的引用，引用名为master
 
在此之前我们查看提交记录需要执行 git log 491404，现在只需执行git log master。
 
$ git log 491404
commit 491404fa6e6f95eb14683c3c06d10ddc5f8e883f (HEAD -> master)
Author: john <john@163.com>
Date: Wed Sep 26 20:01:14 2018 +0800
 

third commit
 

commit e838c8678ef789df84c2666495663060c90975d7
Author: john <john@163.com>
Date: Wed Sep 26 19:47:22 2018 +0800
 

second commit
 

commit 7020a97c0e792f340e00e1bb8edcbafcc4dfb60f
Author: john <john@163.com>
Date: Wed Sep 26 19:31:18 2018 +0800
 

first commit
$ git log master
commit 491404fa6e6f95eb14683c3c06d10ddc5f8e883f (HEAD -> master)
Author: john <john@163.com>
Date: Wed Sep 26 20:01:14 2018 +0800
 

third commit
 

commit e838c8678ef789df84c2666495663060c90975d7
Author: john <john@163.com>
Date: Wed Sep 26 19:47:22 2018 +0800
 

second commit
 

commit 7020a97c0e792f340e00e1bb8edcbafcc4dfb60f
Author: john <john@163.com>
Date: Wed Sep 26 19:31:18 2018 +0800
 

first commit

 
结果完全相同。
 
Git并不提倡直接编辑引用文件，它提供了一个底层命令update-ref来创建或修改引用文件。
 
echo "491404fa6e6f95eb14683c3c06d10ddc5f8e883f" > .git/refs/heads/master 命令可以简单的写作：
 
$ git update-ref refs/heads/master 49140
 
这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。

4. Git基本原理总结
Git的核心是它的对象数据库，其中保存着git的对象，其中最重要的是blob、tree和commit对象，blob对象实现了对文件内容的记录，tree对象实现了对文件名、文件目录结构的记录，commit对象实现了对版本提交时间、版本作者、版本序列、版本说明等附加信息的记录。这三类对象，完美实现了git的基础功能：对版本状态的记录。
Git引用是指向git对象hash键值的类似指针的文件。通过Git引用，我们可以更加方便的定位到某一版本的提交。Git分支、tags等功能都是基于Git引用实现的。
//--------------------------------------------------------------------------------------------------------------
// git命令显示内容不分页，直接全部显示
// 使用参数--no-pager
git --no-pager log
//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------



