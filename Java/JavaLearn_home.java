//------------------------------------------------------------------------------------------------
//打印任务：某个打印机根据打印队列执行打印任务。打印任务分为九个优先级，分别采用数字1~9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A，然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则执行任务A的打印。请编写一个程序，根据输入的打印队列，输出实际打印顺序。
// 输入：9,3,5 -> 输出：0,2,1
// 输入：1,3,1 -> 输出：2,0,1
package test;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    static private class TaskInfo {
        public TaskInfo(int priority, int index, int flag) {
            this.priority = priority;
            this.index = index;
            this.flag = flag;
        }

        int priority;
        int index;
        int flag;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String order = getOrder(in.nextLine());
            System.out.println(order);
        }
    }

    private static String getOrder(String priorityStr) {
        List<TaskInfo> taskInfos = getTasks(priorityStr);
        TaskInfo tmpMaxTaskInfo = taskInfos.get(0);
        StringBuilder result = new StringBuilder();
        while (true) {
            int index = tmpMaxTaskInfo.index;
            for (int i = tmpMaxTaskInfo.index + 1; i < taskInfos.size(); i++) {
                TaskInfo taskInfo = taskInfos.get(i);
                if (taskInfo.priority > tmpMaxTaskInfo.priority && taskInfo.flag == 0) {
                    tmpMaxTaskInfo = taskInfo;
                }
            }

            for (int i = 0; i < index; i++) {
                TaskInfo taskInfo = taskInfos.get(i);
                if (taskInfo.priority > tmpMaxTaskInfo.priority && taskInfo.flag == 0) {
                    tmpMaxTaskInfo = taskInfo;
                }
            }
            result.append(tmpMaxTaskInfo.index + ",");
            tmpMaxTaskInfo.flag = 1;
            tmpMaxTaskInfo = getNextMax(tmpMaxTaskInfo, taskInfos);
            if (tmpMaxTaskInfo == null) {
                break;
            }
        }
        return result.substring(0, result.length() - 1);
    }

    private static List<TaskInfo> getTasks(String priorityStr) {
        List<TaskInfo> taskInfos = new ArrayList<>();
        String[] priorityTasks = priorityStr.split(",");
        for (int index = 0; index < priorityTasks.length; index++) {
            int priority = Integer.parseInt(priorityTasks[index].trim());
            TaskInfo t = new TaskInfo(priority, index, 0);
            taskInfos.add(t);
        }
        return taskInfos;
    }

    private static TaskInfo getNextMax(TaskInfo taskInfo, List<TaskInfo> taskInfos) {
        for (int i = taskInfo.index + 1; i < taskInfos.size(); i++) {
            TaskInfo t = taskInfos.get(i);
            if (t.flag == 0) {
                return t;
            }
        }

        for (int i = 0; i < taskInfo.index; i++) {
            TaskInfo t = taskInfos.get(i);
            if (t.flag == 0) {
                return t;
            }
        }
        return null;
    }
}

//------------------------------------------------------------------------------------------------
//747. Largest Number At Least Twice of Others https://leetcode.com/problems/largest-number-at-least-twice-of-others/submissions/

//把数字和其下标一起排序后获取最大值和第二大值元素，如果满足2倍关系，则直接返回最大值下标索引。
package test;

import java.util.Arrays;
import java.util.Comparator;

class Solution {
    public int dominantIndex(int[] nums) {
        if (nums.length == 1) {
            return 0;
        }

        int[][] sortedInts = new int[nums.length][2];
        for (int i = 0; i < nums.length; i++) {
            sortedInts[i][0] = nums[i];
            sortedInts[i][1] = i;
        }

        Arrays.sort(sortedInts, Comparator.comparing(e -> -e[0]));
        int[] max = sortedInts[0];
        int[] secondMax = sortedInts[1];

        return max[0] >= 2 * secondMax[0] ? max[1] : -1;
    }
}

//优化过的，只遍历一遍，找到最大值和第二大的值
package test;

class Solution { //0ms
    public int dominantIndex(int[] nums) {
        if (nums.length == 1) {
            return 0;
        }

        int max = nums[0];
        int maxIndex = 0;
        int secondMax = Integer.MIN_VALUE;

        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] > max) { //如果找到了最大值，则原最大值变成第二大值
                secondMax = max;
                max = nums[i];
                maxIndex = i;
            } else if (secondMax == Integer.MIN_VALUE || nums[i] > secondMax) { //如果当前值不是最大值，则判断当前值是不是比原来的第二大值大，如果大于则将其赋给第二大值
                secondMax = nums[i];
            }
        }
        return max >= 2 * secondMax ? maxIndex : -1;
    }
}


//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private static final Solution SOLUTION = new Solution();

    @Test
    public void test1() {
        int[] nums = {3, 6, 1, 0};
        assertEquals(1, SOLUTION.dominantIndex(nums));
    }

    @Test
    public void test2() {
        int[] nums = {1, 2, 3, 4};
        assertEquals(-1, SOLUTION.dominantIndex(nums));
    }

    @Test
    public void test3() {
        int[] nums = {1, 0, 0, 0};
        assertEquals(0, SOLUTION.dominantIndex(nums));
    }
}
//------------------------------------------------------------------------------------------------
//406. Queue Reconstruction by Height https://leetcode.com/problems/queue-reconstruction-by-height/
输入：二维数组，其中每个对象是一个小朋友信息，由{k, v}表示，k表示小朋友体重，v表示体重比这个小朋友轻的有几位排在这个小朋友前。
输出：小朋友排序好的二维数组队列。
例：
输入：{{6, 1}, {8, 0}, {9, 0}, {5, 0}, {4, 3}};
输出：{{5, 0}, {8, 0}, {6, 1}, {4, 3}, {9, 0}};

算法：先将输入小朋友按体重由小到大排序，然后依次插入到队列中，当前面有几个空位时，就把这个小朋友放在对应的位置。
分析：之所以可以这样排序，是因为每个小朋友在找位置时，已经没有比他轻的小朋友了，所以在这个小朋友前不用预留比他轻的小朋友位置，只需要预留比他重的小朋友位置，所以v为几，在前面留几个空位即可。

//Solution.java
package test;


import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Solution { //48ms
    private static final int INVALID_STUDENT_FLAG = -1;

    public int[][] reconstructQueue(int[][] students) {
        List<int[]> sortedStudents =
            Arrays.stream(students).sorted((e1, e2) -> {
                if (e1[0] != e2[0]) {
                    return Integer.compare(e1[0], e2[0]);
                } else {
                    return Integer.compare(e2[1], e1[1]);
                }
            }).map(e -> new int[]{e[0], e[1]}).collect(Collectors.toList());
        emptyStudents(students);

        for (int[] sortedStudent : sortedStudents) {
            int studentIndex = getStudentIndex(sortedStudent, students);
            students[studentIndex] = sortedStudent;
        }

        return students;
    }

    private int getStudentIndex(int[] sortedStudent, int[][] students) {
        int emptySeatsInFront = sortedStudent[1];
        int tmp = 0;
        for (int i = 0; i < students.length; i++) {
            if (students[i][1] == INVALID_STUDENT_FLAG) {
                if (tmp++ == emptySeatsInFront) {
                    return i;
                }
            }
        }
        return -1;
    }

    private void emptyStudents(int[][] students) {
        for (int[] student : students) {
            student[0] = INVALID_STUDENT_FLAG;
            student[1] = INVALID_STUDENT_FLAG;
        }
    }
}

//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int[][] students = {{6, 1}, {8, 0}, {9, 0}, {5, 0}, {4, 3}};
        int[][] expectedStudents = {{5, 0}, {8, 0}, {6, 1}, {4, 3}, {9, 0}};
        assertArrayEquals(expectedStudents, new Solution().reconstructQueue(students));
    }

    @Test
    public void test2() {
        int[][] students = {{7, 0}, {4, 4}, {7, 1}, {5, 0}, {6, 1}, {5, 2}};
        int[][] expectedStudents = {{5, 0}, {7, 0}, {5, 2}, {6, 1}, {4, 4}, {7, 1}};
        assertArrayEquals(expectedStudents, new Solution().reconstructQueue(students));

    }
}

//别人的优化算法，每个人在放入队列时，在他之后放的不会有比他大的了，所以可以直接按index放入，后面即使有人放在他前面，这些人也都比他矮，不会影响v参数：
step 1: sort
[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]

step 2: insert by height
[7,0]
[7,0], [7,1]
[7,0], [6,1], [7,1]
[5,0], [7,0], [6,1], [7,1]
[5,0], [7,0], [5,2], [6,1], [7,1]
[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]

def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
    people.sort(key=lambda p: (p[0], -p[1]), reverse=True)
    res = []
    [res.insert(p[1], p) for p in people]
    return res

//Solution.java
package test;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

class Solution { //36ms
    public int[][] reconstructQueue(int[][] students) {
        Arrays.sort(students, (e1, e2) -> {
            if (e1[0] != e2[0]) {
                return -Integer.compare(e1[0], e2[0]);
            } else {
                return Integer.compare(e1[1], e2[1]);
            }
        });

        List<int[]> sortedStudents = new LinkedList<>();

        for (int[] student : students) {
            sortedStudents.add(student[1], student);
        }

        return sortedStudents.toArray(new int[0][]); //sortedStudents.stream().toArray(int[][]::new)
    }
}
//------------------------------------------------------------------------------------------------
//324. Wiggle Sort II https://leetcode.com/problems/wiggle-sort-ii/
//思路：把数组排序，然后对半分，轮流从小的和大的里交插插入。另外要注意从大往小开始插入，以区分出差异值。
//Solution.java
package test;

import java.util.Arrays;

class Solution { //40ms
    public void wiggleSort(int[] nums) {
        int[] sortedNums = Arrays.stream(nums).sorted().toArray();

        int index = 0;
        int length = nums.length;
        int middleIndex = (nums.length + 1) / 2;
        for (int firstIndex = middleIndex - 1, secondIndex = length - 1; firstIndex >= 0; --firstIndex, --secondIndex) {
            nums[index++] = sortedNums[firstIndex];
            if (index < length) {
                nums[index++] = sortedNums[secondIndex];
            }
        }
    }
}

//使用流比较耗时，优化后的，改为纯数组操作：
package test;

import java.util.Arrays;

class Solution { //3ms
    public void wiggleSort(int[] nums) {
        Arrays.sort(nums);
        int length = nums.length;
        int[] tmp = new int[length];

        int index = 0;
        int middleIndex = (nums.length + 1) / 2;
        for (int firstIndex = middleIndex - 1, secondIndex = length - 1; firstIndex >= 0; --firstIndex, --secondIndex) {
            tmp[index++] = nums[firstIndex];
            if (index < length) {
                tmp[index++] = nums[secondIndex];
            }
        }

        for (int i = 0; i < length; i++) {
            nums[i] = tmp[i];
        }
    }
}

//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int[] nums = {1, 5, 1, 1, 6, 4};
        int[] expectedStudents = {1, 6, 1, 5, 1, 4};
        new Solution().wiggleSort(nums);
        assertArrayEquals(expectedStudents, nums);
    }

    @Test
    public void test2() {
        int[] nums = {1, 5, 1, 1, 6, 4, 7};
        int[] expectedStudents = {4, 7, 1, 6, 1, 5, 1};
        new Solution().wiggleSort(nums);
        assertArrayEquals(expectedStudents, nums);
    }

    @Test
    public void test3() {
        int[] nums = {4, 5, 5, 6};
        int[] expectedStudents = {5, 6, 4, 5};
        new Solution().wiggleSort(nums);
        assertArrayEquals(expectedStudents, nums);
    }
}
//------------------------------------------------------------------------------------------------
//面试官考试：调整数字为波峰波谷形式。
输入一个数组序列，调整每一位上的数字，使得奇偶位索引的对应数字满足波峰波谷的变化趋势，如下两种情况都是符合的：
1. 偶数位为波峰、奇数位为波谷：A[0] > A[1] < A[2] > A[3] < A[4] ...
2. 偶数位为波谷、奇数位为波峰：A[0] < A[1] > A[2] < A[3] > A[4] ...
求返回调整数字的最小总和。

例1：
输入：[1, 2, 3]
输出：2
分析：
把index=1的2，增加2，则[1, 4, 3]满足。
或把index=2的3，减少2，则[1, 2, 1]满足。
两种情况变化数字总和都是2。

例2：
输入：[9, 6, 1, 6, 2]
输出：4
分析：
把index=0的9，减少4，则[5, 6, 1, 6, 2]满足。

例3：
输入：[10, 6, 5, 6, 5]
输出：4
分析：
把index=2的5加2，index=4的5加2，则[10, 6, 7, 6, 7]满足。2+2=4
另一种调整情况：把index=0的10减5，则[5, 6, 5, 6, 5]满足，但是变化值为5。
两种情况相比5比4大，所以输出为4。

//1144. Decrease Elements To Make Array Zigzag https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
//LeetCode上有强调只通过减少数字来调整，不能增加数字，所以要么只减少奇数位，要么只减少偶数位即可，没有同时需要调整奇数位和调整偶数位的场景，因为同时减少奇数和偶数位肯定不是最优解。
package test;

class Solution {
    public int movesToMakeZigzag(int[] nums) {
        int decreaseOddValue = 0, decreaseEvenValue = 0, length = nums.length;
        for (int i = 0; i < length; i++) {
            if (i % 2 == 0) { //如果i是偶数，只减少偶数位的场景
                int valueToLowerThanLeft = i > 0 && nums[i] >= nums[i - 1] ? nums[i] - nums[i - 1] + 1 : 0;
                int valueToLowerThanRight = i < length - 1 && nums[i] >= nums[i + 1] ? nums[i] - nums[i + 1] + 1 : 0;
                decreaseEvenValue += Math.max(valueToLowerThanLeft, valueToLowerThanRight);
            } else { //如果i是奇数，只减少奇数位的场景
                int valueToLowerThanLeft = nums[i] >= nums[i - 1] ? nums[i] - nums[i - 1] + 1 : 0;
                int valueToLowerThanRight = i < length - 1 && nums[i] >= nums[i + 1] ? nums[i] - nums[i + 1] + 1 : 0;
                decreaseOddValue += Math.max(valueToLowerThanLeft, valueToLowerThanRight);
            }
        }

        return Math.min(decreaseOddValue, decreaseEvenValue);
    }
}
//------------------------------------------------------------------------------------------------
//997. Find the Town Judge https://leetcode.com/problems/find-the-town-judge/
//Solution.java
package test;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Solution { //66ms
    public int findJudge(int N, int[][] trust) {
        if (N == 1) {
            return 1;
        }

        List<int[]> personHaveTrustList = IntStream.rangeClosed(1, N).mapToObj(i -> new int[]{i, 0}).collect(Collectors.toList());
        Map<Integer, Set<Integer>> personTrustedIndexMap = new HashMap<>();

        init(personHaveTrustList, personTrustedIndexMap, trust);

        List<int[]> personHaveNoTrustList = personHaveTrustList.stream().filter(e -> e[1] == 0).collect(Collectors.toList());
        if (personHaveNoTrustList.size() != 1) {
            return -1;
        }

        int tmpSecretIndex = personHaveNoTrustList.get(0)[0];
        Set<Integer> trustPersonSet = personTrustedIndexMap.get(tmpSecretIndex);
        if (trustPersonSet != null && trustPersonSet.size() == N - 1) {
            return tmpSecretIndex;
        }

        return -1;
    }

    private void init(List<int[]> personHaveTrustList, Map<Integer, Set<Integer>> personTrustedIndexMap, int[][] trust) {
        for (int[] trustPair : trust) {
            int trustPersonIndex = trustPair[0];
            int trustedPersonIndex = trustPair[1];
            personHaveTrustList.get(trustPersonIndex - 1)[1] = 1;

            Set<Integer> allTrustSet = personTrustedIndexMap.get(trustedPersonIndex);
            if (allTrustSet == null) {
                allTrustSet = new HashSet<>();
                personTrustedIndexMap.put(trustedPersonIndex, allTrustSet);
            }
            allTrustSet.add(trustPersonIndex);
        }
    }
}

//别人的优化算法
package test;

class Solution { //2ms
    public int findJudge(int N, int[][] trust) {
        if (trust == null || N <= 0) {
            return -1;
        }

        if (trust.length == 0 && N == 1) {
            return 1;
        }

        int[] candidateCounts = new int[N + 1];

        for (int i = 0; i < trust.length; i++) {
            if (candidateCounts[trust[i][1]] != -1) { //只有从来没有信任过别人，才能加1个被信任计数
                candidateCounts[trust[i][1]]++;
            }

            candidateCounts[trust[i][0]] = -1; //只要信任别人，该位置值就是-1
        }

        for (int i = 0; i <= N; i++) {
            if (candidateCounts[i] == N - 1) { //看哪个编号的值是N - 1，说明被其他所有人信任
                return i;
            }
        }

        return -1;
    }
}

//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int[][] trust = {{1, 2}};
        assertEquals(2, new Solution().findJudge(2, trust));
    }

    @Test
    public void test2() {
        int[][] trust = {{1, 3}, {2, 3}};
        assertEquals(3, new Solution().findJudge(3, trust));
    }

    @Test
    public void test3() {
        int[][] trust = {{1, 3}, {2, 3}, {3, 1}};
        assertEquals(-1, new Solution().findJudge(3, trust));
    }

    @Test
    public void test4() {
        int[][] trust = {{1, 2}, {2, 3}};
        assertEquals(-1, new Solution().findJudge(3, trust));
    }

    @Test
    public void test5() {
        int[][] trust = {{1, 3}, {1, 4}, {2, 3}, {2, 4}, {4, 3}};
        assertEquals(3, new Solution().findJudge(4, trust));
    }

    @Test
    public void test6() {
        int[][] trust = {};
        assertEquals(-1, new Solution().findJudge(1, trust)); //这个用例感觉有问题
    }
}
//------------------------------------------------------------------------------------------------
//11. 盛最多水的容器 https://leetcode-cn.com/problems/container-with-most-water/
//
package test;

class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int maxArea = 0;
        while (l < r) {
            maxArea = Math.max(maxArea, Math.min(height[l], height[r]) * (r - l));
            if (height[l] < height[r]) {
                ++l;
            } else {
                --r;
            }
        }
        return maxArea;
    }
}

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int[] heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};
        assertEquals(49, new Solution().maxArea(heights));
    }
}

//------------------------------------------------------------------------------------------------
//面试官D考试Demo3：
//75. Sort Colors https://leetcode.com/problems/sort-colors/

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？
//Solution.java
package test;

import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;

class Solution { //85ms

    private int wholeIndex;

    public void sortColors(int[] nums) {
//        Arrays.sort(nums);
        
        Map<Integer, Long> numCountMap = Arrays.stream(nums).boxed().collect(Collectors.groupingBy(i -> i,
            TreeMap::new, Collectors.counting()));

        wholeIndex = 0;
        numCountMap.forEach((k, v) -> {
            for (int index = wholeIndex; index < wholeIndex + v; ++index) {
                nums[index] = k;
            }
            wholeIndex += v;
        });
    }
}

//https://blog.csdn.net/xdzhangzhenhao/article/details/81349891
// 类似三路排序的优化方案：维护好三个指针
// arr[0,zero_index]==0,arr[zero_index+1,i-1]==1,arr[two_index,n-1]==2
// 终止条件：i>=two
//Solution.java
package test;

class Solution { //1ms
    public void sortColors(int[] nums) {
        int zero_index = -1;
        int n = nums.length;
        int two_index = n;
        for (int i = 0; i < n; ) {
            if (i >= two_index) {
                return;
            }

            if (nums[i] == 1) {
                i++;
            } else if (nums[i] == 0) {
                swap(nums, ++zero_index, i);
                i++;
            } else if (nums[i] == 2) {
                swap(nums, i, --two_index);
            }
        }
    }

    private void swap(int[] nums, int l, int r) {
        if (l == r) {
            return;
        }
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}

//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int[] ints = {2, 0, 2, 1, 1, 0};
        int[] expectInts = {0, 0, 1, 1, 2, 2};
        new Solution().sortColors(ints);
        assertArrayEquals(expectInts, ints);
    }
}

//------------------------------------------------------------------------------------------------
//面试官D考试Demo1：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
//Solution.java
package test;

class Solution {
    public void moveZeroes(int[] nums) {
        int l = 0;
        for (int r = 0; r < nums.length; ++r) {
            if (nums[r] != 0) {
                swap(nums, l, r);
                ++l;
            }
        }
    }

    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l];
        nums[l] = nums[r];
        nums[r] = tmp;
    }
}

//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class SolutionTest {
    @Test
    public void test() {
        int[] ints = {0, 1, 0, 3, 12};
        int[] expectInts = {1, 3, 12, 0, 0};
        new Solution().moveZeroes(ints);
        assertArrayEquals(expectInts, ints);
    }
}
//------------------------------------------------------------------------------------------------
//441. Arranging Coins https://leetcode.com/problems/arranging-coins/submissions/
class Solution {
    public int arrangeCoins(int n) {
        return (int) Math.floor((-1 + Math.sqrt(1 + 8 * (long) n)) / 2);
    }
}
//------------------------------------------------------------------------------------------------
//632. 最小区间 https://leetcode-cn.com/problems/smallest-range/submissions/
你有?k?个升序排列的整数数组。找到一个最小区间，使得?k?个列表中的每个列表至少有一个数包含在其中。
我们定义如果?b-a < d-c?或者在?b-a == d-c?时?a < c，则区间 [a,b] 比 [c,d] 小。
//Solution.java
package test;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        List<int[]> arr = sort(nums);

        int k = nums.size();
        int[] cnt = new int[k];
        int len = Integer.MAX_VALUE;
        int[] ans = new int[2];
        int count = 0;

        for (int r = 0, l = 0; r < arr.size(); r++) {
            if (cnt[arr.get(r)[1]]++ == 0) {
                ++count;
            }

            while (cnt[arr.get(l)[1]] > 1) {
                --cnt[arr.get(l)[1]];
                ++l;
            }

            if (count == k) {
                int tmpLen = arr.get(r)[0] - arr.get(l)[0];
                if (tmpLen < len) {
                    len = tmpLen;
                    ans[0] = arr.get(l)[0];
                    ans[1] = arr.get(r)[0];
                }
            }
        }
        return ans;
    }

    private List<int[]> sort(List<List<Integer>> nums) {
        List<int[]> arrIndexList = new ArrayList<>();
        for (int i = 0; i < nums.size(); i++) {
            final int index = i;
            nums.get(i).stream().forEach(e -> arrIndexList.add(new int[]{e, index}));
        }
        arrIndexList.sort(Comparator.comparingInt(o -> o[0]));
        return arrIndexList;
    }
}

//SolutionTest.java
package test;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class SolutionTest {
    @Test
    public void test() {
        List<Integer> integers1 = Arrays.asList(4, 10, 15, 24, 26);
        List<Integer> integers2 = Arrays.asList(0, 9, 12, 20);
        List<Integer> integers3 = Arrays.asList(5, 18, 22, 30);
        List<List<Integer>> nums = Arrays.asList(integers1, integers2, integers3);

        int[] expectInts = {20, 24};
        assertArrayEquals(expectInts, new Solution().smallestRange(nums));
    }

    @Test
    public void test1() {
        List<Integer> integers1 = Arrays.asList(1, 2, 3);
        List<List<Integer>> nums = Arrays.asList(integers1, integers1, integers1);

        int[] expectInts = {1, 1};
        assertArrayEquals(expectInts, new Solution().smallestRange(nums));
    }
}

//解析：先将所有数字排序，并记录所在列表编号0、1、2，之后通过l和r两个滑窗索引，判断是否在滑窗范围内包括所有列表编号，每次当r右移后，如果l所在的位置有两个同列表的数字，则将l开始右移，直到l所在位置只有一个该列表元素，再判断len，直到遍历完r。
arr = {ArrayList@1023}  size = 13
 0 = {int[2]@1026} 
  0 = 0
  1 = 1
 1 = {int[2]@1029} 
  0 = 4
  1 = 0
 2 = {int[2]@1027} 
  0 = 5
  1 = 2
 3 = {int[2]@1030} 
  0 = 9
  1 = 1
 4 = {int[2]@1031} 
  0 = 10
  1 = 0
 5 = {int[2]@1032} 
  0 = 12
  1 = 1
 6 = {int[2]@1033} 
  0 = 15
  1 = 0
 7 = {int[2]@1034} 
  0 = 18
  1 = 2
 8 = {int[2]@1035} 
  0 = 20
  1 = 1
 9 = {int[2]@1036} 
  0 = 22
  1 = 2
 10 = {int[2]@1037} 
  0 = 24
  1 = 0
 11 = {int[2]@1038} 
  0 = 26
  1 = 0
 12 = {int[2]@1039} 
  0 = 30
  1 = 2

//------------------------------------------------------------------------------------------------
//831. 隐藏个人信息 https://leetcode-cn.com/problems/masking-personal-information/
//Solution.java
class Solution {
    public String maskPII(String S) {
        if(S.contains(".")){
            return maskEmail(S);
        }else{
            return maskPhone(S);
        }
    }
    public String maskEmail(String str){   
        str = str.toLowerCase();
        StringBuilder sb = new StringBuilder();
        String[] sp = str.split("@");
        sb.append(sp[0].charAt(0)+"*****"+sp[0].charAt(sp[0].length() - 1));
        sb.append("@"+sp[1]);
        return sb.toString();
    }
    public String maskPhone(String str){   
        StringBuilder sb = new StringBuilder();
        for(char ch : str.toCharArray()){
            if(Character.isDigit(ch))
                 sb.append(ch);
        }
        StringBuilder ans = new StringBuilder();
        if(sb.length() == 10){
            ans.append("***-***-");
        }else if(sb.length() == 11){
            ans.append("+*-***-***-"); 
        }else if(sb.length() == 12){
            ans.append("+**-***-***-"); 
        }else if(sb.length() == 13){
            ans.append("+***-***-***-");
        }
         ans.append(sb.substring(sb.length() - 4));
        return ans.toString();
    }
}
//------------------------------------------------------------------------------------------------
//516. 最长回文子序列 https://leetcode-cn.com/problems/longest-palindromic-subsequence/
状态：
f[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。

转移方程：
如果 s 的第 i 个字符和第 j 个字符相同的话
f[i][j] = f[i + 1][j - 1] + 2

如果 s 的第 i 个字符和第 j 个字符不同的话
f[i][j] = max(f[i + 1][j], f[i][j - 1])

然后注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历，这样可以保证每个子问题都已经算好了。

初始化：
f[i][i] = 1 单个字符的最长回文序列是 1

结果：
f[0][n - 1]

                b    b    b    a    b
        下标j   0    1    2    3    4
 下标i
    0           1    2    3    3    4
    1           0    1    2    2    3
    2           0    0    1    1    3
    3           0    0    0    1    1
    4           0    0    0    0    1

//DynamicSolution.java
package test;

public class DynamicSolution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            f[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
}

//DynamicSolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class DynamicSolutionTest {
    @Test
    public void test() {
        assertEquals(4, new DynamicSolution().longestPalindromeSubseq("bbbab"));
    }
}

//另一个解法：
原题相当于，原字符串s与倒置后所得字符串_s，计算两个字符串的最长公共子序列。
Tip:必须用dp[1...n1][1...n2]来存储公共子序列长度，边界默认为0，否则的话在i-1和j-1关于0的边界处处理起来略复杂。
同 5、两个字符串最大公共子序列
//------------------------------------------------------------------------------------------------
//动态规划学习 https://blog.csdn.net/zw6161080123/article/details/80639932
3、数组最大连续子序列和
如arr[] = {6,-1,3,-4,-6,9,2,-2,5}的最大连续子序列和为14。即为：9,2,-2,5
创建一个数组a，长度为原数组长度，不同位置数字a[i]代表0...i上最大连续子序列和，a[0]=arr[0]设置一个最大值max，初始值为数组中的第一个数字。当进来一个新的数字arr[i+1]时，判断到他前面数字子序列和a[i]+arr[i+1]跟arr[i+1]哪个大，前者大就保留前者，后者大就说明前面连续数字加起来都不如后者一个新进来的数字大，前面数字就可以舍弃，从arr[i+1]开始，每次比较完都跟max比较一下，最后的max就是最大值。
//DynamicSolution.java
package test;

public class DynamicSolution {
    public static int MaxContinueArraySum(int a[]) {
        int n = a.length;
        int max = a[0];
        int sum = a[0];
        for (int i = 1; i < n; i++) {
            sum = Math.max(sum + a[i], a[i]);
            if (sum >= max) {
                max = sum;
            }
        }
        return max;
    }
}

//DynamicSolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class DynamicSolutionTest {
    @Test
    public void test() {
        int[] arr = {6, -1, 3, -4, -6, 9, 2, -2, 5};
        assertEquals(14, DynamicSolution.MaxContinueArraySum(arr));
    }
}


4、数字塔从上到下所有路径中和最大的路径
数字塔是第i行有i个数字组成，从上往下每个数字只能走到他正下方数字或者正右方数字，求数字塔从上到下所有路径中和最大的路径，如有下数字塔
3
1    5
8    4    3
2    6    7    9
6    2    3    5    1
最大路径是3-5-3-9-5，和为25。我们可以分别从从上往下看跟从下往上看两种动态规划的方式去解这个题
从上往下看：当从上往下看时，每进来新的一行，新的一行每个元素只能选择他正上方或者左左方的元素，也就是说，第一个元素只能连他上方的元素，最后一个元素只能连他左上方的元素，其他元素可以有两种选择，所以需要选择加起来更大的那一个数字，并把这个位置上的数字改成相应的路径值，具体过程如下图所示
3                            3                            3                            3
1    5                      4    8                      4    8                      4    8
8    4    3                8    4    3                12   12  11             12   12   11  
2    6    7    9          2    6    7    9           2    6    7    9         14   18   19   20
6    2    3    5    1    6    2    3    5    1     6    2    3    5    1    20   20   22   25   21
所以最大值就是最底层的最大值也就是25。
具体运算过程就是，建立一个n*n的二维数组dp[][]，n是数字塔最后一行的数字个数，二维数组每一行数字跟数字塔每一行数字个数一样，保存的值是从上方到这一个位置最大路径的值，填入边界值dp[0][0]=3，每一行除了第一个值跟最后一个值，其他的值选择上方或者左上方更大的值与这个位置上的值相加得来的值，即dp[i][j]=Math.max(dp[i-1][j-1], dp[i-1][j]) + n[i][j]

//DynamicSolution.java
package test;

public class DynamicSolution {
    public static int minNumberInRotateArray(int n[][]) {
        int max = 0;
        int dp[][] = new int[n.length][n.length];
        dp[0][0] = n[0][0];
        for (int i = 1; i < n.length; i++) {
            for (int j = 0; j <= i; j++) {
                if (j == 0) {
                    //如果是第一列，直接跟他上面数字相加
                    dp[i][j] = dp[i - 1][j] + n[i][j];
                } else {
                    //如果不是第一列，比较他上面跟上面左面数字谁大，谁大就跟谁相加，放到这个位置
                    dp[i][j] = Math.max(dp[i - 1][j - 1], dp[i - 1][j]) + n[i][j];
                }
                max = Math.max(dp[i][j], max);
            }
        }
        return max;
    }
}

//DynamicSolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class DynamicSolutionTest {
    @Test
    public void test() {
        int[][] arr = {
            {3},
            {1, 5},
            {8, 4, 3},
            {2, 6, 7, 9},
            {6, 2, 3, 5, 1}
        };
        assertEquals(25, DynamicSolution.minNumberInRotateArray(arr));
    }
}

优化：动态规划中每一个需要创建一个二维数组的解法，都可以换成只创建一个一维数组的滚动数组解法，依据的规则是一般二维数组中存放的是所有的结果，但是一般我们需要的结果实在二维数组的最后一行的某个值，前面几行的值都是为了得到最后一行的值而需要的，所以可以开始就创建跟二维数组最后一行一样大的一维数组，每次存放某一行的值，下一次根据这一行的值算出下一行的值，在存入这个数组，也就是把这个数组滚动了，最后数组存储的结果就是原二维数组中最后一行的值。

拿到本题来说，开始创建一个一维数组dp[n]，初始值只有dp[0]=3，新进来一行时，仍然遵循dp[i][j]=Math.max(dp[i-1][j-1], dp[i-1][j]) + n[i][j]，现在为求dp[j]，所以现在dp[i-1][j]其实就是数组中这个位置本来的元素即dp[j]，而dp[i-1][j-1]其实就是数组中上一个元素dp[j-1]，也就是说dp[j]=Math.max(dp[j], dp[j-1])+n[i][j]
//DynamicSolution.java
package test;

public class DynamicSolution {

    public static int minNumberInRotateArray2(int n[][]) {
        int[] temp = new int[n.length];
        temp[0] = n[0][0];
        for (int i = 1; i < n.length; i++) {
            for (int j = i; j >= 0; j--) {
                if (j == i) {
                    temp[i] = temp[i - 1] + n[i][j];
                } else if (j == 0) {
                    temp[0] += n[i][0];
                } else {
                    temp[j] = Math.max(temp[j], temp[j - 1]) + n[i][j];
                }
            }
        }
        int max = temp[0];
        //从temp数组里取出最大的值
        for (int i = 1; i < temp.length; i++) {
            if (temp[i] > max) {
                max = temp[i];
            }
        }
        return max;
    }
}

5、两个字符串最大公共子序列
比如字符串1：BDCABA；字符串2：ABCBDAB，则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA
具体思想：设 X=(x1,x2,.....xn)和 Y={y1,y2,.....ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)，如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)就好，LCS(X,Y)=LCS(Xn-1，Ym-1)+1；如果xn != ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)。

动态规划解法：先创建一个解空间即数组，因为给定的是两个字符串即两个一维数组存储的数据，所以要创建一个二维数组，设字符串X有n个值，字符串Y有m个值，需要创建一个m+1*n+1的二维数组，二维数组每个位置（i，j）代表当长度为i的X子串与长度为j的Y的子串他们的最长公共子串，之所以要多创建一个是为了将边界值填入进去，边界值就是第一行跟第一列，指X长度为0或者Y长度为0时，自然需要填0，其他位置填数字时，当这两个位置数字相同，dp[i][j] = dp[i-1][j-1]+1；当这两个位置数字不相同时，dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])。最后二维数组最右下角的值就是最大子串。

        下标j  0    1    2    3    4    5    6    7
下标i      
   0           0    0    0    0    0    0    0    0
   1           0    0    1    1    1    1    1    1
   2           0    0    1    1    1    2    2    2
   3           0    0    1    2    2    2    2    2
   4           0    1    1    2    2    2    3    3
   5           0    1    2    2    3    3    3    4
   6           0    1    2    2    3    3    4    4

//DynamicSolution.java
package test;

public class DynamicSolution {
    public static int maxTwoArraySameOrderMethod(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        /*
         * 定义一个二维数组保存公共子序列长度
         * dp[i][j]表示字符串1从头开始长度是i，字符串2从头开始长度是j，这两个字符串的最长公共子序列的长度
         * 设置数组行列比他们长度大一往二维数组中填写数字时，每个位置的数字跟他上方或者左方或者左上方数字有关系，这样处理边界数字时不用处理这种情况，方便接下来的循环
         */
        int dp[][] = new int[m + 1][n + 1];
        /*
         * 初始化第一行第一列
         * dp[0,j]表示啥？表示字符串1的长度是0，字符串2的长度是j，这两个字符串的最长公共子序列的长度是0，因为，字符串1 根本就没有嘛
         */
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= n; i++) {
            dp[0][i] = 0;
        }
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                /*
                 * 如果当c[i][j]时，字符串1从头开始长度是i，字符串2从头开始长度是j时他们最后一个字符相同
                 * 就同时把他们向前移动一位，找c[i-1][j-1]时长度最大的再加一
                 * 表现在二维数组中就是c[i][j]左上方的点
                 */
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    /*
                     * 如果当c[i][j]时，他们最后一个字符不相同
                     * 要将str1往前移动一位的c[i-1][j]的lcs长度，或者将str2往前移动一位的c[i][j-1]的lcs长度
                     * 哪个长，将它赋给c[i][j]
                     * 表现在二维数组中就是c[i][j]上方的点或者左方的点
                     */
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }
        return dp[m][n];
    }
}

//DynamicSolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class DynamicSolutionTest {
    @Test
    public void test() {
        assertEquals(4, DynamicSolution.maxTwoArraySameOrderMethod("BDCABA", "ABCBDAB"));
    }
}

6、背包问题
在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数），求背包能够容纳的最大价值。

像这种固定数值的组合问题，比如这个问题的W总容量，跟下个实例零钱问题的总钱数，都是适合用动态规划来解决的问题，对于这样的问题，动态规划的解法就是：创建一个二维数组，横坐标是从1开始到W，纵坐标是组成W的各种元素，本题中就是指W1，W2……Wn，数组中每个位置（i，j）的数字就是当组成元素只有W1，W2……Wi，背包可放容量为j时的结果，本题中就是容纳的最大价值。所以很容易分析出，当（i，j）时，如果Wi能放的下，空间减小，但是会增加Pi的价值，如果Wi不能放的下，空间不变，是（i-1，j）的价值，取其中最大值就好了，即状态转化方程为能放的下，dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]]+p[i])；放不下，dp[i][j] = dp[i-1][j]；

dp表：
      容量j 0    1    2    3    4     5     6     7     8     9     10
物品i           
    0       0    0    0    0    0     0     0     0     0     0     0
    1       0    0    3    3    3     3     3     3     3     3     3
    2       0    0    3    3    3     3     3     5     5     5     5
    3       0    0    3    7    7     10    10    10    10    10    12
    4       0    0    3    7    7     10    10    10    10    10    12
    5       0    4    4    7    11    11    14    14    14    14    14

//Solution.java
package test;

class Solution {
    public static int PackageHelper(int n, int[] weights, int[] prices, int volume) {
        //设置一个二维数组，横坐标代表从第一个物品开始放到第几个物品，纵坐标代表背包总容量，dp代表最大价值
        int[][] dp = new int[n + 1][volume + 1];
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j <= volume; j++) {
                if (j >= weights[i - 1]) {
                    /*
                     * 当能放得下这个物品时，放下这个物品，价值增加，但是空间减小，最大价值是dp[i-1][j-weights[i]]+prices[i]。其中dp[i-1][j-weights[i]]：表示为了腾出容量放第i个物品，之前的i-1个物品在占用空间j-weights[i]时的最大价值。
                     * 当不放这个物品时，空间大，物品还是到i-1，最大价值是dp[i-1][j]
                     * 比较这两个大小，取最大的，就是dp[i][j]
                     */
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + prices[i - 1]); //这里每一步计算出来的包括当前物品在内的所有物品在总容量为j时的最大价值
                } else {
                    //如果放不下，就是放上一个物品时的dp
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][volume];
    }
}

优化：滚动数组，只创建一个一维数组，长度为从1到W，初始值都是0，能装得下i时，dp[j] = Math.max(dp[j], dp[j-w[i]]+p[i])；装不下时，dp[j] = dp[j];
//Solution.java
package test;

class Solution {
    public static int PackageHelper(int n, int[] weights, int[] prices, int volume) {
        //设置一个二维数组，横坐标代表从第一个物品开始放到第几个物品，纵坐标代表背包还有多少容量，dp代表最大价值
        int[] dp = new int[volume + 1];
        for (int i = 1; i < n + 1; i++) {
            for (int j = volume; j > 0; j--) {
                if (j >= weights[i - 1]) {
                    dp[j] = Math.max(dp[j], dp[j - weights[i - 1]] + prices[i - 1]);
                } else {
                    dp[j] = dp[j];
                }
            }
        }
        return dp[volume];
    }
}
//SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    @Test
    public void test1() {
        int n = 5;
        int[] weights = {2, 5, 3, 6, 1};
        int[] prices = {3, 2, 7, 1, 4};
        int volume = 10;
        assertEquals(14, Solution.PackageHelper(n, weights, prices, volume));
    }
}

动态规划和分治区别：

动态规划算法：它通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。

分治法：若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。

总结：

不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。
//------------------------------------------------------------------------------------------------
//299. Bulls and Cows https://leetcode.com/problems/bulls-and-cows/
package test;

import java.util.Map;
import java.util.stream.Collectors;

class Solution {
    public String getHint(String secret, String guess) {
        int a = 0;
        for (int i = 0; i < secret.length(); i++) {
            if (secret.charAt(i) == guess.charAt(i)) {
                ++a;
            }
        }

        int b = 0;
        Map<Character, Long> characterCountMapSecret =
            secret.chars().mapToObj(c -> (char) c).collect(Collectors.groupingBy(c -> c, Collectors.counting()));
        Map<Character, Long> characterCountMapGuess =
            guess.chars().mapToObj(c -> (char) c).collect(Collectors.groupingBy(c -> c, Collectors.counting()));

        for (Map.Entry<Character, Long> entry : characterCountMapSecret.entrySet()) {
            Character numberSecret = entry.getKey();
            Long numberSecretCount = entry.getValue();
            Long numberGuessCount = characterCountMapGuess.getOrDefault(numberSecret, 0L);
            b += Math.min(numberSecretCount, numberGuessCount);
        }

        return String.format("%dA%dB", a, b - a);
    }
}

//------------------------------------------------------------------------------------------------
// 955. Delete Columns to Make Sorted II https://leetcode.com/problems/delete-columns-to-make-sorted-ii/
// Solution.java
package test;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

enum ColumnOrderType {
    ASCEND, DESCEND, EQUAL_OR_ASCEND
}

class Solution { // 58ms
    private static final char INVALID_CHAR = '-';

    public int minDeletionSize(String[] A) {
        int deleteColumnNum = 0;
        List<Integer> lastOrders = Stream.generate(() -> 0).limit(A.length).collect(Collectors.toList());

        for (int columnIndex = 0; columnIndex < A[0].length(); columnIndex++) {
            ColumnOrderType columnOrderType = getColumnOrderType(A, columnIndex, lastOrders);
            if (columnOrderType == ColumnOrderType.ASCEND) {
                return deleteColumnNum;
            } else if (columnOrderType == ColumnOrderType.DESCEND) {
                ++deleteColumnNum;
            }
        }

        return deleteColumnNum;
    }

    private ColumnOrderType getColumnOrderType(String[] strings, int columnIndex, List<Integer> lastOrders) {
        char lastChar = INVALID_CHAR;
        ColumnOrderType columnOrderType = ColumnOrderType.ASCEND;
        List<Integer> currentOrders = new ArrayList<>();
        int orderLevel = 1;

        for (int i = 0; i < strings.length; i++) {
            char currentChar = strings[i].charAt(columnIndex);
            if (lastChar == INVALID_CHAR) {
                lastChar = currentChar;
                currentOrders.add(orderLevel);
                continue;
            }

            if (lastChar > currentChar) {
                // 如果之前的序列是相等的字典序，则该列是升序，需要删除
                if (lastOrders.get(i - 1) == lastOrders.get(i)) {
                    return ColumnOrderType.DESCEND;
                } else {
                    // 如果之前的序列满足字典序，则当前列字符无影响
                    ++orderLevel;
                }
            } else if (lastChar == currentChar) {
                // 如果之前的序列是相等的字典序，则orderLevel仍不变
                if (lastOrders.get(i - 1) == lastOrders.get(i)) {
                    columnOrderType = ColumnOrderType.EQUAL_OR_ASCEND;
                } else {
                    // 如果之前的序列满足字典序
                    ++orderLevel;
                }
            } else { // lastChar < currentChar
                // 无论之前序列什么字典序，当前都满足了字典序
                ++orderLevel;
            }

            lastChar = currentChar;
            currentOrders.add(orderLevel);
        }

        lastOrders.clear();
        lastOrders.addAll(currentOrders);
        return columnOrderType;
    }
}

// SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private static final Solution SOLUTION = new Solution();

    @Test
    public void test1() {
        String[] strings = {"ca", "bb", "ac"};
        assertEquals(SOLUTION.minDeletionSize(strings), 1);
    }

    @Test
    public void test2() {
        String[] strings = {"xc", "yb", "za"};
        assertEquals(SOLUTION.minDeletionSize(strings), 0);
    }

    @Test
    public void test3() {
        String[] strings = {"zyx", "wvu", "tsr"};
        assertEquals(SOLUTION.minDeletionSize(strings), 3);
    }

    @Test
    public void test4() {
        String[] strings = {"abx", "agz", "bgc", "bfc"};
        assertEquals(1, SOLUTION.minDeletionSize(strings));
    }

    @Test
    public void test5() {
        String[] strings = {"xga","xfb","yfa"};
        assertEquals(1, SOLUTION.minDeletionSize(strings));
    }
}

//用字符串比较
package test;

import java.util.Arrays;


enum ColumnOrderType {
    ASCEND, DESCEND, EQUAL_OR_ASCEND
}

class Solution { // 5ms
    public int minDeletionSize(String[] A) {
        int N = A.length;
        int W = A[0].length();
        int ans = 0;

        // cur : all rows we have written
        // For example, with A = ["abc","def","ghi"] we might have
        // cur = ["ab", "de", "gh"].
        String[] cur = new String[N];
        for (int j = 0; j < W; ++j) {
            // cur2 : What we potentially can write, including the
            //        newest column col = [A[i][j] for i]
            // Eg. if cur = ["ab","de","gh"] and col = ("c","f","i"),
            // then cur2 = ["abc","def","ghi"].
            String[] cur2 = Arrays.copyOf(cur, N);
            for (int i = 0; i < N; ++i)
                cur2[i] += A[i].charAt(j);

            ColumnOrderType columnOrderType = isSorted(cur2);
            if (columnOrderType == ColumnOrderType.ASCEND) {
                return ans;
            } else if (columnOrderType == ColumnOrderType.EQUAL_OR_ASCEND) {
                cur = cur2;
            } else {
                ans++;
            }
        }

        return ans;
    }

    public ColumnOrderType isSorted(String[] A) {
        ColumnOrderType columnOrderType = ColumnOrderType.ASCEND;
        for (int i = 0; i < A.length - 1; ++i) {
            int ret = A[i].compareTo(A[i + 1]);
            if (ret > 0) {
                return ColumnOrderType.DESCEND;
            } else if (ret == 0) {
                columnOrderType = ColumnOrderType.EQUAL_OR_ASCEND;
            }
        }
        return columnOrderType;
    }
}

//使用StringBuilder慢了
package test;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;


enum ColumnOrderType {
    ASCEND, DESCEND, EQUAL_OR_ASCEND
}

class Solution { //48ms
    public int minDeletionSize(String[] A) {
        int N = A.length;
        int W = A[0].length();
        int ans = 0;

        // cur : all rows we have written
        // For example, with A = ["abc","def","ghi"] we might have
        // cur = ["ab", "de", "gh"].

        List<StringBuilder> cur = Stream.generate(() -> new StringBuilder()).limit(N).collect(Collectors.toList());

        for (int j = 0; j < W; ++j) {
            // cur2 : What we potentially can write, including the
            //        newest column col = [A[i][j] for i]
            // Eg. if cur = ["ab","de","gh"] and col = ("c","f","i"),
            // then cur2 = ["abc","def","ghi"].
            List<StringBuilder> cur2 = cur.stream().map(e -> new StringBuilder(e.toString())).collect(Collectors.toList());
            for (int i = 0; i < N; ++i)
                cur2.get(i).append(A[i].charAt(j));

            ColumnOrderType columnOrderType = isSorted(cur2);
            if (columnOrderType == ColumnOrderType.ASCEND) {
                return ans;
            } else if (columnOrderType == ColumnOrderType.EQUAL_OR_ASCEND) {
                cur = cur2;
            } else {
                ans++;
            }
        }

        return ans;
    }

    public ColumnOrderType isSorted(List<StringBuilder> A) {
        ColumnOrderType columnOrderType = ColumnOrderType.ASCEND;
        for (int i = 0; i < A.size() - 1; ++i) {
            int ret = A.get(i).toString().compareTo(A.get(i + 1).toString());
            if (ret > 0) {
                return ColumnOrderType.DESCEND;
            } else if (ret == 0) {
                columnOrderType = ColumnOrderType.EQUAL_OR_ASCEND;
            }
        }
        return columnOrderType;
    }
}

//cuts表示之前列是否已经区分出字典序了，如果已经区分出来，则当前列字母就不需要再比较了
package test;

class Solution { //1ms
    public int minDeletionSize(String[] A) {
        int N = A.length;
        int W = A[0].length();
        // cuts[j] is true : we don't need to check any new A[i][j] <= A[i][j+1]
        boolean[] cuts = new boolean[N - 1];

        int ans = 0;
        search:
        for (int j = 0; j < W; ++j) {
            // Evaluate whether we can keep this column
            for (int i = 0; i < N - 1; ++i)
                if (!cuts[i] && A[i].charAt(j) > A[i + 1].charAt(j)) {
                    // Can't keep the column - delete and continue
                    ans++;
                    continue search;
                }

            // Update 'cuts' information
            for (int i = 0; i < N - 1; ++i)
                if (A[i].charAt(j) < A[i + 1].charAt(j))
                    cuts[i] = true;
        }

        return ans;
    }
}

//------------------------------------------------------------------------------------------------
//技能鉴定1级：求计算机配件整体最大质量因子
//Solution.java
package test;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

class Solution {

    private static final int INVALID_INPUT = -1;
    private static final int NOT_ENOUGH_BUDGET = -2;

    private final Map<String, PartsMgr> partsNameMgrMap = new LinkedHashMap<>();
    private int budget;
    private int currentBudget;
    private int currentQualityFactor = Integer.MAX_VALUE;
    private final List<PartInfo> currentPartInfos = new ArrayList<>();

    /**
     * @param inputStr 电脑配件输入字符串
     * @return 最大整机质量因子
     */
    public int getMaxQualityFactor(String inputStr) {
        if (!init(inputStr)) {
            return INVALID_INPUT;
        }

        if (!getMinFactor()) {
            return NOT_ENOUGH_BUDGET;
        }

        while (currentBudget <= budget) {
            if (!updateQualityFactor()) {
                break;
            }
        }
        return currentQualityFactor;
    }

    private boolean updateQualityFactor() {
        int tmpCurrentQualityFactor = Integer.MAX_VALUE;
        for (PartInfo currentPartInfo : currentPartInfos) {
            int tmpPartInfoQualityFactor = currentPartInfo.getQualityFactor();
            if (tmpPartInfoQualityFactor != currentQualityFactor) {
                tmpCurrentQualityFactor = Math.min(tmpPartInfoQualityFactor, tmpCurrentQualityFactor);
                continue;
            }

            // 取下一级质量因子配件，如果没有，则整体质量因子无法再提升
            PartInfo nextQualityFactorPartInfo =
                partsNameMgrMap.get(currentPartInfo.getName()).getNextQualityFactorPartInfo(currentPartInfo);
            if (nextQualityFactorPartInfo == null) {
                return false;
            }

            tmpCurrentQualityFactor = Math.min(nextQualityFactorPartInfo.getQualityFactor(), tmpCurrentQualityFactor);
            // 如果其中一种配件的下一个质量因子超预算，则整体质量因子无法再提升
            currentBudget += nextQualityFactorPartInfo.getPrice() - currentPartInfo.getPrice();
            if (currentBudget > budget) {
                return false;
            }

            currentPartInfo.update(nextQualityFactorPartInfo);
        }
        currentQualityFactor = tmpCurrentQualityFactor;
        return true;
    }

    private boolean getMinFactor() {
        partsNameMgrMap.forEach(this::calculatePartMinPrice);
        return currentBudget <= budget;
    }

    private void calculatePartMinPrice(String partName, PartsMgr partsMgr) {
        PartInfo cheapestPartInfo = partsMgr.getCheapestPartInfo();
        currentBudget += cheapestPartInfo.getPrice();
        currentQualityFactor = Math.min(currentQualityFactor, cheapestPartInfo.getQualityFactor());
        currentPartInfos.add(cheapestPartInfo.clone());
    }

    private boolean init(String inputStr) {
        try {
            String[] inputStrs = inputStr.split(":");
            if (inputStrs.length != 2) {
                return false;
            }

            String[] budgetAndPartsNumStrs = inputStrs[0].split(",");
            if (budgetAndPartsNumStrs.length != 2) {
                return false;
            }

            budget = Integer.parseInt(budgetAndPartsNumStrs[0]);
            int partsNum = Integer.parseInt(budgetAndPartsNumStrs[1]);

            String[] partsStrs = inputStrs[1].split(";");
            if (partsStrs.length != partsNum) {
                return false;
            }

            for (String partStr : partsStrs) {
                String[] partInfoStrs = partStr.substring(1, partStr.length() - 1).split(",");
                if (partInfoStrs.length != 3) {
                    return false;
                }

                addToPartsMap(partInfoStrs);
            }
            partsNameMgrMap.forEach((key, value) -> value.finishAddingPartInfo());

            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private void addToPartsMap(String[] partInfoStrs) {
        String partName = partInfoStrs[0];
        int partPrice = Integer.parseInt(partInfoStrs[1]);
        int partQualityFactor = Integer.parseInt(partInfoStrs[2]);
        PartInfo partInfo = new PartInfo(partName, partPrice, partQualityFactor);
        if (partsNameMgrMap.containsKey(partName)) {
            partsNameMgrMap.get(partName).addPartInfo(partInfo);
        } else {
            PartsMgr partsMgr = new PartsMgr(partName);
            partsMgr.addPartInfo(partInfo);
            partsNameMgrMap.put(partName, partsMgr);
        }
    }
}

//PartInfo.java
package test;

import java.util.Objects;

public class PartInfo {
    private final String name;
    private int price;
    private int qualityFactor;

    public PartInfo(String name, int price, int qualityFactor) {
        this.name = name;
        this.price = price;
        this.qualityFactor = qualityFactor;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }

    public int getQualityFactor() {
        return qualityFactor;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PartInfo partInfo = (PartInfo) o;
        return price == partInfo.price &&
            qualityFactor == partInfo.qualityFactor &&
            Objects.equals(name, partInfo.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, price, qualityFactor);
    }

    @Override
    public String toString() {
        return "PartInfo{" +
            "name='" + name + '\'' +
            ", price=" + price +
            ", qualityFactor=" + qualityFactor +
            '}';
    }

    public PartInfo clone() {
        return new PartInfo(this.name, this.price, this.qualityFactor);
    }

    public void update(PartInfo partInfo) {
        price = partInfo.price;
        qualityFactor = partInfo.qualityFactor;
    }
}

//PartsMgr.java
package test;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class PartsMgr {
    private final String partName;

    private final Map<Integer, PartInfo> partQualityFactorInfoMap = new TreeMap<>();
    private final Map<Integer, Integer> qualityFactorIndexMap = new HashMap<>();
    private final List<PartInfo> partInfos = new ArrayList<>();
    private int index = 0;

    public PartsMgr(String partName) {
        this.partName = partName;
    }

    public void addPartInfo(PartInfo partInfo) {
        partQualityFactorInfoMap.merge(partInfo.getQualityFactor(), partInfo,
            (oldPartInfo, newPartInfo) -> newPartInfo.getPrice() < oldPartInfo.getPrice() ? newPartInfo : oldPartInfo);
    }

    public PartInfo getCheapestPartInfo() {
        return partInfos.stream()
            .min(Comparator.comparing(PartInfo::getPrice))
            .orElseThrow(() -> new RuntimeException("PartsMgr::getCheapestPartInfo no cheapestPartInfo"));
    }

    public void finishAddingPartInfo() {
        partQualityFactorInfoMap.forEach(this::initQualityFactorIndexMap);
    }

    private void initQualityFactorIndexMap(Integer qualityFactor, PartInfo partInfo) {
        qualityFactorIndexMap.put(qualityFactor, index++);
        partInfos.add(partInfo);
    }

    public PartInfo getNextQualityFactorPartInfo(PartInfo partInfo) {
        int partInfoIndex = qualityFactorIndexMap.get(partInfo.getQualityFactor());
        if (++partInfoIndex >= this.index) {
            return null;
        }

        return partInfos.get(partInfoIndex);
    }
}

//SolutionTest.java
package test;

import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private static Solution SOLUTION;

    @Before
    public void before() {
        SOLUTION = new Solution();
    }

    @Test
    public void test_quality_factor_1() {
        String inputStr = "2000,6:(CPU,500,2);(CPU,700,5);(MEM,200,3);(MB,800,7);(POW,400,4);(POW,600,7)";
        assertEquals(2, SOLUTION.getMaxQualityFactor(inputStr));
    }

    @Test
    public void test_quality_factor_2() {
        String inputStr = "9000,16:" +
            "(CPU,2000,7);(CPU,3000,8);" +
            "(MB,1000,8);(MB,800,6);" +
            "(CASE,600,6);(CASE,400,4);" +
            "(MEM,600,5);(MEM,900,7);" +
            "(DC,2000,6);(DC,3000,7);" +
            "(SPK,200,4);(SPK,500,6);" +
            "(KM,500,7);(KM,200,4);" +
            "(MON,1000,5);(MON,1300,7)";
        assertEquals(6, SOLUTION.getMaxQualityFactor(inputStr));
    }

    @Test
    public void test_expect_not_enough_budget() {
        String inputStr = "100,6:(CPU,500,2);(CPU,700,5);(MEM,200,3);(MB,800,7);(POW,400,4);(POW,600,7)";
        assertEquals(-2, SOLUTION.getMaxQualityFactor(inputStr));
    }

    @Test
    public void test_expect_invalid_input() {
        String inputStr = "100,6:(CPU,500,);(CPU,700,5);(MEM,200,3);(MB,800,7);(POW,400,4);(POW,600,7)";
        assertEquals(-1, SOLUTION.getMaxQualityFactor(inputStr));
    }
}
//------------------------------------------------------------------------------------------------
//技能鉴定1级：n位显示的计算器，计算起始数字k的平方，如果溢出则显示前n位，求最大显示值
//Solution.java
package test;

import java.util.LinkedHashSet;
import java.util.Set;

class Solution {
    /**
     * @param n 计算器位数
     * @param k 起始数字
     * @return 计算器最大显示数字
     */
    int maxSquareResult(int n, int k) {
        int max = -1;
        if (!checkInputValid(n, k)) {
            return max;
        }

        Set<Integer> squareResults = new LinkedHashSet<>();
        int tmpSquareResult = k;
        while (!squareResults.contains(tmpSquareResult)) {
            squareResults.add(tmpSquareResult);
            tmpSquareResult = getSquareResult(n, tmpSquareResult);
            if (tmpSquareResult > max) {
                max = tmpSquareResult;
            }
        }
        System.out.println(String.format("Process = %s, \nlength = %d\n", squareResults, squareResults.size()));
        return max;
    }

    private int getSquareResult(int n, int k) {
        long squareResult = (long) k * k; // 这里要先把k转成long，否则两个int相乘结果还是int，会溢出为0，也可以用BigDecimal
        String strSquareResult = String.valueOf(squareResult);
        return strSquareResult.length() > n ? Integer.parseInt(strSquareResult.substring(0, n)) : (int) squareResult;
        
        // import java.math.BigDecimal;
        // BigDecimal bigDecimalK = new BigDecimal(k);
        // String strSquareResult = String.valueOf(bigDecimalK.multiply(bigDecimalK));
        // return Integer.parseInt(strSquareResult.length() > n ? strSquareResult.substring(0, n) : strSquareResult);
    }

    private boolean checkInputValid(int n, int k) {
        if (n > 0 && n <= 9) {
            return true;
        }

        int maxK = (int) Math.pow(10, n);
        if (k > 0 && k <= maxK) {
            return true;
        }

        return false;
    }
}

// SolutionTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private static final Solution SOLUTION = new Solution();

    @Test
    public void test1() {
        assertEquals(-1, SOLUTION.maxSquareResult(0, 0));
    }

    @Test
    public void test2() {
        assertEquals(1, SOLUTION.maxSquareResult(1, 1));
    }

    @Test
    public void test3() {
        assertEquals(4, SOLUTION.maxSquareResult(1, 2));
    }

    @Test
    public void test4() {
        assertEquals(62, SOLUTION.maxSquareResult(2, 2));
    }

    @Test
    public void test5() {
        assertEquals(36, SOLUTION.maxSquareResult(2, 12));
    }

    @Test
    public void test6() {
        assertEquals(999937937, SOLUTION.maxSquareResult(9, 12));
    }

    @Test
    public void test() {
        System.out.println(Integer.MAX_VALUE);
        System.out.println((long) Math.pow(10, 9));
    }
}
//------------------------------------------------------------------------------------------------
// 用正则表达式查找字符串中的数字
// Solution.java
package test;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class Solution {
    List<String> countNumStr(String str, int num) {
        ArrayList<String> strings = new ArrayList<>();

        Pattern pattern = Pattern.compile("\\d+");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            String numStr = matcher.group(0);
            int tmpNum = Integer.parseInt(numStr);
            if (tmpNum > num) {
                strings.add(numStr);
            }
        }

        return strings;
    }
}

// SolutionTest.java
package test;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    @Test
    public void test1() {
        String str = "333abcd2323defh3456";
        List<String> numStrs = new Solution().countNumStr(str, 1000);
        List<String> expectedNumStrs = Arrays.asList("2323", "3456");
        assertEquals(expectedNumStrs, numStrs);
    }
}
//------------------------------------------------------------------------------------------------
// 594. Longest Harmonious Subsequence https://leetcode.com/problems/longest-harmonious-subsequence/
package test;

import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> intCountMap = getIntCountMap(nums);
        
        int firstNum = 0;
        int firstNumCount = 0;
        int secondNum = 0;
        int secondNumCount = 0;
        int lhs = 0;

        int index = 0;
        for (Map.Entry<Integer, Integer> entry : intCountMap.entrySet()) {
            if (index % 2 == 0) {
                firstNum = entry.getKey();
                firstNumCount = entry.getValue();
            } else {
                secondNum = entry.getKey();
                secondNumCount = entry.getValue();
            }

            if (Math.abs(firstNum - secondNum) == 1 && firstNumCount > 0 && secondNumCount > 0) {
                lhs = Math.max(lhs, firstNumCount + secondNumCount);
            }

            ++index;
        }

        return lhs;
    }

    private Map<Integer, Integer> getIntCountMap(int[] nums) {
        Map<Integer, Integer> intCountMap = new HashMap<>();
        for (int num : nums) {
            intCountMap.put(num, intCountMap.getOrDefault(num, 0) + 1);
        }
        return intCountMap;
    }
}

// 改进1
package test;

import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> intCountMap = getIntCountMap(nums);

        int lhs = 0;
        for (Map.Entry<Integer, Integer> entry : intCountMap.entrySet()) {
            int tmpNum = entry.getKey();
            int tmpNumCount = entry.getValue();
            if (intCountMap.containsKey(tmpNum + 1)) {
                lhs = Math.max(lhs, tmpNumCount + intCountMap.get(tmpNum + 1));
            }
        }

        return lhs;
    }

    private Map<Integer, Integer> getIntCountMap(int[] nums) {
        Map<Integer, Integer> intCountMap = new HashMap<>();
        for (int num : nums) {
            intCountMap.put(num, intCountMap.getOrDefault(num, 0) + 1);
        }
        return intCountMap;
    }
}

// 改进2，没有改进1速度快
package test;

import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> intCountMap = new HashMap<>();

        int lhs = 0;
        for (int num : nums) {
            int numCount = intCountMap.getOrDefault(num, 0) + 1;
            intCountMap.put(num, numCount);
            if (intCountMap.containsKey(num + 1)) {
                lhs = Math.max(lhs, numCount + intCountMap.get(num + 1));
            }
            if (intCountMap.containsKey(num - 1)) {
                lhs = Math.max(lhs, numCount + intCountMap.get(num - 1));
            }
        }

        return lhs;
    }
}
//------------------------------------------------------------------------------------------------
// 计算蜂窝小区最短距离 参考 https://www.cnblogs.com/onduty/p/5709379.html 有问题：直线距离会小区多次折叠的距离，导致计算不准确，如41和57距离为8，如下代码算出来7
//Demo.java
package huawei;

public class Demo {

    private static final int D = 6;

    public int getCellularDistance(int firstValue, int secondValue) {
        // 小值为value1，大值为value2
        int value1 = Math.min(firstValue, secondValue);
        int value2 = Math.max(firstValue, secondValue);

        // 计算数字处于第几圈，1为第1圈，2-7为第2圈，依次类推，对应极座标的r = circleNumber - 1
        int circleNumber1 = getCircleNumber(value1);
        int circleNumber2 = getCircleNumber(value2);

        // 计算数字的极座标弧度
        double radians1 = getRadians(value1, circleNumber1);
        double radians2 = getRadians(value2, circleNumber2);

        // 计算数字的极座标距离
        int r1 = circleNumber1 - 1;
        int r2 = circleNumber2 - 1;

        // 根据极座标计算距离
        return (int) Math.round(Math.sqrt(r1 * r1 - 2 * r1 * r2 * Math.cos(radians1 - radians2) + r2 * r2));
    }

    private double getRadians(int value, int circleNumber) {
        //如果圈数为1，则弧度为0
        if (circleNumber == 1) {
            return 0;
        }

        // 计算该圈最大的数字
        int circleMaxValue = circleNumber * (circleNumber - 1) * D / 2 + 1;
        // 计算该圈的容量
        int circleCapacity = (circleNumber - 1) * D;
        // 计算当前数字对应的弧度，x轴正方向为1->7->19->37->...
        return (circleMaxValue - value) * 2 * Math.PI / circleCapacity;
    }

    private int getCircleNumber(int value) {
        return (int) Math.ceil((1 + Math.sqrt(1 + (double) 4 * (value - 1) / 3)) / 2);
    }
}

//DemoTest.java
package huawei;


import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class DemoTest {
    @Test
    public void test_firstValue_1() {
        Demo demo = new Demo();
        int distance = demo.getCellularDistance(1, 7);
        assertEquals(1, distance);
    }

    @Test
    public void test_SecondValue_1() {
        Demo demo = new Demo();
        int distance = demo.getCellularDistance(8, 1);
        assertEquals(2, distance);
    }

    @Test
    public void test3() {
        Demo demo = new Demo();
        assertEquals(1, demo.getCellularDistance(2, 7));
        assertEquals(1, demo.getCellularDistance(6, 7));
    }

    @Test
    public void test4() {
        Demo demo = new Demo();
        assertEquals(2, demo.getCellularDistance(3, 7));
        assertEquals(2, demo.getCellularDistance(5, 7));
        assertEquals(2, demo.getCellularDistance(4, 7));
    }

    @Test
    public void test5() {
        Demo demo = new Demo();
        assertEquals(4, demo.getCellularDistance(3, 35));
        assertEquals(4, demo.getCellularDistance(57, 61));
    }
}
//------------------------------------------------------------------------------------------------
//165. Compare Version Numbers https://leetcode.com/problems/compare-version-numbers/
通过这个例子，发现使用BigDecimal耗时也多，耗内存也多。

Integer.parseInt返回int，Integer.valueOf返回Integer（内部调用了parseInt），从效率上考虑，建议首先考虑parseInt方法。
package test;

class Solution {
    public int compareVersion(String version1, String version2) {
        String[] versionArray1 = version1.split("\\.");
        String[] versionArray2 = version2.split("\\.");

        int length1 = versionArray1.length;
        int length2 = versionArray2.length;

        int minLength = Math.min(length1, length2);
        for (int i = 0; i < minLength; i++) {
            int i1 = Integer.parseInt(versionArray1[i]);
            int i2 = Integer.parseInt(versionArray2[i]);
            if (i1 == i2) {
                continue;
            } else {
                return i1 > i2 ? 1 : -1;
            }
        }

        //之前所有的位都相同
        int maxLength = Math.max(length1, length2);
        String[] longerVersionArray;
        int flag;

        if (length1 > length2) {
            longerVersionArray = versionArray1;
            flag = 1;
        } else {
            longerVersionArray = versionArray2;
            flag = -1;
        }
        for (int i = minLength; i < maxLength; i++) {
            int i1 = Integer.parseInt(longerVersionArray[i]);
            if (i1 == 0) {
                continue;
            } else {
                return flag * (i1 > 0 ? 1 : -1);
            }
        }

        return 0;
    }
//    public int compareVersion(String version1, String version2) {
//        String[] versionArray1 = version1.split("\\.");
//        String[] versionArray2 = version2.split("\\.");
//
//        int length1 = versionArray1.length;
//        int length2 = versionArray2.length;
//
//        int minLength = Math.min(length1, length2);
//        for (int i = 0; i < minLength; i++) {
//            BigDecimal bigDecimal1 = new BigDecimal(versionArray1[i]);
//            BigDecimal bigDecimal2 = new BigDecimal(versionArray2[i]);
//            if (bigDecimal1.equals(bigDecimal2)) {
//                continue;
//            } else {
//                return bigDecimal1.compareTo(bigDecimal2);
//            }
//        }
//
//        //之前所有的位都相同
//        int maxLength = Math.max(length1, length2);
//        String[] longerVersionArray;
//        BigDecimal bigDecimalZero = new BigDecimal("0");
//        int flag;
//
//        if (length1 > length2) {
//            longerVersionArray = versionArray1;
//            flag = 1;
//        } else {
//            longerVersionArray = versionArray2;
//            flag = -1;
//        }
//        for (int i = minLength; i < maxLength; i++) {
//            BigDecimal bigDecimal = new BigDecimal(longerVersionArray[i]);
//            if (bigDecimal.equals(bigDecimalZero)) {
//                continue;
//            } else {
//                return flag * bigDecimal.compareTo(bigDecimalZero);
//            }
//        }
//
//        return 0;
//    }
}
//------------------------------------------------------------------------------------------------
//493. Reverse Pairs https://leetcode.com/problems/reverse-pairs/
Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].

You need to return the number of important reverse pairs in the given array.

Example1:

Input: [1,3,2,3,1]
Output: 2
Example2:

Input: [2,4,3,5,1]
Output: 3
Note:
The length of the given array will not exceed 50,000.
All the numbers in the input array are in the range of 32-bit integer.

//Solution.java
public class Solution {

    private int ret;

    public int reversePairs(int[] nums) {
        ret = 0;
        mergeSort(nums, 0, nums.length - 1);
        return ret;
    }

    public void mergeSort(int[] nums, int left, int right) {
        if (right <= left) {
            return;
        }
        int middle = left + (right - left) / 2;
        mergeSort(nums, left, middle);
        mergeSort(nums, middle + 1, right);

        //合并排序，中间节点及之前的元素都是排好序的，中间节点之后的节点都是排好序的。
        //每次针对中间元素及之前的元素和中间节点之后元素比较，看是否满足nums[l] > 2 * num[r]
        //count elements
        int count = 0;
        for (int l = left, r = middle + 1; l <= middle; ) {
            //如果中间节点前的某个元素l值已经大于2*中间节点后的某个元素r值就做count++操作，则中间节点l及之后的所有元素都满足这个条件，这是每次可以做ret += count的原因
            //如果r已经大于right了，则说明中间节点后的元素已经检查完了，l~中间节点的值都满足count的个数，也可以直接ret += count
            if (r > right || (long) nums[l] <= 2 * (long) nums[r]) {
                l++;
                ret += count;
            } else {
                r++;
                count++;
            }
        }

        //merge sort
        int[] temp = new int[right - left + 1];
        for (int l = left, r = middle + 1, k = 0; l <= middle || r <= right; ) {
            if (l <= middle && ((r > right) || nums[l] < nums[r])) {
                temp[k++] = nums[l++];
            } else {
                temp[k++] = nums[r++];
            }
        }
        for (int i = 0; i < temp.length; i++) {
            nums[left + i] = temp[i];
        }
    }
}

//效率低的算法
class Solution {
   public int reversePairs(int[] nums) {
       List<Long> numList =
           Arrays.stream(nums).mapToObj(Long::valueOf).collect(Collectors.toCollection(LinkedList::new));
       int pairNum = 0;
       while (!numList.isEmpty()) {
           Long first = numList.get(0);
           numList.remove(0);

           pairNum += numList.stream().mapToInt(e -> (first > e * 2) ? 1 : 0).sum();
       }

       return pairNum;
   }
}

//SolutionTest
package test;


import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private static final Solution SOLUTION = new Solution();

    @Test
    public void test1() {
        int[] ints = {1, 3, 2, 3, 1};
        assertEquals(2, SOLUTION.reversePairs(ints));
    }

    @Test
    public void test2() {
        int[] ints = {7, 10, 3, 5, 1, 2};
        assertEquals(9, SOLUTION.reversePairs(ints));
    }

    @Test
    public void test3() {
        int[] ints = {2147483647, 2147483647, 2147483647, 2147483647, 2147483647, 2147483647};
        assertEquals(0, SOLUTION.reversePairs(ints));
    }
}
//------------------------------------------------------------------------------------------------
//任务优先级输出队列
//TaskSorter.java
package huawei;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TaskSorter {
    public String sort(int n, int[][] orderArray) {
        Map<Integer, Set<Integer>> taskDependencyMap =
            Arrays.stream(orderArray).collect(Collectors.groupingBy(e -> e[1],
                Collectors.mapping(e -> e[0], Collectors.toSet())));
        IntStream.rangeClosed(1, n).forEach(e -> taskDependencyMap.putIfAbsent(e, new HashSet<>()));

        List<Integer> taskOrder = new ArrayList<>();

        while (!taskDependencyMap.isEmpty()) {
            Integer firstTask = getEmptyDependencyTask(taskDependencyMap);
            if (firstTask == null) {
                return null;
            }

            taskOrder.add(firstTask);
            taskDependencyMap.remove(firstTask);
            taskDependencyMap.forEach((k, v) -> v.remove(firstTask));
        }

        return taskOrder.stream().map(String::valueOf).collect(Collectors.joining(" "));
    }

    private Integer getEmptyDependencyTask(Map<Integer, Set<Integer>> taskDependencyMap) {
        for (Map.Entry<Integer, Set<Integer>> taskDependencyEntry : taskDependencyMap.entrySet()) {
            if (taskDependencyEntry.getValue().isEmpty()) {
                return taskDependencyEntry.getKey();
            }
        }
        return null;
    }
}

//TaskSorterTest.java
package huawei;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class TaskSorterTest {
    private TaskSorter taskSorter = new TaskSorter();

    @Test
    public void test1() {
        int[][] orderArray = {
            {5, 4},
            {4, 3},
            {3, 2},
            {2, 1}};
        String tasksOrder = taskSorter.sort(5, orderArray);
        assertEquals("5 4 3 2 1", tasksOrder);
    }
}
//------------------------------------------------------------------------------------------------
//总结深度优先与广度优先的区别 
//树 https://blog.csdn.net/u010412301/article/details/79949730
总结深度优先与广度优先的区别
1、区别
1） 二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。
2） 深度优先遍历：对每一个可能的分支路径深入到不能再深入为止，而且每个结点只能访问一次。要特别注意的是，二叉树的深度优先遍历比较特殊，可以细分为先序遍历、中序遍历、后序遍历。具体说明如下：

先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。
中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。
后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。
广度优先遍历：又叫层次遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　　　

3）深度优先搜素算法：不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。

广度优先搜索算法：保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。

通常 深度优先搜索法不全部保留结点，扩展完的结点从数据库中弹出删去，这样，一般在数据库中存储的结点数就是深度值，因此它占用空间较少。

所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。 　

广度优先搜索算法，一般需存储产生的所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。

但广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索要快些

//BinaryTreeTraverseTest.java
package test;

import java.util.LinkedList;
import java.util.Queue;

/**
 * 二叉树的深度优先遍历和广度优先遍历
 *
 * @author Fantasy
 * @version 1.0 2016/10/05 - 2016/10/07
 */
public class BinaryTreeTraverseTest {
    public static void main(String[] args) {

        BinarySortTree<Integer> tree = new BinarySortTree<Integer>();

        tree.insertNode(35);
        tree.insertNode(20);
        tree.insertNode(15);
        tree.insertNode(16);
        tree.insertNode(29);
        tree.insertNode(28);
        tree.insertNode(30);
        tree.insertNode(40);
        tree.insertNode(50);
        tree.insertNode(45);
        tree.insertNode(55);

        System.out.print("先序遍历（递归）：");
        tree.preOrderTraverse(tree.getRoot());
        System.out.println();
        System.out.print("中序遍历（递归）：");
        tree.inOrderTraverse(tree.getRoot());
        System.out.println();
        System.out.print("后序遍历（递归）：");
        tree.postOrderTraverse(tree.getRoot());
        System.out.println();

        System.out.print("先序遍历（非递归）：");
        tree.preOrderTraverseNoRecursion(tree.getRoot());
        System.out.println();
        System.out.print("中序遍历（非递归）：");
        tree.inOrderTraverseNoRecursion(tree.getRoot());
        System.out.println();
        System.out.print("后序遍历（非递归）：");
        tree.postOrderTraverseNoRecursion(tree.getRoot());
        System.out.println();

        System.out.print("广度优先遍历：");
        tree.breadthFirstTraverse(tree.getRoot());
    }
}

/**
 * 结点
 */
class Node<E extends Comparable<E>> {

    E value;
    Node<E> left;
    Node<E> right;

    Node(E value) {
        this.value = value;
        left = null;
        right = null;
    }

}

/**
 * 使用一个先序序列构建一棵二叉排序树（又称二叉查找树）
 */
class BinarySortTree<E extends Comparable<E>> {

    private Node<E> root;

    BinarySortTree() {
        root = null;
    }

    public void insertNode(E value) {
        if (root == null) {
            root = new Node<E>(value);
            return;
        }
        Node<E> currentNode = root;
        while (true) {
            if (value.compareTo(currentNode.value) > 0) {
                if (currentNode.right == null) {
                    currentNode.right = new Node<E>(value);
                    break;
                }
                currentNode = currentNode.right;
            } else {
                if (currentNode.left == null) {
                    currentNode.left = new Node<E>(value);
                    break;
                }
                currentNode = currentNode.left;
            }
        }
    }

    public Node<E> getRoot() {
        return root;
    }

    /**
     * 先序遍历二叉树（递归）
     *
     * @param node
     */
    public void preOrderTraverse(Node<E> node) {
        System.out.print(node.value + " ");
        if (node.left != null)
            preOrderTraverse(node.left);
        if (node.right != null)
            preOrderTraverse(node.right);
    }

    /**
     * 中序遍历二叉树（递归）
     *
     * @param node
     */
    public void inOrderTraverse(Node<E> node) {
        if (node.left != null)
            inOrderTraverse(node.left);
        System.out.print(node.value + " ");
        if (node.right != null)
            inOrderTraverse(node.right);
    }

    /**
     * 后序遍历二叉树（递归）
     *
     * @param node
     */
    public void postOrderTraverse(Node<E> node) {
        if (node.left != null)
            postOrderTraverse(node.left);
        if (node.right != null)
            postOrderTraverse(node.right);
        System.out.print(node.value + " ");
    }

    /**
     * 先序遍历二叉树（非递归）
     *
     * @param root
     */
    public void preOrderTraverseNoRecursion(Node<E> root) {
        LinkedList<Node<E>> stack = new LinkedList<Node<E>>();
        Node<E> currentNode = null;
        stack.push(root);
        while (!stack.isEmpty()) {
            currentNode = stack.pop();
            System.out.print(currentNode.value + " ");
            if (currentNode.right != null)
                stack.push(currentNode.right);
            if (currentNode.left != null)
                stack.push(currentNode.left);
        }
    }

    /**
     * 中序遍历二叉树（非递归）
     *
     * @param root
     */
    public void inOrderTraverseNoRecursion(Node<E> root) {
        LinkedList<Node<E>> stack = new LinkedList<Node<E>>();
        Node<E> currentNode = root;
        while (currentNode != null || !stack.isEmpty()) {
            // 一直循环到二叉排序树最左端的叶子结点（currentNode是null）  
            while (currentNode != null) {
                stack.push(currentNode);
                currentNode = currentNode.left;
            }
            currentNode = stack.pop();
            System.out.print(currentNode.value + " ");
            currentNode = currentNode.right;
        }
    }

    /**
     * 后序遍历二叉树（非递归）
     *
     * @param root
     */
    public void postOrderTraverseNoRecursion(Node<E> root) {
        LinkedList<Node<E>> stack = new LinkedList<Node<E>>();
        Node<E> currentNode = root;
        Node<E> rightNode = null;
        while (currentNode != null || !stack.isEmpty()) {
            // 一直循环到二叉排序树最左端的叶子结点（currentNode是null）  
            while (currentNode != null) {
                stack.push(currentNode);
                currentNode = currentNode.left;
            }
            currentNode = stack.pop();
            // 当前结点没有右结点或上一个结点（已经输出的结点）是当前结点的右结点，则输出当前结点  
            while (currentNode.right == null || currentNode.right == rightNode) {
                System.out.print(currentNode.value + " ");
                rightNode = currentNode;
                if (stack.isEmpty()) {
                    return; //root以输出，则遍历结束  
                }
                currentNode = stack.pop();
            }
            stack.push(currentNode); //还有右结点没有遍历  
            currentNode = currentNode.right;
        }
    }

    /**
     * 广度优先遍历二叉树，又称层次遍历二叉树
     *
     * @param node
     */
    public void breadthFirstTraverse(Node<E> root) {
        Queue<Node<E>> queue = new LinkedList<Node<E>>();
        Node<E> currentNode = null;
        queue.offer(root);
        while (!queue.isEmpty()) {
            currentNode = queue.poll();
            System.out.print(currentNode.value + " ");
            if (currentNode.left != null)
                queue.offer(currentNode.left);
            if (currentNode.right != null)
                queue.offer(currentNode.right);
        }
    }

}
输出：
先序遍历（递归）：35 20 15 16 29 28 30 40 50 45 55 
中序遍历（递归）：15 16 20 28 29 30 35 40 45 50 55 
后序遍历（递归）：16 15 28 30 29 20 45 55 50 40 35 
先序遍历（非递归）：35 20 15 16 29 28 30 40 50 45 55 
中序遍历（非递归）：15 16 20 28 29 30 35 40 45 50 55 
后序遍历（非递归）：16 15 28 30 29 20 45 55 50 40 35 
广度优先遍历：35 20 40 15 29 50 16 28 30 45 55

//图 https://www.cnblogs.com/skywang12345/p/3711483.html
//MatrixUDG.java
package test; 
/**
 * Java: 邻接矩阵表示的"无向图(Matrix Undirected Graph)"
 *
 * @author skywang
 * @date 2014/04/19
 */

import java.io.IOException;
import java.util.Scanner;

public class MatrixUDG {

    private char[] mVexs;       // 顶点集合
    private int[][] mMatrix;    // 邻接矩阵

    /*
     * 创建图(自己输入数据)
     */
    public MatrixUDG() {

        // 输入"顶点数"和"边数"
        System.out.printf("input vertex number: ");
        int vlen = readInt();
        System.out.printf("input edge number: ");
        int elen = readInt();
        if (vlen < 1 || elen < 1 || (elen > (vlen * (vlen - 1)))) {
            System.out.printf("input error: invalid parameters!\n");
            return;
        }

        // 初始化"顶点"
        mVexs = new char[vlen];
        for (int i = 0; i < mVexs.length; i++) {
            System.out.printf("vertex(%d): ", i);
            mVexs[i] = readChar();
        }

        // 初始化"边"
        mMatrix = new int[vlen][vlen];
        for (int i = 0; i < elen; i++) {
            // 读取边的起始顶点和结束顶点
            System.out.printf("edge(%d):", i);
            char c1 = readChar();
            char c2 = readChar();
            int p1 = getPosition(c1);
            int p2 = getPosition(c2);

            if (p1 == -1 || p2 == -1) {
                System.out.printf("input error: invalid edge!\n");
                return;
            }

            mMatrix[p1][p2] = 1;
            mMatrix[p2][p1] = 1;
        }
    }

    /*
     * 创建图(用已提供的矩阵)
     *
     * 参数说明：
     *     vexs  -- 顶点数组
     *     edges -- 边数组
     */
    public MatrixUDG(char[] vexs, char[][] edges) {

        // 初始化"顶点数"和"边数"
        int vlen = vexs.length;
        int elen = edges.length;

        // 初始化"顶点"
        mVexs = new char[vlen];
        for (int i = 0; i < mVexs.length; i++)
            mVexs[i] = vexs[i];

        // 初始化"边"
        mMatrix = new int[vlen][vlen];
        for (int i = 0; i < elen; i++) {
            // 读取边的起始顶点和结束顶点
            int p1 = getPosition(edges[i][0]);
            int p2 = getPosition(edges[i][1]);

            mMatrix[p1][p2] = 1;
            mMatrix[p2][p1] = 1;
        }
    }

    /*
     * 返回ch位置
     */
    private int getPosition(char ch) {
        for (int i = 0; i < mVexs.length; i++)
            if (mVexs[i] == ch)
                return i;
        return -1;
    }

    /*
     * 读取一个输入字符
     */
    private char readChar() {
        char ch = '0';

        do {
            try {
                ch = (char) System.in.read();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } while (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')));

        return ch;
    }

    /*
     * 读取一个输入字符
     */
    private int readInt() {
        Scanner scanner = new Scanner(System.in);
        return scanner.nextInt();
    }

    /*
     * 返回顶点v的第一个邻接顶点的索引，失败则返回-1
     */
    private int firstVertex(int v) {

        if (v < 0 || v > (mVexs.length - 1))
            return -1;

        for (int i = 0; i < mVexs.length; i++)
            if (mMatrix[v][i] == 1)
                return i;

        return -1;
    }

    /*
     * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
     */
    private int nextVertex(int v, int w) {

        if (v < 0 || v > (mVexs.length - 1) || w < 0 || w > (mVexs.length - 1))
            return -1;

        for (int i = w + 1; i < mVexs.length; i++)
            if (mMatrix[v][i] == 1)
                return i;

        return -1;
    }

    /*
     * 深度优先搜索遍历图的递归实现
     */
    private void DFS(int i, boolean[] visited) {

        visited[i] = true;
        System.out.printf("%c ", mVexs[i]);
        // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走
        for (int w = firstVertex(i); w >= 0; w = nextVertex(i, w)) {
            if (!visited[w])
                DFS(w, visited);
        }
    }

    /*
     * 深度优先搜索遍历图
     */
    public void DFS() {
        boolean[] visited = new boolean[mVexs.length];       // 顶点访问标记

        // 初始化所有顶点都没有被访问
        for (int i = 0; i < mVexs.length; i++)
            visited[i] = false;

        System.out.printf("DFS: ");
        for (int i = 0; i < mVexs.length; i++) {
            if (!visited[i])
                DFS(i, visited);
        }
        System.out.printf("\n");
    }

    /*
     * 广度优先搜索（类似于树的层次遍历）
     */
    public void BFS() {
        int head = 0;
        int rear = 0;
        int[] queue = new int[mVexs.length];            // 辅组队列
        boolean[] visited = new boolean[mVexs.length];  // 顶点访问标记

        for (int i = 0; i < mVexs.length; i++)
            visited[i] = false;

        System.out.printf("BFS: ");
        for (int i = 0; i < mVexs.length; i++) {
            if (!visited[i]) {
                visited[i] = true;
                System.out.printf("%c ", mVexs[i]);
                queue[rear++] = i;  // 入队列
            }

            while (head != rear) {
                int j = queue[head++];  // 出队列
                for (int k = firstVertex(j); k >= 0; k = nextVertex(j, k)) { //k是为访问的邻接顶点
                    if (!visited[k]) {
                        visited[k] = true;
                        System.out.printf("%c ", mVexs[k]);
                        queue[rear++] = k;
                    }
                }
            }
        }
        System.out.printf("\n");
    }

    /*
     * 打印矩阵队列图
     */
    public void print() {
        System.out.printf("Martix Graph:\n");
        for (int i = 0; i < mVexs.length; i++) {
            for (int j = 0; j < mVexs.length; j++)
                System.out.printf("%d ", mMatrix[i][j]);
            System.out.printf("\n");
        }
    }

    public static void main(String[] args) {
        char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        char[][] edges = new char[][]{
            {'A', 'C'},
            {'A', 'D'},
            {'A', 'F'},
            {'B', 'C'},
            {'C', 'D'},
            {'E', 'G'},
            {'F', 'G'}};
        MatrixUDG pG;

        // 自定义"图"(输入矩阵队列)
        //pG = new MatrixUDG();
        // 采用已有的"图"
        pG = new MatrixUDG(vexs, edges);

        pG.print();   // 打印图
        pG.DFS();     // 深度优先遍历
        pG.BFS();     // 广度优先遍历
    }
}
输出：
Martix Graph:
0 0 1 1 0 1 0 
0 0 1 0 0 0 0 
1 1 0 1 0 0 0 
1 0 1 0 0 0 0 
0 0 0 0 0 0 1 
1 0 0 0 0 0 1 
0 0 0 0 1 1 0 
DFS: A C B D F G E 
BFS: A C D F B G E 
//------------------------------------------------------------------------------------------------
//汉诺塔
//HanoiTower.java
package test;

public class HanoiTower {
    /**
     * |1     |     |
     * |2     |     |
     * |3     |     |
     * |4     |     |
     * |5     |     |
     * a:src  b:tmp c:dst
     */

    private int stepNum = 1;

    private static final char SRC_POS = 'a';
    private static final char TMP_POS = 'b';
    private static final char DST_POS = 'c';

    private void move(int towerNum) {
        move(SRC_POS, DST_POS, TMP_POS, towerNum);
    }

    private void move(char srcPos, char dstPos, char tmpPos, int towerNum) {
        if (towerNum == 1) {
            System.out.printf("Step%d: move plate(%d) from pos(%s) to pos(%s)%n", stepNum++, towerNum, srcPos, dstPos);
            return;
        }

        move(srcPos, tmpPos, dstPos, towerNum - 1);
        System.out.printf("Step%d: move plate(%d) from pos(%s) to pos(%s)%n", stepNum++, towerNum, srcPos, dstPos);
        move(tmpPos, dstPos, srcPos, towerNum - 1);
    }

    public static void main(String[] args) {
        new HanoiTower().move(3);
    }
}
//
Step1: move plate(1) from pos(a) to pos(c)
Step2: move plate(2) from pos(a) to pos(b)
Step3: move plate(1) from pos(c) to pos(b)
Step4: move plate(3) from pos(a) to pos(c)
Step5: move plate(1) from pos(b) to pos(a)
Step6: move plate(2) from pos(b) to pos(c)
Step7: move plate(1) from pos(a) to pos(c)
//------------------------------------------------------------------------------------------------
//迷宫最短路径
//Point.java
package huawei;

import java.util.Objects;

public class Point {

    int x = 0;
    int y = 0;

    public Point() {
        this(0, 0);
    }

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Point point = (Point) o;
        return x == point.x &&
            y == point.y;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}

//PointUtils.java
package huawei;

public class PointUtils {
    private int maxX;
    private int maxY;

    public PointUtils(int maxX, int maxY) {
        this.maxX = maxX;
        this.maxY = maxY;
    }

    public Point getUpPoint(Point currentPoint) {
        if (currentPoint.getX() != 0) {
            return new Point(currentPoint.getX() - 1, currentPoint.getY());
        }
        return null;
    }

    public Point getDownPoint(Point currentPoint) {
        if (currentPoint.getX() != maxX) {
            return new Point(currentPoint.getX() + 1, currentPoint.getY());
        }
        return null;
    }


    public Point getLeftPoint(Point currentPoint) {
        if (currentPoint.getY() != 0) {
            return new Point(currentPoint.getX(), currentPoint.getY() - 1);
        }
        return null;
    }

    public Point getRightPoint(Point currentPoint) {
        if (currentPoint.getY() != maxY) {
            return new Point(currentPoint.getX(), currentPoint.getY() + 1);
        }
        return null;
    }
}

//MazeSolver.java
package huawei;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Queue;
import java.util.Stack;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
  功能:从一个迷宫走出的最短路

  输入:
      一个N*M的数组,int[][] maze迷宫图作为输入，如
      {0, 1, 0, 0, 0},
      {0, 1, 0, 1, 0},
      {0, 0, 0, 0, 0},
      {0, 1, 1, 1, 0},
      {0, 0, 0, 1, 0}};

  输出:从左上角到右下角的最短路线：(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4)

*/
public final class MazeSolver {
    //保存路径的List
    private List<Point> outWayList = new Stack<>();

    private Stack<Point> tmpStack = new Stack<>();
    private int maxX;
    private int maxY;
    private Point startPoint;
    private Point endPoint;
    private PointUtils pointUtils;
    private int[][] maze;

    private List<List<Point>> mazePoint; //储存每个位置的点是否被访问过，如果访问过是由哪个点访问的
    private Queue<Point> queue = new ArrayDeque<>();

    public MazeSolver(int[][] maze, Point startPoint, Point endPoint) {
        this.maze = maze;
        this.startPoint = startPoint; //入口
        this.endPoint = endPoint;//出口

        maxX = maze.length - 1;
        maxY = maze[0].length - 1;
        pointUtils = new PointUtils(maxX, maxY);
    }

    //深度搜索
    public List<Point> goByDfs() {
        tmpStack.add(startPoint);
        addNextPoint();
        return outWayList;
    }

    private void addNextPoint() {
        Point currentPoint = tmpStack.peek();
        if (currentPoint.equals(endPoint)) {
            if (outWayList.isEmpty() || outWayList.size() > tmpStack.size()) {
                outWayList.clear();
                outWayList.addAll(tmpStack);
            }
            return;
        }

        addNotNullPoint(pointUtils.getUpPoint(currentPoint));
        addNotNullPoint(pointUtils.getRightPoint(currentPoint));
        addNotNullPoint(pointUtils.getDownPoint(currentPoint));
        addNotNullPoint(pointUtils.getLeftPoint(currentPoint));
    }

    private void addNotNullPoint(Point nextPoint) {
        if (nextPoint != null && !isPointInStack(nextPoint) && isPointValid(nextPoint)) {
            tmpStack.add(nextPoint);
            addNextPoint();
            tmpStack.pop();
        }
    }

    private boolean isPointValid(Point point) {
        return maze[point.getX()][point.getY()] == 0;
    }

    private boolean isPointInStack(Point point) {
        return tmpStack.contains(point);
    }

    //广度搜索
    public List<Point> goByBfs() {
        mazePoint = initMazePoint(maxX, maxY);
        loopToFindWay();
        return getWayPoints();
    }

    private void loopToFindWay() {
        queue.add(startPoint);
        while (!queue.isEmpty()) {
            Point point = queue.poll();
            if (addPointToQueue(point, pointUtils.getUpPoint(point))
                || addPointToQueue(point, pointUtils.getRightPoint(point))
                || addPointToQueue(point, pointUtils.getDownPoint(point))
                || addPointToQueue(point, pointUtils.getLeftPoint(point))) {
                break;
            }
        }
    }

    /**
     * @param currentPoint
     * @param nextPoint
     * @return 是否找到了终点
     */
    private boolean addPointToQueue(Point currentPoint, Point nextPoint) {
        if (nextPoint != null && isPointValid(nextPoint) && isPointNotVisited(nextPoint)) {
            queue.offer(nextPoint);
            mazePoint.get(nextPoint.getX()).set(nextPoint.getY(), currentPoint);
            return nextPoint.equals(endPoint);
        }
        return false;
    }

    private boolean isPointNotVisited(Point point) {
        return mazePoint.get(point.getX()).get(point.getY()) == null;
    }

    private List<List<Point>> initMazePoint(int maxX, int maxY) {
        List<List<Point>> mazePoint = Stream.generate(() -> Stream.generate(() -> (Point) null).limit(maxY + 1).collect(Collectors.toList()))
            .limit(maxX + 1).collect(Collectors.toList());
        mazePoint.get(startPoint.getX()).set(startPoint.getY(), startPoint);//设置起点
        return mazePoint;
    }

    private List<Point> getWayPoints() {
        Point point = mazePoint.get(endPoint.getX()).get(endPoint.getY());
        List<Point> points = new ArrayList<>();
        //查看mazePoint上的对应endPoint位置是不是有点，如果没有点，说明未找到出口
        if (point == null) {
            return points;
        }

        //如果有点，则需要生成完整路径
        points.add(endPoint);
        for (; point != null && !point.equals(startPoint); point = mazePoint.get(point.getX()).get(point.getY())) {
            points.add(point);
        }
        points.add(startPoint);

        Collections.reverse(points);
        return points;
    }
}

//MazeSolverTest.java
package huawei;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class MazeSolverTest {
    @Test
    public void testGo1() {
        int[][] maze = {
            {0, 1, 0, 0, 0},
            {0, 1, 0, 1, 0},
            {0, 0, 0, 0, 0},
            {0, 1, 1, 1, 0},
            {0, 0, 0, 1, 0}};

        MazeSolver mazeSolver = new MazeSolver(maze, new Point(0, 0), new Point(4, 4));
        List<Point> outWayExpected = Arrays.asList(
            new Point(0, 0),
            new Point(1, 0),
            new Point(2, 0),
            new Point(2, 1),
            new Point(2, 2),
            new Point(2, 3),
            new Point(2, 4),
            new Point(3, 4),
            new Point(4, 4));

        List<Point> outWayList1 = mazeSolver.goByDfs();
        assertEquals(outWayExpected, outWayList1);

        List<Point> outWayList2 = mazeSolver.goByBfs();
        assertEquals(outWayExpected, outWayList2);
    }

    @Test
    public void testGo2() {
        int[][] maze = {
            {0, 0, 0, 0, 0},
            {0, 1, 1, 1, 0},
            {0, 0, 0, 0, 0},
            {1, 0, 1, 1, 0},
            {0, 0, 0, 1, 0}};

        MazeSolver mazeSolver = new MazeSolver(maze, new Point(4, 4), new Point(4, 2));
        List<Point> outWayExpected = Arrays.asList(
            new Point(4, 4),
            new Point(3, 4),
            new Point(2, 4),
            new Point(2, 3),
            new Point(2, 2),
            new Point(2, 1),
            new Point(3, 1),
            new Point(4, 1),
            new Point(4, 2));

        List<Point> outWayList1 = mazeSolver.goByDfs();
        assertEquals(outWayExpected, outWayList1);

        List<Point> outWayList2 = mazeSolver.goByBfs();
        assertEquals(outWayExpected, outWayList2);
    }
}

//同类题目：营救公主
//Demo.java
package huawei;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Queue;
import java.util.Stack;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Demo {
    /*
     * 每组测试数据以三个整数N,M,T(0<n, m≤20, t>0)开头，分别代表迷宫的长和高，
     * 以及公主能坚持的天数。紧接着有M行，N列字符，由"."，"*"，"P"，"S"组成。
     * 其中 "." 代表能够行走的空地。 "*" 代表墙壁，Jesse不能从此通过。
     * "P" 是公主所在的位置。 "S" 是Jesse的起始位置。 每个时间段里Jesse
     * 只能选择“上、下、左、右”任意一方向走一步。
     * 迷宫布局（这里用二维数组实现布局） M 迷宫（数组）行数 N 迷宫（数组）列数
     * T 公主能坚持的天数
     * Return Value 0 可以救出公主 -1 不可以救出公主
     */
    private static final char START_CHAR = 'S';
    private static final char END_CHAR = 'P';
    private static final char WAY_CHAR = '.';
    private static final char BLOCK_CHAR = '*';
    private int maxX;
    private int maxY;
    private int maxStep;
    private char[][] maze;
    private Point startPoint;
    private Point endPoint;

    private PointUtils pointUtils;
    private Stack<Point> tmpWay = new Stack<>();
    private List<Point> shortestWay = new Stack<>();

    private List<List<Point>> mazePoint;
    private Queue<Point> queue = new ArrayDeque<>();

    public int SSavepDfs(char[][] visited, int t, int n, int m) {
        this.maxX = m - 1;
        this.maxY = n - 1;
        this.maxStep = t;
        this.maze = visited;
        pointUtils = new PointUtils(maxX, maxY);
        initStartAndEndPoint();

        List<Point> shortestWay = goByDfs();
        return shortestWay.isEmpty() || (shortestWay.size() > maxStep + 1) ? -1 : 0;
    }

    private void initStartAndEndPoint() {
        for (int i = 0; i <= maxX; ++i) {
            for (int j = 0; j <= maxY; j++) {
                char mazeValue = maze[i][j];
                if (mazeValue == START_CHAR) {
                    startPoint = new Point(i, j);
                } else if (mazeValue == END_CHAR) {
                    endPoint = new Point(i, j);
                }

                if (startPoint != null && endPoint != null) {
                    return;
                }
            }
        }
    }

    //深度搜索
    private List<Point> goByDfs() {
        tmpWay.add(startPoint);
        addNextPoint();
        return shortestWay;
    }

    private void addNextPoint() {
        Point currentPoint = tmpWay.peek();
        if (currentPoint.equals(endPoint)) {
            if (shortestWay.isEmpty() || shortestWay.size() > tmpWay.size()) {
                shortestWay.clear();
                shortestWay.addAll(tmpWay);
            }
            return;
        }

        addNotNullPoint(pointUtils.getUpPoint(currentPoint));
        addNotNullPoint(pointUtils.getRightPoint(currentPoint));
        addNotNullPoint(pointUtils.getDownPoint(currentPoint));
        addNotNullPoint(pointUtils.getLeftPoint(currentPoint));
    }

    private void addNotNullPoint(Point nextPoint) {
        if (nextPoint != null && !isPointInStack(nextPoint) && isPointValid(nextPoint)) {
            tmpWay.add(nextPoint);
            addNextPoint();
            tmpWay.pop();
        }
    }

    private boolean isPointValid(Point point) {
        char mazeValue = maze[point.getX()][point.getY()];
        return mazeValue == WAY_CHAR || mazeValue == END_CHAR;
    }

    private boolean isPointInStack(Point point) {
        return tmpWay.contains(point);
    }

    public int SSavepBfs(char[][] visited, int t, int n, int m) {
        this.maxX = m - 1;
        this.maxY = n - 1;
        this.maxStep = t;
        this.maze = visited;
        pointUtils = new PointUtils(maxX, maxY);
        initStartAndEndPoint();

        List<Point> shortestWay = goByBfs();
        return shortestWay.isEmpty() || (shortestWay.size() > maxStep + 1) ? -1 : 0;
    }

    //广度搜索
    private List<Point> goByBfs() {
        mazePoint = initMazePoint(maxX, maxY);
        loopToFindWay();
        return getWayPoints();
    }

    private void loopToFindWay() {
        queue.add(startPoint);
        while (!queue.isEmpty()) {
            Point point = queue.poll();
            if (addPointToQueue(point, pointUtils.getUpPoint(point))
                || addPointToQueue(point, pointUtils.getRightPoint(point))
                || addPointToQueue(point, pointUtils.getDownPoint(point))
                || addPointToQueue(point, pointUtils.getLeftPoint(point))) {
                break;
            }
        }
    }

    /**
     * @param currentPoint
     * @param nextPoint
     * @return 是否找到了终点
     */
    private boolean addPointToQueue(Point currentPoint, Point nextPoint) {
        if (nextPoint != null && isPointValid(nextPoint) && isPointNotVisited(nextPoint)) {
            queue.offer(nextPoint);
            mazePoint.get(nextPoint.getX()).set(nextPoint.getY(), currentPoint);
            return nextPoint.equals(endPoint);
        }
        return false;
    }

    private boolean isPointNotVisited(Point point) {
        return mazePoint.get(point.getX()).get(point.getY()) == null;
    }

    private List<List<Point>> initMazePoint(int maxX, int maxY) {
        List<List<Point>> mazePoint = Stream.generate(() -> Stream.generate(() -> (Point) null).limit(maxY + 1).collect(Collectors.toList()))
            .limit(maxX + 1).collect(Collectors.toList());
        mazePoint.get(startPoint.getX()).set(startPoint.getY(), startPoint);//设置起点
        return mazePoint;
    }

    private List<Point> getWayPoints() {
        Point point = mazePoint.get(endPoint.getX()).get(endPoint.getY());
        List<Point> points = new ArrayList<>();
        //查看mazePoint上的对应endPoint位置是不是有点，如果没有点，说明未找到出口
        if (point == null) {
            return points;
        }

        //如果有点，则需要生成完整路径
        points.add(endPoint);
        for (; point != null && !point.equals(startPoint); point = mazePoint.get(point.getX()).get(point.getY())) {
            points.add(point);
        }
        points.add(startPoint);

        Collections.reverse(points);
        return points;
    }
}


//DemoTest.java
package huawei;

import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class DemoTest {
    @Test
    public void testCase01() {
        int N = 4;
        int M = 4;
        int T = 5;
        char a[][] = {
            {'.', '.', '.', '.'},
            {'.', '.', '.', '.'},
            {'.', '.', '.', '.'},
            {'S', '*', '*', 'P'}};
        Demo demo = new Demo();
        int Ret = demo.SSavepBfs(a, T, N, M);
        assertTrue(Ret == 0);
    }

    @Test
    public void testCase02() {
        int N = 4;
        int M = 4;
        int T = 1;
        char a[][] = {
            {'.', '.', '.', '.'},
            {'.', '.', '.', '.'},
            {'.', '.', '.', '.'},
            {'S', 'P', '*', '*'}};
        Demo demo = new Demo();
        int Ret = demo.SSavepBfs(a, T, N, M);
        assertTrue(Ret == 0);
    }

    @Test
    public void testCase03() {
        int N = 4;
        int M = 4;
        int T = 100;
        char a[][] = {
            {'.', '.', '.', '.'},
            {'.', '.', '.', '.'},
            {'*', '.', '.', '.'},
            {'S', '*', '*', 'P'}};
        Demo demo = new Demo();
        int Ret = demo.SSavepBfs(a, T, N, M);
        assertTrue(Ret == -1);
    }
}
//------------------------------------------------------------------------------------------------
//CAS https://blog.csdn.net/v123411739/article/details/79561458
CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题，本文将深入的介绍CAS的原理。

//VolatileTest.java
package test;

import java.util.concurrent.CountDownLatch;

public class VolatileTest {
    public static volatile int race = 0;

    public static void increase() {
        ++race;
    }

    private static final int THREADS_COUNT = 20;
    private static final int THREAD_COUNT_NUMBER = 10000;

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADS_COUNT];
        CountDownLatch countDownLatch = new CountDownLatch(THREADS_COUNT);
        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i] = new Thread(() -> {
                for (int i1 = 0; i1 < THREAD_COUNT_NUMBER; i1++) {
                    increase();
//                    System.out.printf(String.format("ThreadName: %s, loopNumber: %d%n", Thread.currentThread().getName(), i1));
                }
                countDownLatch.countDown();
            });
            threads[i].start();
        }
        //等待所有累加线程都结束
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(race);
    }
}
输出：68293 （每次不一样）

通过分析字节码我们知道，这是因为volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示），在并发的情况下，putstatic指令可能把较小的race值同步回主内存之中，导致我们每次都无法获得想要的结果。那么，应该怎么解决这个问题了？

解决方法1：
public static synchronized void increase() {
    ++race;
}
使用synchronized修饰后，increase方法变成了一个原子操作，因此是肯定能得到正确的结果。但是，我们知道，每次自增都进行加锁，性能可能会稍微差了点，有更好的方案吗？

解决方法2：
//    public static volatile int race = 0;
public static AtomicInteger race = new AtomicInteger(0);

public static void increase() {
//    ++race;//非原子操作，取值，加1，写值
    race.getAndIncrement();//原子操作
}
我们将例子中的代码稍做修改：race改成使用AtomicInteger定义，“race++”改成使用“race.getAndIncrement()”，AtomicInteger.getAndIncrement()是原子操作，因此我们可以确保每次都可以获得正确的结果，并且在性能上有不错的提升

CAS是什么？
CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

//------------------------------------------------------------------------------------------------
//有一个100G的文件每一行记录一个URL地址，只用一台只有1G内存的电脑，计算出哪个URL地址出现次数最多
//MyFileReader.java
package test;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MyFileReader {
    private static final Map<Integer, FileWriter> INDEX_2_FILE_WRITER_MAP = new HashMap<>();
    private static final Map<Integer, BufferedWriter> INDEX_2_BUFFERED_WRITER_MAP = new HashMap<>();
    private static final String TXT_NAME = "%d.txt";

    private int maxCount = Integer.MIN_VALUE;
    private String maxLengthStr;

    public void readAndWriteToFiles(String filePath, int fileNumber) {
        try (
            FileReader reader = new FileReader(filePath);
            BufferedReader br = new BufferedReader(reader)) {
            String str;
            while ((str = br.readLine()) != null) {
                int hashValue = str.hashCode();
                int fileIndex = Math.abs(hashValue) % fileNumber; //hash值在超过Integer最大值时会反转，用abs取正值
                writeToFile(str, fileIndex);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeWriters();
        }
    }

    public String getMaxCountStr() {
        INDEX_2_BUFFERED_WRITER_MAP.keySet().forEach(this::calcMaxLengthStr);
        return maxLengthStr;
    }

    private void calcMaxLengthStr(Integer fileIndex) {
        Map<String, Integer> strCountMap = getStrCountMap(fileIndex);
        calcMaxLengthStrFromMap(strCountMap);
    }

    private void calcMaxLengthStrFromMap(Map<String, Integer> strCountMap) {
        if (!strCountMap.isEmpty()) {
            List<Map.Entry<String, Integer>> entries = new ArrayList(strCountMap.entrySet());
            Collections.sort(entries, (o1, o2) -> (o2.getValue() - o1.getValue()));
            Map.Entry<String, Integer> maxStrCountEntry = entries.get(0);
            if (maxStrCountEntry.getValue() > maxCount) {
                maxCount = maxStrCountEntry.getValue();
                maxLengthStr = maxStrCountEntry.getKey();
            }

            entries.forEach(entry -> System.out.println(String.format("str: %s , count: %d", entry.getKey(), entry.getValue())));
        }
    }

    private Map<String, Integer> getStrCountMap(Integer fileIndex) {
        Map<String, Integer> strCountMap = new HashMap<>();
        File file = new File(String.format(TXT_NAME, fileIndex));
        try (
            FileReader reader = new FileReader(file);
            BufferedReader br = new BufferedReader(reader)) {
            String str;
            while ((str = br.readLine()) != null) {
                strCountMap.merge(str, 1, (oldV, newV) -> oldV + newV);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (file.exists()) {
                file.delete();
            }
        }
        return strCountMap;
    }

    private void closeWriters() {
        INDEX_2_BUFFERED_WRITER_MAP.forEach(this::closeWriter);//如果这里用MyFileReader::closeWriter，则closeWriter方法需要为static
        INDEX_2_FILE_WRITER_MAP.forEach(this::closeWriter);
    }

    private void closeWriter(Integer k, Writer writer) {
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void writeToFile(String str, int fileIndex) throws IOException {
        if (INDEX_2_BUFFERED_WRITER_MAP.containsKey(fileIndex)) {
            INDEX_2_BUFFERED_WRITER_MAP.get(fileIndex).write(String.format("%s\n", str));
        } else {
            FileWriter fileWriter = new FileWriter(String.format(TXT_NAME, fileIndex));
            INDEX_2_FILE_WRITER_MAP.put(fileIndex, fileWriter);

            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
            INDEX_2_BUFFERED_WRITER_MAP.put(fileIndex, bufferedWriter);

            bufferedWriter.write(String.format("%s\n", str));
        }
    }
}

//MyFileReaderTest.java
package test;

import java.net.URISyntaxException;
import java.net.URL;

import org.junit.Test;

public class MyFileReaderTest {
    @Test
    public void testMyFileReader() throws URISyntaxException {
        URL url = this.getClass().getClassLoader().getResource("Urls.txt");
        MyFileReader myFileReader = new MyFileReader();
        myFileReader.readAndWriteToFiles(url.toURI().getPath(), 10);
        String maxCountStr = myFileReader.getMaxCountStr();
        System.out.printf(String.format("MaxCountStr: %s", maxCountStr));
    }
}

//Urls.txt （位于src/test/resources/Urls.txt）
https://blog.csdn.net/woliuyunyicai/article/details/48489525
https://blog.csdn.net/chenze666/article/details/78332397
https://www.cnblogs.com/youilika/p/4998402.html
https://blog.csdn.net/woliuyunyicai/article/details/48489525
https://blog.csdn.net/chenze666/article/details/78332397
https://blog.csdn.net/woliuyunyicai/article/details/48489525
https://www.cnblogs.com/go-onxp/p/jdk8.html
https://www.baidu.com/s?ie=UTF-8&wd=java%20map.foreah
https://blog.csdn.net/wohaqiyi/article/details/79179600
https://www.imooc.com/u/6424054/courses
https://www.cnblogs.com/go-onxp/p/jdk8.html
https://blog.csdn.net/wohaqiyi/article/details/79179600
https://www.baidu.com/s?ie=UTF-8&wd=java%20%E5%90%8C%E6%97%B6%E8%A6%81%E5%86%99%E5%BE%88%E5%A4%9A%E6%96%87%E4%BB%B6
https://www.imooc.com/u/6424054/courses
https://blog.csdn.net/wohaqiyi/article/details/79179600
https://www.imooc.com/
https://blog.csdn.net/wohaqiyi/article/details/79179600
https://www.cnblogs.com/go-onxp/p/jdk8.html

输出：
str: https://www.baidu.com/s?ie=UTF-8&wd=java%20map.foreah , count: 1
str: https://www.baidu.com/s?ie=UTF-8&wd=java%20%E5%90%8C%E6%97%B6%E8%A6%81%E5%86%99%E5%BE%88%E5%A4%9A%E6%96%87%E4%BB%B6 , count: 1
str: https://www.cnblogs.com/go-onxp/p/jdk8.html , count: 3
str: https://www.cnblogs.com/youilika/p/4998402.html , count: 1
str: https://blog.csdn.net/chenze666/article/details/78332397 , count: 2
str: https://www.imooc.com/u/6424054/courses , count: 2
str: https://www.imooc.com/ , count: 1
str: https://blog.csdn.net/wohaqiyi/article/details/79179600 , count: 4
str: https://blog.csdn.net/woliuyunyicai/article/details/48489525 , count: 3
MaxCountStr: https://blog.csdn.net/wohaqiyi/article/details/79179600
//------------------------------------------------------------------------------------------------
//1. Two Sum https://leetcode.com/problems/two-sum/
package leetcode;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * https://www.cnblogs.com/grandyang/p/4606334.html
 * 1    Two Sum
 */
public class TwoSum {
    public int[] twoSum(int[] nums, int target) {
        // Collectors.toMap的第三个参数表示重复的Key时，如何处理Value值，(a, b) -> a表示保留用第一个Value，(a, b) -> b表示用第一个Value
        Map<Integer, Integer> valuePosMap = IntStream.range(0, nums.length).boxed().collect(Collectors.toMap(i -> nums[i], i -> i, (a, b) -> b));

        int[] res = new int[2];
        for (int firstIndex = 0; firstIndex < nums.length; firstIndex++) {
            int secondValue = target - nums[firstIndex];
            if (valuePosMap.containsKey(secondValue) && valuePosMap.get(secondValue) != firstIndex) {
                res[0] = firstIndex;
                res[1] = valuePosMap.get(secondValue);
                break;
            }
        }

        return res;
    }

    public int[] twoSumForOneLoop(int[] nums, int target) {
        Map<Integer, Integer> valuePosMap = new HashMap<>();

        int[] res = new int[2];
        for (int firstIndex = 0; firstIndex < nums.length; firstIndex++) {
            int firstValue = nums[firstIndex];
            int secondValue = target - firstValue;
            if (valuePosMap.containsKey(secondValue)) {
                res[0] = valuePosMap.get(secondValue); //这里的顺序是反的
                res[1] = firstIndex;
                break;
            } else {
                valuePosMap.put(firstValue, firstIndex);
            }
        }

        return res;
    }
}

//自己写的方法，只是把index存成了Map的List值
package test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, List<Integer>> numIndexMap = getNumIndexMap(nums);

        for (int i = 0; i < nums.length; i++) {
            int otherInt = target - nums[i];

            List<Integer> otherIntIndexList = numIndexMap.get(otherInt);
            if (otherIntIndexList != null) {
                if (otherInt != nums[i]) {
                    return new int[]{i, otherIntIndexList.get(0)};
                } else if (otherIntIndexList.size() > 1) {
                    return new int[]{i, otherIntIndexList.get(1)};
                }
            }
        }

        return new int[]{};
    }

    private Map<Integer, List<Integer>> getNumIndexMap(int[] nums) {
        Map<Integer, List<Integer>> numIndexMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            List<Integer> indexList = numIndexMap.get(nums[i]);
            if (indexList == null) {
                indexList = new ArrayList<>();
                numIndexMap.put(nums[i], indexList);
            }
            indexList.add(i);
        }

        return numIndexMap;
    }
}

//test
package leetcode;

import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;

public class TwoSumTest {

    private static final TwoSum TWO_SUM = new TwoSum();

    @Test
    public void test1() {
        int[] nums = new int[]{2, 3, 10, 7};
        int target = 10;
        int[] targetIndex = new int[]{1, 3};
//        assertArrayEquals(targetIndex, TWO_SUM.twoSum(nums, target));
        assertArrayEquals(targetIndex, TWO_SUM.twoSumForOneLoop(nums, target));
    }

    @Test
    public void test2() {
        int[] nums = new int[]{2, 3, 10, 2};
        int target = 4;
        int[] targetIndex = new int[]{0, 3};
//        assertArrayEquals(targetIndex, TWO_SUM.twoSum(nums, target));
        assertArrayEquals(targetIndex, TWO_SUM.twoSumForOneLoop(nums, target));
    }
}
//------------------------------------------------------------------------------------------------
//3. Longest Substring Without Repeating Characters https://leetcode.com/problems/longest-substring-without-repeating-characters/
package leetcode;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * https://www.cnblogs.com/grandyang/p/4606334.html
 * 3    Longest Substring Without Repeating Characters
 */
public class LongestSubstring {
    public int lengthOfLongestSubstring(String s) {
        int[] m = new int[256];
        Arrays.fill(m, -1);
        int res = 0, left = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            left = Math.max(left, m[c]); //取滑窗左边位置
            m[c] = i;
            res = Math.max(res, i - left); //取res和当前滑窗的最大长度
        }
        return res;
    }

    public int lengthOfLongestSubstringWithMap(String s) {
        Map<Character, Integer> characterPosMap = new HashMap<>();
        int res = 0, left = -1;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            left = Math.max(left, characterPosMap.getOrDefault(c, -1)); //取滑窗左侧位置
            characterPosMap.put(c, i);
            res = Math.max(res, i - left); //取res和当前滑窗的最大长度
        }
        return res;
    }

    public int lengthOfLongestSubstringWithSet(String s) {
        int res = 0, left = 0, right = 0;
        Set<Character> characterSet = new HashSet<>();
        while (right < s.length()) {
            char c = s.charAt(right);
            if (!characterSet.contains(c)) {
                characterSet.add(c);
                right++;
                res = Math.max(res, characterSet.size());
            } else {
                characterSet.remove(s.charAt(left++)); //只要发现right对应的字符串在滑窗(即Set)中存在，就不断往右移滑窗左侧，直到滑窗不包含right字符
            }
        }
        return res;
    }
}

//test
package leetcode;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class LongestSubstringTest {

    private static final LongestSubstring LONGEST_SUBSTRING = new LongestSubstring();

    @Test
    public void lengthOfLongestSubstring() {
        String s = "abcabcbb";
        int length = 3;
        assertEquals(length, LONGEST_SUBSTRING.lengthOfLongestSubstringWithMap(s));
    }

    @Test
    public void lengthOfLongestSubstring2() {
        String s = "bbbbb";
        int length = 1;
        assertEquals(length, LONGEST_SUBSTRING.lengthOfLongestSubstringWithMap(s));
    }

    @Test
    public void lengthOfLongestSubstring3() {
        String s = "pwwkew";
        int length = 3;
        assertEquals(length, LONGEST_SUBSTRING.lengthOfLongestSubstringWithMap(s));
    }
}
//------------------------------------------------------------------------------------------------
//仿Lisp运算
//BracketRecursivelyMatcher.java
package lisp;

public class BracketRecursivelyMatcher {
    public boolean match(String s) {
        return match(s, 0);
    }

    private boolean match(String s, int count) {
        if (s.isEmpty()) {
            return count == 0;
        }

        if (s.charAt(0) == '(') {
            ++count;
        } else if (s.charAt(0) == ')') {
            --count;
        }
        return count >= 0 && match(s.substring(1), count);
    }
}

//OpCalculator.java
package lisp;

public class OpCalculator {
    private static final String ERROR = "error";

    public String calculate(String inputStr) {
        if (!new BracketRecursivelyMatcher().match(inputStr)) {
            return ERROR;
        }

        return calculateValue(inputStr);
    }

    private String calculateValue(String inputStr) {
        int value;
        try {
            value = ParameterUtils.getValue(inputStr);
        } catch (Exception e) {
            return ERROR;
        }
        return String.valueOf(value);
    }
}

//OpP1P2.java
package lisp;

import java.util.Objects;

public class OpP1P2 {
    private OpType opType;
    private String p1;
    private String p2;

    public OpP1P2() {
    }

    public OpP1P2(OpType opType, String p1, String p2) {
        this.opType = opType;
        this.p1 = p1;
        this.p2 = p2;
    }

    public OpType getOpType() {
        return opType;
    }

    public void setOpType(OpType opType) {
        this.opType = opType;
    }

    public String getP1() {
        return p1;
    }

    public void setP1(String p1) {
        this.p1 = p1;
    }

    public String getP2() {
        return p2;
    }

    public void setP2(String p2) {
        this.p2 = p2;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OpP1P2 opP1P2 = (OpP1P2) o;
        return opType == opP1P2.opType &&
            Objects.equals(p1, opP1P2.p1) &&
            Objects.equals(p2, opP1P2.p2);
    }

    @Override
    public int hashCode() {
        return Objects.hash(opType, p1, p2);
    }

    @Override
    public String toString() {
        return "OpP1P2{" +
            "opType=" + opType +
            ", p1='" + p1 + '\'' +
            ", p2='" + p2 + '\'' +
            '}';
    }
}

//OpP1P2Spliter.java
package lisp;

import java.util.Stack;

import org.apache.commons.lang3.tuple.MutablePair;

public class OpP1P2Spliter {
    private Stack<Integer> firstBracketPositionStack = new Stack<>();
    private int segmentNumber = 1;
    private MutablePair<Integer, Integer> lastBracketPosPair = new MutablePair<>();

    public OpP1P2 parse(String inputStr) {
        return getOpP1P2(inputStr);
    }

    private OpP1P2 getOpP1P2(String inputStr) {
        OpP1P2 opP1P2 = new OpP1P2();
        int i = 0;
        for (; i < inputStr.length(); ++i) {
            char c = inputStr.charAt(i);
            if (c == '(') {
                firstBracketPositionStack.push(i);
                if (isProcessingFirstBracket()) {
                    lastBracketPosPair.setLeft(i + 1);
                }
            } else if (c == ')') {
                fillBracketPair(i);
            } else if (c == ' ' && isProcessingFirstBracket()) {
                getAndFillOpP1P2Attr(opP1P2, inputStr, i);
            }
        }

        getAndFillOpP1P2Attr(opP1P2, inputStr, i - 1);
        return opP1P2;
    }

    private boolean isProcessingFirstBracket() {
        return firstBracketPositionStack.size() == 1;
    }

    private void fillBracketPair(int matchedBracketPos) {
        int previousBracketPos = firstBracketPositionStack.pop();
        if (isProcessingFirstBracket()) {
            lastBracketPosPair.setLeft(previousBracketPos);
            lastBracketPosPair.setRight(matchedBracketPos);
        }
    }

    private void getAndFillOpP1P2Attr(OpP1P2 opP1P2, String inputStr, int spacePos) {
        Integer leftBracketPos = lastBracketPosPair.getLeft();
        Integer rightBracketPos = lastBracketPosPair.getRight();
        if (leftBracketPos != null && rightBracketPos != null) {
            //这里匹配上括号了
            String subString = inputStr.substring(leftBracketPos, rightBracketPos + 1);
            fillOpP1P2AttrValue(opP1P2, subString);

            lastBracketPosPair.setLeft(rightBracketPos + 2);
            lastBracketPosPair.setRight(null);
        } else if (leftBracketPos != null) {
            //这里是空格匹配上或者最后P2匹配上
            String subString = inputStr.substring(leftBracketPos, spacePos);
            fillOpP1P2AttrValue(opP1P2, subString);

            lastBracketPosPair.setLeft(spacePos + 1);
            lastBracketPosPair.setRight(null);
        }
    }

    private void fillOpP1P2AttrValue(OpP1P2 opP1P2, String subString) {
        if (segmentNumber == 1) {
            opP1P2.setOpType(OpType.fromStr(subString));
        } else if (segmentNumber == 2) {
            opP1P2.setP1(subString);
        } else {
            opP1P2.setP2(subString);
        }
        ++segmentNumber;
    }
}

//
package lisp;

import java.util.HashMap;
import java.util.Map;

public enum OpType {
    ADD("add") {
        public int getOpValue(int p1, int p2) {
            return p1 + p2;
        }
    },
    SUB("sub") {
        public int getOpValue(int p1, int p2) {
            return p1 - p2;
        }
    },
    MUL("mul") {
        public int getOpValue(int p1, int p2) {
            return p1 * p2;
        }
    },
    DIV("div") {
        public int getOpValue(int p1, int p2) {
            return p1 / p2;
        }
    };

    private static final Map<String, OpType> STRING_TO_ENUM_MAP = new HashMap<>();

    static {
        for (OpType e : OpType.values()) {
            STRING_TO_ENUM_MAP.put(e.getOpStr(), e);
        }
    }

    private final String opStr;

    OpType(String opStr) {
        this.opStr = opStr;
    }

    public String getOpStr() {
        return opStr;
    }

    public static OpType fromStr(String s) {
        return STRING_TO_ENUM_MAP.get(s);
    }

    abstract public int getOpValue(int p1, int p2);
}

//ParameterUtils.java
package lisp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ParameterUtils {

    public static int getValue(String str) {
        if (isNumeric(str)) {
            return Integer.valueOf(str);
        } else {
            OpP1P2 opP1P2 = new OpP1P2Spliter().parse(str);
            OpType opType = opP1P2.getOpType();
            int p1Value = getValue(opP1P2.getP1());
            int p2Value = getValue(opP1P2.getP2());
            return opType.getOpValue(p1Value, p2Value);
        }
    }

    public static boolean isNumeric(String str) {
        Pattern pattern = Pattern.compile("[-0-9]*");
        Matcher isNum = pattern.matcher(str);
        if(!isNum.matches()){
            return false;
        }
        return true;
    }
}

//OpCalculatorTest.java
package lisp;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class OpCalculatorTest {
    @Test
    public void testOpCalculator() {
        OpCalculator opCalculator = new OpCalculator();

        String inputStr = "(mul 3 -7)";
        assertEquals("-21", opCalculator.calculate(inputStr));

        inputStr = "(add 1 2)";
        assertEquals("3", opCalculator.calculate(inputStr));

        inputStr = "(sub (mul 2 4) (div 9 3))";
        assertEquals("5", opCalculator.calculate(inputStr));

        inputStr = "(div 1 0)";
        assertEquals("error", opCalculator.calculate(inputStr));
    }
}

//OpP1P2SpliterTest.java
package lisp;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class OpP1P2SpliterTest {

    @Test
    public void testOneOpAdd() {
        String inputStr = "(add 1 2)";
        OpP1P2 opP1P2 = new OpP1P2(OpType.ADD, "1", "2");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOneOpSub() {
        String inputStr = "(sub 1 2)";
        OpP1P2 opP1P2 = new OpP1P2(OpType.SUB, "1", "2");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOneOpMul() {
        String inputStr = "(mul 1 2)";
        OpP1P2 opP1P2 = new OpP1P2(OpType.MUL, "1", "2");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOneOpDiv() {
        String inputStr = "(div 1 2)";
        OpP1P2 opP1P2 = new OpP1P2(OpType.DIV, "1", "2");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOpInP1() {
        String inputStr = "(div (sub 1 2) 2)";
        OpP1P2 opP1P2 = new OpP1P2(OpType.DIV, "(sub 1 2)", "2");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOpInP2() {
        String inputStr = "(div 1 (sub 1 2))";
        OpP1P2 opP1P2 = new OpP1P2(OpType.DIV, "1", "(sub 1 2)");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testOpInP1P2() {
        String inputStr = "(div (mul 1 2) (sub 1 2))";
        OpP1P2 opP1P2 = new OpP1P2(OpType.DIV, "(mul 1 2)", "(sub 1 2)");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }

    @Test
    public void testTwoOpsInP1() {
        String inputStr = "(div (mul (add 1 2) 2) (sub 1 2))";
        OpP1P2 opP1P2 = new OpP1P2(OpType.DIV, "(mul (add 1 2) 2)", "(sub 1 2)");
        assertEquals(opP1P2, new OpP1P2Spliter().parse(inputStr));
    }
}

//ParameterUtilsTest.java
package lisp;

import org.junit.Test;

import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertTrue;

public class ParameterUtilsTest {
    @Test
    public void testIsNumeric() {
        assertTrue(ParameterUtils.isNumeric("123"));
        assertTrue(ParameterUtils.isNumeric("-123"));
    }

    @Test
    public void testGetValueAdd() {
        assertEquals(3, ParameterUtils.getValue("(add 1 2)"));
    }

    @Test
    public void testGetValueSub() {
        assertEquals(-1, ParameterUtils.getValue("(sub 1 2)"));
    }

    @Test
    public void testGetValueMul() {
        assertEquals(8, ParameterUtils.getValue("(mul 4 2)"));
    }

    @Test
    public void testGetValueDiv() {
        assertEquals(2, ParameterUtils.getValue("(div 4 2)"));
    }

    @Test
    public void testGetValueOpInP1() {
        assertEquals(5, ParameterUtils.getValue("(add (add 1 2) 2)"));
    }

    @Test
    public void testGetValueOpInP1P2() {
        assertEquals(12, ParameterUtils.getValue("(add (add 1 2) (add 4 5))"));
    }

    @Test
    public void testGetValueOpsInP1P2() {
        assertEquals(23, ParameterUtils.getValue("(add (add (mul 3 4) 2) (add 4 5))"));
    }
}
//------------------------------------------------------------------------------------------------
//26进制字母与数字转换
package programtest;

import java.util.Scanner;

public class Main {
    private static final String ERROR_STR = "ERROR";

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            System.out.println(convertTo26(in.next()));
        }
    }

    public static String convertTo26(String inputStr) {
        String alphaRegex = "[a-z]{1,6}";
        String digitRegex = "[0-9]*";

        if (inputStr.matches(alphaRegex)) {
            int result = inputStr.chars().reduce(0, (count, c) -> count * 26 + c - 'a' + 1);
            return String.valueOf(result);
        } else if (inputStr.matches(digitRegex)) {
            try {
                StringBuilder sb = new StringBuilder();
                int inputDigit = Integer.parseInt(inputStr);
                while (inputDigit > 0) {
                    char lastChar = (char) (inputDigit % 26 == 0 ? 'z' : 'a' + inputDigit % 26 - 1);
                    sb.append(lastChar);
                    inputDigit = inputDigit / 26;
                }
                return sb.reverse().toString();
            } catch (Exception e) {
                return ERROR_STR;
            }
        }

        return ERROR_STR;
    }
}

//10进制转2进制
2进制 | 10进制数 | 余数
----------------------
2     | 10       | 0
      ------
2     | 5        | 1
      ------
2     | 2        | 0
      ------
2     | 1        | 1
      ------
        0
将余数取反即可

//------------------------------------------------------------------------------------------------
//判断德州扑克牌型
//CardsTypeJudger.java
package cardstype;

import cardstype.impl.CardsTypeProcessorImplUtils;

import java.util.ArrayList;
import java.util.List;

public class CardsTypeJudger {
    private static final int INPUT_STR_LENGTH = 10;

    /**
     * @param inputStr 10个长度的字符串，每2个连续字符表示一张牌，第1个字符表示数字，第2个字符表示花色；
     *                 2-9，T，JQKA表示1到13，花色表示：方片用d(diamonds), 梅花c(clubs)，红桃h(hearts)，黑桃s(spades)
     *                 如：3s5c4d1s2h表示黑桃3、梅花5、方片4、黑桃1、红桃2
     *                 不用考虑非法输入情况
     * @return 返回牌型，如上例3s5c4d1s2h为顺子，返回5
     * 五张牌，每张牌由牌大小和花色组成，牌大小2~10、J、Q、K、A，牌花色为红桃、黑桃、梅花、方块四种花色之一。 判断牌型:
     * 牌型1，同花顺：同一花色的顺子，如红桃2红桃3红桃4红桃5红桃6。
     * 牌型2，四条：四张相同数字 + 单张，如红桃A黑桃A梅花A方块A + 黑桃K。
     * 牌型3，葫芦：三张相同数字 + 一对，如红桃5黑桃5梅花5 + 方块9梅花9。
     * 牌型4，同花：同一花色，如方块3方块7方块10方块J方块Q。
     * 牌型5，顺子：花色不一样的顺子，如红桃2黑桃3红桃4红桃5方块6。
     * 牌型6，三条：三张相同 + 两张单。
     * 牌型7，其他。
     * 说明：
     * 1）五张牌里不会出现牌大小和花色完全相同的牌。
     * 2）前面的牌型比后面的牌型大，如同花顺比四条大，依次类推。
     */
    public int getCardsType(String inputStr) {
        if (inputStr.length() != INPUT_STR_LENGTH) {
            throw new IllegalArgumentException("Input str is invalid");
        }

        List<PokeCard> pokeCards = parseStrToPokeCards(inputStr);
        CardsTypeProcessorImplUtils.preProcessPokeCards(pokeCards);
        CardsTypeProcessor cardsTypeProcessor = CardsTypeProcessorImplUtils.getCardsTypeProcessor();
        return cardsTypeProcessor.getCardsType(pokeCards);
    }

    private List<PokeCard> parseStrToPokeCards(String inputStr) {
        List<PokeCard> pokeCards = new ArrayList<>();
        for (int i = 0; i < inputStr.length(); i = i + 2) {
            char numberChar = inputStr.charAt(i);
            char typeChar = inputStr.charAt(i + 1);
            PokeCard pokeCard = PokeCard.fromTwoChars(numberChar, typeChar);
            pokeCards.add(pokeCard);
        }
        return pokeCards;
    }
}

//CardType.java
package cardstype;

import java.util.HashMap;
import java.util.Map;

public enum CardType {
    DIAMONDS("d"), CLUBS("c"), HEARTS("h"), SPADES("s");

    private static final Map<String, CardType> STRING_CARD_MAP = new HashMap<>();
    static {
        for (CardType cardType : CardType.values()) {
            STRING_CARD_MAP.put(cardType.typeStr, cardType);
        }
    }

    private String typeStr;

    CardType(String typeStr) {
        this.typeStr = typeStr;
    }

    public String getTypeStr() {
        return typeStr;
    }

    public static CardType fromChar(char typeChar) {
        return STRING_CARD_MAP.get(String.valueOf(typeChar));
    }
}

//PokeCard.java
package cardstype;

import java.util.HashMap;
import java.util.Map;

public class PokeCard {
    private static final Map<Character, Integer> CHARACTER_INTEGER_MAP = new HashMap<Character, Integer>() {
        {
            put('T', 10);
            put('J', 11);
            put('Q', 12);
            put('K', 13);
            put('A', 1);
        }
    };

    private int cardNumber;
    private CardType cardType;

    private PokeCard(int cardNumber, CardType cardType) {
        this.cardNumber = cardNumber;
        this.cardType = cardType;
    }

    public int getCardNumber() {
        return cardNumber;
    }

    public CardType getCardType() {
        return cardType;
    }

    public static PokeCard fromTwoChars(char numberChar, char typeChar) {
        int cardNumber;
        if (Character.isDigit(numberChar)) {
            String cardStr = String.valueOf(numberChar);
            cardNumber = Integer.valueOf(cardStr);
        } else {
            cardNumber = CHARACTER_INTEGER_MAP.get(numberChar);
        }

        CardType cardType = CardType.fromChar(typeChar);
        return new PokeCard(cardNumber, cardType);
    }
}

//CardsTypeProcessor.java
package cardstype;

import java.util.List;

public interface CardsTypeProcessor {
    int getCardsType(List<PokeCard> pokeCards);

    void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor);
}

//CardsTypeRoyalStraightFlushProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeRoyalStraightFlushProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 0;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isStraightFlush(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isStraightFlush(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isAllCardsSameType(pokeCards)
            && CardsTypeProcessorImplUtils.isCardsNumberContinuousIncludingTJQKA(pokeCards);
    }
}

//CardsTypeStraightFlushProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeStraightFlushProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 1;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isStraightFlush(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isStraightFlush(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isAllCardsSameType(pokeCards)
            && CardsTypeProcessorImplUtils.isAllCardsNumberContinuous(pokeCards);
    }
}

//CardsTypeFourOfAKindProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeFourOfAKindProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 2;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isFourOfAKind(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isFourOfAKind(List<PokeCard> pokeCards) {
        return isFirstFourOfAKind(pokeCards)
            || isLastFourOfAKind(pokeCards);
    }

    private boolean isFirstFourOfAKind(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isLastFourOfAKind(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }
}

//CardsTypeFullHouseProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeFullHouseProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 3;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isFullHouse(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isFullHouse(List<PokeCard> pokeCards) {
        return is3And2FullHouse(pokeCards)
            || is2And3FullHouse(pokeCards);
    }

    private boolean is3And2FullHouse(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean is2And3FullHouse(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }
}

//CardsTypeFlushProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeFlushProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 4;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isFlush(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isFlush(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isAllCardsSameType(pokeCards);
    }
}

//CardsTypeStraightProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeStraightProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 5;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isStraight(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isStraight(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isAllCardsSameType(pokeCards)
            && CardsTypeProcessorImplUtils.isAllCardsNumberContinuous(pokeCards);
    }
}

//CardsTypeThreeOfAKindProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeThreeOfAKindProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 6;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isThreeOfAKind(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isThreeOfAKind(List<PokeCard> pokeCards) {
        return isFirstThreeOfAKind(pokeCards)
            || isMiddleThreeOfAKind(pokeCards)
            || isLastThreeOfAKind(pokeCards);
    }

    private boolean isFirstThreeOfAKind(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isMiddleThreeOfAKind(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isLastThreeOfAKind(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }
}

//CardsTypeTwoPairProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeTwoPairProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 7;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isTwoPair(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isTwoPair(List<PokeCard> pokeCards) {
        return isFirstSingle(pokeCards)
            || isMiddleSingle(pokeCards)
            || isLastSingle(pokeCards);
    }

    private boolean isFirstSingle(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isMiddleSingle(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isLastSingle(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }
}

//CardsTypeOnePairProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;
import java.util.Optional;

public class CardsTypeOnePairProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 8;
    private CardsTypeProcessor nextCardsTypeProcessor;

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
        this.nextCardsTypeProcessor = nextCardsTypeProcessor;
    }

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        if (isOnePair(pokeCards)) {
            return CARDS_TYPE_NUMBER;
        }
        return Optional.of(nextCardsTypeProcessor).map(e -> e.getCardsType(pokeCards)).orElseThrow(NullPointerException::new);
    }

    private boolean isOnePair(List<PokeCard> pokeCards) {
        return isFirst2Pair(pokeCards)
            || isSecond2Pair(pokeCards)
            || isThird2Pair(pokeCards)
            || isFourth2Pair(pokeCards);
    }

    private boolean isFirst2Pair(List<PokeCard> pokeCards) {
        return CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isSecond2Pair(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isThird2Pair(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }

    private boolean isFourth2Pair(List<PokeCard> pokeCards) {
        return !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(0), pokeCards.get(1))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(1), pokeCards.get(2))
            && !CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(2), pokeCards.get(3))
            && CardsTypeProcessorImplUtils.isTwoCardsSameNumber(pokeCards.get(3), pokeCards.get(4));
    }
}



//CardsTypeOtherProcessor.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.List;

public class CardsTypeOtherProcessor implements CardsTypeProcessor {
    private static final int CARDS_TYPE_NUMBER = 9;

    @Override
    public int getCardsType(List<PokeCard> pokeCards) {
        return CARDS_TYPE_NUMBER;
    }

    @Override
    public void setNextCardsTypeProcessor(CardsTypeProcessor nextCardsTypeProcessor) {
    }
}

//CardsTypeProcessorImplUtils.java
package cardstype.impl;

import cardstype.CardsTypeProcessor;
import cardstype.PokeCard;

import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class CardsTypeProcessorImplUtils {
    public static CardsTypeProcessor getCardsTypeProcessor() {
        CardsTypeProcessor cardsTypeRoyalStraightFlushProcessor = new CardsTypeRoyalStraightFlushProcessor();
        CardsTypeProcessor cardsTypeStraightFlushProcessor = new CardsTypeStraightFlushProcessor();
        CardsTypeProcessor cardsTypeFourOfAKindProcessor = new CardsTypeFourOfAKindProcessor();
        CardsTypeProcessor cardsTypeFullHouseProcessor = new CardsTypeFullHouseProcessor();
        CardsTypeProcessor cardsTypeFlushProcessor = new CardsTypeFlushProcessor();
        CardsTypeProcessor cardsTypeStraightProcessor = new CardsTypeStraightProcessor();
        CardsTypeProcessor cardsTypeThreeOfAKindProcessor = new CardsTypeThreeOfAKindProcessor();
        CardsTypeProcessor cardsTypeTwoPairProcessorProcessor = new CardsTypeTwoPairProcessor();
        CardsTypeProcessor cardsTypeOnePairProcessor = new CardsTypeOnePairProcessor();
        CardsTypeProcessor cardsTypeOtherProcessor = new CardsTypeOtherProcessor();

        cardsTypeRoyalStraightFlushProcessor.setNextCardsTypeProcessor(cardsTypeStraightFlushProcessor);
        cardsTypeStraightFlushProcessor.setNextCardsTypeProcessor(cardsTypeFourOfAKindProcessor);
        cardsTypeFourOfAKindProcessor.setNextCardsTypeProcessor(cardsTypeFullHouseProcessor);
        cardsTypeFullHouseProcessor.setNextCardsTypeProcessor(cardsTypeFlushProcessor);
        cardsTypeFlushProcessor.setNextCardsTypeProcessor(cardsTypeStraightProcessor);
        cardsTypeStraightProcessor.setNextCardsTypeProcessor(cardsTypeThreeOfAKindProcessor);
        cardsTypeThreeOfAKindProcessor.setNextCardsTypeProcessor(cardsTypeTwoPairProcessorProcessor);
        cardsTypeTwoPairProcessorProcessor.setNextCardsTypeProcessor(cardsTypeOnePairProcessor);
        cardsTypeOnePairProcessor.setNextCardsTypeProcessor(cardsTypeOtherProcessor);

        return cardsTypeRoyalStraightFlushProcessor;
    }

    public static void preProcessPokeCards(List<PokeCard> pokeCards) {
        pokeCards.sort(Comparator.comparingInt(PokeCard::getCardNumber));
    }

    public static boolean isTwoCardsSameNumber(PokeCard firstPokeCard, PokeCard secondPokeCard) {
        return Objects.equals(firstPokeCard.getCardNumber(), secondPokeCard.getCardNumber());
    }

    public static boolean isAllCardsSameType(List<PokeCard> pokeCards) {
        Set<String> types = pokeCards.stream().map(pokeCard -> pokeCard.getCardType().getTypeStr()).collect(Collectors.toSet());
        return types.size() == 1;
    }

    public static boolean isAllCardsNumberContinuous(List<PokeCard> pokeCards) {
        return isCardsNumberContinuousNotIncludingTJQKA(pokeCards)
            || isCardsNumberContinuousIncludingTJQKA(pokeCards);
    }

    private static boolean isCardsNumberContinuousNotIncludingTJQKA(List<PokeCard> pokeCards) {
        return pokeCards.get(0).getCardNumber() + 1 == pokeCards.get(1).getCardNumber()
            && pokeCards.get(1).getCardNumber() + 1 == pokeCards.get(2).getCardNumber()
            && pokeCards.get(2).getCardNumber() + 1 == pokeCards.get(3).getCardNumber()
            && pokeCards.get(3).getCardNumber() + 1 == pokeCards.get(4).getCardNumber();
    }

    public static boolean isCardsNumberContinuousIncludingTJQKA(List<PokeCard> pokeCards) {
        return pokeCards.get(0).getCardNumber() == 1
            && pokeCards.get(1).getCardNumber() + 1 == pokeCards.get(2).getCardNumber()
            && pokeCards.get(2).getCardNumber() + 1 == pokeCards.get(3).getCardNumber()
            && pokeCards.get(3).getCardNumber() + 1 == pokeCards.get(4).getCardNumber()
            && pokeCards.get(4).getCardNumber() == 13;
    }
}


//测试用例
//CardsTypeJudgerTest.java
package cardstype;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CardsTypeJudgerTest {
    private static CardsTypeJudger cardsTypeJudger = new CardsTypeJudger();

    @Test
    public void testOtherType() {
        String inputStr = "1s3h5d7s9d";
        assertEquals(9, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testFirstThreeOfAKindType() {
        String inputStr = "1s1h1d7s9d";
        assertEquals(6, cardsTypeJudger.getCardsType(inputStr));
        inputStr = "1s7s9d1h1d";
        assertEquals(6, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testMiddleThreeOfAKindType() {
        String inputStr = "7s7h1d7s9d";
        assertEquals(6, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testLastThreeOfAKindType() {
        String inputStr = "7s9h1d9s9d";
        assertEquals(6, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testStraightTypeNotIncludingTJQKA() {
        String inputStr = "6s8h4d5s7d";
        assertEquals(5, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testStraightTypeIncludingTJQKA() {
        String inputStr = "AsKhTdQsJd";
        assertEquals(5, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testFlushType() {
        String inputStr = "1s1s1s7s9s";
        assertEquals(4, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void test3And2FullHouseType() {
        String inputStr = "Js7dJh7s7h";
        assertEquals(3, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void test2And3FullHouseType() {
        String inputStr = "Qs7dQh7sQh";
        assertEquals(3, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testFirstFourOfAKindType() {
        String inputStr = "AsAdAh7sAc";
        assertEquals(2, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testLastFourOfAKindType() {
        String inputStr = "QsQdQh7sQc";
        assertEquals(2, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testStraightFlushTypeNotIncludingTJQKA() {
        String inputStr = "Ac2c3c4c5c";
        assertEquals(1, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testStraightFlushTypeIncludingTJQKA() {
        String inputStr = "QcTcKc9cJc";
        assertEquals(1, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testRoyalStraightFlushType() {
        String inputStr = "QcTcKcAcJc";
        assertEquals(0, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testTwoPairTypeFirstSingle() {
        String inputStr = "TcTs2c7d7h";
        assertEquals(7, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testTwoPairTypeMiddleSingle() {
        String inputStr = "TcTs2c7d2h";
        assertEquals(7, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testTwoPairTypeLastSingle() {
        String inputStr = "Tc2s2c7d7h";
        assertEquals(7, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testOnePairTypeWithFirst2Pair() {
        String inputStr = "Jc2s2c7d8h";
        assertEquals(8, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testOnePairTypeWithSecond2Pair() {
        String inputStr = "Jc2s7c7d8h";
        assertEquals(8, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testOnePairTypeWithThird2Pair() {
        String inputStr = "Jc2s8c7d8h";
        assertEquals(8, cardsTypeJudger.getCardsType(inputStr));
    }

    @Test
    public void testOnePairTypeWithFourth2Pair() {
        String inputStr = "Jc2s8c7dJh";
        assertEquals(8, cardsTypeJudger.getCardsType(inputStr));
    }
}
//------------------------------------------------------------------------------------------------
//Java 排序
//MyTask.java
package test;

public class MyTask {
    private int priority;
    private String desc;

    public MyTask(int priority, String desc) {

        this.priority = priority;
        this.desc = desc;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public int getPriority() {
        return priority;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "MyTask{" +
            "priority=" + priority +
            ", desc='" + desc + '\'' +
            '}';
    }
}

//MyTaskSorterTest.java
package test;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class MyTaskSorterTest {
    @Test
    public void testTaskSort() {
        MyTask myTask1 = new MyTask(5, "5");
        MyTask myTask2 = new MyTask(3, "first3");
        MyTask myTask3 = new MyTask(3, "second3");

        List<MyTask> myTasks = Arrays.asList(myTask1, myTask2, myTask3);
        myTasks.sort(Comparator.comparingInt(MyTask::getPriority));
//        myTasks.sort(Comparator.comparingInt(MyTask::getPriority).reversed());//对比较算法进行反向排序
        List<MyTask> expectedMyTasks = Arrays.asList(myTask2, myTask3, myTask1);
        assertEquals(expectedMyTasks, myTasks);
    }
}

//------------------------------------------------------------------------------------------------
//int数字倒序
package test;

public class Solution {
    public int reverse(int x) {
        boolean positive = x > 0;
        if (x == Integer.MIN_VALUE) {
            return 0;
        }

        int positiveInt = Math.abs(x);
        String positiveIntStr = String.valueOf(positiveInt);
        StringBuilder sbOfPositiveIntStr = new StringBuilder(positiveIntStr);
        if (!positive) {
            sbOfPositiveIntStr.append('-');
        }
        String reverseIntStr = sbOfPositiveIntStr.reverse().toString();

        int reverseInt = 0;
        try {
            reverseInt = Integer.valueOf(reverseIntStr);
        } catch (NumberFormatException e) {
        }
        return reverseInt;
    }

    public static void main(String[] args) {
        int i = Integer.valueOf("2147483647");
        System.out.println(Math.abs(-2147483648));
    }
}

//优化过的
public int reverse(int x) {
    boolean positive = x > 0;
    if (x == Integer.MIN_VALUE) {
        return 0;
    }

    int positiveInt = Math.abs(x);
    StringBuilder sbOfPositiveInt = new StringBuilder();
    reverseByStringBuilder(sbOfPositiveInt, positiveInt);
    if (!positive) {
        sbOfPositiveInt.insert(0, '-');
    }

    int reverseInt = 0;
    try {
        reverseInt = Integer.valueOf(sbOfPositiveInt.toString());
    } catch (NumberFormatException e) {
    }
    return reverseInt;
}

private void reverseByStringBuilder(StringBuilder result, int num) {
    if (num != 0) {
        result.append(num % 10);
        reverseByStringBuilder(result, num / 10);
    }
}

//Test
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class SolutionTest {
    private final Solution solution = new Solution();
    @Test
    public void test_should_when() {
        assertEquals(solution.reverse(1234), 4321);
        assertEquals(solution.reverse(-1234), -4321);
        assertEquals(solution.reverse(120), 21);
        assertEquals(solution.reverse(0), 0);
        assertEquals(solution.reverse(2147483647), 0);
        assertEquals(solution.reverse(-2147483648), 0);
    }
}
//------------------------------------------------------------------------------------------------
//LastCalculator.java
package test;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class LastCalculator {

    private static final int REMOVED_POSITION = -1;

    /**
     * maxNumber：最大有多少编号的人坐成一桌；
     * interval：大家从1、2、3。。。开始报数，数到interval编号，则排除此人，其余人再从1、2开始报数，直到剩最后一人
     * 返回值：剩下的最后一个人编号
     */
    public static int getLast(int maxNumber, int interval) {
        assert maxNumber > 1 && interval > 0 : "Input args wrong";

        List<Integer> numberList = IntStream.range(1, maxNumber + 1).boxed().collect(Collectors.toList());
        int leftNumber = maxNumber;
        int index = 0;
        int countNumber = 0;

        while (leftNumber != 1) {
            //如果当前位置有人，则将计数加1
            if (numberList.get(index) > 0) {
                ++countNumber;
                //如果计数等于interval，则将此位置删除
                if (countNumber == interval) {
                    numberList.set(index, REMOVED_POSITION);
                    --leftNumber;
                    countNumber = 0;
                }
            }

            ++index;
            //如果遍历超过了List，则重新从第0个位置开始
            if (index == maxNumber) {
                index = 0;
            }
        }

        return numberList.stream().filter(e -> e > 0).findFirst().orElse(REMOVED_POSITION);
    }
}

//LastCalculatorTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class LastCalculatorTest {

    @Test
    public void testGetLast_shouldReturn1_whenInput3And1() {
        assertEquals(3, LastCalculator.getLast(3, 1));
    }

    @Test
    public void testGetLast_shouldReturn3_whenInput3And2() {
        assertEquals(3, LastCalculator.getLast(3, 2));
    }

    @Test
    public void testGetLast_shouldReturn2_whenInput3And3() {
        assertEquals(2, LastCalculator.getLast(3, 3));
    }

    @Test
    public void testGetLast_shouldReturn1_whenInput5And4() {
        assertEquals(1, LastCalculator.getLast(5, 4));
    }

    @Test
    public void testGetLast_shouldReturn3_whenInput4And6() {
        assertEquals(3, LastCalculator.getLast(4, 6));
    }
}
//------------------------------------------------------------------------------------------------
//Java解析json（依赖fastjson-1.2.28.jar）
//JsonUtils.java
package test;


import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

public class JsonUtils {

    public static Object select(JSONObject jsonObj, String keyPath, String indexPath) {
        if (null == jsonObj || null == keyPath) {
            return null;
        }

        String[] pathArr = keyPath.split("\\.");
        String[] indexArr = indexPath.split("\\.");

        if (pathArr.length != indexArr.length) {
            throw new IndexOutOfBoundsException("Length of keyPath and indexPath is not equal.");
        }

        JSONObject current = jsonObj;
        Object retValue = null;
        for (int i = 0; i < pathArr.length; i++) {
            String key = pathArr[i];
            retValue = current.get(key);
            int index = Integer.valueOf(indexArr[i]) - 1;

            if (retValue instanceof JSONObject) {
                current = (JSONObject) retValue;
            } else if (retValue instanceof JSONArray) {
                JSONArray jsonArrayValue = (JSONArray) retValue;
                current = jsonArrayValue.getJSONObject(index);
                retValue = current;
            }
        }
        return retValue;
    }

    public static void main(String[] args) {
        String jsonStr = readString3("src/test/fight.json");
        try {
            JSONObject jsonObject = JSONObject.parseObject(jsonStr);
            Object ret = JsonUtils.select(jsonObject, "AppFlightSearchResponse.flightSegmentResult.flightObject", "1.1.1");
            System.out.println(ret);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static String readString3(String filePath) {
        String str = "";
        File file = new File(filePath);
        try {
            FileInputStream in = new FileInputStream(file);
            // size  ????????? ??????????????
            int size = in.available();
            byte[] buffer = new byte[size];
            in.read(buffer);
            in.close();
            str = new String(buffer, "UTF-8");
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
        return str;
    }
}

//------------------------------------------------------------------------------------------------
//使用dom4j解析xml（依赖dom4j-1.6.1.jar、jaxen-1.1.6.jar）
//Dom4jParseXml.java
package test;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.List;

public class Dom4jParseXml {
    // private static final Logger log = LoggingManager.getLoggerForClass();
    public Document doc;
    private SAXReader reader = new SAXReader();

    //构造函数
    public Dom4jParseXml(String xml) throws Exception {
        InputStream in = new ByteArrayInputStream(xml.getBytes("utf-8"));
        doc = reader.read(in);
        in.close();
    }

    //获取text方法
    public String getNodeText(String xpath, int index) {
        String test = "";
        List nodes = doc.selectNodes(xpath);

        if (nodes.size() > index) {
            Element node = (Element) nodes.get(index);
            test = node.getText();
        }

        return test;
    }
}


//DomParseData.java
package test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class DomParseData {
    Dom4jParseXml dom;

    public DomParseData(String response) {
        try {
            dom = new Dom4jParseXml(response);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取节点的text
     */
    public String domParseData(String xpath, int index) throws Exception {
        //    log.info("传入的路径为："+xpath+"  索引："+index);
        return dom.getNodeText(xpath, index - 1);
    }

    public static void main(String[] args) {
        //String responseXml = readString3("src/test/fight.json");
        String responseXml = readString3("src/test/ResponseData.xml");
//        System.out.println(responseXml);
        try {
            DomParseData domParseData = new DomParseData(responseXml);

            String ret = domParseData.domParseData("//ns2:policyId", 1);
            System.out.println(ret);
            ret = domParseData.domParseData("//ns2:settlement", 1);
            System.out.println(ret);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static String readString3(String filePath) {
        String str = "";
        File file = new File(filePath);
        try {
            FileInputStream in = new FileInputStream(file);
            // size  为字串的长度 ，这里一次性读完
            int size = in.available();
            byte[] buffer = new byte[size];
            in.read(buffer);
            in.close();
            str = new String(buffer, "UTF-8");
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
        return str;
    }
}

//-----
package test;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.util.Iterator;
import java.util.List;

public class ResponseDataParser {
    public static void main(String[] args) throws Exception {
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(new File("src/test/ResponseData.xml"));
        Element root = document.getRootElement();
        System.out.println("Root:" + root.getName());
        List<Element> childList = root.elements();
        // List<Element> litterchildList=childList.elements();
        for (Element subChild : childList) {
            printNodes(subChild.elements());
            printAttribute(subChild);
        }
        //printNodes(childList);

        //Element policyId = (Element) root.selectSingleNode("//ns4:policyId[contains(text(),'|0|0|')]");
        Element policyId = (Element) root.selectSingleNode("//ns2:policyId");
//        List<Element> policyIds = root.selectNodes("//ns4:policyId");
        System.out.println(policyId.getText());

        Element policyIdParent = policyId.getParent();
        System.out.println(policyIdParent.getName());


    }

    private static void printAttribute(Element e) {
        Iterator<Attribute> attributes = e.attributeIterator();
        while (attributes.hasNext()) {
            Attribute attribute = attributes.next();
            System.out.println(attribute.getName() + "<-->" + attribute.getValue());
        }
    }

    private static void printNodes(List<Element> childList) {
        for (Element e : childList) {
            //if ("wangwu2".equals(e.attributeValue("name"))) {
            System.out.println(e.getName());
            //e.sele
        }
    }
}
//------------------------------------------------------------------------------------------------
//http://blog.csdn.net/lonely_fireworks/article/details/7962171/
//Java格式化输出 http://blog.sina.com.cn/s/blog_416bfbd90101nm0r.html
从JDK 1.5 版本以后，java.io.PrintWriter类中有以下格式化输出方法：
PrintWriter format(Locale l, String format, Object… args)
PrintWriter format(String format, Object… args)
PrintWriter printf(Locale l, String format, Object… args)
PrintWriter printf(String format, Object… args)

以下是JDK文档的说明：
使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区。

【参数】：
l C 格式化过程中应用的 locale。如果 l 为 null，则不应用本地化。
format C 在格式字符串的语法中描述的格式字符串。
args C 格式字符串中的格式说明符引用的参数。如果参数多于格式说明符，则忽略额外的参数。参数的数量是可变的，并且可以为零。参数的最大数量受到 Java Virtual Machine Specification 定义的 Java 数组的最大维数的限制。针对 null 参数的行为依赖于 conversion。
【注】：format(String format, Object… args) 与printf(String format, Object… args)始终使用的语言环境是由 Locale.getDefault() 返回的语言环境，不管以前在此对象上调用了其他什么样的格式化方法。
【抛出】：
IllegalFormatException C 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、对给定格式字符串而言不够充足的参数或其他非法条件。有关所有可能的格式错误的规范，请参阅 formatter 类规范的详细信息部分。
NullPointerException C 如果 format 为 null
以上四个方法中两对相应的调用方法和效果完全相同。

字符串：
%s表示输出字符串；
%S将字符串以大写形式输出；

boolean类型：
%b输出boolean类型，false和null的值为false，其余好像都是true（包括数字0和字符串“false”）；
%B输出大写的boolean类型TRUE和FALSE。
 
整数类型：
%d表示将整数格式化为10进制整数，%-d输出带符号位的10进制数；
%o表示将整数格式化为8进制整数；
%x表示将整数格式化为16进制整数；
%X表示将整数格式化为16进制整数，并且字母变成大写形式；
【注意】以上只有%-d的带符号格式，没有%+d、%+o、%-o等形式，只可转换整数类型（Integer：byte， short， int， long）。
 
浮点类型：
%f表示以十进制格式化输出浮点数
%.3f 表示以十进制格式化输出浮点数，不足末尾补0；
%e表示以科学技术法输出浮点数
%E表示以科学技术法输出浮点数，并且为大写形式，如-1.5E+03;
【注意】以上都有形如%+f的形式输出带符号的浮点数值，但是没有%-f的类型，只可转换浮点类型（Floating：float，double）。
 
日期类型：
%t或%T之后用c（%tc）表示输出时间日期的完整信息；
%t或%T之后用y（%ty）表示输出日期的年份（2位数的年，如12）；
%t或%T之后用Y（%tY）表示输出日期的年份（4位数的年，如2012）；
%t或%T之后用m（%tm）表示输出日期的月份；
%t或%T之后用M（%tM）表示输出日期的分钟；
%t或%T之后用d（%td）表示输出日期的日号；
%t或%T之后用H表示输出时间的时（24进制）；
%t或%T之后用I表示输出时间的时（12进制）；
%t或%T之后用M表示输出时间的分；
%t或%T之后用S表示输出时间的秒；
%t或%T之后用L表示输出时间的秒中的毫秒；
%t或%T之后p表示输出时间的上午或下午信息；
%t或%T之后用A表示得到星期几的全称；
%t或%T之后用a表示得到星期几的简称；
%t或%T之后用D表示以 “%tm/%td/%ty”格式化日期；
%t或%T之后用F表示以”%tY-%tm-%td”格式化日期；
%t或%T之后用R表示以”%tH:%tM”格式化时间；
%t或%T之后用T表示以”%tH:%tM:%tS”格式化时间；
%t或%T之后用r表示以”%tI:%tM:%tS %Tp”格式化时间；
【注意】以上不可添加符号位（+、-）。
 
换行：
%n表示换行。

指定长度值输出：
在格式中间添加数字指定值的输出长度，长用于对齐输出。如 s表示输出长度为20的字符串，不足在前面补空格，%-20d表示输出长度为20的整形数字，不足在后面补空格，没有%+20d的格式。

指定第几个参数：
多个参数时，可以在格式中间插入变量编号，如%1$s表示第一个字符串，%3$s表示第3个字符串。
//------------------------------------------------------------------------------------------------
//深入理解Java的接口和抽象类
http://www.cnblogs.com/felixzh/p/5938544.html
三.抽象类和接口的区别
1. 语法层面上的区别
　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。
2. 设计层面上的区别
　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。
　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

　　下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：
abstract class Door {
    public abstract void open();
    public abstract void close();
}
或者：
interface Door {
    public abstract void open();
    public abstract void close();
}
但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：
　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；
　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。
　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。
interface Alram {
    void alarm();
}
 
abstract class Door {
    void open();
    void close();
}
 
class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}
//------------------------------------------------------------------------------------------------
//括号匹配
//
package test;

public interface BracketMatcher {
    boolean match(String s);
}

//
package test;

public class BracketRecursivelyMatcher implements BracketMatcher {
    @Override
    public boolean match(String s) {
        return match(s, 0);
    }

    private boolean match(String s, int count) {
        if (s.isEmpty()) {
            return count == 0;
        }

        if (s.charAt(0) == '(') {
            ++count;
        } else if (s.charAt(0) == ')') {
            --count;
        }
        return count >= 0 && match(s.substring(1), count);
    }
}

//
package test;

public class BracketLambdaMatcher implements BracketMatcher {
    @Override
    public boolean match(String s) {
        return 0 == s.chars().reduce(0, (count, c) -> {
            if (count >= 0) {
                if (c == '(') {
                    ++count;
                } else if (c == ')') {
                    --count;
                }
            }
            return count;
        });
    }
}


//
package test;

import org.junit.Test;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class BracketMatcherTest {

    private final BracketMatcher bracketRecursivelyMatcher = new BracketRecursivelyMatcher();
    private final BracketMatcher bracketLambdaMatcher = new BracketLambdaMatcher();

    @Test
    public void testBracketRecursivelyBracket_shouldMatchSmallBracket() {
        matchBrackets(bracketRecursivelyMatcher, "()()");
    }

    @Test
    public void testBracketRecursivelyBracket_shouldMatchInnerSmallBracket() {
        matchBrackets(bracketRecursivelyMatcher, "(())");
    }

    @Test
    public void testBracketRecursivelyBracket_shouldNotMatch() {
        notMatchBrackets(bracketRecursivelyMatcher, ")()(");
    }

    @Test
    public void testBracketLambdaMatcher_shouldMatchSmallBracket() {
        matchBrackets(bracketLambdaMatcher, "()()");
    }

    @Test
    public void testBracketLambdaMatcher_shouldMatchInnerSmallBracket() {
        matchBrackets(bracketLambdaMatcher, "(())");
    }

    @Test
    public void testBracketLambdaBracket_shouldNotMatch() {
        notMatchBrackets(bracketLambdaMatcher, ")()(");
    }

    private void matchBrackets(BracketMatcher bracketMatcher, String s) {
        assertTrue(bracketMatcher.match(s));
    }

    private void notMatchBrackets(BracketMatcher bracketMatcher, String s) {
        assertFalse(bracketMatcher.match(s));
    }
}

//-----
//String转List<Character>
String big_data = "big-data";
ArrayList<Character> chars
   = new ArrayList<>(
   big_data.chars()
       .mapToObj(e -> (char) e)
       .collect(
           Collectors.toList()
       )
);
//------------------------------------------------------------------------------------------------
//Mockito Unit tests with Mockito - Tutorial
http://www.vogella.com/tutorials/Mockito/article.html
翻译版：http://www.jianshu.com/p/f6e3ab9719b9

4.3. 配置 mock
当我们需要配置某个方法的返回值的时候，Mockito 提供了链式的 API 供我们方便的调用
when(…?.).thenReturn(…?.)可以被用来定义当条件满足时函数的返回值，如果你需要定义多个返回值，可以多次定义。当你多次调用函数的时候，Mockito 会根据你定义的先后顺序来返回返回值。Mocks 还可以根据传入参数的不同来定义不同的返回值。譬如说你的函数可以将anyString 或者 anyInt作为输入参数，然后定义其特定的放回值。

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

@Test
public void test1()  {
        //  创建 mock
        MyClass test = Mockito.mock(MyClass.class);

        // 自定义 getUniqueId() 的返回值
        when(test.getUniqueId()).thenReturn(43);

        // 在测试中使用mock对象
        assertEquals(test.getUniqueId(), 43);
}

// 返回多个值
@Test
public void testMoreThanOneReturnValue()  {
        Iterator i= mock(Iterator.class);
        when(i.next()).thenReturn("Mockito").thenReturn("rocks");
        String result=i.next()+" "+i.next();
        // 断言
        assertEquals("Mockito rocks", result);
}

// 如何根据输入来返回值
@Test
public void testReturnValueDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo("Mockito")).thenReturn(1);
        when(c.compareTo("Eclipse")).thenReturn(2);
        // 断言
        assertEquals(1,c.compareTo("Mockito"));
}

// 如何让返回值不依赖于输入
@Test
public void testReturnValueInDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo(anyInt())).thenReturn(-1);
        // 断言
        assertEquals(-1 ,c.compareTo(9));
}

// 根据参数类型来返回值
@Test
public void testReturnValueInDependentOnMethodParameter()  {
        Comparable c= mock(Comparable.class);
        when(c.compareTo(isA(Todo.class))).thenReturn(0);
        // 断言
        Todo todo = new Todo(5);
        assertEquals(todo ,c.compareTo(new Todo(1)));
}

对于无返回值的函数，我们可以使用doReturn(…?).when(…?).methodCall来获得类似的效果。例如我们想在调用某些无返回值函数的时候抛出异常，那么可以使用doThrow 方法。如下面代码片段所示
package test;

import org.junit.Test;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;

import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;

public class MockTest {

    @Test(expected = IOException.class)
    public void testForIOException() throws IOException {
        // 创建并配置 mock 对象
        OutputStream mockStream = mock(OutputStream.class);
        doThrow(new IOException()).when(mockStream).close();

        // 使用 mock
        OutputStreamWriter streamWriter= new OutputStreamWriter(mockStream);
        streamWriter.close();
    }
}


4.4. 验证 mock 对象方法是否被调用
Mockito 会跟踪 mock 对象里面所有的方法和变量。所以我们可以用来验证函数在传入特定参数的时候是否被调用。这种方式的测试称行为测试，行为测试并不会检查函数的返回值，而是检查在传入正确参数时候函数是否被调用。

import static org.mockito.Mockito.*;

@Test
public void testVerify()  {
        // 创建并配置 mock 对象
        MyClass test = Mockito.mock(MyClass.class);
        when(test.getUniqueId()).thenReturn(43);

        // 调用mock对象里面的方法并传入参数为12
        test.testing(12);
        test.getUniqueId();
        test.getUniqueId();

        // 查看在传入参数为12的时候方法是否被调用
        verify(test).testing(Matchers.eq(12));//testing测试方法没有找到在哪个包中？

        // 方法是否被调用两次
        verify(test, times(2)).getUniqueId();

        // 其他用来验证函数是否被调用的方法
        verify(mock, never()).someMethod("never called");
        verify(mock, atLeastOnce()).someMethod("called at least once");
        verify(mock, atLeast(2)).someMethod("called at least twice");
        verify(mock, times(5)).someMethod("called five times");
        verify(mock, atMost(3)).someMethod("called at most 3 times");
}


4.5. 使用 Spy 封装 java 对象
@Spy或者spy()方法可以被用来封装 java 对象。被封装后，除非特殊声明（打桩 stub），否则都会真正的调用对象里面的每一个方法
package test;

import org.junit.Test;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

public class MockTest {

    @Test(expected = IndexOutOfBoundsException.class)
    public void testForIOException() throws IOException {
        // Lets mock a LinkedList
        List list = new LinkedList();
        List spy = spy(list);

        // 可用 doReturn() 来打桩
        doReturn("foo").when(spy).get(0); //如果这里定义doReturn("foo").when(spy).get(anyInt());则不会抛出异常
        // 或用如下语句打桩
        //when(spy.get(0)).thenReturn("foo");
        assertEquals("foo", spy.get(0));

        // 如果某个方法未被打桩，则真正的方法会被调用
        // 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空
        spy.get(1);
    }
}

//对于用Spy封装的对象，也是一个Mock对象，不同点就是如果某个方法被打桩，则调用时会调用打桩方法，如果某个方法没有被打桩，调用时会调用真正的对象方法
//也可以用@Spy注解来标识Spy对象，初始化时同@Mock对象
package test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.doReturn;

public class MockTest {

    @Spy
    List<String> spyOnStrings = new ArrayList<>();

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test(expected = IndexOutOfBoundsException.class)
    public void testForIOException() {
        // 可用 doReturn() 来打桩
        doReturn("foo").when(spyOnStrings).get(0); //如果这里定义doReturn("foo").when(spy).get(anyInt());则不会抛出异常
        // 或用如下语句打桩
        //when(spy.get(0)).thenReturn("foo");
        assertEquals("foo", spyOnStrings.get(0));

        // 如果某个方法未被打桩，则真正的方法会被调用
        // 将会抛出 IndexOutOfBoundsException 的异常，因为 List 为空
        spyOnStrings.get(1);
    }
}

//-----@Capture注解
package test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;

public class MockTest {

    @Captor
    private ArgumentCaptor<Integer> integerArgumentCaptor;

    @Mock
    private List<String> strings;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testForIOException() {
        assertEquals(null, strings.get(0));
        verify(strings).get(integerArgumentCaptor.capture());
        int value = integerArgumentCaptor.getValue();
        assertEquals(0, value);
        verifyNoMoreInteractions(strings);
    }
}


//-----@InjectMocks注解
http://hotdog.iteye.com/blog/937862
通过这个注解，可实现自动注入mock对象。当前版本只支持setter的方式进行注入（但是我如下用例试了，只能通过构造函数进行依赖注入，setter函数无法进行自动注入），Mockito首先尝试类型注入，如果有多个类型相同的mock对象，那么它会根据名称进行注入。当注入失败的时候Mockito不会抛出任何异常，所以你可能需要手动去验证它的安全性。 
例： 
//
package test;

import java.util.List;
import java.util.Map;

public class DataBaseMgr {
    private List<Integer> userIds;
    private Map<Integer, String> idNameMap;

    //如果只有一个如下一个参数的构造函数，同时提供了set函数，dataBaseMgr.addIdName(4, "James");方法将抛出空指针异常，idNameMap为空对象
//    DataBaseMgr(List<Integer> userIds) {
//        this.userIds = userIds;
//    }

    //提供了两个参数的构造函数，测试用例可以运行成功
    DataBaseMgr(List<Integer> userIds, Map<Integer, String> idNameMap) {
        this.userIds = userIds;
        this.idNameMap = idNameMap;
    }


    public void setIdNameMap(Map<Integer, String> idNameMap) {
        this.idNameMap = idNameMap;
    }

    public void addUserId(int id) {
        userIds.add(id);
    }

    public void addIdName(int id, String name) {
        idNameMap.put(id, name);
    }
}

//
package test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.List;
import java.util.Map;

import static org.mockito.Mockito.verify;

public class DataBaseMgrTest {

    @Mock
    private List<Integer> userIds;

    @Mock
    private Map<Integer, String> idNameMap;

    @InjectMocks
    private DataBaseMgr dataBaseMgr;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testInjectMocks() {
        dataBaseMgr.addUserId(3);
        dataBaseMgr.addIdName(4, "James");

        verify(userIds).add(3);
        verify(idNameMap).put(4, "James");
    }
}


4.7. 捕捉参数
ArgumentCaptor类允许我们在verification期间访问方法的参数。得到方法的参数后我们可以使用它进行测试。
//
package test;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.List;

import static org.hamcrest.Matchers.hasItem;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.verify;

public class MockTest {

    @Mock
    private List<String> strings;

    @Captor
    ArgumentCaptor<List<String>> stringArgumentCaptor;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testCaptor() {
        strings.addAll(Arrays.asList("hello", "world"));
        verify(strings).addAll(stringArgumentCaptor.capture());

        List<String> capturedStrings = stringArgumentCaptor.getValue();
        assertThat(capturedStrings, hasItem("hello"));
        assertThat(capturedStrings, hasItem("world"));
    }
}

4.8. Mockito的限制
Mockito当然也有一定的限制。而下面三种数据类型则不能够被测试
final classes
anonymous classes
primitive types

8.1. 使用 Powermock 来模拟静态方法
http://huangyunbin.iteye.com/blog/2176728

因为Mockito使用继承的方式实现mock的，用CGLIB生成mock对象代替真实的对象进行执行，为了mock实例的方法，你可以在subclass中覆盖它，而static方法是不能被子类覆盖的，所以Mockito不能mock静态方法。
但PowerMock可以mock静态方法，因为它直接在bytecode上工作，类似这样：

还是以刚才的DataBaseMgr类来做测试，新增了一个getPassword方法，并且调用的是PasswordMgr的静态方法getPassword
//DataBaseMgr.java
package test;

import java.util.List;
import java.util.Map;

public class DataBaseMgr {
    private List<Integer> userIds;
    private Map<Integer, String> idNameMap;

    DataBaseMgr(List<Integer> userIds, Map<Integer, String> idNameMap) {
        this.userIds = userIds;
        this.idNameMap = idNameMap;
    }

    public void setIdNameMap(Map<Integer, String> idNameMap) {
        this.idNameMap = idNameMap;
    }

    public void addUserId(int id) {
        userIds.add(id);
    }

    public void addIdName(int id, String name) {
        idNameMap.put(id, name);
    }

    public String getUserPassword(Integer userId) {
        return PasswordMgr.getPasword(userId);
    }
}

//PasswordMgr.java
package test;

public class PasswordMgr {
    public static String getPasword(Integer userId) {
        return userId + "_hello";
    }
}

//DataBaseMgrTest.java
package test;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.util.List;
import java.util.Map;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.verify;

@RunWith(PowerMockRunner.class)
public class DataBaseMgrTest {

    @Mock
    private List<Integer> userIds;

    @Mock
    private Map<Integer, String> idNameMap;

    @InjectMocks
    private DataBaseMgr dataBaseMgr;

    //注掉initMocks也可以测试成功，据猜测PowerMockRunner.class也可以初始化@Mock对象
    // @Before
    // public void setUp() {
        // MockitoAnnotations.initMocks(this);
    // }

    @Test
    @PrepareForTest(PasswordMgr.class) //如果没有这个@PrepareForTest注解，PowerMockito.when无法无法识别静态方法
    public void testStaticMethod() {
        dataBaseMgr.addUserId(3);
        dataBaseMgr.addIdName(4, "James");

        verify(userIds).add(3);
        verify(idNameMap).put(4, "James");

        //如果PasswordMgr.getPasword这个静态方法很容易就调用了，没有复杂的依赖，那么可以直接调用其静态方法
        //assertEquals("101_hello", dataBaseMgr.getUserPassword(101));

        //如果PasswordMgr.getPasword静态方法有很多的依赖，不能很容易的调用，则需要将这个静态方法Mock掉，Mockito无法做到，只能通过PowerMockito
        PowerMockito.mockStatic(PasswordMgr.class);
        PowerMockito.when(PasswordMgr.getPasword(any())).thenReturn("password").thenReturn("helloworld");//这里的any()可以用具体的int，也可以用anyInt()
        assertEquals("password", dataBaseMgr.getUserPassword(100));
        assertEquals("helloworld", dataBaseMgr.getUserPassword(101));
    }
}


//-----PowerMock介绍
http://blog.csdn.net/jackiehff/article/details/14000779
一、为什么要使用Mock工具
在做单元测试的时候，我们会发现我们要测试的方法会引用很多外部依赖的对象，比如：（发送邮件，网络通讯，远程服务, 文件系统等等）。 而我们没法控制这些外部依赖的对象，为了解决这个问题，我们就需要用到Mock工具来模拟这些外部依赖的对象，来完成单元测试。
二、为什么要使用PowerMock
现如今比较流行的Mock工具如jMock 、EasyMock 、Mockito等都有一个共同的缺点：不能mock静态、final、私有方法等。而PowerMock能够完美的弥补以上三个Mock工具的不足。
三、PowerMock简介
PowerMock是一个扩展了其它如EasyMock等mock框架的、功能更加强大的框架。PowerMock使用一个自定义类加载器和字节码操作来模拟静态方法，构造函数，final类和方法，私有方法，去除静态初始化器等等。通过使用自定义的类加载器，简化采用的IDE或持续集成服务器不需要做任何改变。熟悉PowerMock支持的mock框架的开发人员会发现PowerMock很容易使用，因为对于静态方法和构造器来说，整个的期望API是一样的。PowerMock旨在用少量的方法和注解扩展现有的API来实现额外的功能。目前PowerMock支持EasyMock和Mockito。
四、PowerMock入门    
PowerMock有两个重要的注解：
C@RunWith(PowerMockRunner.class)
C@PrepareForTest( { YourClassWithEgStaticMethod.class })
如果你的测试用例里没有使用注解@PrepareForTest，那么可以不用加注解@RunWith(PowerMockRunner.class)，反之亦然。当你需要使用PowerMock强大功能（Mock静态、final、私有方法等）的时候，就需要加注解@PrepareForTest。
五、PowerMock基本用法
(1) 普通Mock： Mock参数传递的对象
测试目标代码：
public boolean callArgumentInstance(File file) {
     return file.exists();
}
测试用例代码： 
@Test 
public void testCallArgumentInstance() {
    File file = PowerMockito.mock(File.class); 
    ClassUnderTest underTest = new ClassUnderTest();
    PowerMockito.when(file.exists()).thenReturn(true);
    Assert.assertTrue(underTest.callArgumentInstance(file)); 
}
说明：普通Mock不需要加@RunWith和@PrepareForTest注解。
(2)  Mock方法内部new出来的对象
测试目标代码：
public class ClassUnderTest {
    public boolean callInternalInstance(String path) { 
        File file = new File(path); 
        return file.exists(); 
    } 
}
测试用例代码：    
@RunWith(PowerMockRunner.class) 
public class TestClassUnderTest {
    @Test 
    @PrepareForTest(ClassUnderTest.class) 
    public void testCallInternalInstance() throws Exception { 
        File file = PowerMockito.mock(File.class); 
        ClassUnderTest underTest = new ClassUnderTest(); 
        PowerMockito.whenNew(File.class).withArguments("bbb").thenReturn(file); 
        PowerMockito.when(file.exists()).thenReturn(true); 
        Assert.assertTrue(underTest.callInternalInstance("bbb")); 
    } 
}
说明：当使用PowerMockito.whenNew方法时，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是需要mock的new对象代码所在的类。
(3) Mock普通对象的final方法
测试目标代码：
public class ClassUnderTest {
    public boolean callFinalMethod(ClassDependency refer) { 
        return refer.isAlive(); 
    } 
}

public class ClassDependency {
    public final boolean isAlive() {
        // do something 
        return false; 
    } 
}
测试用例代码：
@RunWith(PowerMockRunner.class) 
public class TestClassUnderTest {
    @Test 
    @PrepareForTest(ClassDependency.class) 
    public void testCallFinalMethod() {
        ClassDependency depencency =  PowerMockito.mock(ClassDependency.class);
        ClassUnderTest underTest = new ClassUnderTest();
        PowerMockito.when(depencency.isAlive()).thenReturn(true);
        Assert.assertTrue(underTest.callFinalMethod(depencency));
    }
}
说明： 当需要mock final方法的时候，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是final方法所在的类。 
(4) Mock普通类的静态方法
测试目标代码：
public class ClassUnderTest {
    public boolean callStaticMethod() {
        return ClassDependency.isExist(); 
    }  
}

public class ClassDependency {
    public static boolean isExist() {
        // do something 
        return false; 
    } 
}
测试用例代码：
@RunWith(PowerMockRunner.class) 
public class TestClassUnderTest {
    @Test 
    @PrepareForTest(ClassDependency.class) 
    public void testCallStaticMethod() {
        ClassUnderTest underTest = new ClassUnderTest();
        PowerMockito.mockStatic(ClassDependency.class); 
        PowerMockito.when(ClassDependency.isExist()).thenReturn(true);
        Assert.assertTrue(underTest.callStaticMethod());
    }
}
说明：当需要mock静态方法的时候，必须加注解@PrepareForTest和@RunWith。注解@PrepareForTest里写的类是静态方法所在的类。
(5) Mock 私有方法
测试目标代码： 
public class ClassUnderTest {
    public boolean callPrivateMethod() { 
        return isExist(); 
    }       

    private boolean isExist() {
        return false; 
    }
}
     测试用例代码：  
@RunWith(PowerMockRunner.class) 
public class TestClassUnderTest {
    @Test 
    @PrepareForTest(ClassUnderTest.class) 
    public void testCallPrivateMethod() throws Exception { 
       ClassUnderTest underTest = PowerMockito.mock(ClassUnderTest.class); 
       PowerMockito.when(underTest.callPrivateMethod()).thenCallRealMethod();//这里不如果不声明thenCallRealMethod()方法，因为是mock出来的对象，则无法调用其真正方法。并且Public方法可以直接用.调用，也可以用字符串方法调用，私有方法只能用字符串方法调用
       PowerMockito.when(underTest, "isExist").thenReturn(true);
       Assert.assertTrue(underTest.callPrivateMethod());
    }
}
说明：和Mock普通方法一样，只是需要加注解@PrepareForTest(ClassUnderTest.class)，注解里写的类是私有方法所在的类。 

//如果不调用thenCallRealMethod()方法，则可以用spy方法
public void testPrivateMethod() throws Exception {
    ClassUnderTest underTest = new ClassUnderTest();
    ClassUnderTest underTestSpy = PowerMockito.spy(underTest);
    //PowerMockito.when(underTestSpy.callPrivateMethod()).thenCallRealMethod();
    PowerMockito.when(underTestSpy, "isExist").thenReturn(true);
    assertTrue(underTestSpy.callPrivateMethod());
}
(6) Mock系统类的静态和final方法 
测试目标代码：   
public class ClassUnderTest {
    public boolean callSystemFinalMethod(String str) {
        return str.isEmpty(); 
    } 

    public String callSystemStaticMethod(String str) {
        return System.getProperty(str); 
    }
}
测试用例代码：
@RunWith(PowerMockRunner.class) 
public class TestClassUnderTest {
  @Test 
  @PrepareForTest(ClassUnderTest.class) 
  public void testCallSystemStaticMethod() { 
      ClassUnderTest underTest = new ClassUnderTest(); 
      PowerMockito.mockStatic(System.class); 
      PowerMockito.when(System.getProperty("aaa")).thenReturn("bbb");
      Assert.assertEquals("bbb", underTest.callJDKStaticMethod("aaa")); 
  } 
}
说明：和Mock普通对象的静态方法、final方法一样，只不过注解@PrepareForTest里写的类不一样 ，注解里写的类是需要调用系统方法所在的类。
六 、无所不能的PowerMock
(1) 验证静态方法：
PowerMockito.verifyStatic();
Static.firstStaticMethod(param);
(2) 扩展验证:
PowerMockito.verifyStatic(Mockito.times(2)); //  被调用2次                                Static.thirdStaticMethod(Mockito.anyInt()); // 以任何整数值被调用
(3) 更多的Mock方法
http://code.google.com/p/powermock/wiki/MockitoUsage13
七、PowerMock简单实现原理
?  当某个测试方法被注解@PrepareForTest标注以后，在运行测试用例时，会创建一个新的org.powermock.core.classloader.MockClassLoader实例，然后加载该测试用例使用到的类（系统类除外）。

?   PowerMock会根据你的mock要求，去修改写在注解@PrepareForTest里的class文件（当前测试类会自动加入注解中），以满足特殊的mock需求。例如：去除final方法的final标识，在静态方法的最前面加入自己的虚拟实现等。

?   如果需要mock的是系统类的final方法和静态方法，PowerMock不会直接修改系统类的class文件，而是修改调用系统类的class文件，以满足mock需求。
//------------------------------------------------------------------------------------------------
//PowerMock
http://www.w2bc.com/article/111452
注意PowerMockito.verifyNew的第2个参数支持前面提到的验证模式。
PowerMockito.whenNew().withArguments(...).thenReturn()是对构造方法的mock模式，PowerMockito.verifyNew().withArguments()是验证模式。

另外其他类似的内置匹配器如下：Mockito.eq、Mockito.matches、Mockito.any(anyBoolean , anyByte , anyShort , anyChar , anyInt ,anyLong , anyFloat , anyDouble , anyList , anyCollection , anyMap , anySet等等)、Mockito.isNull、Mockito.isNotNull、Mockito.endsWith、Mockito.isA

--回答(Answer)
在某些边缘的情况下不可能通过简单地通过PowerMockito.when().thenReturn()模拟，这时可以使用Answer接口。
在EmployeeControllerTest类中增加如下方法：
import org.mockito.stubbing.Answer;
  
public class EmployeeControllerTest {
  
    @Test
    public void shouldFindEmployeeByEmailUsingTheAnswerInterface() {
         
        final EmployeeService mock = PowerMockito.mock(EmployeeService.class);
        final Employee employee = new Employee();
        
        PowerMockito.when(mock.findEmployeeByEmail(Mockito.anyString())).then(new Answer<Employee>() {

            public Employee answer(InvocationOnMock invocation) throws Throwable {
                final String email = (String) invocation.getArguments()[0];
                if(email == null) return null;
                if(email.startsWith("deep")) return employee;
                if(email.endsWith("packtpub.com")) return employee;
                return null;
            }
        });
        
        final EmployeeController employeeController = new EmployeeController(mock);
        assertSame(employee, employeeController.findEmployeeByEmail("deep@gitshah.com"));
        assertSame(employee, employeeController.findEmployeeByEmail("deep@packtpub.com"));
        assertNull(employeeController.findEmployeeByEmail("hello@world.com"));
    }
         
    @Test
    public void shouldReturnCountOfEmployeesFromTheServiceWithDefaultAnswer() {
         
        EmployeeService mock = PowerMockito.mock(EmployeeService.class, new Answer() {
            
            public Object answer(InvocationOnMock invocation) {
                return 10;
            }
        });
        
        EmployeeController employeeController = new EmployeeController(mock);
        assertEquals(12, employeeController.getProjectedEmployeeCount());
    }
}
Answer接口指定执行的action和返回值执。 Answer的参数是InvocationOnMock的实例，支持：
callRealMethod()：调用真正的方法
getArguments()：获取所有参数
getMethod()：返回mock实例调用的方法
getMock()：获取mock实例
第一个测试方法根据不同情况构造不同返回。第2个测试方法设定调用返回的默认值。


shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee：
@Test
public void shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee() {
    
    final EmployeeService spy = PowerMockito.spy(new EmployeeService());
    final Employee employeeMock = PowerMockito.mock(Employee.class);
    PowerMockito.when(employeeMock.isNew()).thenReturn(true);
    PowerMockito.doNothing().when(spy).createEmployee(employeeMock);
    spy.saveEmployee(employeeMock);
    Mockito.verify(spy).createEmployee(employeeMock);      
}
注意spy只能使用PowerMockito.doNothing()/doReturn()/doThrow()。

模拟私有方法
现在我们修改EmployeeService.createEmployee为private，在EmployeeServiceTest类添加如下方法：
import org.junit.Test;
import org.junit.runner.RunWith;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
 
@RunWith(PowerMockRunner.class)
@PrepareForTest({EmployeeIdGenerator.class, EmployeeService.class})
public class EmployeeServiceTest {
    
    @Test
    public void shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee() throws Exception {
         
        final EmployeeService spy = PowerMockito.spy(new EmployeeService());
        final Employee employeeMock = PowerMockito.mock(Employee.class);
        PowerMockito.when(employeeMock.isNew()).thenReturn(true);
        PowerMockito.doNothing().when(spy, "createEmployee", employeeMock);
        spy.saveEmployee(employeeMock);
        PowerMockito.verifyPrivate(spy).invoke("createEmployee", employeeMock);
    }
}


--查看封装内容
添加 Department类
//Employee.java
package test;

public class Employee {
    private long salary;

    public static int count() {
        throw new UnsupportedOperationException();
    }

    public long getSalary() {
        return salary;
    }

    public void setSalary(int i) {
        salary = i;
    }

    public void save() {
        throw new UnsupportedOperationException();
    }

    public static void giveIncrementOf(int percentage) {
        throw new UnsupportedOperationException();
    }

    public boolean isNew() {
        throw new UnsupportedOperationException();
    }

    public void update() {
        throw new UnsupportedOperationException();
    }
}


//Department.java
package test;

import java.util.ArrayList;
import java.util.List;

public class Department {
    private List<Employee> employees = new ArrayList<>();
    private long maxSalaryOffered;
    public void addEmployee(final Employee employee) {
        employees.add(employee);
        updateMaxSalaryOffered();
    }

    /**
     * The private method that keeps track of
     * max salary offered by this department.
     */
    private void updateMaxSalaryOffered() {
        maxSalaryOffered = 0;
        for (Employee employee : employees) {
            if(employee.getSalary() > maxSalaryOffered) {
                maxSalaryOffered = employee.getSalary();
            }
        }
    }
}

//EmployeeService.java
package test;

public class EmployeeService {

    public int getEmployeeCount() {
        return Employee.count();
    }

    public void saveEmployee(Employee employee) {
        if(employee.isNew()) {
            createEmployee(employee);
            return;
        }
        employee.update();
    }

    public boolean giveIncrementToAllEmployeesOf(int percentage) {
        try{
            Employee.giveIncrementOf(percentage);
            return true;
        } catch(Exception e) {
            return false;
        }
    }

    private void createEmployee(Employee employeeMock) {
        throw new UnsupportedOperationException();
    }
}

//DepartmentTest.java
package test;

import org.junit.Test;
import org.powermock.reflect.Whitebox;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class DepartmentTest {
    @Test
    public void shouldVerifyThatNewEmployeeIsAddedToTheDepartment() {
        final Department department = new Department();
        final Employee employee = new Employee();
        department.addEmployee(employee);
        final List<Employee> employees = Whitebox.getInternalState(department, "employees");

        assertTrue(employees.contains(employee));
    }

    @Test
    public void shouldAddNewEmployeeToTheDepartment() {
        final Department department = new Department();
        final Employee employee = new Employee();
        final ArrayList<Employee> employees = new ArrayList<>();
        Whitebox.setInternalState(department, "employees", employees);
        department.addEmployee(employee);

        assertTrue(employees.contains(employee));
    }

    @Test
    public void shouldVerifyThatMaxSalaryOfferedForADepartmentIsCalculatedCorrectly() throws Exception {
        final Department department = new Department();

        final Employee employee1 = new Employee();
        final Employee employee2 = new Employee();
        employee1.setSalary(60000);
        employee2.setSalary(65000);

        final ArrayList<Employee> employees = new ArrayList<Employee>();
        employees.add(employee1);
        employees.add(employee2);

        Whitebox.setInternalState(department, "employees", employees);
        Whitebox.invokeMethod(department, "updateMaxSalaryOffered");

        final long maxSalary = Whitebox.getInternalState(department, "maxSalaryOffered");
        assertEquals(65000, maxSalary);
    }
}
Whitebox.getInternalState(department, "employees")类似堆栈，查看变量的值。
Whitebox.setInternalState(department, "employees", employees)设置变量的值。 
Whitebox.invokeMethod(department, "updateMaxSalaryOffered")调用方法。


//EmployeeServiceTest.java
package test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

@RunWith(PowerMockRunner.class)
@PrepareForTest({Employee.class, EmployeeService.class})
public class EmployeeServiceTest {

    @Test
    public void shouldReturnTrueWhenIncrementOf10PercentageIsGivenSuccessfully() {
        PowerMockito.mockStatic(Employee.class);
        PowerMockito.doNothing().when(Employee.class);//对于类方法的使用，告诉PowerMock下一个方法调用时什么也不做
        Employee.giveIncrementOf(10);
        EmployeeService employeeService = new EmployeeService();
        assertTrue(employeeService.giveIncrementToAllEmployeesOf(10));
    }

    @Test
    public void shouldReturnFalseWhenIncrementOf10PercentageIsNotGivenSuccessfully() {
        PowerMockito.mockStatic(Employee.class);
        PowerMockito.doThrow(new IllegalStateException()).when(Employee.class);//对于类方法的使用，告诉PowerMock下一个方法调用时抛出异常
        Employee.giveIncrementOf(10);
        EmployeeService employeeService = new EmployeeService();
        assertFalse(employeeService.giveIncrementToAllEmployeesOf(10));
    }

//    //如果createEmployee为public方法，则不需要@PrepareForTest(EmployeeService.class)，并且验证public方法为Mockito.verify
//    @Test
//    public void shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee_verityPublic() {
//        final EmployeeService spy = PowerMockito.spy(new EmployeeService());
//        final Employee employeeMock = PowerMockito.mock(Employee.class);
//        PowerMockito.when(employeeMock.isNew()).thenReturn(true);
//        PowerMockito.doNothing().when(spy).createEmployee(employeeMock);
//
//        spy.saveEmployee(employeeMock);
//        Mockito.verify(spy).createEmployee(employeeMock);
//    }

    //测试spy类的私有方法，并且用doNothing来标识调用spy类的私有方法时不做任何事，验证private方法为PowerMockito.verifyPrivate
    @Test
    public void shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee_verifyPrivate() throws Exception {
        final EmployeeService spy = PowerMockito.spy(new EmployeeService());
        final Employee employeeMock = PowerMockito.mock(Employee.class);
        PowerMockito.when(employeeMock.isNew()).thenReturn(true);
        PowerMockito.doNothing().when(spy, "createEmployee", employeeMock);

        spy.saveEmployee(employeeMock);
        PowerMockito.verifyPrivate(spy).invoke("createEmployee", employeeMock);
    }
}

//EmployeeTest.java
package test;

import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;

import static org.junit.Assert.fail;

public class EmployeeTest {

    @Test()
    public void shouldNotDoAnythingIfEmployeeWasSaved() {
        Employee employee = PowerMockito.mock(Employee.class);
        PowerMockito.doNothing().when(employee).save();
        try {
            employee.save();
        } catch(Exception e) {
            fail("Should not have thrown an exception");
        }
    }

    @Test(expected = IllegalStateException.class)
    public void shouldThrowAnExceptionIfEmployeeWasNotSaved() {
        Employee employee = PowerMockito.mock(Employee.class);
        PowerMockito.doThrow(new IllegalStateException()).when(employee).save();
        employee.save();
    }
}

更多参考：http://powermock.googlecode.com/svn/docs/powermock-1.5/apidocs/org/powermock/reflect/Whitebox.html。
//------------------------------------------------------------------------------------------------
//初始化@Mock注解对象的三个方法
http://blog.csdn.net/hotdust/article/details/51416670
(1) 在@Before注解中每次初始化mock对象
(2) 在测试类定义处使用@RunWith(MockitoJUnitRunner.class)注解
(3) 使用@Rule注解（没有找到合适的MockitoRule定义，不知道是什么问题？）

//
package test;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class) //(2)
public class MockTest {

    @Mock
    private List<String> strings;

//    @Rule
//    public MockitoRule mockitoRule = MockitoJUnit.rule(); //(3)

//    @Before
//    public void setUp() {
//        MockitoAnnotations.initMocks(this); //(1)
//    }

    @Test
    public void testMockitoJUnitRunner() {
        when(strings.get(0)).thenReturn("hello");
        assertEquals("hello", strings.get(0));
        verify(strings).get(0);
    }
}

//------------------------------------------------------------------------------------------------
//Mockito学习
http://blog.csdn.net/zhoudaxia/article/details/33056093
Mockito 框架
Mockito 是一个基于MIT协议的开源java测试框架。 
Mockito区别于其他模拟框架的地方主要是允许开发者在没有建立“预期”时验证被测系统的行为。对mock对象的一个批评是测试代码与被测系统高度耦合，由于Mockito试图通过移除“期望规范”来去除expect-run-verify模式（期望--运行--验证模式），因此使耦合度降低到最低。这样的突出特性简化了测试代码，使它更容易阅读和修改了。
//
package test;

import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;
import org.mockito.internal.InOrderImpl;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.atMost;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

public class MockTest {
    @Test
    public void testMock() {
        // 模拟的创建，对接口进行模拟
        List mockedList = mock(List.class);
        // 使用模拟对象
        mockedList.add("one");//mockedList.Add("one")将报错无法解析Add，调用的方法一定是被Mock的类有的方法
        mockedList.clear();
        // 选择性地和显式地验证，即验证mock对象的函数调用了几次，可以不用预先设置期待返回，降低耦合
        verify(mockedList, times(1)).add("one");//同verify(mockedList).add("one");不加次数时默认为1次
        verify(mockedList, atLeast(1)).clear();//verify(mockedList, atLeastOnce()).clear()
        verify(mockedList, never()).add("two");//验证从未调用过
        verifyNoMoreInteractions(mockedList);//验证还有没有verify的交互，如果把verify(mockedList, atLeast(1)).clear();注释掉，则会报错mockedList.clear();未验证
        verifyZeroInteractions(mockedList);//同verifyNoMoreInteractions(mockedList)一样
        
        //初始化一个抓取器，用于抓取入参对象
        ArgumentCaptor<String> stringArgumentCaptor = ArgumentCaptor.forClass(String.class);
        verify(mockedList).add(stringArgumentCaptor.capture());//抓取一个String对象
        String addedString = stringArgumentCaptor.getValue();//获得抓取的对象
        assertEquals("one", addedString);//验证抓取对象值

        verify(mockedList, times(1)).add("one");//可以重复验证
        verify(mockedList, atMost(2)).clear();
        verify(mockedList, timeout(100).times(1)).add("one");//验证someMethod()是否能在指定的100毫秒中执行完毕

//        List<Integer> integers = new ArrayList<>(); //如果不是Mock对象，则verify会报错
//        integers.add(1);
//        integers.add(2);
//        verify(integers).add(3);
    }

    @Test
    public void testMockReturn() {
        // 你不仅可以模拟接口,任何具体类都行
        LinkedList mockedList = mock(LinkedList.class);
        // 执行前准备测试数据
        when(mockedList.get(0)).thenReturn("first");
        // 接着打印"first"
        System.out.println(mockedList.get(0));
        // 因为get(999)未对准备数据,所以下面将打印"null".
        System.out.println(mockedList.get(999));
    }
    
    @Test
    public void testInOrder() {
        List<String> firstMock = mock(List.class);
        List<String> secondMock = mock(List.class);

        firstMock.add("was called first");
        firstMock.add("was called first");
        secondMock.add("was called second");
        secondMock.add("was called third");

        InOrder inOrder = new InOrderImpl(Arrays.asList(secondMock, firstMock));//如下定义也可以：InOrder inOrder = new InOrderImpl(Arrays.asList(firstMock, secondMock));
        inOrder.verify(firstMock, times(2)).add("was called first");
        inOrder.verify(secondMock).add("was called second");
        inOrder.verify(secondMock).add("was called third");//依次调用这三个顺序，如果不是这三个调用顺序，则报错
        inOrder.verifyNoMoreInteractions();//如果未验证完，则此校验不过
    }
}
输出：
first
null

//-----
//Person.java
package mockitodemo;

public class Person {
    private final Integer personID;
    private final String personName;

    public Person(Integer personID, String personName) {
        this.personID = personID;
        this.personName = personName;
    }

    public Integer getPersonID() {
        return personID;
    }

    public String getPersonName() {
        return personName;
    }
}

//PersonDao.java
package mockitodemo;

public interface PersonDao {
    Person fetchPerson(Integer personID);

    void update(Person person);
}

//PersonService.java
package mockitodemo;

public class PersonService {
    private final PersonDao personDao;

    public PersonService(PersonDao personDao) {
        this.personDao = personDao;
    }

    public boolean update(Integer personId, String name) {
        Person person = personDao.fetchPerson(personId);
        if (person != null) {
            Person updatedPerson = new Person(person.getPersonID(), name);
            personDao.update(updatedPerson);
            return true;
        } else {
            return false;
        }
    }
}

//PersonServiceTest.java
package mockitodemo;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.ArgumentCaptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.*;

public class PersonServiceTest {

    @Mock
    private PersonDao personDao;  // 模拟对象
    private PersonService personService;  // 被测类

    public PersonServiceTest() {
    }

    @BeforeClass
    public static void setUpClass() {
        //如果将personDao和personService改为static变量，并且在@BeforeClass中初始化，则全局所有用例都使用这两个变量
        //此时，第一个用例调用了personDao.fetchPerson方法后，第二个用例再次调用此方法，将导致此方法调用了2次
        //如shouldNotUpdateIfPersonNotFound()中的verify(personDao).fetchPerson(1);方法将验证失败
        //此时修改为verify(personDao, times(2)).fetchPerson(1);，则用例会通过
        //但是这样的话，就违反了用例测试的FIRST原则，F快速、I独立、R可重复、S自验证、T及时
        //personDao = mock(PersonDao.class);
        //personService = new PersonService(personDao);
    }

    @AfterClass
    public static void tearDownClass() {
    }

    // 在@Test标注的测试方法之前运行
    @Before
    public void setUp() throws Exception {
        // 初始化测试用例类中由Mockito的注解标注的所有模拟对象
        MockitoAnnotations.initMocks(this);//一定要testClass已经完全生成好，所以无法放在@BeforeClass里
        // 用模拟对象创建被测类对象
        personService = new PersonService(personDao);
    }

    @After
    public void tearDown() {
    }

    @Test
    public void shouldUpdatePersonName() {
        Person person = new Person(1, "Phillip");
        // 设置模拟对象的返回预期值
        when(personDao.fetchPerson(1)).thenReturn(person);
        // 执行测试
        boolean updated = personService.update(1, "David");
        // 验证更新是否成功
        assertTrue(updated);
        // 验证模拟对象的fetchPerson(1)方法是否被调用了一次
        verify(personDao).fetchPerson(1);
        // 得到一个抓取器
        ArgumentCaptor<Person> personCaptor = ArgumentCaptor.forClass(Person.class);
        // 验证模拟对象的update()是否被调用一次，并抓取调用时传入的参数值
        verify(personDao).update(personCaptor.capture());
        // 获取抓取到的参数值
        Person updatePerson = personCaptor.getValue();
        // 验证调用时的参数值
        assertEquals("David", updatePerson.getPersonName());
        // asserts that during the test, there are no other calls to the mock object.
        // 检查模拟对象上是否还有未验证的交互
        verifyNoMoreInteractions(personDao);
    }

    @Test
    public void shouldNotUpdateIfPersonNotFound() {
        // 设置模拟对象的返回预期值
        when(personDao.fetchPerson(1)).thenReturn(null);
        // 执行测试
        boolean updated = personService.update(1, "David");
        // 验证更新是否失败
        assertFalse(updated);
        // 验证模拟对象的fetchPerson(1)方法是否被调用了一次
        verify(personDao).fetchPerson(1);
        // 验证模拟对象是否没有发生任何交互
        verifyZeroInteractions(personDao);
        // 检查模拟对象上是否还有未验证的交互
        verifyNoMoreInteractions(personDao);
    }

    /**
     * Test of update method, of class PersonService.
     */
    @Test
    public void testUpdate() {
        System.out.println("update");
        Integer personId = null;
        String name = "Phillip";
        PersonService instance = new PersonService(new PersonDao() {

            @Override
            public Person fetchPerson(Integer personID) {
                System.out.println("Not supported yet.");
                return null;
            }

            @Override
            public void update(Person person) {
                System.out.println("Not supported yet.");
            }
        });
        boolean expResult = false;
        boolean result = instance.update(personId, name);
        assertEquals(expResult, result);
        // TODO review the generated test code and remove the default call to fail.
        fail("The test case is a prototype.");
    }
}
这里setUpClass()、tearDownClass()、setUp()、tearDown()称为测试夹具（Fixture），就是测试运行程序（test runner）在运行测试方法之前进行初始化、或之后进行回收资源的工作。JUnit 4 之前是通过setUp、tearDown方法完成。在JUnit 4 中，仍然可以在每个测试方法运行之前初始化字段和配置环境，当然也是通过注解完成。在JUnit 4 中，通过@Before标注setUp方法；@After标注tearDown方法。在一个测试类中，甚至可以使用多个@Before来注解多个方法，这些方法都是在每个测试之前运行。说明一点，一个测试用例类可以包含多个打上@Test注解的测试方法，在运行时，每个测试方法都对应一个测试用例类的实例。@Before是在每个测试方法运行前均初始化一次，同理@Ater是在每个测试方法运行完毕后均执行一次。也就是说，经这两个注解的初始化和注销，可以保证各个测试之间的独立性而互不干扰，它的缺点是效率低。另外，不需要在超类中显式调用初始化和清除方法，只要它们不被覆盖，测试运行程序将根据需要自动调用这些方法。超类中的@Before方法在子类的@Before方法之前调用（与构造函数调用顺序一致），@After方法是子类在超类之前运行。
　　这里shouldUpdatePersonName()、shouldNotUpdateIfPersonNotFound()和testUpdate()都是测试PersonService的update()方法，它依赖于PersonDao接口。前两者使用了模拟测试。testUpdate()则没有使用模拟测试。下面是测试结果：

　　可以看出，使用模拟测试的两个测试成功了，没有使用模拟测试的testUpdate()失败。对于模拟测试，在测试用例类中要先声明依赖的各个模拟对象，在setUp()中用MockitoAnnotations.initMocks()初始化所有模拟对象。在进行模拟测试时，要先设置模拟对象上方法的返回预期值，执行测试时会调用模拟对象上的方法，因此要验证这些方法是否被调用，并且传入的参数值是否符合预期。对于testUpdate()测试，我们需要自己创建测试PersonService.update()所需的所有PersonDao数据，因为我们只知道公开的PersonDao接口，其具体实现类（比如从数据库中拿真实的数据，或写入到数据库中）可能由另一个团队在负责，以适配不同的数据库系统。这样的依赖关系无疑使单元测试比较麻烦，而要拿真正PersonDao实现来进行测试，那也应该是后期集成测试的任务，把不同的组件集成到一起在真实环境中测试。有了模拟测试框架，就可以最大限度地降低单元测试时的依赖耦合性。

//-----学习Mockito - Mock对象的行为验证
http://hotdog.iteye.com/blog/908827

--验证的基本方法 
我们已经熟悉了使用verify(mock).someMethod(…)来验证方法的调用。例子中，我们mock了List接口，然后调用了mock对象的一些方法。验证是否调用了mock.get(2)方法可以通过verify(mock).get(2)来进行。verify方法的调用不关心是否模拟了get(2)方法的返回值，只关心mock对象后，是否执行了mock.get(2)，如果没有执行，测试方法将不会通过。 

--验证未曾执行的方法 
在verify方法中可以传入never()方法参数来确认mock.get(3)方法不曾被执行过。另外还有很多调用次数相关的参数将会在下面提到。 

--查询多余的方法调用 
verifyNoMoreInteractions()方法可以传入多个mock对象作为参数，用来验证传入的这些mock对象是否存在没有验证过的调用方法。本例中传入参数mock，测试将不会通过，因为我们只verify了mock对象的get(2)方法，没有对get(0)和get(1)进行验证。为了增加测试的可维护性，官方不推荐我们过于频繁的在每个测试方法中都使用它，因为它只是测试的一个工具，只在你认为有必要的时候才用。 

--查询没有交互的mock对象 
verifyZeroInteractions()也是一个测试工具，源码和verifyNoMoreInteractions()的实现是一样的，为了提高逻辑的可读性，所以只不过名字不同。在例子中，它的目的是用来确认mock2对象没有进行任何交互，但mock2执行了get(0)方法，所以这里测试会报错。由于它和verifyNoMoreInteractions()方法实现的源码都一样，因此如果在verifyZeroInteractions(mock2)执行之前对mock.get(0)进行了验证那么测试将会通过。 

--验证方法调用的次数 
如果要验证Mock对象的某个方法调用次数，则需给verify方法传入相关的验证参数，它的调用接口是verify(T mock, VerificationMode mode)。如：verify(mock,times(3)).someMethod(argument)验证mock对象someMethod(argument)方法是否调用了三次。times(N)参数便是验证调用次数的参数，N代表方法调用次数。其实verify方法中如果不传调用次数的验证参数，它默认传入的便是times(1)，即验证mock对象的方法是否只被调用一次，如果有多次调用测试方法将会失败。 

Mockito除了提供times(N)方法供我们调用外，还提供了很多可选的方法： 
never() 没有被调用，相当于times(0) 
atLeast(N) 至少被调用N次 
atLeastOnce() 相当于atLeast(1) 
atMost(N) 最多被调用N次 

--超时验证 
Mockito提供对超时的验证，但是目前不支持在下面提到的顺序验证中使用。进行超时验证和上述的次数验证一样，也要在verify中进行参数的传入，参数为timeout(int millis)，timeout方法中输入的是毫秒值。下面看例子： 
验证someMethod()是否能在指定的100毫秒中执行完毕 
verify(mock, timeout(100)).someMethod(); 
结果和上面的例子一样，在超时验证的同时可进行调用次数验证，默认次数为1 
verify(mock, timeout(100).times(1)).someMethod(); 
在给定的时间内完成执行次数 
verify(mock, timeout(100).times(2)).someMethod(); 
给定的时间内至少执行两次 
verify(mock, timeout(100).atLeast(2)).someMethod(); 
另外timeout也支持自定义的验证模式， 
verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod(); 

--验证方法调用的顺序 
Mockito同样支持对不同Mock对象不同方法的调用次序进行验证。进行次序验证是，我们需要创建InOrder对象来进行支持。例： 

创建mock对象 
List<String> firstMock = mock(List.class); 
List<String> secondMock = mock(List.class); 

调用mock对象方法 
firstMock.add("was called first"); 
firstMock.add("was called first"); 
secondMock.add("was called second"); 
secondMock.add("was called third"); 

创建InOrder对象 
inOrder方法可以传入多个mock对象作为参数，这样便可对这些mock对象的方法进行调用顺序的验证InOrder inOrder = inOrder( secondMock, firstMock ); 

验证方法调用 
接下来我们要调用InOrder对象的verify方法对mock方法的调用顺序进行验证。注意，这里必须是你对调用顺序的预期。 

InOrder对象的verify方法也支持调用次数验证，上例中，我们期望firstMock.add("was called first")方法先执行并执行两次，所以进行了下面的验证inOrder.verify(firstMock,times(2)).add("was called first")。其次执行了secondMock.add("was called second")方法，继续验证此方法的执行inOrder.verify(secondMock).add("was called second")。如果mock方法的调用顺序和InOrder中verify的顺序不同，那么测试将执行失败。 

InOrder的verifyNoMoreInteractions()方法 
它用于确认上一个顺序验证方法之后，mock对象是否还有多余的交互。它和Mockito提供的静态方法verifyNoMoreInteractions不同，InOrder的验证是基于顺序的，另外它只验证创建它时所提供的mock对象，在本例中只对firstMock和secondMock有效。例如： 

inOrder.verify(secondMock).add("was called second"); 
inOrder.verifyNoMoreInteractions(); 

在验证secondMock.add("was called second")方法之后，加上InOrder的verifyNoMoreInteractions方法，表示此方法调用后再没有多余的交互。例子中会报错，因为在此方法之后还执行了secondMock.add("was called third")。现在将上例改成： 

inOrder.verify(secondMock).add("was called third"); 
inOrder.verifyNoMoreInteractions(); 

测试会恢复为正常，因为在secondMock.add("was called third")之后已经没有多余的方法调用了。如果这里换成Mockito类的verifyNoMoreInteractions方法测试还是会报错，它查找的是mock对象中是否存在没有验证的调用方法，和顺序是无关的。 

//-----
Mock对象时不依赖于类的构造函数，即使一个类没有无参数构造函数，也可以调用mock(SomeClass.class)方法来mock该对象
//
package test;

public class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class PersonTest {
    @Test
    public void testPersonMock() {
        Person mockedPerson = mock(Person.class);

        when(mockedPerson.getId()).thenReturn(10);
        assertEquals(10, mockedPerson.getId());
    }
}

//-----
参数捕获器
http://blog.csdn.net/mergades/article/details/51009631

Mockito - Argument Matcher（参数匹配器）
http://hotdog.iteye.com/blog/908381

package test;

import org.junit.Test;
import org.mockito.ArgumentCaptor;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class MockTest {
    @Test
    public void testMockCapture() {
        // 模拟的创建，对接口进行模拟
        List<String> mockedList = mock(List.class);
        mockedList.add("a");
        ArgumentCaptor<String> stringArgumentCaptor = ArgumentCaptor.forClass(String.class);
        verify(mockedList).add("a");
        verify(mockedList).add(stringArgumentCaptor.capture());
        assertEquals("a", stringArgumentCaptor.getValue());

        mockedList.add("b");
        verify(mockedList, times(2)).add(stringArgumentCaptor.capture());//这里验证了times(2)，捕获器会把两次的值都捕获到，即"a", "b"
        assertEquals("b", stringArgumentCaptor.getValue());

        assertArrayEquals(new String[] {"a", "a", "b"}, stringArgumentCaptor.getAllValues().toArray());//总共捕获了三次，所以是"a", "b", "c"
    }

    @Test
    public void testMockReturn() {
        // 你不仅可以模拟接口,任何具体类都行
        LinkedList mockedList = mock(LinkedList.class);
        // 执行前准备测试数据
        when(mockedList.get(0)).thenReturn("first");
        assertEquals("first", mockedList.get(0));
        assertEquals("first", mockedList.get(0));

        when(mockedList.get(0)).thenReturn("second").thenReturn("third");//所有大于1次的调用都返回third
        assertEquals("second", mockedList.get(0));
        assertEquals("third", mockedList.get(0));
        assertEquals("third", mockedList.get(0));
    }

    @Test
    public void testMockAnyArg() {
        // 你不仅可以模拟接口,任何具体类都行
        List<String> mockedList = mock(LinkedList.class);
        when(mockedList.get(anyInt())).thenReturn("hello");
        assertEquals("hello", mockedList.get(0));
    }

    //如果使用了参数匹配器，那么所有的参数需要由匹配器来提供，否则将会报错。假如我们使用参数匹配器stubbing了mock对象的方法，那么在verify的时候也需要使用它。如下例
    //在最后的验证时如果只输入字符串”hello”是会报错的，必须使用Matchers类内建的eq方法。如果将anyInt()换成1进行验证也需要用eq(1)。 
    @Test
    public void argumentMatchersTest(){
        Map mapMock = mock(Map.class);
        when(mapMock.put(anyInt(), anyString())).thenReturn("world");
        mapMock.put(1, "hello");
        verify(mapMock).put(anyInt(), eq("hello"));//verify(mapMock).put(anyInt(), "hello");将报错
    }
    
    @Test
    public void testIsA() {
        when(strings.get(isA(Integer.class))).thenReturn("hello");
        assertEquals("hello", strings.get(0));
        verify(strings).get(0);
    }
}

//-----any()
package test;

import org.junit.Test;

import java.io.IOException;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class MockTest {

    @Test
    public void testForIOException() throws IOException {
        // Lets mock a LinkedList
        List<String> strings = mock(List.class);

        //这里用isA或者any都可以通过，个人感觉isA传入一个派生类对象也可以，而any只能是这个类对象
        when(strings.get(any(Integer.class))).thenReturn("hello");
        //when(strings.get(isA(Integer.class))).thenReturn("hello");
        assertEquals("hello", strings.get(any(Integer.class)));
    }
}
//------------------------------------------------------------------------------------------------
//技能鉴定3级 字母螺旋矩阵
http://blog.csdn.net/sunmenggmail/article/details/7779651

//AlphaSpiralMatrix.java
package test;

public interface AlphaSpiralMatrix {
    String getRowAlpha(int rowIndex);
}


//AlphaSpiralMatrixWithAlg.java
package test;

import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class AlphaSpiralMatrixWithAlg implements AlphaSpiralMatrix {
    private final int maxRow;
    private final int maxCol;

    private static final char START_ALPHA = 'A';
    private static final int MAX_ALPHA_NUM = 26;

    public AlphaSpiralMatrixWithAlg(int maxRow, int maxCol) {
        assert (maxRow > 0 && maxCol > 0);
        this.maxRow = maxRow;
        this.maxCol = maxCol;
    }

    @Override
    public String getRowAlpha(int rowIndex) {
        assert (rowIndex >= 0 && rowIndex < maxRow);

        return IntStream.range(0, maxCol).mapToObj(colIndex -> {
            long value = getValueByRowAndCol(rowIndex, colIndex);
            char charByValue = getCharByValue(value);
            //System.out.println(String.format("[%d, %d] <--> %d <--> %c", rowIndex, colIndex, value, charByValue));
            return String.valueOf(charByValue);
        }).collect(Collectors.joining());
        
        //        StringBuilder rowAlpha = new StringBuilder();
        //        for (int colIndex = 0; colIndex < maxCol; ++colIndex) {
        //            long value = getValueByRowAndCol(rowIndex, colIndex);
        //            char charByValue = getCharByValue(value);
        //            System.out.println(String.format("[%d, %d] <--> %d <--> %c", rowIndex, colIndex, value, charByValue));
        //            rowAlpha.append(charByValue);
        //        }
        //        return rowAlpha.toString();
    }

    private long getValueByRowAndCol(int rowIndex, int colIndex) {
        int level = Math.min(Math.min(rowIndex, colIndex), Math.min(maxRow - 1 - rowIndex, maxCol - 1 - colIndex));
        int distance = rowIndex + colIndex - 2 * level;
        int startValue = getStartValue(level);

        //如果当前坐标位于该level矩形向右、向下的边，或者只有一条直线层时，坐标值为起始值+距离
        if (rowIndex == level || colIndex == maxCol - 1 - level || (maxCol < maxRow && level * 2 + 1 == maxCol)) {
            return startValue + distance;
        }

        //不在以上场景时，即当前坐标位于该level矩形向左、向上的边，则坐标值为下一level矩形起始值-距离
        int nextLevelStartValue = getStartValue(level + 1);
        return nextLevelStartValue - distance;
    }

    private int getStartValue(int level) {
        return 2 * level * (maxRow + maxCol - 2 * level) + 1;
    }

    private char getCharByValue(long value) {
        int remainder = (int) (value % MAX_ALPHA_NUM);
        if (remainder == 0) {
            remainder = MAX_ALPHA_NUM;
        }
        return (char) (remainder - 1 + START_ALPHA);
    }
}

//AlphaSpiralMatrixWithTraverse.java
package test;

import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AlphaSpiralMatrixWithTraverse implements AlphaSpiralMatrix {
    private final int maxRow;
    private final int maxCol;
    private char[][] charMatrix;

    private static final char START_ALPHA = 'A';
    private static final int MAX_ALPHA_NUM = 26;

    public AlphaSpiralMatrixWithTraverse(int maxRow, int maxCol) {
        assert (maxRow > 0 && maxCol > 0);
        this.maxRow = maxRow;
        this.maxCol = maxCol;
    }

    @Override
    public String getRowAlpha(int rowIndex) {
        assert (rowIndex >= 0 && rowIndex < maxRow);
        initCharMatrix();
        return Stream.of(charMatrix[rowIndex]).map(String::valueOf).collect(Collectors.joining());
    }

    private enum Direction {
        RIGHT(0, 1) {
            @Override
            Direction getNextDirection() {
                return DOWN;
            }
        }, DOWN(1, 0) {
            @Override
            Direction getNextDirection() {
                return LEFT;
            }
        }, LEFT(0, -1) {
            @Override
            Direction getNextDirection() {
                return UP;
            }
        }, UP(-1, 0) {
            @Override
            Direction getNextDirection() {
                return RIGHT;
            }
        };

        private final int rowIncrement;

        private final int columnIncrement;
        Direction(int rowIncrement, int columnIncrement) {
            this.rowIncrement = rowIncrement;
            this.columnIncrement = columnIncrement;
        }

        public int getRowIncrement() {
            return rowIncrement;
        }

        public int getColumnIncrement() {
            return columnIncrement;
        }

        abstract Direction getNextDirection();
    }

    private void initCharMatrix() {
        if (charMatrix != null) {
            return;
        }
        charMatrix = new char[maxRow][maxCol];

        long maxNumber = maxRow * maxCol;
        int rowIndex = 0;
        int columnIndex = 0;
        Direction direction = Direction.RIGHT;
        for (long index = 0; index < maxNumber; ++index) {
            charMatrix[rowIndex][columnIndex] = (char) (index % MAX_ALPHA_NUM + START_ALPHA);

            int nextRowIndex = rowIndex + direction.getRowIncrement();
            int nextColumnIndex = columnIndex + direction.getColumnIncrement();

            if (!isNextPosValid(nextRowIndex, nextColumnIndex)) {
                direction = direction.getNextDirection();
            }

            rowIndex += direction.getRowIncrement();
            columnIndex += direction.getColumnIncrement();
        }

    }

    private boolean isNextPosValid(int nextRowIndex, int nextColumnIndex) {
        return nextRowIndex < maxRow && nextRowIndex >= 0
            && nextColumnIndex < maxCol && nextColumnIndex >= 0
            && charMatrix[nextRowIndex][nextColumnIndex] == 0;
    }
}


//AlphaSpiralMatrixTest.java
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class AlphaSpiralMatrixTest {
    @Test
    public void testAlphaSpiralMatrixWithAlg_oneRow() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithAlg(1, 3);
        assertEquals("ABC", alphaSpiralMatrix.getRowAlpha(0));
    }

    @Test
    public void testAlphaSpiralMatrixWithAlg_oneColumn() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithAlg(3, 1);
        assertEquals("B", alphaSpiralMatrix.getRowAlpha(1));
    }

    @Test
    public void testAlphaSpiralMatrixWithAlg_multiRowMulitColumn() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithAlg(100, 30);
        assertEquals("CRYXOXYRCFANSPEDKJAJKDORMZEBQX", alphaSpiralMatrix.getRowAlpha(20));
    }

    @Test
    public void testAlphaSpiralMatrixWithTraverse_oneRow() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithTraverse(1, 3);
        assertEquals("ABC", alphaSpiralMatrix.getRowAlpha(0));
    }

    @Test
    public void testAlphaSpiralMatrixWithTraverse_oneColumn() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithTraverse(3, 1);
        assertEquals("B", alphaSpiralMatrix.getRowAlpha(1));
    }

    @Test
    public void testAlphaSpiralMatrixWithTraverse_multiRowMulitColumn() {
        AlphaSpiralMatrix alphaSpiralMatrix = new AlphaSpiralMatrixWithTraverse(100, 30);
        assertEquals("CRYXOXYRCFANSPEDKJAJKDORMZEBQX", alphaSpiralMatrix.getRowAlpha(20));
    }
}

@Test
public void testCharString() {
    String s = Stream.of('a', 'b', 'c').map(String::valueOf).collect(Collectors.joining()).toString();//这里必须转为String，再做joining，不能直接用char做joining吗？
    System.out.println(s);
}
//------------------------------------------------------------------------------------------------
//技能鉴定3级 石头分堆求最小差值
//StonesGrouper.java
package test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class StonesGrouper {

    public int getMinDiffValue(List<Integer> integers) {
        Collections.sort(integers);//Collections.sort(integers, (i1, i2) -> Integer.compare(i2, i1));
        int sum = integers.stream().mapToInt(x -> x).sum();

        Map<Integer, List<List<Integer>>> integerListMap = pickAllIntegers(integers);
        return getMinDiffValueFromAllIntegers(integerListMap, sum);
    }

    private Map<Integer, List<List<Integer>>> pickAllIntegers(List<Integer> integers) {
        Map<Integer, List<List<Integer>>> integerListMap = new HashMap<>();
        int size = integers.size();
        int maxCalculatedInteger = size % 2 == 0 ? size / 2 : (size - 1) / 2;

        for (int i = 1; i <= maxCalculatedInteger; ++i) {
            List<List<Integer>> groupedIntegers = pickIntegers(integers, i); //利用递归求出所有分组，可以完成任务，效率较低
            integerListMap.put(i, groupedIntegers);
        }
        return integerListMap;
    }

    private List<List<Integer>> pickIntegers(List<Integer> inputIntegers, int index) {
        if (index == 1) {
            return inputIntegers.stream().map(i -> Arrays.asList(i)).collect(Collectors.toList());
        }

        --index;
        List<List<Integer>> integersList = new ArrayList<>();
        List<Integer> copyOfInputIntegers = new ArrayList<>(inputIntegers);

        for (int i : inputIntegers) {
            copyOfInputIntegers.remove(0);//remove删除时是按索引删除
            List<List<Integer>> integersWithoutFirst = pickIntegers(copyOfInputIntegers, index);
            List<List<Integer>> integersCombinationWithFirst = integersWithoutFirst.stream().map(integers -> {
                List<Integer> copyOfIntegers = new ArrayList<>(integers);
                copyOfIntegers.add(i);
                return copyOfIntegers;
            }).collect(Collectors.toList());
            integersList.addAll(integersCombinationWithFirst);
        }
        return integersList;
    }

    private int getMinDiffValueFromAllIntegers(Map<Integer, List<List<Integer>>> integerListMap, Integer sum) {
        int minDiffValue = sum;
        for (Map.Entry<Integer, List<List<Integer>>> integerListEntry : integerListMap.entrySet()) {
            int tempMinDiffValue = integerListEntry.getValue().stream()
                .peek(integers -> System.out.print("One heap of stones: " + integers))
                .mapToInt(integers -> Math.abs(integers.stream().mapToInt(Integer::intValue).sum() * 2 - sum))
                .peek(i -> System.out.println(", weight difference: " + i))
                .min()
                .getAsInt();

            if (tempMinDiffValue < minDiffValue) {
                minDiffValue = tempMinDiffValue;
            }
        }
        return minDiffValue;
    }
}

//StonesGrouperTest.java
package test;

import org.junit.Test;

import java.util.Arrays;

import static org.junit.Assert.assertEquals;

public class StonesGrouperTest {
    @Test
    public void testGroupStones_multiStones() {
        int diffMinValue = new StonesGrouper().getMinDiffValue(Arrays.asList(5, 8, 13, 27, 14));
        assertEquals(3, diffMinValue);
    }

    @Test
    public void testGroupStones_multiStonesWithSameWeight() {
        int diffMinValue = new StonesGrouper().getMinDiffValue(Arrays.asList(5, 8, 10, 14, 10));
        assertEquals(1, diffMinValue);//按照排序后的简单叠加则得到差值为3
    }

    @Test
    public void testGroupStones_1Stones() {
        int diffMinValue = new StonesGrouper().getMinDiffValue(Arrays.asList(5));
        assertEquals(5, diffMinValue);
    }

    @Test
    public void testGroupStones_2Stones() {
        int diffMinValue = new StonesGrouper().getMinDiffValue(Arrays.asList(5, 12));
        assertEquals(7, diffMinValue);
    }
}
输出：（以一个测试用例为例）
One heap of stones: [5], weight difference: 57
One heap of stones: [8], weight difference: 51
One heap of stones: [13], weight difference: 41
One heap of stones: [14], weight difference: 39
One heap of stones: [27], weight difference: 13
One heap of stones: [8, 5], weight difference: 41
One heap of stones: [13, 5], weight difference: 31
One heap of stones: [14, 5], weight difference: 29
One heap of stones: [27, 5], weight difference: 3
One heap of stones: [13, 8], weight difference: 25
One heap of stones: [14, 8], weight difference: 23
One heap of stones: [27, 8], weight difference: 3
One heap of stones: [14, 13], weight difference: 13
One heap of stones: [27, 13], weight difference: 13
One heap of stones: [27, 14], weight difference: 15

//-----另在Stream发现如下问题，对流中的List对象做add操作会抛出异常，为什么？
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;

public class ListAddInStreamTest {
    @Test
    public void testListAddInStream() {
        List<List<Integer>> integersList = Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5));
        integersList.stream().mapToInt(integers -> integers.size()).forEach(System.out::println); //这样也可以：i -> System.out.println(i)

        integersList.stream().mapToInt(integers -> {
            integers.add(1); //这里为什么add会抛出异常？
            return integers.size();
        }).forEach(i -> System.out.println(i));
    }
}
输出：
3
2

java.lang.UnsupportedOperationException
    at java.util.AbstractList.add(AbstractList.java:148)
    at java.util.AbstractList.add(AbstractList.java:108)
    at test.ListAddInStreamTest.lambda$testListAddInStream$2(ListAddInStreamTest.java:15)
    at java.util.stream.ReferencePipeline$4$1.accept(ReferencePipeline.java:210)
    at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
    at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
    at java.util.stream.ForEachOps$ForEachOp$OfInt.evaluateSequential(ForEachOps.java:189)
    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
    at java.util.stream.IntPipeline.forEach(IntPipeline.java:404)
    at test.ListAddInStreamTest.testListAddInStream(ListAddInStreamTest.java:17)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:237)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)


//------------------------------------------------------------------------------------------------
//命令行编译运行junit
1. 编译源文件：
javac -d classes src\com\huawei\demo\Hello.java
-d：指定生成的class文件目录

2. 将class文件打成jar包：
jar -cvf Hello.jar -C classes com
-c：生成新文件
-v：显示打包的详细信息
-f：指定jar包名字
-C：进入指定目录并将指定文件夹下的所有内容打包

3. 编译Test测试文件：
javac -d classes -classpath lib\junit.jar;src test\com\huawei\demo\HelloTest.java
-classpath：指定查找用户类文件和注释处理程序的位置，用;分隔指定多个查找位置，可以用-cp替换
-d：指定生成的class文件目录
说明：
--这里一定要指定src，其余src/com、src/com/huawei/demo等都不行，报错无法找到Hello，所以要按包com\huawei\demo来提供查找路径
--在当前lib目录下放置junit.jar包
--;号路径前后没有差异，如下也没有问题：javac -d classes -classpath src;lib\junit.jar test\com\huawei\demo\HelloTest.java
--还可以将-d参数与-cp参数互换位置：javac -classpath src;lib\junit.jar -d classes test\com\huawei\demo\HelloTest.java

4. 将Test.class文件打包：
jar -cvf HelloTest.jar -C classes com
说明：语句同2，所以第2步没有什么用，只是用来学习

5. 运行测试用例：
java -classpath lib\junit.jar;HelloTest.jar org.junit.runner.JUnitCore com.huawei.demo.HelloTest
-classpath：目录和 zip/jar 文件的类搜索路径，可以用-cp替换
org.junit.runner.JUnitCore [your junit test case class]
说明：运行的测试类要用完整的包和类名，com\huawei\demo\HelloTest
//------------------------------------------------------------------------------------------------
//命令行运行jar
http://lj830723.iteye.com/blog/1415766
http://blog.sina.com.cn/s/blog_98a617c70101jl91.html
1. 编译包含main函数的类：
javac Hello.java

2. 将class文件打成jar包：
jar -cvf Hello.jar Hello.class

3. 修改jar包中的文件MANIFEST.MF，添加“Main-Class: XXX”，如下第二行
Manifest-Version: 1.0
Main-Class: Hello
Created-By: 1.8.0_91 (Oracle Corporation)
说明：或者可以手工编辑MANIFEST.MF文件，在打jar包时将该文件包含进去，如下：jar -cvfm Hello.jar MANIFEST.MF Hello.class

4. 运行主函数：
java -jar Hello.jar
-jar：使用-jar参数后, 系统的Classpath变量不再起作用. 虚拟机将去MANIFEST.MF中的Class-Path下找相关的包。表示后面跟的jar包是有main class可独立运行，所以一定要在第3步添加Main-Class: XXX。
因为已经在MANIFEST.MF文件中指定了主函数，所以这里不用指定运行类Hello，当然也可以写成：java -jar Hello.jar Hello

5. 如果不采用3、4步骤，想要运行时动态指定：
java -classpath Hello.jar Hello
-classpath：可以用-cp替换

//-----
Manifest 技巧
总是以Manifest-Version属性开头
每行最长72个字符，如果超过的化，采用续行
确认每行都以回车结束，否则改行将会被忽略
如果Class-Path 中的存在路径，使用"/"分隔目录，与平台无关
使用空行分隔主属性和package属性
使用"/"而不是"."来分隔package 和class ,比如 com/example/myapp/
class 要以.class结尾，package 要以 / 结尾
//------------------------------------------------------------------------------------------------
//3n+1实现
//两个问题：
//1. 输入1怎么处理？
//2. 是否使用静态方法

出错的地方：
1. 下限1的处理方法，是否应该包括1
2. ThreeNPlusOneTransformer类的两个函数没有return返回值
3. ThreeNPlusOneTransformer类首次开发时没有使用静态方法，而测试类直接使用静态方法测试

//ThreeNPlusOneTransformer.java
package com.huawei.demo;

//import java.util.stream.Stream;

public class ThreeNPlusOneTransformer {
    private static final int MAX_INPUT = 1000000;
    private static final int MIN_INPUT = 0;
    private static final int INVALID_INPUT_RETURN_VALUE = -1;
    
    public static int getMaxStepsOf3NPlus1(int input1, int input2) {
        int minInput = Integer.min(input1, input2);
        int maxInput = Integer.max(input1, input2);
        
        if (checkInputInvalid(minInput, maxInput)) {
            return INVALID_INPUT_RETURN_VALUE;
        }
        
        return getMaxStepsOf3NPlus1OneByOne(minInput, maxInput);
    }
    
    private static boolean checkInputInvalid(int minInput, int maxInput) {
        return minInput <= MIN_INPUT || maxInput >= MAX_INPUT;
    }
    
    private static int getMaxStepsOf3NPlus1OneByOne(int minInput, int maxInput) {
        int maxSteps = 0;
        for (int i = minInput; i <= maxInput; ++i) {
            maxSteps = Integer.max(maxSteps, getStepsOf3NPlus1(i));
        }
        return maxSteps;
    }
    
    private static int getStepsOf3NPlus1(int input) {
        int steps = 1;
        while (input != 1) {
            ++steps;
            if (input % 2 == 0) {
                input /= 2;
            } else {
                input = 3 * input + 1;
            }
        }
        return steps;
        
        // int steps = (int) Stream.iterate(number, current -> {
            // if (current == 1) {
                // return 0;
            // }

            // if (current % 2 == 0) {
                // return current / 2;
            // }

            // return 3 * current + 1;
        // }).limit(100).filter(i -> i > 0).count();//这里实现得不好，没办法在得到1时终止操作，只能遍历到第100个元素结束

        // return steps - 1;
    }
}

//ThreeNPlusOneTransformerTest.java
package com.huawei.demo;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class ThreeNPlusOneTransformerTest {
    
    @Test
    public void test_getMaxSteps_differentValidInput() {
        assertEquals(8, ThreeNPlusOneTransformer.getMaxStepsOf3NPlus1(3, 5));
    }
    
    @Test
    public void test_getMaxSteps_sameValidInput() {
        assertEquals(8, ThreeNPlusOneTransformer.getMaxStepsOf3NPlus1(3, 3));
    }
    
    @Test
    public void test_getMaxSteps_inValidMinInput() {
        assertEquals(-1, ThreeNPlusOneTransformer.getMaxStepsOf3NPlus1(0, 3));
    }
    
    @Test
    public void test_getMaxSteps_inValidMaxInput() {
        assertEquals(-1, ThreeNPlusOneTransformer.getMaxStepsOf3NPlus1(5, 1000000));
    }
}
//------------------------------------------------------------------------------------------------
//Java 8的map，merge功能
@Test
public void testMapMerge() {
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1000);
    map.put("B", 2000);
    map.put("C", 3000);

    // add new key value ("A",99), if key "A" exist in map then do function  "(X,Y) -> (Y+X)" ,the function return value will replace the oldvalue.
    Integer newValue1 = map.merge("A", 99, (X, Y) -> (Y + X));
    System.out.println(newValue1);

    Integer newValue2 = map.merge("B", 666, (X, Y) -> Y);
    System.out.println(newValue2);

    Integer newValue3 = map.merge("D", 777, (X, Y) -> (Y + X));
    System.out.println(newValue3);

    System.out.println(map);
}
输出：
1099
666
777
{A=1099, B=666, C=3000, D=777}

@Test
public void testMapMerge2() {
    Map<String, List<String>> map = new HashMap<>();
    List<String> aList = new ArrayList<>();
    aList.add("a");
    //List<String> aList = Arrays.asList("a");//不能使用Arrays.asList，因为返回的List无法add值
    map.put("A", aList);

    List<String> bList = new ArrayList<>();
    bList.add("b");
    map.put("B", bList);

    List<String> newAList = Arrays.asList("aa");
    List newValue1 = map.merge("A", newAList, (strings, strings2) -> {
        strings.addAll(strings2);
        return strings;
    });
    System.out.println(newValue1);

    System.out.println(map);
}
输出：
[a, aa]
{A=[a, aa], B=[b]}
//------------------------------------------------------------------------------------------------
//Java8 Stream API
http://www.liaoxuefeng.com/article/001411309538536a1455df20d284b81a7bfa2f91db0f223000

Java 8 引入了全新的Stream API。这里的Stream和I/O流不同，它更像具有Iterable的集合类，但行为和集合类又有所不同。
Stream API引入的目的在于弥补Java函数式编程的缺陷。对于很多支持函数式编程的语言，map()、reduce()基本上都内置到语言的标准库中了，不过，Java 8的Stream API总体来讲仍然是非常完善和强大，足以用很少的代码完成许多复杂的功能。
创建一个Stream有很多方法，最简单的方法是把一个Collection变成Stream。我们来看最基本的几个操作：
//
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testStream() {
        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Stream<Integer> integerStream = integers.stream();
        integerStream.filter(i -> i % 2 == 0)
            .map(i -> i * i)
            .limit(3) //取流中的前3个
            .forEach(System.out::println);
    }
}
输出：
4
16
36
//-----
为什么不在集合类实现这些操作，而是定义了全新的Stream API？Oracle官方给出了几个重要原因：
一是集合类持有的所有元素都是存储在内存中的，非常巨大的集合类会占用大量的内存，而Stream的元素却是在访问的时候才被计算出来，这种“延迟计算”的特性有点类似Clojure的lazy-seq，占用内存很少。
二是集合类的迭代逻辑是调用者负责，通常是for循环，而Stream的迭代是隐含在对Stream的各种操作中，例如map()。

要理解“延迟计算”，不妨创建一个无穷大小的Stream。
如果要表示自然数集合，显然用集合类是不可能实现的，因为自然数有无穷多个。但是Stream可以做到。
自然数集合的规则非常简单，每个元素都是前一个元素的值+1 ，因此，自然数发生器用代码实现如下：
//
package test;

import java.util.function.Supplier;

public class NaturalSupplier implements Supplier<Long> {
    private long l = 0;

    @Override
    public Long get() {
        return ++l;
    }
}

反复调用get()，将得到一个无穷数列，利用这个Supplier，可以创建一个无穷的Stream：
//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testNaturalSupplier() {
        Stream<Long> naturals = Stream.generate(new NaturalSupplier());
        naturals.map(l -> l * l)
            .limit(10)
            .forEach(System.out::println);
    }
}
输出：
1
4
9
16
25
36
49
64
81
100

对这个Stream做任何map()、filter()等操作都是完全可以的，这说明Stream API对Stream进行转换并生成一个新的Stream并非实时计算，而是做了延迟计算。
当然，对这个无穷的Stream不能直接调用forEach()，这样会无限打印下去。但是我们可以利用limit()变换，把这个无穷Stream变换为有限的Stream。
//-----
利用Stream API，可以设计更加简单的数据接口。例如，生成斐波那契数列，完全可以用一个无穷流表示（受限Java的long型大小，可以改为BigInteger）：
//
package test;

import java.util.function.Supplier;

public class FibonacciSupplier implements Supplier<Long> {
    private long a = 0;
    private long b = 1;

    @Override
    public Long get() {
        long x = a + b;
        a = b;
        b = x;
        return x;
    }
}

//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testFibonacciSupplier() {
        Stream<Long> fibonacci  = Stream.generate(new FibonacciSupplier());
        fibonacci.limit(10)
            .forEach(System.out::println);
    }
}
输出：
1
2
3
5
8
13
21
34
55
89

如果想取得数列的前10项，用limit(10)，如果想取得数列的第20~30 项，用：
List<Long> list = fibonacci.skip(20).limit(10).collect(Collectors.toList());
最后通过collect()方法把Stream变为List。该List存储的所有元素就已经是计算出的确定的元素了。
用Stream表示Fibonacci数列，其接口比任何其他接口定义都要来得简单灵活并且高效。

//-----
计算π可以利用π的展开式：
π/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
把π表示为一个无穷Stream如下：
//
package test;

import java.util.function.Supplier;

public class PiSupplier implements Supplier<Double> {
    private double sum = 0.0;
    private double current = 1.0;
    private boolean sign = true;

    @Override
    public Double get() {
        sum += (sign ? 4 : -4) / current;
        current += 2.0;
        sign = !sign;
        return sum;
    }
}

//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testPiSupplier() {
        Stream<Double> piStream  = Stream.generate(new PiSupplier());
        piStream.skip(10000).limit(10).forEach(System.out::println); //跳过前1000项，显示10个，可以把pi值确定在3.1416和3.1414之间
    }
}
输出：
3.1416926435905346
3.1414926735860353
3.1416926235985323
3.141492693574041
3.1416926036145227
3.141492713554056
3.141692583638501
3.141492733526085
3.1416925636704622
3.1414927534901333

这个级数从100项开始可以把π的值精确到3.13~3.15 之间：
3.1514934010709914
3.1317889675734545
3.1513011626954057
3.131977491197821
3.1511162471786824
3.1321589012071183
3.150938243930123
3.132333592767332
3.1507667724908344
3.1325019323081857
//-----
利用欧拉变换对级数进行加速，可以利用下面的公式：

用代码实现就是把一个流变成另一个流：
//
package test;

import java.util.function.Function;

public class EulerTransform implements Function<Double, Double> {
    private double n1 = 0.0;
    private double n2 = 0.0;
    private double n3 = 0.0;

    @Override
    public Double apply(Double t) {
        n1 = n2;
        n2 = n3;
        n3 = t;
        if (n1 == 0.0) {
            return 0.0;
        }
        return calc();
    }

    private Double calc() {
        double d = n3 - n2;
        return n3 - d * d / (n1 - 2 * n2 + n3);
    }
}

//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testPiSupplier() {
        Stream<Double> piStream  = Stream.generate(new PiSupplier());
        piStream.map(new EulerTransform()).skip(10).limit(10).forEach(System.out::println);
    }
}
输出：
3.1418396189294033
3.141406718496503
3.1417360992606667
3.1414796890042562
3.1416831892077566
3.1415189855952774
3.141653394197428
3.1415419859977844
3.14163535667939
3.141556330284574

可以在10项之内把π的值计算到3.141~3.142 之间：

0.0
0.0
3.166666666666667
3.1333333333333337
3.1452380952380956
3.13968253968254
3.1427128427128435
3.1408813408813416
3.142071817071818
3.1412548236077655

还可以多次应用这个加速器：
//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testPiSupplier() {
        Stream<Double> piStream  = Stream.generate(new PiSupplier());
        piStream.map(new EulerTransform())
            .map(new EulerTransform())
            .map(new EulerTransform())
            .map(new EulerTransform())
            .map(new EulerTransform())
            .limit(20)
            .forEach(System.out::println);
    }
}

20 项之内可以计算出极其精确的值：
...
3.14159265359053
3.1415926535894667
3.141592653589949
3.141592653589719

可见用Stream API可以写出多么简洁的代码，用其他的模型也可以写出来，但是代码会非常复杂。
//------------------------------------------------------------------------------------------------
//Java 8 中的 Streams API 详解
http://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/
Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。
//清单 1. Java 7 的排序、取值实现

//而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。
//清单 2. Java 8 的排序、取值实现
//Cat.java
package test;

import java.awt.Color;

public class Cat {
    private final int id;
    private final int age;
    private final Color color;

    public Cat(int id, int age, Color color) {
        this.id = id;
        this.age = age;
        this.color = color;
    }

    public int getId() {
        return id;
    }

    public int getAge() {
        return age;
    }

    public Color getColor() {
        return color;
    }
}

//StreamTest.java
package test;

import org.junit.BeforeClass;
import org.junit.Test;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static java.util.Comparator.comparing;
import static org.junit.Assert.assertEquals;

public class StreamTest {

    private static List<Cat> cats;
    private static Cat cat2;
    private static Cat cat3;
    private static Cat cat1;
    private static Cat cat4;

    @BeforeClass
    public static void before() {
        cat1 = new Cat(1, 10, Color.WHITE);
        cat2 = new Cat(2, 20, Color.BLACK);
        cat3 = new Cat(3, 30, Color.BLUE);
        cat4 = new Cat(4, 40, Color.WHITE);
        cats = Arrays.asList(cat2, cat3, cat1, cat4);
    }
    
    //在该BeforeClass中初始化的static变量，可以在static块中初始化
    // static {
        // cat1 = new Cat(1, 10, Color.WHITE);
        // cat2 = new Cat(2, 20, Color.BLACK);
        // cat3 = new Cat(3, 30, Color.BLUE);
        // cat4 = new Cat(4, 40, Color.WHITE);
        // cats = Arrays.asList(cat2, cat3, cat1, cat4);
    // }

    @Test
    public void testSort() {
        List<Cat> someCats = new ArrayList<>();

        for (Cat cat : cats) {
            if (cat.getColor() == Color.WHITE) {
                someCats.add(cat);
            }
        }

        Collections.sort(someCats, new Comparator<Cat>() {
            @Override
            public int compare(Cat cat1, Cat cat2) {
                return Integer.compare(cat2.getAge(), cat1.getAge());
            }
        });

        List<Integer> catsId = new ArrayList<>();
        for (Cat cat : someCats) {
            catsId.add(cat.getId());
        }

        assertResult(catsId);
    }

    @Test
    public void testSortUsingStream() {
        List<Integer> catsId = cats.stream() //cats.parallelStream()
            .filter(cat -> cat.getColor() == Color.WHITE)
            .sorted(comparing(Cat::getAge).reversed())
            .map(Cat::getId)
            .collect(Collectors.toList());

        assertResult(catsId);
    }

    private void assertResult(List<Integer> catsId) {
        assertEquals(2, catsId.size());
        assertEquals(Optional.of(4), Optional.ofNullable(catsId.get(0)));
        assertEquals(Optional.of(1), Optional.ofNullable(catsId.get(1)));
    }
}

Stream 总览
--什么是流
Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。
Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。
而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：
1. 1.0-1.4 中的 java.lang.Thread
2. 5.0 中的 java.util.concurrent
3. 6.0 中的 Phasers 等
4. 7.0 中的 Fork/Join 框架
5. 8.0 中的 Lambda
Stream 的另外一大特点是，数据源本身可以是无限的。

--流的构成
当我们使用一个流的时候，通常包括三个基本步骤：
获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。

有多种方式生成 Stream Source：
--从 Collection 和数组
    Collection.stream()
    Collection.parallelStream()
    Arrays.stream(T array) or Stream.of()
--从 BufferedReader
    java.io.BufferedReader.lines()
--静态工厂
    java.util.stream.IntStream.range()
    java.nio.file.Files.walk()
--自己构建
    java.util.Spliterator
--其它
    Random.ints()
    BitSet.stream()
    Pattern.splitAsStream(java.lang.CharSequence)
    JarFile.stream()

流的操作类型分为两种：
Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。
Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。

在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。

还有一种操作被称为 short-circuiting。用以指：
    对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。
    对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。
当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。

清单 3. 一个流操作的示例
int sum = widgets.stream()
    .filter(w -> w.getColor() == RED)
    .mapToInt(w -> w.getWeight())
    .sum();
stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。


--流的使用详解
简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。

--流的构造与转换
下面提供最常见的几种构造 Stream 的样例。
清单 4. 构造流的几种常见方法
// 1. Individual values
Stream stream = Stream.of("a", "b", "c");
// 2. Arrays
String [] strArray = new String[] {"a", "b", "c"};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);
// 3. Collections
List<String> list = Arrays.asList(strArray);
stream = list.stream();

需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：
IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> >、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。
Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。

清单 5. 数值流的构造
IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
IntStream.range(1, 3).forEach(System.out::println); //[1, 3)
IntStream.rangeClosed(1, 3).forEach(System.out::println); //[1, 3]


清单 6. 流转换为其它数据结构
// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// Stream<String> stringStream = Stream.of("a", "b", "c");
// String[] strings = stringStream.toArray(String[]::new);
// for (String s : strings) { //查看数组内容需要手工遍历，如果用System.out.println(strings)无法打出数组元素
    // System.out.println(s);
// }

// List转换为Array可以这样处理：
// ArrayList<String> list=new ArrayList<String>();
// String[] strings = new String[list.size()];
// list.toArray(strings);
// 反过来，如果要将数组转成List怎么办呢？如下：
// String[] s = {"a","b","c"};
// List list = java.util.Arrays.asList(s);

// 2. Collection
List<String> list1 = stream.collect(Collectors.toList()); //实现是ArrayList::new
List<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new)); //List<String> list2 = stringStream.collect(Collectors.toCollection(LinkedList::new));//这里可以指定生成Collection的类型，也可以用LinkedList等

Set set1 = stream.collect(Collectors.toSet()); //HashSet::new
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();

一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。

//测试如下
package test;

import org.junit.Test;

import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testToCollection() {
        Stream<String> stringStream = Stream.of("b", "a", "c");
        Set set1 = stringStream.collect(Collectors.toCollection(TreeSet::new));
        System.out.println(set1); //[a, b, c]
    }

    @Test
    public void testToString_emptyDelimiter() {
        Stream<String> stringStream = Stream.of("b", "a", "c");
        String str = stringStream.collect(Collectors.joining()).toString();
        System.out.println(str); //bac
    }

    @Test
    public void testToString_commaDelimiter() {
        Stream<String> stringStream = Stream.of("b", "a", "c");
        String str = stringStream.collect(Collectors.joining(", ")).toString();
        System.out.println(str); //b, a, c
    }

    @Test
    public void testToString_prefixsufixDelimiter() {
        Stream<String> stringStream = Stream.of("b", "a", "c");
        String str = stringStream.collect(Collectors.joining(", ", ":", ";")).toString();
        System.out.println(str); //:b, a, c;
    }
}

--流的操作
接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。
Intermediate：
map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered
Terminal：
forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator
Short-circuiting：
anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit

我们下面看一下 Stream 的比较典型用法。
--map/flatMap
我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。
清单 7. 转换大写
List<String> output = wordList.stream().
    map(String::toUpperCase).
    collect(Collectors.toList());
这段代码把所有的单词转换为大写。

清单 8. 平方数
List<Integer> nums = Arrays.asList(1, 2, 3, 4);
List<Integer> squareNums = nums.stream().
map(n -> n * n).
collect(Collectors.toList());
这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。

从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。

清单 9. 一对多
Stream<List<Integer>> inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream<Integer> outputStream = inputStream.
flatMap((childList) -> childList.stream());

flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。
//样例
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testToCollection() {
        Stream<List<String>> listStream = Stream.of(Arrays.asList("a"), Arrays.asList("b", "c"), Arrays.asList("d", "e", "f"));
        List<String> allLists = listStream.flatMap(lists -> lists.stream()).collect(Collectors.toList());
        System.out.println(allLists); //[a, b, c, d, e, f]
    }
}

--filter
filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。
清单 10. 留下偶数
Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens = Stream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);
经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。

清单 11. 把单词挑出来
List<String> output = reader.lines().
 flatMap(line -> Stream.of(line.split(REGEXP))).
 filter(word -> word.length() > 0).
 collect(Collectors.toList());
这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。

--forEach
forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。
清单 12. 打印姓名（forEach 和 pre-java8 的对比）
// Java 8
roster.stream()
 .filter(p -> p.getGender() == Person.Sex.MALE)
 .forEach(p -> System.out.println(p.getName()));
// Pre-Java 8
for (Person p : roster) {
 if (p.getGender() == Person.Sex.MALE) {
 System.out.println(p.getName());
 }
}
对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。
但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。

另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：
     stream.forEach(element -> doOneThing(element));
     stream.forEach(element -> doAnotherThing(element));
清单 13. peek 对每个元素执行操作并返回一个新的 Stream
Stream.of("one", "two", "three", "four")
 .filter(e -> e.length() > 3)
 .peek(e -> System.out.println("Filtered value: " + e))
 .map(String::toUpperCase)
 .peek(e -> System.out.println("Mapped value: " + e))
 .collect(Collectors.toList());
forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。

--findFirst
这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。
这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。
清单 14. Optional 的两个用例
String strA = " abcd ", strB = null;
print(strA);
print("");
print(strB);
getLength(strA);
getLength("");
getLength(strB);
public static void print(String text) {
    // Java 8
    Optional.ofNullable(text).ifPresent(System.out::println);
    // Pre-Java 8
    if (text != null) {
        System.out.println(text);
    }
}
public static int getLength(String text) {
    // Java 8
    return Optional.ofNullable(text).map(String::length).orElse(-1);
    // Pre-Java 8
    return (text != null) ? text.length() : -1;
};

在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。
Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。

--reduce
这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于
Integer sum = integers.reduce(0, (a, b) -> a+b);
或
Integer sum = integers.reduce(0, Integer::sum);
也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。
清单 15. reduce 的用例
// 字符串连接，concat = "ABCD"
String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); 
// 求最小值，minValue = -3.0
double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
// 求和，sumValue = 10, 有起始值
int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
// 求和，sumValue = 10, 无起始值
sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
// 过滤，字符串连接，concat = "ace"
concat = Stream.of("a", "B", "c", "D", "e", "F").
 filter(x -> x.compareTo("Z") > 0).
 reduce("", String::concat);
上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。

--limit/skip
limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。
清单 16. limit 和 skip 对运行次数的影响
package test;

import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class StreamTest {

    private class Person {
        public int no;
        private String name;

        public Person(int no, String name) {
            this.no = no;
            this.name = name;
        }

        public String getName() {
            System.out.println(name);
            return name;
        }
    }

    @Test
    public void testLimitAndSkip() {
        List<Person> persons = new ArrayList();
        for (int i = 1; i <= 10000; i++) {
            Person person = new Person(i, "name" + i);
            persons.add(person);
        }

        List<String> personList2 = persons.stream().
            map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
        System.out.println(personList2);
    }
}
输出：
name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]

这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。

有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。
清单 17. limit 和 skip 对 sorted 后的运行次数无影响
@Test
public void testLimitAfterSorted() {
    List<Person> persons = new ArrayList();
    for (int i = 1; i <= 5; i++) {
        Person person = new Person(i, "name" + i);
        persons.add(person);
    }
    
    List<String> personList2 = persons.stream().sorted((p1, p2) ->
            p1.getName().compareTo(p2.getName())).limit(2).map(Person::getName).collect(Collectors.toList());
        System.out.println(personList2);
}
输出：
name2
name1
name3
name2
name4
name3
name5
name4
name1 --这两个是map(Person::getName)的输出
name2
[name1, name2]

上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果如上。

最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。

--sorted
对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：
清单 18. 优化：排序前进行 limit 和 skip
//另外，试验先limit再sorted，可以看到只对两个元素进行了排序
@Test
public void testLimitBeforeSorted() {
    List<Person> persons = new ArrayList();
    for (int i = 1; i <= 5; i++) {
        Person person = new Person(i, "name" + i);
        persons.add(person);
    }

    List<String> personList2 = persons.stream().limit(2).sorted((p1, p2) ->
        p1.getName().compareTo(p2.getName())).map(Person::getName).collect(Collectors.toList());
    System.out.println(personList2);
}
输出
name2
name1
name1
name2
[name1, name2]
当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。

--min/max/distinct
min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。
清单 19. 找出最长一行的长度
//abc.txt
day
hello
nice

//
package test;

import org.junit.Test;

import java.io.BufferedReader;
import java.io.FileReader;

public class StreamTest {

    @Test
    public void testLimitAndSkip() {
        try {
            FileReader fr = new FileReader("src/main/java/test/abc.txt");
            BufferedReader br = new BufferedReader(fr);

            int longest = br.lines().
                mapToInt(String::length).
                max().
                getAsInt();

            br.close();
            fr.close();
            System.out.println(longest);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
5

下面的例子则使用 distinct 来找出不重复的单词。
清单 20. 找出全文的单词，转小写，并排序
//abc.txt
hello what a nice day
DAY day up GOOD good study
HELLO

//
package test;

import org.junit.Test;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testLimitAndSkip() {
        try {
            FileReader fr = new FileReader("src/main/java/test/abc.txt"); //这里如果路径为main/java/test/abc.txt，则找不到相应文件
            BufferedReader br = new BufferedReader(fr);

            List<String> words = br.lines().
                flatMap(line -> Stream.of(line.split(" "))).
                filter(word -> word.length() > 0).
                map(String::toLowerCase).
                distinct().
                sorted().
                collect(Collectors.toList());

            br.close();
            fr.close();
            System.out.println(words);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
[a, day, good, hello, nice, study, up, what]


--Match
Stream 有三个 match 方法，从语义上说：
allMatch：Stream 中全部元素符合传入的 predicate，返回 true
anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true
noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true
它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。
清单 21. 使用 Match
List<Person> persons = new ArrayList();
persons.add(new Person(1, "name" + 1, 10));
persons.add(new Person(2, "name" + 2, 21));
persons.add(new Person(3, "name" + 3, 34));
persons.add(new Person(4, "name" + 4, 6));
persons.add(new Person(5, "name" + 5, 55));
boolean isAllAdult = persons.stream().
 allMatch(p -> p.getAge() > 18);
System.out.println("All are adult? " + isAllAdult);
boolean isThereAnyChild = persons.stream().
 anyMatch(p -> p.getAge() < 12);
System.out.println("Any child? " + isThereAnyChild);
输出结果：
 All are adult? false
 Any child? true

//-----
进阶：自己生成流
--Stream.generate
通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。
清单 22. 生成 10 个随机整数
package test;

import org.junit.Test;

import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testRandom() {
        Random seed = new Random();
        Supplier<Integer> random = seed::nextInt;
        Stream.generate(random).limit(10).forEach(System.out::println);

        //Another way
        IntStream.generate(() -> (int) (System.nanoTime() % 100)).
            limit(10).forEach(System.out::println);
    }
}
输出：
943966293
2055700156
-844810453
817068663
444598564
-624756530
-260647001
-613986940
-1579427386
154983337
87
44
97
50
92
34
21
7
38
70

Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。
清单 23. 自实现 Supplier
//
package test;

import org.junit.Test;

import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testRandom() {
        Stream.generate(new PersonSupplier()).
            limit(10).
            forEach(p -> System.out.println(p.getName() + ", " + p.getAge()));
    }

    private class PersonSupplier implements Supplier<Person> {
        private int index = 0;
        private Random random = new Random();

        @Override
        public Person get() {
            return new Person(index++, "StormTestUser" + index, random.nextInt(100));
        }
    }

    private class Person {
        public int no;
        private String name;
        private int age;

        public Person(int no, String name, int age) {
            this.no = no;
            this.name = name;
            this.age = age;
        }

        public int getAge() {
            return age;
        }

        public String getName() {
            return name;
        }
    }
}

--Stream.iterate
iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。
清单 24. 生成一个等差数列
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testRandom() {
        Stream.iterate(0, n -> n + 3).limit(10).forEach(x -> System.out.print(x + " "));
    }
}
输出：
0 3 6 9 12 15 18 21 24 27
与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。

//-----
进阶：用 Collectors 来进行 reduction 操作
java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。
groupingBy/partitioningBy
清单 25. 按照年龄归组
@Test
public void testRandom() {
    Stream<Person> personStream = Stream.generate(new PersonSupplier());
    Map<Integer, List<Person>> personGroups = personStream.limit(100).collect(Collectors.groupingBy(Person::getAge));
    Iterator<Map.Entry<Integer, List<Person>>> iterator = personGroups.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<Integer, List<Person>> persons = iterator.next();
        System.out.println("Age " + persons.getKey() + " = " + persons.getValue().size());
    }
}
输出：
Age 0 = 3
Age 2 = 1
Age 3 = 1
Age 4 = 4
Age 5 = 1
Age 13 = 1
Age 15 = 1
Age 17 = 3
Age 18 = 1
Age 19 = 1
Age 20 = 4
Age 22 = 1
Age 23 = 3
Age 24 = 1
Age 25 = 1
Age 26 = 1
Age 28 = 1
Age 29 = 1
Age 36 = 5
Age 37 = 1
Age 39 = 1
Age 40 = 3
Age 42 = 1
Age 44 = 1
Age 45 = 1
Age 47 = 1
Age 48 = 2
Age 50 = 1
Age 51 = 1
Age 52 = 1
Age 55 = 1
Age 56 = 1
Age 57 = 3
Age 58 = 1
Age 59 = 1
Age 61 = 2
Age 62 = 2
Age 63 = 2
Age 65 = 1
Age 66 = 2
Age 70 = 1
Age 71 = 1
Age 72 = 1
Age 75 = 1
Age 76 = 1
Age 77 = 1
Age 78 = 2
Age 80 = 1
Age 81 = 2
Age 83 = 1
Age 87 = 1
Age 88 = 3
Age 89 = 4
Age 90 = 1
Age 91 = 1
Age 93 = 1
Age 94 = 2
Age 96 = 4
Age 97 = 1
Age 98 = 3
Age 99 = 2

清单 26. 按照未成年人和成年人归组
@Test
public void testRandom() {
    Map<Boolean, List<Person>> children = Stream.generate(new PersonSupplier()).
        limit(100).
        collect(Collectors.partitioningBy(p -> p.getAge() < 18));
    System.out.println("Children number: " + children.get(true).size());
    System.out.println("Adult number: " + children.get(false).size());
}
输出：
Children number: 13
Adult number: 87
在使用条件“年龄小于18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。

//-----
结束语
总之，Stream 的特性可以归纳为：
不是数据结构
它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。
它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。
所有 Stream 的操作必须以 lambda 表达式为参数
不支持索引访问
你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。
很容易生成数组或者 List
惰性化
很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。
Intermediate 操作永远是惰性化的。
并行能力
当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。
可以是无限的
集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。
//------------------------------------------------------------------------------------------------
//Java Stream 使用详解
http://www.codeceo.com/article/java-stream-usage.html
本节翻译整理自 Javadoc ，并对流的这些特性做了进一步的解释。

//-----
Stream接口还包含几个基本类型的子接口如IntStream, LongStream 和 DoubleStream。

关于流和其它集合具体的区别，可以参照下面的列表：
--不存储数据 。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。
--函数式编程 。流的操作不会修改数据源，例如filter不会将数据源中的数据删除。
--延迟操作 。流的很多操作如filter,map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。
--可以解绑 。对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n)或findFirst()，这些操作可是实现”短路”(Short-circuiting)，访问到有限的元素后就可以返回。
--纯消费 。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。
流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。
//-----
并行 Parallelism
所有的流操作都可以串行执行或者并行执行。除非显示地创建并行流，否则Java库中创建的都是串行流。Collection.stream()为集合创建串行流而Collection.parallelStream()为集合创建并行流。IntStream.range(int, int)创建的是串行流。通过parallel()方法可以将串行流转换成并行流,sequential()方法将流转换成并行流。
除非方法的Javadoc中指明了方法在并行执行的时候结果是不确定(比如findAny、forEach)，否则串行和并行执行的结果应该是一样的。
//-----
不干涉 Non-interference
流可以从非线程安全的集合中创建，当流的管道执行的时候，非concurrent数据源不应该被改变。下面的代码会抛出java.util.ConcurrentModificationException异常：
List<String> l = new ArrayList(Arrays.asList("one", "two"));
Stream<String> sl = l.stream();
sl.forEach(s -> l.add("three"));

在设置中间操作的时候，可以更改数据源，只有在执行终点操作的时候，才有可能出现并发问题(抛出异常，或者不期望的结果)，比如下面的代码不会抛出异常：
List<String> l = new ArrayList(Arrays.asList("one", "two"));
Stream<String> sl = l.stream();
l.add("three");sl.forEach(System.out::println);

对于concurrent数据源，不会有这样的问题，比如下面的代码很正常：
List<String> l = new CopyOnWriteArrayList<>(Arrays.asList("one", "two"));
Stream<String> sl = l.stream();
sl.forEach(s -> l.add("three"));
虽然我们上面例子是在终点操作中对非并发数据源进行修改，但是非并发数据源也可能在其它线程中修改，同样会有并发问题。
//-----
无状态 Stateless behaviors
大部分流的操作的参数都是函数式接口，可以使用Lambda表达式实现。它们用来描述用户的行为，称之为行为参数(behavioral parameters)。
如果这些行为参数有状态，则流的操作的结果可能是不确定的，比如下面的代码:
List<String> l = new ArrayList(Arrays.asList("one", "two", ……));
class State {
    boolean s;
}
final State state = new State();
Stream<String> sl = l.stream().map(e -> {
    if (state.s)
        return "OK";    
    else {
        state.s = true;
        return e;
    } 
    });
sl.forEach(System.out::println);
上面的代码在并行执行时多次的执行结果可能是不同的。这是因为这个lambda表达式是有状态的。
//-----
副作用 Side-effects
有副作用的行为参数是（不？）被鼓励使用的。
副作用指的是行为参数在执行的时候有输入输入，比如网络输入输出等。
这是因为Java不保证这些副作用对其它线程可见，也不保证相同流管道上的同样的元素的不同的操作运行在同一个线程中。
很多有副作用的行为参数可以被转换成无副作用的实现。一般来说println()这样的副作用代码不会有害。
ArrayList<String> results = new ArrayList<>();
stream.filter(s -> pattern.matcher(s).matches())      
    .forEach(s -> results.add(s));  // 副作用代码
上面的代码可以改成无副作用的。
List<String>results = stream.filter(s -> pattern.matcher(s).matches())          
    .collect(Collectors.toList());  // No side-effects!
//-----
排序 Ordering
某些流的返回的元素是有确定顺序的，我们称之为encounter order。这个顺序是流提供它的元素的顺序，比如数组的encounter order是它的元素的排序顺序，List是它的迭代顺序(iteration order)，对于HashSet,它本身就没有encounter order。

一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的。

sorted()方法可以将流转换成有序的，unordered可以将流转换成无序的。除此之外，一个操作可能会影响流的有序,比如map方法，它会用不同的值甚至类型替换流中的元素，所以输入元素的有序性已经变得没有意义了，但是对于filter方法来说，它只是丢弃掉一些值而已，输入元素的有序性还是保障的。

对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。

对于并行流，去掉有序这个约束可能会提供性能，比如distinct、groupingBy这些聚合操作。
//-----
结合性 Associativity
一个操作或者函数op满足结合性意味着它满足下面的条件：
(a op b) op c == a op (b op c)

对于并发流来说，如果操作满足结合性，我们就可以并行计算：
a op b op c op d == (a op b) op (c op d)
比如min、max以及字符串连接都是满足结合性的。
//-----
创建Stream

可以通过多种方式创建流：

1、 通过集合的stream()方法或者parallelStream()，比如Arrays.asList(1,2,3).stream()。
    
2、 通过Arrays.stream(Object[])方法, 比如Arrays.stream(new int[]{1,2,3})。
    
3、 使用流的静态方法，比如Stream.of(Object[]),IntStream.range(int, int)或者Stream.iterate(Object, UnaryOperator)，如Stream.iterate(0, n -> n * 2)，或者generate(Supplier<T> s)如Stream.generate(Math::random)。
    
4、 BufferedReader.lines()从文件中获得行的流。
    
5、 Files类的操作路径的方法，如list、find、walk等。
    
6、 随机数流Random.ints()。
    
7、 其它一些类提供了创建流的方法，如BitSet.stream(),Pattern.splitAsStream(java.lang.CharSequence), 和JarFile.stream()。
    
8、 更底层的使用StreamSupport，它提供了将Spliterator转换成流的方法。
package test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class StreamTest {
    @Before
    public void setUp() {
        System.out.println("before a test");
    }

    @After
    public void tearDown() {
        System.out.println("after a test");
    }

    @Test
    public void testStreamIterate() {
        Stream<Integer> integerStream = Stream.iterate(0, n -> n + 2);
        integerStream.limit(10).forEach(System.out::println);
    }

    @Test
    public void testStreamGenerate() {
        Stream<Double> doubleStream = Stream.generate(Math::random);
        doubleStream.limit(10).forEach(System.out::println);
    }

    @Test
    public void testArraysStream() {
        IntStream integerStream = Arrays.stream(new int[]{3, 5, 7});
        integerStream.limit(10).forEach(System.out::println); //limit(10)没有作用
    }

    @Test
    public void testStreamOf() {
        Stream<Integer> integerStream = Stream.of(3, 5, 7);
        integerStream.limit(10).forEach(System.out::println); //limit(10)没有作用
    }
}
输出：
before a test
0.6412578001250876
0.6807637928663443
0.4643683375012767
0.9000359460802849
0.7639279866143656
0.6827440857975002
0.32281157764858115
0.44884674944585
0.46244218856353414
0.6012744202148783
after a test
before a test
3
5
7
after a test
before a test
3
5
7
after a test
before a test
0
2
4
6
8
10
12
14
16
18
after a test
//-----
中间操作 intermediate operations

中间操作会返回一个新的流，并且操作是延迟执行的(lazy)，它不会修改原始的数据源，而且是由在终点操作开始的时候才真正开始执行。这个Scala集合的转换操作不同，Scala集合转换操作会生成一个新的中间集合，显而易见Java的这种设计会减少中间对象的生成。

下面介绍流的这些中间操作：

--distinct
distinct保证输出的流中包含唯一的元素，它是通过Object.equals(Object)来检查是否包含相同的元素。
List<String> l = Stream.of("a","b","c","b")        .distinct()        .collect(Collectors.toList());System.out.println(l); //[a, b, c]

--filter
filter返回的流中只包含满足断言(predicate)的数据。
下面的代码返回流中的偶数集合。
List<Integer> l = IntStream.range(1,10).filter( i -> i % 2 == 0).boxed().collect(Collectors.toList());
System.out.println(l); //[2, 4, 6, 8]
//
package test;

import org.junit.Test;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class StreamTest {

    @Test
    public void testIntStreamRange() {
        List<Integer> l = IntStream.range(1,10)
            .filter(i -> i % 2 == 0)
            .boxed() //这里不用装箱操作返回Stream<Integer>，collect操作会编译错误
            .collect(Collectors.toList());
        System.out.println(l); //[2, 4, 6, 8]
    }

    @Test
    public void testIntStreamRangeForeach() {
        IntStream.range(1,10).boxed().forEach(System.out::println); //这里加不加boxed都没有关系
    }
}

--map
map方法将流中的元素映射成另外的值，新的值类型可以和原来的元素的类型不同。
下面的代码中将字符元素映射成它的哈希码(ASCII值)。
List<Integer> l = Stream.of('a','b','c')
    .map(c -> c.hashCode())
    .collect(Collectors.toList());
System.out.println(l); //[97, 98, 99]

--flatmap
flatmap方法混合了map+flattern的功能，它将映射后的流的元素全部放入到一个新的流中。它的方法定义如下：
<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper) //解释为入参数为一个Function，消费T，生产R的Stream
可以看到mapper函数会将每一个元素转换成一个流对象，而flatMap方法返回的流包含的元素为mapper生成的流中的元素。

下面这个例子中将一首唐诗生成一个按行分割的流，然后在这个流上调用flatmap得到单词的小写形式的集合，去掉重复的单词然后打印出来。
//
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testFlagMap() {
        String poetry = "Where, before me, are the ages that have gone?/n"
            + "And where, behind me, are the coming generations?/n"
            + "I think of heaven and earth, without limit, without end,/n"
            + "And I am all alone and my tears fall down.";
        Stream<String> lines = Arrays.stream(poetry.split("/n"));
        Stream<String> words = lines.flatMap(line -> Arrays.stream(line.split(" "))); //flatMap是把每一个元素映射成一个stream
        List<String> l = words.map(w -> {
            if (w.endsWith(",") || w.endsWith(".") || w.endsWith("?"))
                return w.substring(0, w.length() - 1).trim().toLowerCase();
            else
                return w.trim().toLowerCase();
        })
            .distinct()
            .sorted()
            .collect(Collectors.toList());
        System.out.println(l); //[ages, all, alone, am, and, are, before, behind, coming, down, earth, end, fall, generations, gone, have, heaven, i, limit, me, my, of, tears, that, the, think, where, without]
    }
}
输出：
[ages, all, alone, am, and, are, before, behind, coming, down, earth, end, fall, generations, gone, have, heaven, i, limit, me, my, of, tears, that, the, think, where, without]

flatMapToDouble、flatMapToInt、flatMapToLong提供了转换成特定流的方法。

--peek
peek方法方法会使用一个Consumer消费流中的元素，但是返回的流还是包含原来的流中的元素。
String[] arr = new String[]{"a","b","c","d"};
Arrays.stream(arr).peek(System.out::println) //a,b,c,d        .count();
//
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void testPeek() {
        String[] arr = new String[]{"a","b","c","d"};
        Arrays.stream(arr).peek(System.out::println).count(); //如果没有count()，则peek里的Consumer操作不会执行

        Stream.of("one", "two", "three", "four")
            .filter(e -> e.length() > 3)
            .peek(e -> System.out.println("Filtered value: " + e))
            .map(String::toUpperCase)
            .peek(e -> System.out.println("Mapped value: " + e))
            .collect(Collectors.toList());//如果没有collect，则peek里的Consumer操作不会执行；还有这里的输出显示流操作是按元素从头到尾，而不是所有元素操作完再进行下一元素
    }
}
输出：
a
b
c
d
Filtered value: three
Mapped value: THREE
Filtered value: four
Mapped value: FOUR

--sorted
sorted()将流中的元素按照自然排序方式进行排序，如果元素没有实现Comparable，则终点操作执行时会抛出java.lang.ClassCastException异常。sorted(Comparator<? super T> comparator)可以指定排序的方式。
对于有序流，排序是稳定的。对于非有序流，不保证排序稳定。
String[] arr = new String[]{"b_123","c+342","b#632","d_123"};
List<String> l  = Arrays.stream(arr)
    .sorted((s1,s2) -> {
        if (s1.charAt(0) == s2.charAt(0))
            return s1.substring(2).compareTo(s2.substring(2));
        else
            return s1.charAt(0) - s2.charAt(0);
    })
        .collect(Collectors.toList());
    System.out.println(l); //[b_123, b#632, c+342, d_123]
//-----
终点操作 terminal operations

--match
public boolean allMatch(Predicate<? super T> predicate)
public boolean anyMatch(Predicate<? super T> predicate)
public boolean noneMatch(Predicate<? super T> predicate)
这一组方法用来检查流中的元素是否满足断言。
allMatch只有在所有的元素都满足断言时才返回true,否则flase,流为空时总是返回true
anyMatch只有在任意一个元素满足断言时就返回true,否则flase,
noneMatch只有在所有的元素都不满足断言时才返回true,否则flase,

System.out.println(Stream.of(1,2,3,4,5).allMatch( i -> i > 0)); //true      
System.out.println(Stream.of(1,2,3,4,5).anyMatch( i -> i > 0)); //true      
System.out.println(Stream.of(1,2,3,4,5).noneMatch( i -> i > 0)); //false

System.out.println(Stream.<Integer>empty().allMatch( i -> i > 0)); //true      
System.out.println(Stream.<Integer>empty().anyMatch( i -> i > 0)); //false      
System.out.println(Stream.<Integer>empty().noneMatch( i -> i > 0)); //true

--count
count方法返回流中的元素的数量。它实现为：
mapToLong(e -> 1L).sum();

--collect
<R,A> R collect(Collector<? super T,A,R> collector)
<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)

使用一个collector执行mutable reduction操作。辅助类 Collectors 提供了很多的collector，可以满足我们日常的需求，你也可以创建新的collector实现特定的需求。它是一个值得关注的类，你需要熟悉这些特定的收集器，如聚合类averagingInt、最大最小值maxByminBy、计数counting、分组groupingBy、字符串连接joining、分区partitioningBy、汇总summarizingInt、化简reducing、转换toXXX等。

IntStream intStream = Arrays.stream(new int[]{10, 9, 8, 7, 6, 5});
intStream.boxed().collect(maxBy((i1, i2) -> Integer.compare(i1, i2))); //不太会用？

第二个提供了更底层的功能，它的逻辑类似下面的伪代码：
R result = supplier.get();
for (T element : this stream)
    accumulator.accept(result, element);
return result;

例子：
List<String> asList = stringStream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
String concat = stringStream.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();

--find
findAny()返回任意一个元素，如果流为空，返回空的Optional，对于并行流来说，它只需要返回任意一个元素即可，所以性能可能要好于findFirst()，但是有可能多次执行的时候返回的结果不一样。findFirst()返回第一个元素，如果流为空，返回空的Optional。

--forEach、forEachOrdered
forEach遍历流的每一个元素，执行指定的action。它是一个终点操作，和peek方法不同。这个方法不担保按照流的encounter order顺序执行，如果对于有序流按照它的encounter order顺序执行，你可以使用forEachOrdered方法。
Stream.of(1,2,3,4,5).forEach(System.out::println);

--最大最小值
max返回流中的最大值，min返回流中的最小值。

IntStream intStream = Arrays.stream(new int[]{10, 9, 8, 7, 6, 5});
System.out.println(intStream.max().getAsInt()); //10

--reduce
reduce是常用的一个方法，事实上很多操作都是基于它实现的。它有几个重载方法：

pubic Optional<T> reduce(BinaryOperator<T> accumulator)
pubic T reduce(T identity, BinaryOperator<T> accumulator)
pubic <U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

第一个方法使用流中的第一个值作为初始值，后面两个方法则使用一个提供的初始值。
Optional<Integer> total = Stream.of(1,2,3,4,5).reduce( (x, y) -> x +y);
Integer total2 = Stream.of(1,2,3,4,5).reduce(0, (x, y) -> x +y);
值得注意的是accumulator应该满足结合性(associative)。
//
package test;

import org.junit.Test;

import java.util.Optional;
import java.util.stream.Stream;

public class StreamTest {

    @Test
    public void test() {
        Optional<Integer> total = Stream.of(1, 2, 3, 4, 5).reduce((x, y) -> x + y); //以第1个元素为初始值依次累加，就有可能是NULL，所以返回值是Optional
        System.out.println(total);

        Optional<Integer> totalNull = Stream.<Integer>empty().reduce((x, y) -> x + y);
        System.out.println(totalNull.isPresent());
        System.out.println(totalNull);

        Integer total2 = Stream.of(1, 2, 3, 4, 5).reduce(0, (x, y) -> x + y); //以提供值为初始值，返回值为提供值类型
        System.out.println(total2);

        Integer total2Null = Stream.<Integer>empty().reduce(0, (x, y) -> x + y);
        System.out.println(total2Null);
    }
}
输出：
Optional[15]
false
Optional.empty
15
0

--toArray()
将流中的元素放入到一个数组中。


--组合
concat用来连接类型一样的两个流。
public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)

--转换
toArray方法将一个流转换成数组，而如果想转换成其它集合类型，需要调用collect方法，利用Collectors.toXXX方法进行转换：
public static <T,C extends Collection<T>> Collector<T,?,C> toCollection(Supplier<C> collectionFactory)
public static …… toConcurrentMap(……)
public static <T> Collector<T,?,List<T>> toList()
public static ……     toMap(……)
public static <T> Collector<T,?,Set<T>> toSet()
//------------------------------------------------------------------------------------------------
//Java 8 Streams API：对Stream分组和分区
http://www.importnew.com/17313.html
这篇文章展示了如何使用 Streams API 中的 Collector 及 groupingBy 和 partitioningBy 来对流中的元素进行分组和分区。
思考一下 Employee 对象流，每个对象对应一个名字、城市和销售数量，如下表所示：
+----------+------------+-----------------+
| Name     | City       | Number of Sales |
+----------+------------+-----------------+
| Alice    | London     | 200             |
| Bob      | London     | 150             |
| Charles  | New York   | 160             |
| Dorothy  | Hong Kong  | 190             |
+----------+------------+-----------------+
1. 分组
首先，我们利用（lambda表达式出现之前的）命令式风格Java 程序对流中的雇员按城市进行分组：
Map<String, List<Employee>> result = new HashMap<>();
for (Employee e : employees) {
  String city = e.getCity();
  List<Employee> empsInCity = result.get(city);
  if (empsInCity == null) {
    empsInCity = new ArrayList<>();
    result.put(city, empsInCity);
  }
  empsInCity.add(e);
}
你可能很熟悉写这样的代码，你也看到了，一个如此简单的任务就需要这么多代码！

而在 Java 8 中，你可以使用 groupingBy 收集器，一条语句就能完成相同的功能，像这样：
Map<String, List<Employee>> employeesByCity =
  employees.stream().collect(groupingBy(Employee::getCity));
结果如下面的 map 所示：
{New York=[Charles], Hong Kong=[Dorothy], London=[Alice, Bob]}

还可以计算每个城市中雇员的数量，只需传递一个计数收集器给 groupingBy 收集器。第二个收集器的作用是在流分类的同一个组中对每个元素进行递归操作。
Map<String, Long> numEmployeesByCity =
  employees.stream().collect(groupingBy(Employee::getCity, counting()));
结果如下面的 map 所示：
{New York=1, Hong Kong=1, London=2}
顺便提一下，该功能与下面的 SQL 语句是等同的：
select city, count(*) from Employee group by city

另一个例子是计算每个城市的平均年龄，这可以联合使用 averagingInt 和 groupingBy 收集器：
Map<String, Double> avgSalesByCity =
  employees.stream().collect(groupingBy(Employee::getCity,
结果如下 map 所示：
{New York=160.0, Hong Kong=190.0, London=175.0}

2. 分区
分区是一种特殊的分组，结果 map 至少包含两个不同的分组――一个true，一个false。例如，如果想找出最优秀的员工，你可以将所有雇员分为两组，一组销售量大于 N，另一组小于 N，使用 partitioningBy 收集器：
Map<Boolean, List<Employee>> partitioned =
  employees.stream().collect(partitioningBy(e -> e.getNumSales() > 150));
输出如下结果：
{false=[Bob], true=[Alice, Charles, Dorothy]}

你也可以将 groupingBy 收集器传递给 partitioningBy 收集器来将联合使用分区和分组。例如，你可以统计每个分区中的每个城市的雇员人数：
Map<Boolean, Map<String, Long>> result =
  employees.stream().collect(partitioningBy(e -> e.getNumSales() > 150,
                               groupingBy(Employee::getCity, counting())));
这样会生成一个二级 Map:
{false={London=1}, true={New York=1, Hong Kong=1, London=1}}

//测试代码如下：
//Employee.java
package test;

public class Employee {
    private String name;
    private String city;
    private int sales;

    public Employee(String name, String city, int sales) {
        this.name = name;
        this.city = city;
        this.sales = sales;
    }

    public String getName() {
        return name;
    }

    public String getCity() {
        return city;
    }

    public int getSales() {
        return sales;
    }

}

//Grouper.java
package test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.stream.Collectors.averagingInt;
import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.partitioningBy;

public class Grouper {
    public static Map<String, List<Employee>> groupByCityUsingOld(List<Employee> employees) {
        Map<String, List<Employee>> result = new HashMap<>();
        for (Employee e : employees) {
            String city = e.getCity();
            List<Employee> empsInCity = result.get(city);
            if (empsInCity == null) {
                empsInCity = new ArrayList<>();
                result.put(city, empsInCity);
            }
            empsInCity.add(e);
        }
        return result;
    }

    public static Map<String, List<Employee>> groupByCityUsingStream(List<Employee> employees) {
        Map<String, List<Employee>> result = employees.stream().collect(groupingBy(Employee::getCity));
        return result;
        //return employees.stream().collect(groupingBy(Employee::getCity));
    }

    public static Map<String, Long> groupNumByCity(List<Employee> employees) {
        Map<String, Long> result = employees.stream().collect(groupingBy(Employee::getCity, counting()));
        return result;
    }

    public static Map<String, Double> groupAverageSalesByCity(List<Employee> employees) {
        Map<String, Double> result = employees.stream().collect(groupingBy(Employee::getCity, averagingInt(Employee::getSales)));
        return result;
    }

    public static Map<Boolean, List<Employee>> partitionBySales(List<Employee> employees) {
        Map<Boolean, List<Employee>> result = employees.stream().collect(partitioningBy(e -> e.getSales() > 150));
        return result;
    }

    public static Map<Boolean, Map<String, Long>> partitionBySalseAndThenCountByCity(List<Employee> employees) {
        Map<Boolean, Map<String, Long>> result = employees.stream().collect(
            partitioningBy(e -> e.getSales() > 150, groupingBy(Employee::getCity, counting())));
        return result;
    }
}

//GouperTest.java
package test;

import org.junit.BeforeClass;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import static org.hamcrest.core.IsCollectionContaining.hasItem;
import static org.hamcrest.core.IsCollectionContaining.hasItems;
import static org.hamcrest.Matchers.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;

public class GrouperTest {

    private static List<Employee> employees;
    private static Employee alice;
    private static Employee bob;
    private static Employee charles;
    private static Employee dorothy;

    @BeforeClass
    public static void before() {
        employees = new ArrayList<>();
        alice = new Employee("Alice", "London", 200);
        bob = new Employee("Bob", "London", 150);
        charles = new Employee("Charles", "New York", 160);
        dorothy = new Employee("Dorothy", "Hong Kong", 190);

        employees.add(alice);
        employees.add(bob);
        employees.add(charles);
        employees.add(dorothy);
    }

    @Test
    public void testGroupUsingOldCodeStyle() {
        Map<String, List<Employee>> result = Grouper.groupByCityUsingOld(employees);
        assertCityGrouperResult(result);
    }

    @Test
    public void testGroupUsingStream() {
        Map<String, List<Employee>> result = Grouper.groupByCityUsingStream(employees);
        assertCityGrouperResult(result);
    }

    private void assertCityGrouperResult(Map<String, List<Employee>> result) {
        assertEquals(3, result.size());

        List<Employee> empsInLondon = result.get("London");
        assertThat(empsInLondon, hasItem(alice));
        assertThat(empsInLondon, hasItem(bob));
        assertThat(empsInLondon, hasItems(alice, bob));
        //assertThat(empsInLondon, hasItem(new Employee("Alice", "London", 200))); 这个判断将失败，所以是基于引用的相等？

        List<Employee> empsInNewYork = result.get("New York");
        assertThat(empsInNewYork, hasItem(charles));

        List<Employee> empsInHongKong = result.get("Hong Kong");
        assertThat(empsInHongKong, hasItem(dorothy));
    }

    @Test
    public void testGroupAndCountUsingSteam() {
        Map<String, Long> empCityNumberMap = Grouper.groupNumByCity(employees);

        assertEquals(3, empCityNumberMap.size());
        assertThat(empCityNumberMap, hasEntry("London", 2L));
        assertThat(empCityNumberMap, hasEntry("New York", 1L));
        assertThat(empCityNumberMap, hasEntry("Hong Kong", 1L));
//        Long empsNumInLondon = empCityNumberMap.get("London");
//        assertEquals(2, empsNumInLondon.longValue());
//
//        Long empsNumInNewYork = empCityNumberMap.get("New York");
//        assertEquals(1, empsNumInNewYork.longValue());
//
//        Long empsNumInHongKong = empCityNumberMap.get("Hong Kong");
//        assertEquals(1, empsNumInHongKong.longValue());
    }

    @Test
    public void testGroupAndAverageUsingStream() {
        Map<String, Double> empCitySalesMap = Grouper.groupAverageSalesByCity(employees);
        assertEquals(3, empCitySalesMap.size());
        assertThat(empCitySalesMap, hasEntry("London", 175.0));
        assertThat(empCitySalesMap, hasEntry("New York", 160.0));
        assertThat(empCitySalesMap, hasEntry("Hong Kong", 190.0));
    }

    @Test
    public void testPartition() {
        Map<Boolean, List<Employee>> partitioned = Grouper.partitionBySales(employees);
        assertEquals(2, partitioned.size());

        List<Employee> falseList = partitioned.get(false);
        assertThat(falseList, hasItem(bob));

        List<Employee> trueList = partitioned.get(true);
        assertThat(trueList, hasItems(alice, charles, dorothy));

//        //也可以用如下方法测试
//        List<Employee> toBeTestedList = new ArrayList<>();
//        toBeTestedList.add(bob);
//        assertThat(partitioned, hasEntry(false, toBeTestedList));
//
//        toBeTestedList.clear();
//        toBeTestedList.addAll(Arrays.asList(alice, charles, dorothy));
//        assertThat(partitioned, hasEntry(true, toBeTestedList));
    }

    @Test
    public void testPartitionAndGroupCombination() {
        Map<Boolean, Map<String, Long>> result = Grouper.partitionBySalseAndThenCountByCity(employees);
        assertEquals(2, result.size());

        Map<String, Long> falseList = result.get(false);
        assertThat(falseList, hasEntry("London", 1L));

        Map<String, Long> trueList = result.get(true);
        assertThat(trueList, hasEntry("London", 1L));
        assertThat(trueList, hasEntry("New York", 1L));
        assertThat(trueList, hasEntry("Hong Kong", 1L));
    }
}

//------------------------------------------------------------------------------------------------
//Stream和Optional
http://www.jdon.com/idea/java/using-optional-effectively-in-java-8.html

如果不想每次都进行null值判断，Java 8 的Optional就发挥作用了，允许我们返回一个空的对象。
Optional<T>有方法 isPresent() 和 get() 是用来检查其包含的对象是否为空或不是，然后返回它，如：

Optional<SomeType> someValue = someMethod();
if (someValue.isPresent()) { // check
    someValue.get().someOtherMethod(); // retrieve and call
}

//1. ifPresent()
//例：将单词流中的第一个以“L”开头的单词取出，并转换为大写字母输出
package test;

import org.junit.Test;

import java.util.Optional;
import java.util.stream.Stream;

public class StreamTest {
    @Test
    public void testOptional_NotNull() {
        Stream<String> names = Stream.of("Large", "Good", "Hello", "Luck");
        Optional<String> nameWithL = names.filter(name -> name.startsWith("L")).findFirst();
        nameWithL.ifPresent(name -> {
            String s = name.toUpperCase();
            System.out.println("The first word starting with L in upper case is : " + s);
        });
    }

    @Test
    public void testOptional_Null() {
        Stream<String> names = Stream.of("Large", "Good", "Hello", "Luck");
        Optional<String> nameWithA = names.filter(name -> name.startsWith("A")).findFirst();//如果不重新定义Stream变量，会编译错误：stream已经被操作过或已经关闭
        nameWithA.ifPresent(name -> { //找不到，则对象为空，ifPresent将无法进入
            String s = name.toUpperCase();
            System.out.println("The first word starting with A in upper case is : " + s);
        });
    }
}
输出：
The first word starting with L in upper case is : LARGE

这里ifPresent() 是将一个Lambda表达式作为输入，T值如果不为空将传入这个lambda。那么这个lambda将不为空的单词转为大写输出显示。在前面names单词流寻找结果中，有可能找不到开始字母为L的单词，返回为空，也可能找到不为空，这两种情况都传入lambda中，无需我们打开盒子自己编写代码来判断，它自动帮助我们完成了，无需人工干预。

//2. filter() 过滤
@Test
public void testOptional_filter() {
    Stream<String> names = Stream.of("Large", "Good", "Hello", "Luck");
    Optional<String> nameWithA = names.filter(name -> name.startsWith("L")).findFirst();
    //Optional<String> nameWithAFilter = nameWithA.filter(name -> name.equals("Luck"));
    //Optional<String> nameWithAFilter = nameWithA.filter(name -> true);
    Optional<String> nameWithAFilter = nameWithA.filter(name -> {
        String s = name.toUpperCase();
        return s.equals("LARGE");
    });
    nameWithAFilter.ifPresent(name -> {
        String s = name.toUpperCase();
        System.out.println("The first word starting with A in upper case is : " + s);
    });
}
输出：
The first word starting with L in upper case is : LARGE

//3. map() 将value值映射成一个新的Optional<U>对象
@Test
public void testOptional_map() {
    Stream<String> names = Stream.of("Large", "Good", "Hello", "Luck");
    Optional<String> nameLengthGTFour = names.filter(name -> isLengthGTFour(name)).findFirst();
    //Optional<String> nameLengthLTFive = names.filter(name -> isLengthLTFive(name)).findFirst();
    Optional<String> nameMapToUpperCase = nameLengthGTFour.map(String::toUpperCase);
    nameMapToUpperCase.ifPresent(name -> {
        System.out.println("Map value: " + name);
    });
}

private boolean isLengthGTFour(String s) {
    return s.length() > 4;
}

private boolean isLengthLTFive(String s) {
    return s.length() < 5;
}

//--http://www.importnew.com/6675.html
新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：
这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。
本文会逐个探讨Optional类包含的方法，并通过一两个示例展示如何使用。

1. of
为非null的值创建一个Optional。
of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException 。
//调用工厂方法创建Optional实例
Optional<String> name = Optional.of("Sanaulla");
//传入参数为null，抛出NullPointerException.
Optional<String> someNull = Optional.of(null);

2. ofNullable
为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。
ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下：
//下面创建了一个不包含任何值的Optional实例
//例如，值为'null'
Optional empty = Optional.ofNullable(null);

3. isPresent
非常容易理解
如果值存在返回true，否则返回false。
类似下面的代码：
//isPresent方法用来检查Optional实例中是否包含值
if (name.isPresent()) {
  //在Optional实例内调用get()返回已存在的值
  System.out.println(name.get());//输出Sanaulla
}

4. get
如果Optional有值则将其返回，否则抛出NoSuchElementException。
上面的示例中，get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException的例子：
//执行下面的代码会输出：No value present 
try {
  //在空的Optional实例上调用get()，抛出NoSuchElementException
  System.out.println(empty.get());
} catch (NoSuchElementException ex) {
  System.out.println(ex.getMessage());
}

5. ifPresent
如果Optional实例有值则为其调用consumer，否则不做处理
要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。
如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码：
//ifPresent方法接受lambda表达式作为参数。
//lambda表达式对Optional的值调用consumer进行处理。
name.ifPresent((value) -> {
  System.out.println("The length of the value is: " + value.length());
});

6. orElse
如果有值则将其返回，否则返回指定的其它值。
如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下：
//如果值不为null，orElse方法返回Optional实例的值。
//如果为null，返回传入的消息。
//输出：There is no value present!
System.out.println(empty.orElse("There is no value present!"));
//输出：Sanaulla
System.out.println(name.orElse("There is some value!"));

7. orElseGet
orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下：
//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，
//orElseGet可以接受一个lambda表达式生成默认值。
//输出：Default Value
System.out.println(empty.orElseGet(() -> "Default Value"));
//输出：Sanaulla
System.out.println(name.orElseGet(() -> "Default Value"));
//Supplier接口下：无入参数，返回T类型
public interface Supplier<T> {
    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}

8. orElseThrow
如果有值则将其返回，否则抛出supplier接口创建的异常。
在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下：
try {
  //orElseThrow与orElse方法类似。与返回默认值不同，
  //orElseThrow会抛出lambda表达式或方法生成的异常 
  empty.orElseThrow(ValueAbsentException::new);
} catch (Throwable ex) {
  //输出: No value present in the Optional instance
  System.out.println(ex.getMessage());
}
ValueAbsentException定义如下：
class ValueAbsentException extends Throwable {
 
  public ValueAbsentException() {
    super();
  }
 
  public ValueAbsentException(String msg) {
    super(msg);
  }
 
  @Override
  public String getMessage() {
    return "No value present in the Optional instance";
  }
}

//
@Test(expected=RuntimeException.class)
public void testOptional_orElseGet() {
    Optional<String> empty = Optional.ofNullable(null);
    System.out.println(empty.orElse("orElse::empty"));
    System.out.println(empty.orElseGet(() -> "orElseGet::empty"));
    //System.out.println(empty.orElseThrow(() -> new RuntimeException()));
    System.out.println(empty.orElseThrow(RuntimeException::new));
}

9. map
map方法文档说明如下：
如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。
map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。如果你不熟悉Function接口，可以参考我的这篇博客。map方法示例如下：
//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。
//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。
Optional<String> upperName = name.map((value) -> value.toUpperCase());
System.out.println(upperName.orElse("No value found"));

10. flatMap
如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。
flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。
参照map函数，使用flatMap重写的示例如下：
//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。
//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 
//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 
Optional<String> upperName = name.flatMap((value) -> Optional.of(value.toUpperCase()));
System.out.println(upperName.orElse("No value found"));//输出SANAULLA

@Test()
public void testOptional_map_flatMap() {
    Optional<String> hello = Optional.ofNullable("hello");
    Optional<String> upperHello = hello.map(String::toUpperCase);
    System.out.println(upperHello.orElse("No value"));

    Optional<String> upperhello2 = hello.flatMap(name -> Optional.of(name.toUpperCase()));
    System.out.println(upperhello2.orElse("No value"));
}
输出：
HELLO
HELLO

@Test()
public void testOptional_map_flatMap_null() {
    Optional<String> hello = Optional.ofNullable(null);
    Optional<String> upperHello = hello.map(String::toUpperCase);
    System.out.println(upperHello.orElse("No value"));

    Optional<String> upperhello2 = hello.flatMap(name -> Optional.of(name.toUpperCase()));
    System.out.println(upperhello2.orElse("No value"));
}
输出：
No value
No value

11. filter
filter个方法通过传入限定条件对Optional实例的值进行过滤。文档描述如下：
如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。
读到这里，可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。如果你不熟悉Predicate接口，可以参考这篇文章。
现在我来看看filter的各种用法，下面的示例介绍了满足限定条件和不满足两种情况：
//filter方法检查给定的Option值是否满足某些条件。
//如果满足则返回同一个Option实例，否则返回空Optional。
Optional<String> longName = name.filter((value) -> value.length() > 6);
System.out.println(longName.orElse("The name is less than 6 characters"));//输出Sanaulla
 
//另一个例子是Optional值不满足filter指定的条件。
Optional<String> anotherName = Optional.of("Sana");
Optional<String> shortName = anotherName.filter((value) -> value.length() > 6);
//输出：name长度不足6字符
System.out.println(shortName.orElse("The name is less than 6 characters"));
//------------------------------------------------------------------------------------------------
//volatile使用
http://blog.csdn.net/feier7501/article/details/20001083
在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 
要解决这个问题，只需要像在本程序中的这样，把该变量声明为volatile（不稳定的）即可，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。 
volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 

上面的情况，可以使用synchronized来对boolPattern加锁，但是synchronized开销比volatile大，volatile能够胜任上面的工作。
volatile不保证原子操作，所以，很容易读到脏数据。
使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。 
//------------------------------------------------------------------------------------------------
//学习重构到模式
//策略模式 猫咪排序
//CatSortAlg
package test;

public class CatSortAlg {
    public static void sortByAge(Cat[] cats) {
        for (int i = 1; i < cats.length; i++) {
            for (int j = 0; j < cats.length - i; j++) {
                if (cats[j].age() > cats[j + 1].age()) {
                    Cat temp = cats[j];
                    cats[j] = cats[j + 1];
                    cats[j + 1] = temp;
                }
            }
        }
    }

    public static void sortByName(Cat[] cats) {
        for (int i = 1; i < cats.length; i++)
            for (int j = 0; j < cats.length - i; j++) {
                if (cats[j].name().compareTo(cats[j + 1].name()) > 0) {
                    Cat temp = cats[j];
                    cats[j] = cats[j + 1];
                    cats[j + 1] = temp;
                }
            }
    }
}

//
package test;

public class Cat {
    private final int age;
    private final String name;
    private final int weight;

    public Cat(int age, String name, int weight) {
        this.age = age;
        this.name = name;
        this.weight = weight;
    }

    public int age() {
        return age;
    }

    public String name() {
        return name;
    }

    public int weight() {
        return weight;
    }
}


//测试用例
package test;

import org.junit.Test;

import static org.junit.Assert.*;

public class CatSortAlgTest {
    @Test
    public void testCatOrderByAge() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        CatSortAlg.sortByAge(cats);
        assertEquals(cats[0].age(), 1);
        assertEquals(cats[1].age(), 2);
        assertEquals(cats[2].age(), 3);
    }

    @Test
    public void testCatOrderByName() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        CatSortAlg.sortByName(cats);
        assertEquals(cats[0].name(), "DaHuang");
        assertEquals(cats[1].name(), "MiMi");
        assertEquals(cats[2].name(), "XiaoHei");
    }
}

(1)Ctrl + Alt + M：抽取方法
(2)Ctrl + Alt + P：抽取到方法参数
(3)Move：将抽取的方法移到外部类
(4)删除static方法
(5)Ctrl + Alt + V：抽取局部变量
(6)Ctrl + Shift + Up：将比较函数抽取到for循环外
(7)Ctrl + Shift + Alt + T：抽取Interface
(8)修改子类为接口
(9)Ctrl + Alt + M：两个for循环抽取为函数
(10)Ctrl + Alt + P：Comparator抽取为函数入参
(11)Ctrl + Alt + N：把sortByName内联，再把sortByAge内联

最终效果如下：
//
package test;

import org.junit.Test;

import static org.junit.Assert.*;

public class CatSortAlgTest {
    @Test
    public void testCatOrderByAge() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        CatSortAlg.sort(cats, new AgeComparator());
        assertEquals(cats[0].age(), 1);
        assertEquals(cats[1].age(), 2);
        assertEquals(cats[2].age(), 3);
    }

    @Test
    public void testCatOrderByName() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        CatSortAlg.sort(cats, new NameComparator());
        assertEquals(cats[0].name(), "DaHuang");
        assertEquals(cats[1].name(), "MiMi");
        assertEquals(cats[2].name(), "XiaoHei");
    }
    
    @Test
    public void testCatOrderByWeight() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        CatSortAlg.sort(cats, new WeightComparator());
        assertEquals(cats[0].weight(), 3);
        assertEquals(cats[1].weight(), 4);
        assertEquals(cats[2].weight(), 5);
    }
}

//
package test;

public class CatSortAlg {
    public static void sort(Cat[] cats, Comparator comparator) {
        for (int i = 1; i < cats.length; i++) {
            for (int j = 0; j < cats.length - i; j++) {
                if (comparator.compare(cats[j], cats[j + 1])) {
                    Cat temp = cats[j];
                    cats[j] = cats[j + 1];
                    cats[j + 1] = temp;
                }
            }
        }
    }
}


//
package test;

public interface Comparator {
    boolean compare(Cat cat1, Cat cat2);
}

//
package test;

public class AgeComparator implements Comparator {
    @Override
    public boolean compare(Cat cat1, Cat cat2) {
        return cat1.age() > cat2.age();
    }
}


//
package test;

public class NameComparator implements Comparator {
    @Override
    public boolean compare(Cat cat1, Cat cat2) {
        return cat1.name().compareTo(cat2.name()) > 0;
    }
}


//
package test;

public class WeightComparator implements Comparator {
    @Override
    public boolean compare(Cat cat1, Cat cat2) {
        return cat1.weight() > cat2.weight();
    }
}

//------------------------------------------------------------------------------------------------
//junit4 assert类中的assert方法总结
http://blog.sina.com.cn/s/blog_44d19b500102vf5f.html

junit中的assert方法全部放在Assert类中，总结一下junit类中assert方法的分类。
1.assertTrue/False([String message,]boolean condition);
判断一个条件是true还是false。感觉这个最好用了，不用记下来那么多的方法名。
2.fail([String message,]);
失败，可以有消息，也可以没有消息。
3.assertEquals([String message,]Object expected,Object actual);
判断是否相等，可以指定输出错误信息。
第一个参数是期望值，第二个参数是实际的值。
这个方法对各个变量有多种实现。在JDK1.5中基本一样。
但是需要主意的是float和double最后面多一个delta的值，可能是误差范围，不确定这个 单词什么意思，汗一个。
4.assertNotNull/Null([String message,]Object obj);
判读一个对象是否非空(非空)。
5.assertSame/NotSame([String message,]Object expected,Object actual);
判断两个对象是否指向同一个对象。看内存地址。
7.failNotSame/failNotEquals(String message, Object expected, Object actual)
当不指向同一个内存地址或者不相等的时候，输出错误信息。
注意信息是必须的，而且这个输出是格式化过的。


//------------------------------------------------------------------------------------------------
//JUnit4单元测试
http://www.blogjava.net/jnbzwm/archive/2010/12/15/340801.html
JUnit4的用法介绍：
1. 在 JUnit4 中，测试是由 @Test 注释来识别的，如下所示
2. JUnit4 中，我们仍然可以在每个测试方法运行之前初始化字段或准备数据。然而，完成这些操作的方法不再需要叫做 setUp()，只要用 @Before 注释来指示该方法即可。
JUnit4允许我们使用 @Before 来注释多个方法，这些方法都在每个测试之前运行
3. 清除方法与初始化方法类似。在 JUnit3 中，我们要将方法命名为 tearDown() 才可以实现清除方法，但在JUnit4中，只要给方法添加@After标注即可。
测试方法结束后清除为此测试用例准备的一些数据。
与 @Before 一样，也可以用 @After 来注释多个清除方法，这些方法都在每个测试之后运行。 
最后，我们不再需要显式调用在超类中的初始化和清除方法，只要它们不被覆盖，测试运行程序将根据需要自动为您调用这些方法。
超类中的 @Before 方法在子类中的 @Before 方法之前被调用（这反映了构造函数调用的顺序）。
@After 方法以反方向运行：子类中的方法在超类中的方法之前被调用。否则，多个 @Before 或 @After 方法的相对顺序就得不到保证。

浅谈TDD
测试驱动开发，它是敏捷开发的最重要的部分。方法主要是先根据客户的需求编写测试程序，然后再编码使其通过测试。在敏捷开发实施中，开发人员主要从两个方面去理解测试驱动开发。
a)在测试的辅助下，快速实现客户需求的功能。通过编写测试用例，对客户需求的功能进行分解，并进行系统设计。我们发现从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。 
b)在测试的保护下，不断重构代码，提高代码的重用性，从而提高软件产品的质量。可见测试驱动开发实施的好坏确实极大的影响软件产品的质量，贯穿了软件开发的始终。 
在测试驱动开发中，为了保证测试的稳定性，被测代码接口的稳定性是非常重要的。否则，变化的成本就会急剧的上升。所以，自动化测试将会要求您的设计依赖于接口，而不是具体的类。进而推动设计人员重视接口的设计，体现系统的可扩展性和抗变性。 

则Before、After方法的执行流程如图所示：
这种方法有明显的缺陷，如果要初始化的是数据库的链接，或者是一个大的对象的话，而这些资源恰恰是整个测试用例类可以共用的，每次都去申请，确实是种浪费。所以JUnit4引入了@BeforeClass和@AfterClass。

这个特定虽然很好，但是一定要小心对待这个特性。它有可能会违反测试的独立性，并引入非预期的混乱。如果一个测试在某种程度上改变了 @BeforeClass 所初始化的一个对象，那么它有可能会影响其他测试的结果。也就是说，由BeforeClass申请或创建的资源，如果是整个测试用例类共享的，那么尽量不要让其中任何一个测试方法改变那些共享的资源，这样可能对其他测试方法有影响。它有可能在测试套件中引入顺序依赖，并隐藏 bug。

--测试异常@Test(expected=XXXException.class)

--参数化测试
为了保证单元测试的严谨性，我们经常要模拟很多种输入参数，来确定我们的功能代码是可以正常工作的，为此我们编写大量的单元测试方法。可是这些测试方法都是大同小异：代码结构都是相同的，不同的仅仅是测试数据和期望输出值。
JUnit4 的参数化测试方法给我们提供了更好的方法，将测试方法中相同的代码结构提取出来，提高代码的重用度，减少复制粘贴代码的痛苦。

很明显，代码简单且很清晰了。在静态方法 words 中，我们使用二维数组来构建测试所需要的参数列表，其中每个数组中的元素的放置顺序并没有什么要求，只要和构造函数中的顺序保持一致就可以了。现在如果再增加一种测试情况，只需要在静态方法 words 中添加相应的数组即可，不再需要复制粘贴出一个新的方法出来了。
这种参数化的测试用例写法，很适用于一些共用的功能方法。
//------------------------------------------------------------------------------------------------
//JUnit进行单元测试
//FizzBuzz
package fizzbuzz;

import static java.lang.String.*;

public class FizzBuzz {
    public static String convert(int i) {
        if (i % 15 == 0) {
            return "FizzBuzz";
        } else if (i % 3 == 0) {
            return "Fizz";
        } else if (i % 5 == 0) {
            return "Buzz";
        } else {
            return format("%d", i);
        }
    }
}

//哪种风格更好？
package fizzbuzz;

import static java.lang.String.*;

public class FizzBuzz {
    public static String convert(int i) {
        if (i % 15 == 0) {
            return "FizzBuzz";
        }

        if (i % 3 == 0) {
            return "Fizz";
        }

        if (i % 5 == 0) {
            return "Buzz";
        }

        return format("%d", i);
    }
}


//FizzBuzzTest
package fizzbuzz;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class FizzBuzzTest {
    @Test
    public void test_return_normal_when_input_normal() {
        assertEquals("1", FizzBuzz.convert(1));
        assertEquals("2", FizzBuzz.convert(2));
    }

    @Test
    public void test_return_fizz_when_input_fizz() {
        assertEquals("Fizz", FizzBuzz.convert(3));
        assertEquals("Fizz", FizzBuzz.convert(6));
    }

    @Test
    public void test_return_buzz_when_input_buzz() {
        assertEquals("Buzz", FizzBuzz.convert(5));
        assertEquals("Buzz", FizzBuzz.convert(10));
    }

    @Test
    public void test_return_fizzbuzz_when_input_fizzbuzz() {
        assertEquals("FizzBuzz", FizzBuzz.convert(15));
    }
}

//--
http://tonl.iteye.com/blog/1948869
package calculator;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int minus(int a, int b) {
        return a - b;
    }

    public int square(int n) {
        return n * n;
    }

    public void squareRoot(int n) {
        for (; ;) {
            ;
        }
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public int divide(int a, int b) throws Exception {
        if (0 == b) {
            throw new Exception("除数不能为零");
        }
        return a / b;
    }
}

//
package calculator;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

public class CalculatorTest {
    private Calculator calculator = new Calculator();

    @BeforeClass
    public static void before() {
        System.out.println("global before");
    }

    @AfterClass
    public static void after() {
        System.out.println("global after destory");
    }

    @Before
    public void setUp() {
        System.out.println("一个测试开始：");
    }

    @After
    public void tearDown() {
        System.out.println("一个测试结束");
    }

    @Test
    @Ignore //@Ignore("该方法还未实现")
    public void test_return_addValue_when_add() {
        int result = calculator.add(1, 2);
        assertEquals(3, result);
    }

    @Test
    public void test_return_minusValue_when_minus() {
        int result = calculator.minus(5, 2);
        assertEquals(3, result);
    }

    @Test
    public void test_return_multiplyValue_when_multiply() {
        int result = calculator.multiply(4, 2);
        assertEquals(8, result);
    }

    @Test(timeout = 1000) //单位为毫秒
    public void test_return_outoftime_when_runingSquareRoot() {
        calculator.squareRoot(4);
    }

    @Test(expected = Exception.class)
    public void test_throw_exception() throws Exception {
        System.out.println("test divide 4 / 0");
        calculator.divide(4, 0);
    }

    @Test
    public void test_return_divideValue_when_divide() {
        int result = 0;
        try {
            result = calculator.divide(10, 5);
        } catch (Exception e) {
            e.printStackTrace();
            fail(); //如果这行没有执行，说明这部分正确
        }
        assertEquals(2, result);
    }
}
输出：
一个测试开始：
一个测试结束

org.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds

    at calculator.Calculator.squareRoot(Calculator.java:17)
    at calculator.CalculatorTest.test_return_outoftime_when_runingSquareRoot(CalculatorTest.java:57)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298)
    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.lang.Thread.run(Thread.java:745)

一个测试开始：
一个测试结束
一个测试开始：
test divide 4 / 0
一个测试结束
一个测试开始：
一个测试结束

Test ignored.一个测试开始：
一个测试结束
global before
global after destory


//assertThat
package calculator;

import org.junit.Test;

import java.util.ArrayList;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.core.IsCollectionContaining.hasItem;
import static org.junit.Assert.assertThat;

public class CalculatorTest {

    @Test
    public void test_that() {
        String s = "hello, world";
        assertThat(s, is(s));
        assertThat(s, containsString("hello"));

        //assertThat(16, greaterThan(10)); //没有在hamcrest找到greaterThan方法

        //String[] stringArray = new String[]{"hello", "world"};//数组不是可迭代的对象
        //可以如下转化为List
        //List<String> stringList = Arrays.asList(stringArray);
        
        ArrayList<String> stringList = new ArrayList<String>();
        stringList.add("hello");
        stringList.add("world");
        assertThat(stringList, hasItem("hello"));
    }
}

//同样的用例，多组测试数据，参数化测试
package calculator;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

import java.util.Arrays;
import java.util.Collection;

import static org.junit.Assert.assertEquals;

@RunWith(Parameterized.class)
public class CalculatorTest2 {
    private Calculator calculator = new Calculator();
    private int param;
    private int result;

    //构造函数，对变量进行初始化
    //定义一个待测试的类，并且定义两个变量，一个用于存放参数，一个用于存放期待的结果
    public CalculatorTest2(int param, int result) {
        this.param = param;
        this.result = result;
    }

    @Parameters
    public static Collection data() {
        return Arrays.asList(new Object[][] {
                {2, 4}, {0, 0}, {-3, 9}
        });
    }

    @Test
    public void test_return_multiTestValue_when_inputMultiTest() {
        int temp = calculator.square(param);
        assertEquals(result, temp);
    }
}

测试代码提交给JUnit框架后，框架如何来运行代码呢?答案就是――Runner。在JUnit中有很多个 Runner，他们负责调用测试代码，每一个Runner都有各自的特殊功能，要根据需要选择不同的Runner来运行测试代码。JUnit中有一个默认Runner，如果没有指定，那么系统自动使用默认 Runner来运行你的代码。这里参数化测试就没有再用默认的Runner了。
//--自定义Runner
package calculator;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

/**
 * 大家可以看到，这个功能也需要使用一个特殊的Runner，
 * 因此我们需要向@RunWith标注传递一个参数Suite.class。
 * 同时，我们还需要另外一个标注@Suite.SuiteClasses，
 * 来表明这个类是一个打包测试类。我们把需要打包的类作为参数传递给该标注就可以了。
 * 有了这两个标注之后，就已经完整的表达了所有的含义，因此下面的类已经无关紧要，
 * 随便起一个类名，内容全部为空既可
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({CalculatorTest.class, CalculatorTest2.class})
public class AllCalculatorTests {
}

这个测试类包含了上面的CalculatorTest.class和CalculatorTest2.class里面所有的测试函数，它的目的就是进行打包所有的测试。


//--
http://www.cnblogs.com/eggbucket/archive/2012/02/02/2335697.html
四、Runner (运行器)
大家有没有想过这个问题，当你把测试代码提交给JUnit框架后，框架如何来运行你的代码呢？答案就是――Runner。在JUnit中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。可能你会觉得奇怪，前面我们写了那么多测试，并没有明确指定一个Runner啊？这是因为JUnit中有一个默认Runner，如果你没有指定，那么系统自动使用默认Runner来运行你的代码。换句话说，下面两段代码含义是完全一样的：
import org.junit.internal.runners.TestClassRunner;
import org.junit.runner.RunWith;
//使用了系统默认的TestClassRunner，与下面代码完全一样
public class CalculatorTest ...{...} 

@RunWith(TestClassRunner.class)
public class CalculatorTest ...{...}
//------------------------------------------------------------------------------------------------
//assertThat断言
http://langgufu.iteye.com/blog/1893927
//------------------------------------------------------------------------------------------------
//Java中的Pair结构
package test;

import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class TestPair {
    public static void main(String args[]) {
        Map.Entry<String, Integer> strIntPair1 = new AbstractMap.SimpleEntry<>("DingBen", 1);
        Map.Entry<String, Integer> strIntPair2 = new AbstractMap.SimpleEntry<>("LiLei", 2);
        System.out.println(strIntPair1);
        System.out.println(strIntPair2);

        Map<Map.Entry<String, Integer>, String> map = new HashMap<>();//这里如果换成TreeMap，将会有运行错误，提示AbstractMap.SimpleEntry无法比较，可以参考http://blog.csdn.net/litoupu/article/details/9335007进行自定义排序
        map.put(strIntPair2, "hello");
        map.put(strIntPair1, "world");

        Set<Map.Entry<String, Integer>> set = map.keySet();
        Iterator<Map.Entry<String, Integer>> iterator = set.iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, Integer> key = iterator.next();
            String value = map.get(key);
            System.out.println("Key:" + key + ", Value:" + value);
        }
    }
}
输出：
DingBen=1
LiLei=2
Key:LiLei=2, Value:hello
Key:DingBen=1, Value:world

//用mapEntry进行遍历是最高效的
package test;

import java.util.LinkedHashMap;
import java.util.Map;

public class TestMapIteration {

    public static void main(String args[]) {
        Map<String, Integer> stringIntegerMap = new LinkedHashMap<>();
        stringIntegerMap.put("abc", 1);
        stringIntegerMap.put("def", 2);
        stringIntegerMap.put("opq", 3);

        for (Map.Entry<String, Integer> mapEntry : stringIntegerMap.entrySet()) {
            System.out.println("key: " + mapEntry.getKey() + ", value: " + mapEntry.getValue());
        }
    }
}
key: abc, value: 1
key: def, value: 2
key: opq, value: 3

//------------------------------------------------------------------------------------------------
//http://blog.sina.com.cn/s/blog_48c0812c0101alaz.html
由于interface中的数据成员会自动成为public static final，所以我们可以利用此性质把需要的常量归结到一个接口中，如下：
public interface Months{
int JANURAUY = 1;
int FEBRUARY = 2;                   
int MARCH =3;
}
然后要用的话，就直接Months.JANURAUY＊10类似的直接用就行了
//------------------------------------------------------------------------------------------------
java 一个类不能同时继承多个类，一个类只能继承一个类(class)，但是可以实现多个接口(interface);一个接口(interface)能够继承多个接口(interface)
//------------------------------------------------------------------------------------------------
? extends T 
?表示某个泛型类型，该类型继承于T（上限是T），是T的子类。所以声明一个List<? extends T> list，表示声明一个对象类型?是T子类的List，是无法加入基类T。list.add(T)不行。
? super T
?表示某个泛型类型，该类型下限为T，是T的基类。所以声明一个List<? super T> list，表示声明一个对象类型?是T基类的List，可以加入基类T。list.add(T)可以。
//------------------------------------------------------------------------------------------------
//Java值传递，即传入的是引用的副本，在函数里会把该引用指向到新的对象上，但不会影响到函数入口处对象
public class Test {
    public static void swap(int a, int b) {
        int temp = a;
        a = b;
        b = temp;
        System.out.println("swap方法里，a的值是" + a + ";b的值是" + b);
    }

    public static void main(String args[]) {
        int a = 6;
        int b = 9;
        System.out.println("交换开始前，变量a的值是" + a + ";变量b的值是" + b);
        swap(a, b);
        System.out.println("交换结束后，变量a的值是" + a + ";变量b的值是" + b);
    }
}
输出如下：
交换开始前，变量a的值是6;变量b的值是9
swap方法里，a的值是9;b的值是6
交换结束后，变量a的值是6;变量b的值是9

//需要把待交换的值放入对象中
class DataWrap
{
    public int a;
    public int b;
}

public class Test
{
    //这里的DataWrap对象dw，仍是函数入口对象的引用副本，只不过这个副本地址与原对象地址一致，所以修其成员函数变量即可修改原对象成员函数
    public static void swap(DataWrap dw)
    {
        int tmp = dw.a;
        dw.a = dw.b;
        dw.b = tmp;
        System.out.println("swap方法里，a属性的值是" + dw.a + ";b属性的值是" + dw.b);
    }

    public static void main(String args[])
    {
        DataWrap dw = new DataWrap();
        dw.a = 6;
        dw.b = 9;
        System.out.println("交换开始前，a属性的值是" + dw.a + ";b属性的值是" + dw.b);
        swap(dw);
        System.out.println("交换结束后，a属性的值是" + dw.a + ";b属性的值是" + dw.b);
    }
}
输出如下：
交换开始前，a属性的值是6;b属性的值是9
swap方法里，a属性的值是9;b属性的值是6
交换结束后，a属性的值是9;b属性的值是6

//这种对象方式也无法实现，Integer尽管是封装类对象，但是一旦生成好，就没有办法修改值了
public class Test
{
    public static void main(String args[])
    {
        Integer a = new Integer(3);
        Integer b = new Integer(4);
        Test.swap(a, b);
        System.out.println(a);
        System.out.println(b);
    }
    
    public static void swap(Integer lhs, Integer rhs) {
        int temp = lhs;
        lhs = rhs;
        rhs = temp; 
    }
}
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第2章 P66

public class HelloJava {
    private static String say = "我要学会你.";
    public static void main(String[] args) {
        System.out.println("你好 Java " + say);
    }
}

//一个*.java中最多只能有一个类为public，可以没有public
public class Hello{
    public static void main(String[] args){
        System.out.println("Hello, world!");
    }
}

class HelloA{
    public static void main(String[] args){
        System.out.println("Hello, world!");
    }
}

class HelloB{
    public static void main(String[] args){
        System.out.println("Hello, world!");
    }
}

以0开头的整型表示八进制数
以0x开头的整型表示十六进制数
长整型long定义的数要以L或l结尾
浮点数float定义的数要以F或f结尾
双精度浮点数double定义的数可以以D或d结尾

//P78
public class HelloJava {
    public static void main(String[] args) {
        char char1 = '\\';
        char char2 = '\u2605';
        System.out.println(char1);
        System.out.println(char2);
    }
}
输出如下：
\
★


//P80
public class HelloJava {
    private static final double PI = 3.141592653;//这里的private可以不加，现在还不太懂有什么差别
    private static int age = 23;//这里的private可以不加，现在还不太懂有什么差别
    public static void main(String[] args) {
        final int number;
        number = 1234;//对于final常量只能赋一次值，可以在声明时赋值，也可声明时不赋值
        //number = 22222;//这里再次赋值将编译报错
        age = 22;
        System.out.println(PI);
        System.out.println(number);
        System.out.println(age);
    }
}


//P81
public class HelloJava {
    static int times = 3;
    public static void main(String[] args) {
        int times = 4;
        System.out.println(times);
        System.out.println(HelloJava.times);
    }
}


//P86
&&与&都是逻辑与，||与|都是逻辑或，不同点是前者有短路特性，后者没有

public class HelloJava {
    public static void main(String[] args) {
        System.out.println(5 & -4);
        System.out.println(3 | 6);
        System.out.println(~7);
        System.out.println(10 ^ 3);
        System.out.println(48 << 1);
        System.out.println(48 >> 1);//>>>无符号右移运算符，以0填充
    }
}
输出如下：
4
7
-8
9
96
24

//变量交换 P90
//这个算法说白了就是：两个变量A和B，想交换值，B = A ^ B ^ B，A = A ^ B ^ A
import java.util.Scanner;

public class VariableExchange {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.println("Please input value of variable A:");
        long A = scan.nextLong();
        System.out.println("Please input value of variable B:    ");
        long B = scan.nextLong();
        //scan.close();//不加这行会有提示scan没有close
        System.out.println("A = " + A + "\tB = " + B);
        System.out.println("Exchange the two variables...");
        A = A ^ B;//可以这么写：A ^= B;
        B = B ^ A;//B = A ^ B;
        A = A ^ B;
        System.out.println("After exchange: A = " + A + "\tB = " + B);
    }
}
输出如下：
Please input value of variable A:
10
Please input value of variable B:
20
A = 10    B = 20
Exchange the two variables...
After exchange: A = 20    B = 10


//数据溢出 P93
public class HelloJava {
    public static void main(String[] args) {
        short s = 516;
        byte b = (byte)s;
        System.out.println(b);
    }
}

boolen类型不能与任何类型作转换，所以如下写法编译不过，与C++不同
public class HelloJava {
    public static void main(String[] args) {
        boolean b = true;
        if (0)
        {
            System.out.println(b);
        }
    }
}

//闰年的判断 P96
import java.util.Scanner;

public class HelloJava {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个年份：");
        long year = scan.nextLong();
        scan.close();
        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        {
            System.out.println(year + "年是闰年！");
        }
        else
        {
            System.out.println(year + "年不是闰年！");
        }
    }
}

//P105 switch语句中的case内容，如果不加break，则会不进行判断直接执行后续case中的语句内容，直到遇到break或结束
public class HelloJava {
    public static void main(String[] args) {
        int a = 2;
        switch (a)
        {
        case 1:
            System.out.println("1");
            System.out.println("11");
        case 2:
            System.out.println("2");
        case 3:
            System.out.println("3");
        default:
            System.out.println("don't know");
        }
    }
}

//foreach语句，int x不能在for之前定义
public class HelloJava {
    public static void main(String[] args) {
        int arr[] = {0, 1, 2};
        System.out.println("数组元素为：");
        for (int x : arr) {
            System.out.println(x);
        }
    }
}

//P112 
public class HelloJava {
    public static void main(String[] args) {
        String[] aves = new String[] {"白鹭", "丹顶鹤"};//可以写为如下几种形式String aves[] = new String[] {"白鹭", "丹顶鹤"}或String aves[] = {"白鹭", "丹顶鹤"}或String[] aves = {"白鹭", "丹顶鹤"}
        int index = 0;
        System.out.println("鸟：");
        while (index < aves.length) {
            System.out.print(aves[index++] + " ");
        }
        
        //while可以写成如下for循环
        for (String b : aves) {
            System.out.print(b + " ");
        }
    }
}

//双层for循环遍历二维数组 P116
public class HelloJava {
    public static void main(String[] args) {
        int[][] scores = new int[][] {{1, 2, 3}, {4, 5, 6}};//维数可以不完全匹配{{1, 3}, {4, 5, 6}}
        for (int[] is : scores) {
            for (int i : is) {
                System.out.println(i);
            }
        }
    }
}


//P130矩阵转置
public class HelloJava {
    public static void main(String[] args) {
        int arr[][] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        System.out.println("转置前的矩阵是：");
        printArray(arr);//
        
        int arr2[][] = new int[arr.length][arr.length];
        for (int i = 0; i < arr.length; ++i) {
            for (int j = 0; j < arr[i].length; ++j) {
                arr2[j][i] = arr[i][j];
            }
        }
        System.out.println("转置后的矩阵是：");
        printArray(arr2);
    }
    
    //这里如果不加static，会报错说静态函数不能引用非静态函数
    private static void printArray(int[][] arr) {
        for (int i = 0; i < arr.length; ++i) {
            for (int j = 0; j < arr[i].length; ++j) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
    }
}

private static void print1DimensionArray(int[] arr) {
    for (int i = 0; i < arr.length; ++i) {
        System.out.println(arr[i] + " ");
    }
}

private static void print2DimensionArray(int[][] arr) {
    for (int i = 0; i < arr.length; ++i) {
        for (int j = 0; j < arr[i].length; ++j) {
            System.out.print(arr[i][j] + " ");
        }
        System.out.println();
    }
}

Arrays.fill 填充数组 P133
Arrays.sort 排序数组 P134
Arrays.copyOf/Arrays.copyOfRange 复制数组 P135


//对比一维二维数组所占内存 P137
public class HelloJava {
    public static void main(String[] args) {
        int num1 = 1024 * 1024 * 2;
        int arr1[] = new int[num1];
        for (int i = 0; i < arr1.length; ++i) {
            arr1[i] = i;
        }
        //获得占用内存总数，并将单位转换为MB
        long memory1 = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        System.out.println("一维数组占用内存问题为：" + memory1);
        
        int num2 = 1024 * 1024;
        int arr2[][] = new int[num2][2];
        for (int i = 0; i < arr2.length; ++i) {
            arr2[i][0] = i;
            arr2[i][1] = i;
        }
        //获得占用内存总数，并将单位转换为MB
        long memory2 = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        System.out.println("二维数组占用内存问题为：" + memory2);
    }
}

P144 在字符串和其他数据类型连接时，同样使用“+”连接符，连接之后的返回值是字符串。

P146 获取字符串信息
public class HelloJava {
    public static void main(String[] args) {
        String s = "";
        System.out.println(s.length());
        System.out.println(s.indexOf("a"));
        System.out.println(s.lastIndexOf("a"));
        s = "abc";
        System.out.println(s.charAt(2));
    }
}

s.trim();不对当前字符串修改，需要将返回值赋值 s = s.trim();

//去除字符串中的空格 P148
import java.util.StringTokenizer;

public class HelloJava {
    public static void main(String[] args) {
        String text = "   We are students     ";
        System.out.println("原字符串是：\n" + text);
        StringTokenizer st = new StringTokenizer(text, " ");//可以把空格换成任意字符串，如换成"tsn"，则去除所有的't','s','n'字符
        StringBuffer sb = new StringBuffer();
        while (st.hasMoreTokens()) {
            sb.append(st.nextToken());
        }
        System.out.println("去掉字符串中所有空格之后的字符串是：\n" + sb.toString());
        String s = text.replaceAll("ts", "");
        System.out.println(s);
    }
}
输出如下：
原字符串是：
   We are students     
去掉字符串中所有空格之后的字符串是：
   We are ude     
   We are studen     
   
s.replaceAll(" ", "");

//P151 比较运算符“==”比较的是内存位置，不适宜拿来比较字符串，但整型等可以用比较运算符比较；equals()方法比较的两个字符串内容必须完全一样；equalsIgnoreCase()方法在忽略大小写的情况下内容必须一样。

public class HelloJava {
    public static void main(String[] args) {
        String text = "   We are students     ";
        System.out.println(text.toUpperCase());
    }
}

//split分割字符串
public class HelloJava {
    public static void main(String[] args) {
        String s = new String("abc,def,ghi,gkl");
        String news[] = s.split(",");//String news[] = s.split(",|g") 用|表示,和g都是分隔符，即遇到,也分隔，遇到g也分隔
        for (String str : news) {
            System.out.println(str);
        }
    }
}

//判断字符串是否是数字 P155
public class CheckNumber {
    public static void main(String[] args) {
        String s = "123456a";
        if (CheckNumber.isNumber(s)) {//这里可以不用指定类名，直接使用isNumber
            System.out.println(s + " is a number.");
        }
        else {
            System.out.println(s + " is not a number.");
        }
    }
    
    private static boolean isNumber(String str) {
        char c[] = str.toCharArray();
        for (int i = 0; i < c.length; ++i) {
            if (!Character.isDigit(c[i])) {
                return false;
            }
        }
        return true;
    }
}

//日期格式化 P158
import java.util.Date;
import java.util.Locale;

public class HelloJava {
    public static void main(String[] args) {
        Date today = new Date();
        String a = String.format(Locale.US, "%tb", today);//可以将US改成CHINESE/CHINA，或者省略，得到中文的显示
        String b = String.format(Locale.US, "%tB", today);
        String c = String.format("%ta", today);
        String d = String.format("%tA", today);
        String e = String.format("%tY", today);
        String f = String.format("%ty", today);
        String g = String.format("%tm", today);
        String h = String.format("%td", today);
        String i = String.format("%te", today);
        
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
        System.out.println(e);
        System.out.println(f);
        System.out.println(g);
        System.out.println(h);
        System.out.println(i);
    }
}
输出如下：
Apr
April
星期四
星期四
2015
15
04
02
2
//时间格式化 P158 日期时间组合格式化 P159 常规类型格式化 P160
//金额格式化成大写 P161
//数字格式化成货币格式 P163

//正则表达式 P165
public class HelloJava {
    public static void main(String[] args) {
        String s1 = "Mrkj007";
        String s2 = "mrdk007";
        String regexStr = "\\p{Upper}\\p{Lower}\\p{Lower}\\p{Lower}\\d\\d\\d";//String regexStr = "\\p{Upper}\\p{Lower}{3}\\d{3}";
        
        boolean bn1 = s1.matches(regexStr);
        boolean bn2 = s2.matches(regexStr);
        
        System.out.println(bn1);
        System.out.println(bn2);
    }
}

//P166
//通配符.前不用\\，匹配单个特定字符可以直接将这个字符写上，如@
public class HelloJava {
    public static void main(String[] args) {
        String s1 = "a@aa";
        
        String regexStr = "\\w{0,}@.{1}\\w{1,}";//"\\w{0,}@.{1}\\w{1,}3$"必须要求以3为结尾
        
        boolean bn1 = s1.matches(regexStr);
        
        System.out.println(bn1);
    }
}


public class HelloJava {
    public static void main(String[] args) {
        String telephone1 = "13024588795";
        if (check(telephone1)) {
            System.out.println("Legal");
        }
        else {
            System.out.println("Unlegal");
        }
    }
    
    public static boolean check(String handset) {
        String regex = "1[3,5,8]\\d{9}$";//[3,5,8]里的逗号可以省略为[358]，最后的$是字符串是以什么为结尾的匹配符
        if (handset.matches(regex)) {
            return true;
        }
        else {
            return false;
        }
    }
}

//P168 正则表达式验证IP地址合法性
//P168 统计汉字个数
import java.util.regex.Pattern;
public class HelloJava {
    public static void main(String[] args) {
        String text = "明日科技 soft";
        int amount = 0;
        for (int i = 0; i < text.length(); ++i) {
            boolean matches = Pattern.matches("^[\u4E00-\u9FA5]{0,}$", "" + text.charAt(i));//第二个参数是String，所以要将字符串与字符相加得到字符串入参，第一个参数感觉这样也可以"[\u4E00-\u9FA5]"
            if (matches) {
                ++amount;
            }
        }
        System.out.println(text + " 汉字个数 = " + amount);
    }
}

//StringBuilder类 P170 感觉有点像C++里的stringstream类
public class HelloJava {
    public static void main(String[] args) {
        String s1 = "int";
        String s2 = "ser";
        StringBuilder builder = new StringBuilder(s1);
        builder.insert(2, s2);//builder.insert(builder.length(), s2)等于builder.append(s2)
        System.out.println(builder);
    }
}

//Java里可以正常打印出字符数组里的字符，而不必像C++一样加结束符'\0'
public class HelloJava {
    public static void main(String[] args) {
        char arr[] = new char[] {'a', 'b'};
        System.out.println(arr);
    }
}

//null与空字符串的差别
String str1=null;
String str2="";

System.out.print(str1.length());//空指针异常
System.out.print(str2.length());//无异常

意思就是
null 那个对象没有内存空间
"" 有内存空间 值为空


//字符串加密 P174
public class HelloJava {
    public static void main(String[] args) {
        String value = "我爱 Java";
        char secret = '祈';
        System.out.println("原字符串为：" + value);
        String encryt = EAndU(value, secret);
        System.out.println("加密后的值：" + encryt);
        String uncrypt = EAndU(encryt, secret);
        System.out.println("解密后的值：" + uncrypt);
    }
    
    private static String EAndU(String value, char secret) {
        byte bt[] = value.getBytes();
        for (int i = 0; i < bt.length; ++i) {
            bt[i] = (byte)(bt[i] ^ (int)secret);
        }
        return new String(bt, 0, bt.length);
    }
}

//P184 只可以在无参构造方法中的第一句使用this关键字调用有参构造方法
public class AnyThing {
    public AnyThing() {
        //String a;
        this("this 调用有参构造方法");
        System.out.println("无参构造方法");
    }
    
    public AnyThing(String name) {
        System.out.println("有参构造方法" + name);
    }
}

//P190
静态方法中不可以使用this关键字。
静态方法中不可以直接调用非静态方法。
Java中不能将方法体内的局部变量声明为static。
如果在执行类时，希望先执行类的初始化动作，可以使用static定义一个静态区域。
当这段代码被执行时，首先执行static块中的程序，并且只会执行一次。
public class AnyThing {
    static {
        System.out.println("static area");
    }
    public AnyThing() {
        this("this 调用有参构造方法");
        System.out.println("无参构造方法");
    }
    
    public AnyThing(String name) {
        System.out.println("有参构造方法" + name);
    }
}

public class HelloJava {
    public static void main(String[] args) {
        AnyThing a1 = new AnyThing();
        AnyThing a2 = new AnyThing();
    }
}
输出如下：
static area
有参构造方法this 调用有参构造方法
无参构造方法
有参构造方法this 调用有参构造方法
无参构造方法

//P190 权限修饰符
当声明类时不使用public/protected/private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。
类的权限设定会约束类成员上的权限设定。

//可以对有main函数的类进行声明创建 P193
public class HelloJava {
    public static void main(String[] args) {
        HelloJava hj = new HelloJava();
        System.out.println(hj.plus(1, 2));
    }
    
    public double plus(double d1, double d2) {
        return d1 + d2;
    }
}

//当把plus定义为static后，会有提示静态方法应该通过静态方式访问，所以hj.plus应该修改为HelloJava.plus
public class HelloJava {
    public static void main(String[] args) {
        HelloJava hj = new HelloJava();//HelloJava hj = null;设置hj为null,下一句的输出仍是正常可用的，因为静态函数不依赖于对象，若去掉static，则编译报错
        System.out.println(hj.plus(1, 2));//System.out.println(HelloJava.plus(1, 2));
    }
    
    public static double plus(double d1, double d2) {
        return d1 + d2;
    }
}

P199 垃圾回收器只能回收那些由new操作符创建的对象，如果对象不是通过new操作符在内存中获取一块内存区域，这种对象可能不被垃圾回收机制所识别，所以在Java语言中提供了一个finalize()方法，是Object类的方法，它被声明为protected，用户可以在自己的类中定义这个方法，如果用户在类中定义了finalize()方法，在垃圾回收时首先调用该方法，并且在下一次垃圾回收动作发生时，才能真正回收对象占用的内存。
由于垃圾回收不受人为控制，具体执行时间也不确定，所以finalize()方法也就无法执行，为此，Java提供了System.gc()方法强制启动垃圾回收器，告知垃圾回收器来清理。

//P200 统计图书数量
import java.util.Random;

public class HelloJava {
    public static void main(String[] args) {
        String titles[] = {"Java1", "Java2", "Java3"};
        for (int i = 0; i < 5; ++i) {
            new Book(titles[new Random().nextInt(3)]);//这里的new Random().nextInt(3)会被识别为(new Random()).nextInt(3)，即new出来一个Random对象，并调用其成员函数nextInt。
        }
        System.out.println("总计卖书：" + Book.getCounter());
    }
}


public class Book {
    private static int counter = 0;
    public Book(String titel) {
        System.out.println("Sold book: " + titel);
        ++counter;
    }
    
    public static int getCounter() {
        return counter;
    }
}

//Java里的默认对象的equals方法继承自Object，与==一样，只有当两个对象所引用的内存一致时，才返回true；String的==仍是默认比较内存是否一致，equals是重载过的比较字符串内容是否一样
public class HelloJava {
    public static void main(String[] args) {
        Book b1 = new Book("abc");
        Book b2 = new Book("abc");
        Book b3 = b1;
        System.out.println(b1 == b2);//System.out.println(b1.equals(b2));
        System.out.println(b1 == b3);//System.out.println(b1.equals(b3));
    }
}
输出如下：
Sold book: abc
Sold book: abc
false
true

//重新计算对象的哈希码 P200
import java.awt.Color;

public class HelloJava {
    public static void main(String[] args) {
        Cat cat1 = new Cat("Java", 12, 21, Color.BLACK);
        Cat cat2 = new Cat("C++", 12, 21, Color.WHITE);
        Cat cat3 = new Cat("Java", 12, 21, Color.BLACK);
        
        System.out.println("Cat1 hashCode: " + cat1.hashCode());
        System.out.println("Cat2 hashCode: " + cat2.hashCode());
        System.out.println("Cat3 hashCode: " + cat3.hashCode());
        
        System.out.println("Cat1 equals Cat2: " + cat1.equals(cat2));
        System.out.println("Cat1 equals Cat3: " + cat1.equals(cat3));
    }
}

import java.awt.Color;

public class Cat {
    private String name;
    private int age;
    private double weight;
    private Color color;
    
    public Cat(String name, int age, double weight, Color color) {
        this.name = name;
        this.age = age;//age = age这样赋值，将没有效果，不像书中所述可以去掉this
        this.weight = weight;
        this.color = color;
    }

    //@Override告诉编译器下面的函数是重载，如果识写成Equals，则会有编译错误，如果不加@Override，就算函数写错了，编译器也只会认为是新增了一个函数
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        Cat cat = (Cat) obj;
        return name.equals(cat.name) && (age == cat.age)
                && (weight == cat.weight) && (color.equals(cat.color));
    }
    
    @Override
    public int hashCode() {
        //这里的几个数字可以随便加，只是为了区分不同对象的哈希码
        //Integer和Double这些原始数据类型要转换成原数据类型才有hashCode函数，这也是这些数据类型可以直接用==比较的原因吗？
        return 7 * name.hashCode() + 11 * new Integer(age).hashCode()
                + 13 * new Double(weight).hashCode() + 17 * color.hashCode();
    }
    
    public void show() {
        System.out.println(name + age + weight + color);
    }
}

//P201 汉诺塔
//P202 单例模式
//Java里没有static局部变量，所以不能像C++一样，在getInstance里声明一个static的单例对象
public class HelloJava {
    public static void main(String[] args) {
        Emperor emperor1 = Emperor.getInstance();
        Emperor emperor2 = Emperor.getInstance();
        Emperor emperor3 = Emperor.getInstance();
        
        emperor1.getName();
        emperor2.getName();
        emperor3.getName();
    }
}


public class Emperor {
    private static Emperor emperor = null;
    private Emperor() {
    }
    
    public static Emperor getInstance() {//只在使用时才创建
        if (null == emperor) {
            emperor = new Emperor();
        }
        return emperor;
    }
    
    public void getName() {
        System.out.println("我是皇帝：明日科技");
    }
}

//可参考Head First中所讲的，在程序初始化就将实例建好。在C++程序中搜“private static Singleton uniqueInstance = new Singleton();”
public class Emperor {
    private static Emperor emperor = new Emperor();
    private Emperor() {
    }
    
    public static Emperor getInstance() {
        return emperor;
    }
    
    public void getName() {
        System.out.println("我是皇帝：明日科技");
    }
}


//P209 接口
public class GifSaver implements ImageSaver {
    @Override
    public void save() {//如果不implements ImageSaver，则加了@Override会提供报错
        System.out.println("save as GIF");
    }
    
    public static void main(String[] args) {
        GifSaver gs = new GifSaver();
        gs.save();
    }
}

public interface ImageSaver {
    void save();//只能是public或不加即public，不能为private
}

//接口和继承的使用 P208
import java.awt.Point;

public class Image {//如果这里加了final，则此类将无法被继承
    private String name;//不加修饰符，则默认为public
    private Point size;
    
    public Image(String name, Point size) {
        this.name = name;
        this.size = size;
    }
    
    public String getName() {
        return name;
    }
    
    public Point getSize() {
        return size;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void setSize(Point size) {
        this.size = size;
    }
}


public interface ImageSaver {
    void save();
}


import java.awt.Point;

public class GifSaver extends Image implements ImageSaver {//如果有多个接口要实现，则用,分隔多个接口
    private static String extendsName = ".gif";
    
    public GifSaver(String name, Point size) {
        super(name, size);//这里调用父类的构造函数
    }
    
    @Override
    public void save() {
        System.out.println(getName() + " is saved as a GIF.");
    }
    
    @Override
    public String getName() {//这里改为private，将提示不能减少基类的可见性。可将基类的修饰符改为protected，这里改为public
        return super.getName() + extendsName;
    }
    
    public static void main(String[] args) {
        GifSaver gs = new GifSaver("hello", new Point(3, 4));//可改为：Image gs = new GifSaver("hello", new Point(3, 4));，则gs.save()将无法调用
        gs.save();
        System.out.println(gs.getName());
        
        Image i = new Image("abc", new Point(4, 5));//如果在Image的声明里加了abstract，则是虚基类，那么这里将不能实例化
        //i.save();//save是接口提供的函数，父类没有此函数
        System.out.println(i.getName());
    }
}
输出如下：
hello.gif is saved as a GIF.
hello.gif
abc

//P218 提到反射机制
在基类中 return this.getClass().getSimpleName();
有点类似C++中的typeid(someClass).name()

//P221 使用Comparable接口自定义排序
public class Employee implements Comparable<Employee>{
    private int id;
    private String name;
    private int age;
    
    public Employee(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Employee o) {
        if (id > o.id) {
            return 1;
        }
        else if (id < o.id) {
            return -1;
        }
        return 0;
    }
    
    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("Id: " + id + ",");
        sb.append("name: " + name + ",");
        sb.append("age: " + age);
        return sb.toString();
    }
}


import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Test {
    public static void main(String args[]) {
        Employee e1 = new Employee(3, "Li Lei", 26);
        Employee e2 = new Employee(2, "Han Meimei", 25);
        Employee e3 = new Employee(1, "Kily", 27);
        
        List<Employee> employeeList = new ArrayList<Employee>();//这是数组型的List，也可以创建链表型的LinkedList<>
        employeeList.add(e1);
        employeeList.add(e2);
        employeeList.add(e3);
        
        System.out.println("Before sort: ");//System.out.println(employeeList);可以直接打印整个List
        for (Employee e : employeeList) {
            System.out.println(e);
        }
        
        Collections.sort(employeeList);
        
        System.out.println("After sort: ");
        for (Employee e : employeeList) {
            System.out.println(e);
        }
    }
}
输出如下：
Before sort: 
Id: 3,name: Li Lei,age: 26
Id: 2,name: Han Meimei,age: 25
Id: 1,name: Kily,age: 27
After sort: 
Id: 1,name: Kily,age: 27
Id: 2,name: Han Meimei,age: 25
Id: 3,name: Li Lei,age: 26

//动态设置类的私有域 P222
public class Student {
    private int id;
    private String name;
    private boolean male;
    private double account;
    
    public Student(int id, String name, boolean male, double account) {
        this.id = id;
        this.name = name;
        this.male = male;
        this.account = account;
    }
    
    public int getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
    public boolean isMale() {
        return male;
    }
    
    public double getAccount() {
        return account;
    }
}


import java.lang.reflect.Field;

public class Test {
    public static void main(String args[]) {
        Student student = new Student(1, "Li Lei", true, 100);
        Class<?> clazz = student.getClass();
        System.out.println("The standard class name: " + clazz.getCanonicalName());
        System.out.println("The simple class name: " + clazz.getSimpleName());
        try {
            Field id = clazz.getDeclaredField("id");
            System.out.println("Before id is set: " + student.getId());
            id.setAccessible(true);
            id.setInt(student, 10);
            System.out.println("After id is set: " + student.getId());
            
            Field name = clazz.getDeclaredField("name");
            System.out.println("Before name is set: " + student.getName());
            name.setAccessible(true);
            name.set(student, "Han Meimei");
            System.out.println("After name is set: " + student.getName());
            
            Field male = clazz.getDeclaredField("male");
            System.out.println("Before male is set: " + student.isMale());
            male.setAccessible(true);
            male.setBoolean(student, false);
            System.out.println("After male is set: " + student.isMale());
            
            Field account = clazz.getDeclaredField("account");
            System.out.println("Before account is set: " + student.getAccount());
            account.setAccessible(true);
            account.setDouble(student, 200);
            System.out.println("After account is set: " + student.getAccount());
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
输出如下：
The standard class name: Student
The simple class name: Student
Before id is set: 1
After id is set: 10
Before name is set: Li Lei
After name is set: Han Meimei
Before male is set: true
After male is set: false
Before account is set: 100.0
After account is set: 200.0

//基类与子类的类型转换 P223 练习2
class HighSchoolStudent extends Student {
    public HighSchoolStudent(int id, String name, boolean male, double account) {
        super(id, name, male, account);
    }
    
    @Override
    public String getName() {
        return "High School: " + super.getName();
    }
    
    public void highSchoolSpecification() {
        System.out.println("I'm high school student.");
    }
}


public class Test {
    public static void main(String args[]) {
        HighSchoolStudent hss = new HighSchoolStudent(1, "Li Lei", true, 100);
        System.out.println(hss.getName());
        hss.highSchoolSpecification();
        
        Student s = (Student)hss;//类型转换直接用()即可
        System.out.println(s.getName());
        //s.highSchoolSpecification();//这里转换成基类后，没有子类函数了
        
        hss = (HighSchoolStudent)s;
        hss.highSchoolSpecification();
    }
}

P225 抽象方法不能使用private或static关键字进行修饰，包含一个或多个抽象方法的类必须被声明为抽象类。

//P229 内部类
public class OuterClass {
    innerClass in = new innerClass(); // 在外部类实例化内部类对象引用
    
    public void ouf() {
        in.inf(); // 在外部类方法中调用内部类方法
    }
    
    class innerClass {//这里加private，没有什么差异
        innerClass() { // 内部类构造方法
        }
        
        public void inf() { // 内部类成员方法
        }
        
        int y = 0; // 定义内部类成员变量
    }
    
    //这种写法编译不过，内部类必须依赖外部类的存在，而不能用静态函数来创建内部类
//    public static innerClass getInnerClass() {
//        return new innerClass();
//    }

    public innerClass doit() { // 外部类方法，返回值为内部类引用
        // y=4; //外部类不可以直接访问内部类成员变量
        in.y = 4;
        return new innerClass(); // 返回内部类引用
    }
    
    public static void main(String args[]) {
        OuterClass out = new OuterClass();
        // 内部类的对象实例化操作必须在外部类或外部类中的非静态方法中实现
        OuterClass.innerClass in = out.doit();
        System.out.println(in.y);
        System.out.println(out.in.y);
        OuterClass.innerClass in2 = out.new innerClass();//实例化内部类时需要用外部类对象来实例化，new out.innerClass()这种写法错误
    }
}

//P229 this关键字获取内部类与外部类的引用
public class TheSameName {
    private int x;
    
    public void doit() {
        x = 5;
        Inner in = new Inner();
        in.doit(x);
    }
    
    private class Inner {
        private int x = 9;
        public void doit(int x) {
            x++; // 调用的是形参x
            this.x++; // 调用内部类的变量x
            TheSameName.this.x++; // 调用外部类的变量x
        }
    }
    
    public static void main(String args[]) {
        TheSameName tsn = new TheSameName();
        tsn.doit();
    }
}

//对字符串的赋值，相当于对形参的引用改变，而对调用处的入参没有影响
public class TheSameName {
    public void doit(String s) {
        s = "abc";
    }
    
    public static void main(String args[]) {
        String s = "aaa";
        TheSameName tsn = new TheSameName();
        tsn.doit(s);
        System.out.println(s);
    }
}
输出如下：
aaa

http://www.cnblogs.com/dolphin0520/p/3736238.html
如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。
注：类的private方法会隐式地被指定为final方法。
对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。（类似C++中的引用）

public class Test {
    public static void main(String args[]) {
        String a = "hello2";  

        final String b = "hello";
        String d = "hello";
        String c = b + 2;  
        String e = d + 2;
        System.out.println((a == c));//true
        System.out.println((a == e));//false
    }
}
大家可以先想一下这道题的输出结果。为什么第一个比较结果为true，而第二个比较结果为fasle。这里面就是final变量和普通变量的区别了，当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。因此在上面的一段代码中，由于变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b 替换为它的  值。而对于变量d的访问却需要在运行时通过链接来进行。想必其中的区别大家应该明白了，不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。比如下面的这段代码就不会进行优化：
public class Test {
    public static void main(String[] args)  {
        String a = "hello2";  
        final String b = getHello();
        String c = b + 2;  
        System.out.println((a == c));//false
    }
     
    public static String getHello() {
        return "hello";
    }
}

上面这段代码好像让人觉得用final修饰之后，就不能在方法中更改变量i的值了。殊不知，方法changeValue和main方法中的变量i根本就不是一个变量，因为java参数传递采用的是值传递，对于基本类型的变量，相当于直接将变量进行了拷贝。所以即使没有final修饰的情况下，在方法内部改变了变量i的值也不会影响方法外的i。
运行这段代码就会发现输出结果为 helloworld。很显然，用final进行修饰并没有阻止在changeValue中改变buffer指向的对象的内容。有人说假如把final去掉了，万一在changeValue中让buffer指向了其他对象怎么办。有这种想法的朋友可以自己动手写代码试一下这样的结果是什么，如果把final去掉了，然后在changeValue中让buffer指向了其他对象，也不会影响到main方法中的buffer，原因在于java采用的是值传递，对于引用变量，传递的是引用的值，也就是说让实参和形参同时指向了同一个对象，因此让形参重新指向另一个对象对实参并没有任何影响。


P230 局部内部类
P231 匿名内部类
在图形化编程的事件监控器代码中，会大量使用匿名内部类，这样可大大简化代码，并增强代码的可读性。

public interface IStringDeal {
    public String filterBlankChar();
}

public class Test {
    public static void main(String args[]) {
        final String sourceStr = "abc de f";//这里不加final也没什么问题，但是在匿名类中不能修改sourceStr的值。2.为什么局部内部类和匿名内部类只能访问局部final变量？
        IStringDeal s = new IStringDeal() {
            @Override
            public String filterBlankChar() {
                String convertStr = sourceStr;//这里直接用sourceStr.replace(" ", "")也没什么问题？
                convertStr = convertStr.replace(" ", "");
                return convertStr;
            }
        };
        
        System.out.println("源字符串：" + sourceStr);
        System.out.println("转换后的字符串：" + s.filterBlankChar());
    }
}
输出如下：
源字符串：abc de f
转换后的字符串：abcdef

//如果不用使用匿名类，则需要修改为如下局部内部类方式。这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。
public class Test {
    public static void main(String args[]) {
        final String sourceStr = "abc de f";
        
        class Dealer implements IStringDeal {
            @Override
            public String filterBlankChar() {
                String convertStr = sourceStr;
                convertStr = convertStr.replace(" ", "");
                return convertStr;
            }
        }
        
        IStringDeal s = new Dealer();
        
        System.out.println("源字符串：" + sourceStr);
        System.out.println("转换后的字符串：" + s.filterBlankChar());
    }
}

http://www.cnblogs.com/dolphin0520/p/3811445.html
代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。
匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：
　　1）成员内部类的引用方式必须为 Outter.Inner.
　　2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》
//内部类的继承 P233
class WithInner {
    class Inner{
         
    }
}
class InheritInner extends WithInner.Inner {
    // InheritInner() 是不能通过编译的，一定要加上形参
    InheritInner(WithInner wi) {
        wi.super(); //必须有这句调用
    }
  
    public static void main(String[] args) {
        WithInner wi = new WithInner();
        InheritInner obj = new InheritInner(wi);
    }
}

//P233 编译不过
错误: 在类 Test 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
public class Test {
    static int x = 100;
    
    static class Inner {
        static void doitinner() {
            System.out.println("外部类的成员变量：" + x);
        }
        
        public static void maint(String args[]) {
            doitinner();
        }
    }
}

//P233 局部内部类设置闹钟，没运行起来？
public class Test {
    public static void main(String args[]) {
        AlarmClock ac = new AlarmClock(1, true);
        ac.start();
    }
}

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.swing.Timer;

public class AlarmClock {
    private int delay;
    private boolean flag;
    
    public AlarmClock(int delay, boolean flag) {
        this.delay = delay;
        this.flag = flag;
    }
    
    public void start() {
        class Printer implements ActionListener {
            @Override
            public void actionPerformed(ActionEvent e) {
                SimpleDateFormat format = new SimpleDateFormat("k:m:s");
                String result = format.format(new Date());
                System.out.println("Current time is: " + result);
                if (flag) {
                    Toolkit.getDefaultToolkit().beep();
                }
            }
        }
        new Timer(delay, new Printer()).start();
    }
}


//P234 静态内部类求极值

public class MaxMin {
    public static class Result {//这里改为private则Test中不可见，编译报错
        private double max;
        private double min;
        
        public Result(double max, double min) {
            this.max = max;
            this.min = min;
        }
        
        public double getMax() {
            return max;
        }
        
        public double getMin() {
            return min;
        }
    }
    
    public static Result getResult(double[] array) {
        double max = Double.MIN_VALUE;//设置最小值给max
        double min = Double.MAX_VALUE;//设置最大值给max
        
        for (double i : array) {
            if (i > max) {
                max = i;
            }
            if (i < min) {
                min = i;
            }
        }
        
        return new Result(max, min);
    }
}

public class Test {
    public static void main(String args[]) {
        double array[] = new double[5];
        for (int i = 0; i < array.length; i++) {
            array[i] = 100 * Math.random();
        }
        System.out.println("源数组：");
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
        
        MaxMin.Result result= MaxMin.getResult(array);
        System.out.println("最大值：" + result.getMax());
        System.out.println("最小值：" + result.getMin());
    }
}
输出如下：
源数组：
20.280779188500432
4.834134188174344
50.30131219984979
52.04190222448042
39.703315549452455
最大值：52.04190222448042
最小值：4.834134188174344

//P235 Class类与Java反射

//P238 访问构造方法
public class MoreConstructor {
    String s;
    int i, i2, i3;
    
    private MoreConstructor() {
    }
    
    protected MoreConstructor(String s, int i) {
        this.s = s;
        this.i = i;
    }
    
    public MoreConstructor(String... strings) throws NumberFormatException {
        if (0 < strings.length) {
            i = Integer.valueOf(strings[0]);
        }
        if (1 < strings.length) {
            i2 = Integer.valueOf(strings[1]);
        }
        if (2 < strings.length) {
            i3 = Integer.valueOf(strings[2]);
        }
    }
    
    public void print() {
        System.out.println("s=" + s);
        System.out.println("i=" + i);
        System.out.println("i2=" + i2);
        System.out.println("i3=" + i3);
    }
}

import java.lang.reflect.Constructor;

public class Test {
    public static void main(String args[]) {
        MoreConstructor example = new MoreConstructor();
        Class<?> exampleC = example.getClass();
        Constructor<?>[] declaredConstructors = exampleC.getDeclaredConstructors();
        for (int i = 0; i < declaredConstructors.length; ++i) {
            Constructor<?> constructor = declaredConstructors[i];
            System.out.println("查看是否允许带有可变数量的参数：" + constructor.isVarArgs());
            
            System.out.println("该构造方法的入口参数类型依次为：");
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            for (int j = 0; j < parameterTypes.length; j++) {
                System.out.println(" " + parameterTypes[j]);
            }
            
            System.out.println("该构造方法可能抛出的异常类型为：");
            Class<?>[] exceptionTypes = constructor.getExceptionTypes();
            for (int j = 0; j < exceptionTypes.length; j++) {
                System.out.println(" " + exceptionTypes[j]);
            }
            
            MoreConstructor example2 = null;
            while (example2 == null) {
                try {
                    //这里有点问题的话，i=0的时候不一定是第一个声明顺序中的第一个构造函数，导致构造失败，死循环
                    if (i == 0) {
                        Object[] parameters = new Object[] {new String[] {"1", "2", "3"}};
                        example2 = (MoreConstructor) constructor.newInstance(parameters);
                    }
                    else if (i == 1) {
                        example2 = (MoreConstructor) constructor.newInstance("7", 5);
                    }
                    else {
                        example2 = (MoreConstructor) constructor.newInstance();
                    }
                }
                catch (Exception e) {
                    System.out.println("在创建对象时抛出异常，下面执行setAccessible()方法");
                    constructor.setAccessible(true);
                }
            }
            example2.print();
            System.out.println();
        }
    }
}

//P240访问成员变量
//P242访问方法
访问一个名称为print、入口参数类型依次为String和int型的方法，可以通过下面两种方式实现：
objectClass.getDeclaredMethod("print", String.class, int.class);
objectClass.getDeclaredMethod("print", new Class[] {String.class, int.class});

//字符串转成int，不能用(int)s进行转型
System.out.println(Integer.valueOf("100"));

//P244 利用反射查看类的成员
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;


public class ClassDeclarationViewer {
    public static void main(String args[]) throws ClassNotFoundException {
        Class<?> clazz = Class.forName("java.util.ArrayList");
        System.out.println("类的标准名称：" + clazz.getCanonicalName());
        System.out.println("类的修饰符：" + Modifier.toString(clazz.getModifiers()));
        
        //泛型参数
        TypeVariable<?>[] typeVariables = clazz.getTypeParameters();
        System.out.print("类的泛型参数：");
        if (typeVariables.length != 0) {
            for (TypeVariable<?> typeVariable : typeVariables) {
                System.out.println(typeVariable + "\t");
            }
        }
        else {
            System.out.println("空");
        }
        
        Type[] interfaces = clazz.getGenericInterfaces();
        System.out.println("类所实现的接口：");
        if (interfaces.length != 0) {
            for (Type type : interfaces) {
                System.out.println("\t" + type);
            }
        }
        else {
            System.out.println("\t空");
        }
        
        Type superClass = clazz.getGenericSuperclass();
        System.out.print("类的直接继承类：");
        if (superClass != null) {
            System.out.println(superClass);
        }
        else {
            System.out.println("空");
        }
        
        Annotation[] annotations = clazz.getAnnotations();
        System.out.print("类的注释：");
        if (annotations.length != 0) {
            for (Annotation annotation : annotations) {
                System.out.println("\t" + annotation);
            }
        }
        else {
            System.out.println("空");
        }
    }
}
输出如下：
类的标准名称：java.util.ArrayList
类的修饰符：public
类的泛型参数：E    
类所实现的接口：
    java.util.List<E>
    interface java.util.RandomAccess
    interface java.lang.Cloneable
    interface java.io.Serializable
类的直接继承类：java.util.AbstractList<E>
类的注释：空

//P246 动态调用类中方法
import java.lang.reflect.Method;

public class MethodTest {
    public static void main(String args[]) {
        try {
            System.out.println("调用Math类的静态方法sin()");
            Method sin = Math.class.getDeclaredMethod("sin", Double.TYPE);//double.class一样
            double sin1 = (double) sin.invoke(null, new Integer(1));//double sin1 = (double) sin.invoke(null, 1);一样
            System.out.println("1的正弦值是：" + sin1);
            
            System.out.println("调用String类的非静态方法equals()");
            Method equals = String.class.getDeclaredMethod("equals", Object.class);
            boolean flag = (boolean) equals.invoke(new String("abc"), "abc");//boolean flag = (boolean) equals.invoke("abc", "abc");一样
            System.out.println("字符串是否相等：" + flag);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//P246 利用反射重写toString()方法。Object类的toString()函数默认是输出类名和哈希码
public class MethodTest {
    public static void main(String args[]) {
        String s = "abc";
        System.out.println(s.toString());
    }
}

public class Test {
    public static void main(String args[]) {
        MethodTest mt = new MethodTest();
        System.out.println(mt.toString());
    }
}
输出如下：
MethodTest@1db9742

//书中例子
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class StringUtils {
    @SuppressWarnings("unchecked")//取消 unchecked 警告
    public String toString(Object object) {
        Class<?> clazz = object.getClass();
        StringBuilder sb = new StringBuilder();
        Package packageName = clazz.getPackage();
        sb.append("包名：" + packageName.getName() + "\t");
        
        String className = clazz.getSimpleName();
        sb.append("类名：" + className + "\n");
        
        //这三个部分感觉可以用泛型函数来写，目前还不会-.-？
        sb.append("公共构造方法：\n");
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();
        for (Constructor<?> constructor : constructors) {
            String modifier = Modifier.toString(constructor.getModifiers());
            if (modifier.contains("public")) {
                sb.append(constructor.toGenericString() + "\n");
            }
        }
        
        sb.append("公共域 ：\n");
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            String modifier = Modifier.toString(field.getModifiers());
            if (modifier.contains("public")) {
                sb.append(field.toGenericString() + "\n");
            }
        }
        
        sb.append("公共方法：\n");
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            String modifier = Modifier.toString(method.getModifiers());
            if (modifier.contains("public")) {
                sb.append(method.toGenericString() + "\n");
            }
        }
        
        return sb.toString();
    }
    
    public static void main(String args[]) {
        System.out.println(new StringUtils().toString(new java.util.Date()));
    }
}
输出如下：
包名：java.util    类名：Date
公共构造方法：
public java.util.Date(java.lang.String)
public java.util.Date(int,int,int,int,int,int)
public java.util.Date(int,int,int,int,int)
public java.util.Date()
public java.util.Date(long)
public java.util.Date(int,int,int)
公共域 ：
公共方法：
public boolean java.util.Date.equals(java.lang.Object)
public java.lang.String java.util.Date.toString()
public int java.util.Date.hashCode()
public java.lang.Object java.util.Date.clone()
public int java.util.Date.compareTo(java.lang.Object)
public int java.util.Date.compareTo(java.util.Date)
public boolean java.util.Date.after(java.util.Date)
public boolean java.util.Date.before(java.util.Date)
public static long java.util.Date.parse(java.lang.String)
public int java.util.Date.getDate()
public long java.util.Date.getTime()
public void java.util.Date.setTime(long)
public java.time.Instant java.util.Date.toInstant()
public void java.util.Date.setDate(int)
public static long java.util.Date.UTC(int,int,int,int,int,int)
public static java.util.Date java.util.Date.from(java.time.Instant)
public int java.util.Date.getDay()
public int java.util.Date.getHours()
public int java.util.Date.getMinutes()
public int java.util.Date.getMonth()
public int java.util.Date.getSeconds()
public int java.util.Date.getTimezoneOffset()
public int java.util.Date.getYear()
public void java.util.Date.setHours(int)
public void java.util.Date.setMinutes(int)
public void java.util.Date.setMonth(int)
public void java.util.Date.setSeconds(int)
public void java.util.Date.setYear(int)
public java.lang.String java.util.Date.toGMTString()
public java.lang.String java.util.Date.toLocaleString()

//Set集合 P253
不允许存在重复值，可以使用Set集合中的addAll()方法，将Collection集合添加到Set集合中并除掉重复值。
//书中例子
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;


public class Test {
    public static void main(String args[]) {
        List<String> list = new LinkedList<String>();
        list.add("apple");
        list.add("pear");
        list.add("banana");
        list.add("apple");
        //list.add("a");
        System.out.println(list);
        
        Set<String> set = new TreeSet<String>();//TreeSet自带默认排序功能，HashSet自带HashCode排序功能
        set.addAll(list);
        Iterator<String> iter = set.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next() + "\t");
            
        }
        
        set.clear();
        set.add("banana");
        set.add("pear");
        set.add("apple");
        System.out.println(set);
        
        set.clear();
        set.add("c");
        set.add("b");
        set.add("a");
        System.out.println(set);
    }
}

//P259 List接口的实现类
ArrayList：按索引查找快，插入删除慢
LinkedList：按索引查找慢，插入删除快
import java.util.ArrayList;

public class Test {
    public static void main(String args[]) {
        List<String> list = new ArrayList<String>();
        list.add("a");
        list.add("b");
        list.add("c");
        
        int i = (int) (Math.random() * (list.size()));
        System.out.println("随机获取数组中的元素：" + list.get(i));
        list.remove(2);
        System.out.println("索引2的元素移除后，数组为：" + list);
    }
}

//P260 Set接口的实现类
HashSet/TreeSet。Set中的对象是无序的。

//如果Employee未实现Comparable的接口，则只能插入到HashSet中，插入到TreeSet中将报错
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;

public class Test {
    public static void main(String args[]) {
        Employee e1 = new Employee(3, "Li Lei", 26);
        Employee e2 = new Employee(2, "Han Meimei", 25);
        Employee e3 = new Employee(1, "Kily", 27);
        
        Set<Employee> employeeList = new HashSet<Employee>();//Employee实现了Comparable接口后，就可以用Set<Employee> employeeList = new TreeSet<Employee>();保存了，输出如下第2段输出，并且是排好序的
        employeeList.add(e1);
        employeeList.add(e2);
        employeeList.add(e3);
        
        System.out.println("The order in set:");
        for (Employee e : employeeList) {
            System.out.println(e);
        }
    }
}
输出如下：
The order in set:
Id: 1,name: Kily,age: 27
Id: 3,name: Li Lei,age: 26
Id: 2,name: Han Meimei,age: 25

换成TreeSet输出如下：
The order in set:
Id: 1,name: Kily,age: 27
Id: 2,name: Han Meimei,age: 25
Id: 3,name: Li Lei,age: 26

//P261 Map接口的实现类
Map接口常用的实现类有HashMap和TreeMap。通常建议用HashMap实现类实现Map集合，因为由HashMap类实现的Map集合对于添加和删除映射关系效率更好。HashMap是基于哈希表的Map接口的实现，HashMap通过哈希码对其内部的映射关系进行快速查找；由HashMap类实现的Map集合对于添加或删除映射关系效率较高；而TreeMap中的映射关系存在一定的顺序，如果希望Map集合中的对象存在一琮的顺序，应该使用TreeMap类实现Map集合。
1. HashMap类
基于哈希表的Map接口实现。允许使用null值和null键，但必须保证键的唯一性。
2. TreeMap类
不仅实现了Map接口，还实现了java.util.SortedMap接口，因此集合中的映射关系具有一定的顺序。但在添加、删除和定位映射关系上，TreeMap类比HashMap类的性能差一些。由于TreeMap类实现的Map集合中的映射关系是根据键对象按照一定的顺序排列的，因此不允许键对象是null。
//我这里的HashMap和TreeMap顺序都一样了
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Test {
    public static void main(String args[]) {
        Map<String, String> map = new HashMap<String, String>();
        map.put("001", "Zhang San");
        map.put("005", "Li Si");
        map.put("004", "Wang Yi");
        
        Set<String> set = map.keySet();
        Iterator<String> it = set.iterator();
        System.out.println("HashMap类实现的Map集合，无序：");
        while (it.hasNext()) {
            String str = (String) it.next();//if not using String convertion，不加类型转换也没有问题
            String name = (String) map.get(str);
            System.out.println(str + " " + name);
        }
        
        TreeMap<String, String> treeMap = new TreeMap<String, String>();
        treeMap.putAll(map);
        Iterator<String> iter = treeMap.keySet().iterator();
        System.out.println("TreeMap类实现的Map集合，键对象升序：");
        while (iter.hasNext()) {
            String str = (String) iter.next();
            String name = (String) map.get(str);
            System.out.println(str + " " + name);
        }
    }
}
输出如下：
HashMap类实现的Map集合，无序：
001 Zhang San
004 Wang Yi
005 Li Si
TreeMap类实现的Map集合，键对象升序：
001 Zhang San
004 Wang Yi
005 Li Si

//可以把所有的Key值换成Integer，如下
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Test {
    public static void main(String args[]) {
        Map<Integer, String> map = new HashMap<Integer, String>();
        map.put(1, "Zhang San");
        map.put(5, "Li Si");
        map.put(4, "Wang Yi");
        
        Set<Integer> set = map.keySet();
        Iterator<Integer> it = set.iterator();
        System.out.println("HashMap类实现的Map集合，无序：");
        while (it.hasNext()) {
            int str = it.next();//if not using String convertion
            String name = map.get(str);
            System.out.println(str + " " + name);
        }
        
        TreeMap<Integer, String> treeMap = new TreeMap<Integer, String>();
        treeMap.putAll(map);
        Iterator<Integer> iter = treeMap.keySet().iterator();
        System.out.println("TreeMap类实现的Map集合，键对象升序：");
        while (iter.hasNext()) {//System.out.println(treeMap);可以直接这样打印
            int str = iter.next();
            String name = map.get(str);
            System.out.println(str + " " + name);
        }
    }
}

//P265 迭代器
import java.util.ArrayList;
import java.util.Collections;
import java.util.ListIterator;

public class Test {
    public static void main(String args[]) {
        ArrayList<Integer> array = new ArrayList<>();
        Collections.addAll(array, 1, 2, 3, 4, 5, 6);
        System.out.println("集合中的元素：" + array);
        ListIterator<Integer> iterator = array.listIterator();//迭代器声明好的时候，是指向位置0的元素的
        
        //iterator.set(10);此时迭代器还会返回过任何值，无法set
        
        //所有的next的操作，都是指当前迭代器所指向的元素，无论是next()，还是nextIndex()
        //所有的previous的操作，都是指迭代器的前一个元素的
        
        System.out.println(iterator.next());
        iterator.add(-1);
        System.out.println("集合中的元素：" + array);
        
        boolean hasNext = iterator.hasNext();
        System.out.println("集合是否具有下一个元素：" + hasNext);
        
        boolean hasPrevious = iterator.hasPrevious();
        System.out.println("集合是否具有前一个元素：" + hasPrevious);
        
        int next = iterator.next();
        System.out.println("获得集合的下一个元素：" + next);
        
        //iterator.next();
        
        int nextIndex = iterator.nextIndex();
        System.out.println("获得集合的下一个元素的索引：" + nextIndex);
        System.out.println("获得元素的上一个元素的索引：" + iterator.previousIndex());
        
        
        int previous = iterator.previous();//返回当前迭代器最后一次next()得到的元素值（也可以认为是当前指向的元素值），并且将迭代器后退一个元素
        System.out.println("获得集合的前一个元素：" + previous);
        
        int previousIndex = iterator.previousIndex();//返回当前迭代器所指向的元素索引
        System.out.println("获得集合的前一个元素的索引：" + previousIndex);
        
        iterator.add(7);//在迭代器当前所指向的元素位置 增加一个元素，并且会使迭代器前进1
        System.out.println("向集合中增加元素7后的集合：" + array);
        
        System.out.println("增加元素7后的next()：" + iterator.next());
        iterator.set(12);//修改迭代器最后一次返回的元素值
        System.out.println("将获得的下一个元素修改成12后的集合：" + array);
        
        iterator.remove();//删除的是迭代器最后一次返回的元素值，并且会使迭代器index减1
        System.out.println("将获得的下一个元素删除后的集合：" + array);
        
        System.out.println("remove()后的next()值：" + iterator.next());
    }
}

//P267 逆序打出所有List中的元素
import java.util.ArrayList;
import java.util.Collections;
import java.util.ListIterator;

public class Test {
    public static void main(String args[]) {
        ArrayList<Integer> array = new ArrayList<>();
        Collections.addAll(array, 1, 2, 3, 4, 5, 6);
        System.out.println("集合中的元素：" + array);
        ListIterator<Integer> iterator = array.listIterator();
        
        for (; iterator.hasNext();) {
            iterator.next();
        }
        
        for (; iterator.hasPrevious();) {
            System.out.print(iterator.previous() + " ");
        }
    }
}

//迭代器对象中有个变量lastRet，用来维护最近一次操作的元素索引，初始时lastRet=-1，无法remove，当remove后，lastRet也会被置为-1，因此不能重复的进行remove操作
import java.util.ArrayList;
import java.util.Collections;
import java.util.ListIterator;

public class Test {
    public static void main(String args[]) {
        ArrayList<Integer> array = new ArrayList<>();
        Collections.addAll(array, 6, 5, 4, 3, 2, 2, 1);
        System.out.println("集合中的元素：" + array);

        ListIterator<Integer> iter = array.listIterator();
        iter.next();
        iter.remove();
        iter.remove();//抛异常
        System.out.println("集合中的元素：" + array);
    }
}

//List中删除元素最好用迭代器，否则自己遍历会容易出错
import java.util.ArrayList;
import java.util.Collections;
import java.util.ListIterator;

public class Test {
    public static void main(String args[]) {
        ArrayList<Integer> array = new ArrayList<>();
        Collections.addAll(array, 6, 5, 4, 3, 2, 2, 1);
        System.out.println("集合中的元素：" + array);
        
        //这种删除方式，会导致跳过了一个索引值，只能删除一个2
//        for (int i = 0; i < array.size(); ++i) {
//            int n = array.get(i);
//            if (n == 2) {
//                array.remove(i);//List.remove(index)中的参数是索引，而不是具体值
//            }
//        }
        
        for (ListIterator<Integer> iter = array.listIterator(); iter.hasNext();) {
            if (iter.next() == 2) {
                iter.remove();
            }
        }
        
        System.out.println("集合中的元素：" + array);
    }
}
输出如下：
集合中的元素：[6, 5, 4, 3, 2, 2, 1]
集合中的元素：[6, 5, 4, 3, 1]
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第11章 异常处理 P272
Throwable类是所有异常类的超类，该类的两个直接子类是Error和Exception。其中，Error及其子类用于指示合理的应用程序不应该试图捕获的严重问题，Exception及其子类给出了合理的应用程序需要捕获的异常。

可捕获的异常（即Exception类的子类）分为可控式异常和运行时异常两种类型。
可控式异常可以捕获到
运行时异常

//运行时异常
public class Test {
    public static void main(String args[]) {
        try {
            int i = 3/0;
        } catch (Exception e) {
            e.printStackTrace();//可以用System.out.println(e.getMessage());来输出
        }
    }
}
报如下错误：
java.lang.ArithmeticException: / by zero
    at Test.main(Test.java:6)

11.2.3 算术异常 P276
整数被0除产生的异常。浮点数被0除，将不引发算法异常。
public class Test {
    public static void main(String args[]) {
        try {
            double d = 3.0 / 0;
            System.out.println(d);
        } 
        catch (ArithmeticException e) {
            e.printStackTrace();
        }
    }
}
输出如下：
Infinity

在Java的异常处理机制中，有一个默认处理异常的程序。当程序出现异常时，默认处理程序将显示一个描述异常的字符串，打印异常发生处的堆栈轨迹，并终止程序。

11.2.4 数组下标越界异常 P277
import java.util.Arrays;

public class Test {
    public static void main(String args[]) {
        int array[] = new int[5];
        Arrays.fill(array, 8);
        for (int i = 0; i < 6; ++i) {
            System.out.println(array[i]);
        }
    }
}
遍历数组，推荐使用foreach循环，可以避免数组下标越界。如果要使用数组的下标，需要记住数组的下标是从0开始计算的。如果需要使用数组的长度，则推荐使用length属性。另外使用ArrayList类也可以避免这些问题。

P278 捕获异常信息
public class Test {
    public static void main(String args[]) {
        try {
            int i = 3/0;
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("getMessage方法：\t" + e.getMessage());
            System.out.println("getLocalizedMessage方法：\t" + e.getLocalizedMessage());
            System.out.println("toString方法：\t" + e.toString());
        }
    }
}
输出如下：
java.lang.ArithmeticException: / by zero
    at Test.main(Test.java:4)
getMessage方法：    / by zero
getLocalizedMessage方法：    / by zero
toString方法：    java.lang.ArithmeticException: / by zero

11.4 处理异常 P280
11.4.2 使用 try...catch...finally 处理异常
finally后的两个大括号内的语句，不管程序是否发生异常都要执行（也就是说程序执行完try和catch之间的语句或执行完catch后两个大括号内的语句都将执行finally后的语句），因此finally语句块通常用于执行垃圾回收、释放资源等操作。
在Java中进行异常处理时，应该尽量使用finally块进行资源回收，因为在 try...catch...finally 语句块中，不管程序是否发生异常，最终都会执行finally语句块，因此可以在finally块中添加释放资源的代码。
（不加finally，不是也会正常执行到？）

//P281 创建IO对象，关闭对象
import java.io.FileInputStream;
import java.io.IOException;
import java.security.spec.ECGenParameterSpec;

public class CloseIo {
    private FileInputStream in = null;
    
    public void readInfo() {
        try {
            in = new FileInputStream("src/IStringDeal.java");
            System.out.println("创建IO流，分配内存资源。");
        } 
        catch (IOException io) {
            io.printStackTrace();
            System.out.println("创建IO对象发生异常。");
        }
        //感觉这个finally块不加也没什么问题，反正都会走到
        finally {
            if (in != null) {
                try {
                    in.close();
                    System.out.println("关闭IO流，释放内存资源。");
                } 
                catch (IOException ioe) {
                    ioe.printStackTrace();
                    System.out.println("关闭IO对象发生异常。");
                }
            }
        }
    }
    
    public static void main(String args[]) {
        CloseIo ex = new CloseIo();
        ex.readInfo();
    }
}
输出如下：
创建IO流，分配内存资源。
关闭IO流，释放内存资源。

11.4.3 使用try...finally处理异常 P282
finally里的语句不管程序是否发生异常，都必定会走进去
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.spec.ECGenParameterSpec;

public class CloseIo {
    private FileInputStream in = null;
    
    public void readInfo() {
        try {
            try {
                in = new FileInputStream("src/IStringsDeal.java");
                System.out.println("创建IO流，分配内存资源。");
            } 
            catch (FileNotFoundException e) {
                e.printStackTrace();
                System.out.println("创建IO对象发生异常。");
            }
        }
        finally {
            if (in != null) {
                try {
                    in.close();
                    System.out.println("关闭IO流，释放内存资源。");
                } 
                catch (IOException ioe) {
                    ioe.printStackTrace();
                    System.out.println("关闭IO对象发生异常。");
                }
            }
        }
    }
    
    public static void main(String args[]) {
        CloseIo ex = new CloseIo();
        ex.readInfo();
    }
}

11.5.1 使用throws声明抛出异常 P283
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.spec.ECGenParameterSpec;

public class CloseIo {
    private FileInputStream in = null;
    
    public void showInfo() throws Exception {
        FileInputStream in = new FileInputStream("src/abc.java");//这里如果in成功打开文件，但却没有关闭文件，可能造成资源泄露
    }
    
    public static void main(String args[]) {
        CloseIo ex = new CloseIo();
        ex.showInfo();//调showInfo函数可能会抛出异常，但这里却没有处理
    }
}

//P286 使用throw抛出异常
public class CloseIo {
    final static double PI = 3.14;
    
    public void computeArea(double r) throws Exception {
        if (r <= 20.0) {
            throw new Exception("程序异常：\n半径为：" + r + "\n半径不能小于20。");
        }
        else {
            double circleArea = PI * r * r;
            System.out.println("半径是" + r + "的圆的面积是：" + circleArea);
        }
    }
    
    public static void main(String args[]) {
        CloseIo ex = new CloseIo();
        try {
            ex.computeArea(20.1);
        }
        catch (Exception e){
            System.out.println(e.getMessage());
        }
    }
}

11.5.3 方法中抛出异常
如果某个类还没有实现，可以先在其中抛出异常，这样其他类调用时，会抛出异常，以便以后修改完成。

public class CloseIo {
    public void computeArea(double r) {
        throw new UnsupportedOperationException("方法尚未实现");
    }
    
    public static void main(String args[]) {
        CloseIo ex = new CloseIo();
        ex.computeArea(20.1);
    }
}
输出如下：
Exception in thread "main" java.lang.UnsupportedOperationException: 方法尚未实现
    at CloseIo.computeArea(CloseIo.java:4)
    at CloseIo.main(CloseIo.java:9)

11.6.1 创建自定义异常类 P287
public class NewException extends Exception {
    public NewException(String s) {
        super(s);
    }
}

public class Test {    
    public static void main(String args[]) {
        try {
            throw new NewException("Throw a NewException.");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
输出如下：
Throw a NewException.

11.6.2 使用自定义异常类 P288
//感觉书上的例子输出不太对
public class NewException extends Exception {
    public NewException(String s) {
        System.out.println(s);
    }
}

public class Test {    
    public static void main(String args[]) {
        try {
            throw new NewException("Throw a NewException.");
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
输出如下：
Throw a NewException.
NewException

11.7 异常使用原则
--不要过多的使用异常，这样会增加系统的负担。
--使用try...catch语句块捕获异常时，要对异常作出处理。
--tyr...catch语句块的范围不要太大，这样不利于对异常的分析。
--一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或者子异常。
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第12章 输入输出 P293
Java语言定义了许多类专门负责各种方式的输入/输出，这些类都被放在java.io包中。其中所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutputStream（字节输出流）或抽象类Writer（字符输出流）的子类。

12.2.1 输入流 P294

12.2.2 输出流 P295

12.2.4 查找替换文本文件内容 P297

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;


public class Test {    
    public static void main(String args[]) {
        String before = "today";
        String after = "今天";
        
        FileReader reader = null;
        FileWriter writer = null;
        StringBuilder sb = new StringBuilder();
        
        int flag = 0;
        final int maxLength = 1024;
        char temp[] = new char[maxLength];
                        
        String textFile = "src/TestFile.txt";
        try {
            reader = new FileReader(textFile);
            while ((flag = reader.read(temp)) != -1) {
                //这里如果不做这个判断，那么会将temp的1024个字符全都写进文件中，如果未读满，则会出现一堆未定义字符
                if (flag == maxLength) {
                    sb.append(temp);
                }
                else {
                    //将字符数组的特定长度附加到sb中
                    sb.append(temp, 0, flag);
                    
                    //或者将获取的特定长度字符生成String，并附加到sb中
                    // String tempString = new String(temp, 0, flag);
                    // sb.append(tempString);
                    
                    //如下方法，字符转成toString得到的将是类名加HashCode的字符串，而不原字符串，类似[C@1db9742的内容
//                    String tempString = temp.toString();
//                    tempString = tempString.substring(0, flag);
//                    sb.append(tempString);
                }
            }
            
            String content = sb.toString().replace(before, after);
            writer = new FileWriter(textFile);
            writer.write(content);
        } 
        catch (FileNotFoundException e1) {
            System.out.println(e1);
        }
        catch (IOException e2) {
            e2.printStackTrace();
        }
        finally {
            try {
                if (reader != null) {
                    reader.close();
                }
                if (writer != null) {
                    writer.close();
                }
            }
            catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
替换前的文件内容：
today is a nice day.
What day is is today?
Hello.


替换后的文件内容：
今天 is a nice day.
What day is is 今天?
Hello.

toString()：
Returns a string representation of the object. In general, the toString method returns a string that "textually represents" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. 
The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of: 

 getClass().getName() + '@' + Integer.toHexString(hashCode())

12.3.1 文件的创建与删除 P298

import java.io.File;

public class Test {    
    public static void main(String args[]) {
        File file = new File("src","abc.txt");//同"src/abc.txt"，这里的路径文件夹一定要存在，否则在创建文件时会报错
        if (file.exists()) {
            file.delete();
            System.out.println("文件已删除");
        }
        else {
            try {
                file.createNewFile();//如果存在原文件，这里创建新文件不会创建，也不会报错
                System.out.println("文件已创建");
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
        
    }
}

//P300
import java.io.File;

public class Test {    
    public static void main(String args[]) {
        File file = new File("src/abc.txt");
        if (file.exists()) {
            System.out.println("文件名称：" + file.getName());
            System.out.println("文件长度：" + file.length());
            System.out.println("文件是否是隐藏文件：" + file.isHidden());
            System.out.println("父路径：" + file.getParent());
            System.out.println("文件绝对路径：" + file.getAbsolutePath());
            System.out.println("文件路径：" + file.getPath());
            System.out.println("系统分隔符：" + File.separator);
        }
        else {
            System.out.println("文件不存在");
        }
        
        String newFileName = new String(file.getParent() + File.separator + "def.txt");//将文件重命名，入参为新文件类。如果路径不同，也可以用于移动文件
        file.renameTo(new File(newFileName));
    }
}
输出如下：
文件名称：abc.txt
文件长度：0
文件是否是隐藏文件：false
父路径：src
文件绝对路径：D:\Program Files\eclipseJava workspace\LearningProject\src\abc.txt
文件路径：src\abc.txt
系统分隔符：\

12.4.1 FileInputStream与FileOutputStream类 P302
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class Test {    
    public static void main(String args[]) {
        File file = new File("src","abc.txt");
        try {
            FileOutputStream out = new FileOutputStream(file);
            byte buy[] = "Hello".getBytes();
            out.write(buy);
            out.close();
        } 
        catch (Exception e) {
            e.printStackTrace();
        }

        try {
            FileInputStream in = new FileInputStream(file);
            byte byt[] = new byte[1024];
            int len = in.read(byt);
            System.out.println("文件中的信息是：" + new String(byt, 0, len));
            in.close();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出如下：
文件中的信息是：Hello

虽然Java语言在程序结束时自动关闭所有打开的流，但是当使用完流后，显式地关闭任何打开的流仍是一个好习惯。一个被打开的流有可能会用尽系统资源，这取决于平台和实现。如果没有将打开的流关闭，当另一个程序试图打开另一个流时，这些资源可能会得不到。

12.4.2 FileReader类和FileWriter类 P303

//P307 删除文件夹中所有文件
import java.io.File;

public class Test {
    public void deleteFile(String path) {
        File file = new File(path);
        StringBuilder sb = new StringBuilder();
        deleteFile(file, sb);
        System.out.print(sb.toString());
    }
    
    private void deleteFile(File root, StringBuilder sbLog) {
        if (!root.exists()) {
            sbLog.append("File or directory does not exist. Path: \n" + root.getAbsolutePath());
            return;
        }
        if (root.isFile()) {
            deleteOneFile(root, sbLog);
        } else {
            File files[] = root.listFiles();
            for (File file : files) {
                if (file.isFile()) {
                    deleteOneFile(file, sbLog);
                } else {
                    deleteFile(file, sbLog);
                }
            }
            deleteOneFile(root, sbLog);
        }
    }
    
    private void deleteOneFile(File file, StringBuilder sbLog) {
        String s = new String(file.isFile() ? "File is deleted: " : "Directory is delete: ");
        file.delete();
        sbLog.append(s + file.getAbsolutePath() + "\n");
    }
    
    public static void main(String args[]) {
        Test t = new Test();
        t.deleteFile("d:/Program Files/eclipseJava workspace/dbTest");
    }
}
输出如下：
File is deleted: d:\Program Files\eclipseJava workspace\dbTest\b.txt
File is deleted: d:\Program Files\eclipseJava workspace\dbTest\DirA\a.txt
Directory is delete: d:\Program Files\eclipseJava workspace\dbTest\DirA
Directory is delete: d:\Program Files\eclipseJava workspace\dbTest

12.5 带缓存的输入/输出流
//P309
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

public class Student {
    public static void main(String args[]) {
        String content[] = {"abc", "def", "opq"};
        File file = new File("src", "abc.txt");
        try {
            FileWriter fw = new FileWriter(file);//构造函数可以是File对象，也可以是字符串文件路径
            BufferedWriter bufw = new BufferedWriter(fw);
            for (int k = 0; k < content.length; ++k) {
                bufw.write(content[k]);
                bufw.newLine();
            }
            bufw.close();
            fw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        try {
            FileReader fr = new FileReader(file);
            BufferedReader bufr = new BufferedReader(fr);
            String s = null;
            int i = 0;
            while ((s = bufr.readLine()) != null) {
                ++i;
                System.out.println("Line " + i + ": " + s);
            }
            bufr.close();
            fr.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出如下：
Line 1: abc
Line 2: def
Line 3: opq


//P310 文件属性
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Properties;

public class Student {
    public static void main(String args[]) {
        File file = new File("src/abc.txt");
        Properties properties = new Properties();
        FileReader reader = null;
        try {
            reader = new FileReader(file);
            properties.load(reader);
            Enumeration<?> keys = properties.propertyNames();
            while (keys.hasMoreElements()) {
                String key = (String) keys.nextElement();
                String value = properties.getProperty(key);
                System.out.println("Key: " + key + "-- Value: "+ value);
            }
        } catch (FileNotFoundException e1) {
            e1.printStackTrace();
        } catch (IOException e2) {
            e2.printStackTrace();
        } finally {
            try {
                reader.close();
            } catch (Exception e3) {
                e3.printStackTrace();
            }
        }
    }
}
输出如下：
Key: abc-- Value: 你好
Key: def-- Value: 天气不错
Key: opq-- Value: 什么

文件内容：
abc=你好
def:天气不错
opq    :    什么

//P311 合并多个txt文件
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Student {
    public static void main(String args[]) {
        File file = new File("d:/Program Files/eclipseJava workspace/LearningProject/dbTest");
        File textFiles[] = file.listFiles();
        BufferedReader reader = null;
        FileWriter writer = null;
        try {
            writer = new FileWriter("d:/Program Files/eclipseJava workspace/LearningProject/Concatenation.txt");
            for (File textFile : textFiles) { 
                if (textFile.isDirectory()) {
                    continue;
                }
                reader = new BufferedReader(new FileReader(textFile));
                String line;
                while ((line = reader.readLine()) != null) {
                    writer.write(line + "\n");
                }
                reader.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
                if (writer != null) {
                    writer.close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

12.6 数据输入/输出流 P312
//
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class Student {
    public static void main(String args[]) {
        try {
            FileOutputStream fs = new FileOutputStream("src/Concatenation.txt");
            DataOutputStream ds = new DataOutputStream(fs);
            ds.writeUTF("使用writeUTF()方法写入数据");
            //ds.writeChars("使用writeChars()方法写入数据");//这两个方法，将无法读出数据
            //ds.writeBytes("使用writeBytes方法写入数据");
            ds.close();
            
            FileInputStream fis = new FileInputStream("src/Concatenation.txt");
            DataInputStream dis = new DataInputStream(fis);
            System.out.println(dis.readUTF());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

12.7 ZIP压缩输入/输出流 P313
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class MyZip {
    private void zip(String zipFilename, File inputFile) throws Exception {
        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFilename));
        zip(out, inputFile, "");
        System.out.println("Zipping...");
        out.close();
    }
    
    private void zip(ZipOutputStream out, File f, String base) throws Exception {
        if (f.isDirectory()) {
            File files[] = f.listFiles();
            out.putNextEntry(new ZipEntry(base + "/"));
            base = base.length() == 0 ? "" : base + "/";
            for (int i = 0; i < files.length; ++i) {
                zip(out, files[i], base + files[i]);
            }
        } else {
            out.putNextEntry(new ZipEntry(base));
            FileInputStream in = new FileInputStream(f);
            int b;
            System.out.println(base);
            while ((b = in.read()) != -1) {
                out.write(b);
            }
            in.close();
        }
    }
    
    public static void main(String args[]) {
        MyZip book = new MyZip();
        try {
            book.zip("d:/Program Files/eclipseJava workspace/LearningProject/dbTest.zip", 
                    new File("d:/Program Files/eclipseJava workspace/LearningProject/dbTest"));
            System.out.println("Finish zipping.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

12.7.2 解压缩ZIP文件 P315 未看

//简单的投票软件 P319
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;

public class Candidate {
    public static void main(String args[]) {
        Candidate c = new Candidate();
        System.out.println(c.getBallot("B"));
    }
    
    public int getBallot(String name) {
        File file = new File("src/count.txt");
        FileReader fr = null;
        BufferedReader br = null;
        int len = 0;
        try {
            if (!file.exists()) {
                file.createNewFile();
            }
            fr = new FileReader(file);
            br = new BufferedReader(fr);
            String str[] = new String[3];
            String size;
            int i = 0;
            while ((size = br.readLine()) != null) {
                str[i] = size.trim();
                if (str[i].startsWith(name)) {
                    int length = str[i].indexOf(":");
                    String sub = str[i].substring(length + 1, str[i].length());
                    len = Integer.parseInt(sub);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (fr != null) {
                    fr.close();
                }
                if (br != null) {
                    br.close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return len;
    }
}

count.txt内容如下：
A:3
B:4
C:5
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第13章 Swing程序设计 P322
13.2.1 JFrame框架窗体
import java.awt.Color;
import java.awt.Container;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.WindowConstants;


public class JFrameExample {
    public static void main(String args[]) {
        new JFrameExample().CreateJFrame("创建一个JFrame窗体");
    }
    
    public void CreateJFrame(String title) {
        JFrame jf = new JFrame(title);//创建一个初始不可见的，但是具体标题的窗体，可以不加title参数
        Container container = jf.getContentPane();
        JLabel jl = new JLabel("这是一个JFrame窗体");
        jl.setHorizontalAlignment(SwingConstants.CENTER);
        container.add(jl);
        container.setBackground(Color.white);
        jf.setVisible(true);
        jf.setSize(400, 300);
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//DO_NOTHING_ON_CLOSE时，点击X无法关闭窗体；HIDE_ON_CLOSE时，点击X也可以关闭窗体
    }
}

13.2.2 JDialog窗体 P325

import java.awt.Color;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.WindowConstants;


class MyJDialog extends JDialog{
    private static final long serialVersionUID = 1L;
    
    public MyJDialog(JFrame jFrame) {
        //实例化一个JDailog类对象，指定对话框的父窗体、窗体标题和类型
        super(jFrame, "第一个JDialog窗体", true);
        Container container = getContentPane();
        container.add(new JLabel("这是一个对话框"));
        setSize(100, 100);
        //setBounds(120, 120, 100, 100); // 设置对话框窗体大小，其中前两个参数，是离屏幕左上角的距离
    }
}

public class MyFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public static void main(String args[]) {
        new MyFrame();
    }
    
    public MyFrame() {
        Container container = getContentPane();
        container.setLayout(null);
        
        //这三行的JLabel无法显示出来，把上一行的container.setLayout(null);去掉，又会导致JButton占据了整个窗体，目前不知道如何解决？
//        JLabel jl = new JLabel("这是一个JFrame窗体");
//        jl.setHorizontalAlignment(SwingConstants.CENTER);
//        container.add(jl);
        
        JButton bl = new JButton("弹出对话框");
        bl.setBounds(10, 10, 100, 21);//可以设置JButton在窗体中的位置和其大小
        bl.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                new MyJDialog(MyFrame.this).setVisible(true);
            }
        });
        container.add(bl);
        
        container.setBackground(Color.white);
        setSize(200, 200);
        //setBounds(100, 100, 200, 200);
        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        setVisible(true);
    }
}

13.2.3 设置窗体大小 P326
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class ControlFormSize extends JFrame {
    public static void main(String args[]) {
        new ControlFormSize();
    }
    
    public ControlFormSize() {
        setTitle("设置窗体大小");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(400, 300);
        JPanel contentPane = new JPanel();
        contentPane.setLayout(new BorderLayout(0, 0));
        setContentPane(contentPane);//设置当前窗体面板，与getContentPane是相反的过程
        JLabel label = new JLabel("宽度：400， 高度：300");
        contentPane.add(label, BorderLayout.CENTER);
        setVisible(true);
    }
    
}

13.2.4 禁止改变窗体的大小 P327
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;

public class LimitChangeFormSize extends JFrame {
    public static void main(String args[]) {
        new LimitChangeFormSize();
    }
    
    public LimitChangeFormSize() {
        Container container = getContentPane();
        container.setLayout(null);//不进行setLayout的话，则JButton将占据整个面板大小
        
        setTitle("设置窗体大小");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(400, 300);
        setLocation(100, 100);
        
        String title = new String("切换窗体是否可变状态");
        JButton jb = new JButton(title);//居然没有找到可以修改JButton名称的方法？
        //jb.setBounds(MAXIMIZED_BOTH, MAXIMIZED_BOTH, 200, 22);
        jb.setSize(200, 22);
        //jb.setHorizontalAlignment(SwingConstants.CENTER);//没效果？只有JLabel才有用？
        jb.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                setResizable(!isResizable());
            }
        });
        container.add(jb);
        
        setVisible(true);
    }
}

13.3.2 图标的使用 P328
import java.awt.Component;
import java.awt.Container;
import java.awt.Graphics;

import javax.swing.Icon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.WindowConstants;

public class DrawIcon implements Icon {
    private int width;
    private int height;

    public DrawIcon(int width, int height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public int getIconHeight() {
        // TODO Auto-generated method stub
        return this.height;
    }

    @Override
    public int getIconWidth() {
        // TODO Auto-generated method stub
        return this.width;
    }

    @Override
    public void paintIcon(Component arg0, Graphics arg1, int x, int y) {
        // TODO Auto-generated method stub
        arg1.fillOval(x, y, width, height);
    }
    
    public static void main(String args[]) {
        DrawIcon icon = new DrawIcon(15, 15);
        JLabel jb = new JLabel("测试", icon, SwingConstants.CENTER);
        JFrame jf = new JFrame();
        Container c = jf.getContentPane();
        c.add(jb);
        jf.setSize(100, 100);
        jf.setVisible(true);
        jf.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
}

//P329 使用图片图标
import java.awt.Container;
import java.net.URL;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.WindowConstants;

public class MyImageIcon extends JFrame {
    public MyImageIcon() {
        Container container = getContentPane();
        JLabel jl = new JLabel("这是一个JFrame窗体", JLabel.CENTER);
        URL url = MyImageIcon.class.getResource("imageButton.jpg");//需要将imageButton.jpg与MyImageIcon.class文件放置在同级目录。目前试了只有.jpg好用，.bmp无法识别
        Icon icon = new ImageIcon(url);
        jl.setIcon(icon);
        jl.setHorizontalAlignment(SwingConstants.CENTER);
        jl.setOpaque(true);//设置标签为不透明状态
        container.add(jl);
        setSize(250, 100);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        
    }
    
    public static void main(String args[]) {
        new MyImageIcon();
    }
}

13.3.3 为图片添加说明 P330
import java.awt.BorderLayout;
import java.net.URL;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class UseLabelFrame extends JFrame {
    public UseLabelFrame() {
        super();
        setTitle("使用标签组件");
        setBounds(100, 100, 330, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        final JLabel label = new JLabel();
        label.setText("这是美丽的山水照片：");
        getContentPane().add(label, BorderLayout.NORTH);
        URL url = UseLabelFrame.class.getResource("wxPython.jpg");
        Icon icon = new ImageIcon(url);
        final JLabel labelPicture = new JLabel();
        labelPicture.setIcon(icon);
        getContentPane().add(labelPicture, BorderLayout.CENTER);
    }
    
    public static void main(String args[]) {
        UseLabelFrame frame = new UseLabelFrame();
        frame.setVisible(true);
    }
}

13.4 常用布局管理器 P331
13.4.1 绝对布局
import java.awt.Container;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class AbsolutePosition extends JFrame {
    public AbsolutePosition() {
        setTitle("本窗体使用绝对布局");
        setLayout(null);//取消布局管理器
        setBounds(0, 0, 200, 150);//设置每个组件的大小与位置
        Container c = getContentPane();
        JButton b1 = new JButton("按钮1");
        JButton b2 = new JButton("按钮2");
        b1.setBounds(10, 30, 80, 30);
        b2.setBounds(60, 70, 100, 20);
        c.add(b1);
        c.add(b2);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new AbsolutePosition();
    }
}

13.4.2 流布局管理器 P332

import java.awt.Container;
import java.awt.FlowLayout;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class FlowLayoutPosition extends JFrame {
    public FlowLayoutPosition() {
        setTitle("本窗体使用流布局管理器");
        Container c = getContentPane();
        setLayout(new FlowLayout(2, 10, 10));//第一个参数，FlowLayout.LEFT=0，左对齐；FlowLayout.CENTER=1，右对齐；FlowLayout.RIGHT=2，右对齐，第2，3参数设置各组件之间的水平间隔与垂直间隔
        
        for (int i = 0; i < 10; i++) {
            c.add(new JButton("button" + i));
        }
        setSize(300, 200);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new FlowLayoutPosition();
    }
}

13.4.3 边界布局管理器 P334
在默认不指定窗体布局的情况下，Swing组件的布局模式是边界（BorderLayout）布局管理器。如例13.3 ，在容器中只添加了一个标签组件，这个标签被放置在窗体中间，并且整个组件占据了窗体的所有空间，实质上在这个容器中默认使用了边界布局管理器。
import java.awt.BorderLayout;
import java.awt.Container;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class BorderlayoutPosition extends JFrame {
    String border[] = {BorderLayout.CENTER, BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.WEST, BorderLayout.EAST};
    String buttonName[] = {"center button", "north button", "south button", "west button", "east button"};
    
    public BorderlayoutPosition() {
        setTitle("本窗体使用边界布局管理器");
        Container c = getContentPane();
        setLayout(new BorderLayout());
        
        for (int i = 0; i < border.length; ++i) {
            c.add(border[i], new JButton(buttonName[i]));//提供在容器中添加组件的功能，并同时设置组件的摆放位置
        }
        
        setSize(350, 200);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new BorderlayoutPosition();
    }
}

13.4.4 风格布局管理器 P335
import java.awt.Container;
import java.awt.GridLayout;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class GridLayoutPosition extends JFrame {
    public GridLayoutPosition() {
        setTitle("本窗体使用风格布局管理器");
        Container c = getContentPane();
        setLayout(new GridLayout(7, 3, 5, 5));//前两个参数表格网格的行数与列数，只有一个可以为0，代表一行或一列可以排列任意多个组件。后两个参数指定网格之间的间距。
        
        for (int i = 0; i < 20; ++i) {
            c.add(new JButton("button" + i));
        }
        
        setSize(300, 300);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new GridLayoutPosition();
    }
}

13.5 常用面板 P336
13.5.1 JPanel面板 P336
import java.awt.Container;
import java.awt.GridLayout;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.WindowConstants;

public class JPanelTest extends JFrame {
    public JPanelTest() {
        setTitle("在这个窗体中使用中面板");
        Container c = getContentPane();
        setLayout(new GridLayout(2, 1, 10, 10));
        
        JPanel p1 = new JPanel(new GridLayout(1, 3, 10, 10));
        JPanel p2 = new JPanel(new GridLayout(1, 2, 10, 10));
        JPanel p3 = new JPanel(new GridLayout(1, 2, 10, 10));
        JPanel p4 = new JPanel(new GridLayout(2, 10, 10, 10));
        
        p1.add(new JButton("1"));
        p1.add(new JButton("2"));
        p1.add(new JButton("3"));
        
        p2.add(new JButton("4"));
        p2.add(new JButton("5"));
        
        p3.add(new JButton("6"));
        p3.add(new JButton("7"));
        
        p4.add(new JButton("8"));
        p4.add(new JButton("9"));
        
        c.add(p1);
        c.add(p2);
        c.add(p3);
        c.add(p4);
        
        setSize(600, 300);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JPanelTest();
    }
}

13.5.2 JScrollPane面板 P337
import java.awt.Container;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class JScrollPaneTest extends JFrame {
    public JScrollPaneTest() {
        setTitle("带滚动条的文字编辑器");
        Container c = getContentPane();
        JTextArea ta = new JTextArea(20, 50);//初始文本编辑器的行与列数
        ta.setText("带滚动条的文字编译器");
        JScrollPane sp = new JScrollPane(ta);
        c.add(sp);
        
        setSize(600, 300);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JScrollPaneTest();
    }
}

//添加了四个JScrollPane
import java.awt.Container;
import java.awt.GridLayout;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class JScrollPaneTest extends JFrame {
    public JScrollPaneTest() {
        setTitle("带滚动条的文字编辑器");
        Container c = getContentPane();
        setLayout(new GridLayout(2, 2, 10, 10));
        JTextArea ta1 = new JTextArea(10, 50);
        ta1.setText("带滚动条的文字编译器1");
        JScrollPane sp1 = new JScrollPane(ta1);
        
        JTextArea ta2 = new JTextArea(20, 50);
        ta2.setText("带滚动条的文字编译器2");
        JScrollPane sp2 = new JScrollPane(ta2);
        
        JTextArea ta3 = new JTextArea(30, 50);
        ta3.setText("带滚动条的文字编译器3");
        JScrollPane sp3 = new JScrollPane(ta3);
        
        JTextArea ta4 = new JTextArea(40, 50);
        ta4.setText("带滚动条的文字编译器4");
        JScrollPane sp4 = new JScrollPane(ta4);
        
        c.add(sp1);
        c.add(sp2);
        c.add(sp3);
        c.add(sp4);
        
        setSize(600, 300);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JScrollPaneTest();
    }
}

13.6.1 提交按钮组件 P338
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.net.URL;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class JButtonTest extends JFrame {
    public JButtonTest() {
        Container c = getContentPane();
        setLayout(new GridLayout(3, 2, 5, 5));
        URL url = JButtonTest.class.getResource("imageButton.jpg");
        Icon icon = new ImageIcon(url);
        for (int i = 0; i < 5; ++i) {
            JButton j = new JButton("button" + i, icon);
            c.add(j);
            if (i % 2 == 0) {
                j.setEnabled(false);
            }
        }
        
        JButton jb = new JButton();
        jb.setMaximumSize(new Dimension(90, 30));
        jb.setIcon(icon);
        jb.setHideActionText(true);
        jb.setToolTipText("图片按钮");
        jb.setBorderPainted(false);
        c.add(jb);
        
        setSize(350, 150);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JButtonTest();
    }
}

13.6.2 单选按钮组件 P339
import java.awt.BorderLayout;
import java.awt.Container;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JRadioButton;
import javax.swing.WindowConstants;

public class JRadioButtonTest extends JFrame {
    public JRadioButtonTest() {
        setTitle("带滚动条的文字编辑器");
        Container c = getContentPane();
        setLayout(new BorderLayout());
        //setLayout(new GridLayout(3, 2, 5, 5));
        
        JRadioButton jr1 = new JRadioButton("radio button 1");
        JRadioButton jr2 = new JRadioButton("radio button 2");
        JRadioButton jr3 = new JRadioButton("radio button 3");
        ButtonGroup group = new ButtonGroup();//需要加到组中，才能在组中做单选操作
        group.add(jr1);
        group.add(jr2);
        group.add(jr3);
        
        c.add(jr1, BorderLayout.NORTH);
        c.add(jr2, BorderLayout.SOUTH);
        c.add(jr3, BorderLayout.CENTER);
        
        setSize(350, 150);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JRadioButtonTest();
    }
}

13.6.3 复选框组件 P340
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class CheckBoxTest extends JFrame {
    public CheckBoxTest() {
        setTitle("复选框的使用");
        Container c = getContentPane();
        setLayout(new BorderLayout());
        
        JPanel panel1 = new JPanel();
        panel1.setLayout(new BorderLayout());
        //panel1.setMinimumSize(new Dimension(300, 300));
        JTextArea ta = new JTextArea(20, 10);
        JScrollPane scrollPanel = new JScrollPane(ta);
        panel1.add(scrollPanel, BorderLayout.CENTER);
        c.add(panel1, BorderLayout.NORTH);
        
        
        JPanel panel2 = new JPanel();
        panel2.setLayout(new FlowLayout(1, 20, 10));
        //panel2.setMinimumSize(new Dimension(300, 200));
        JCheckBox cb1 = new JCheckBox("1");
        JCheckBox cb2 = new JCheckBox("2");
        JCheckBox cb3 = new JCheckBox("3");
        panel2.add(cb1);
        panel2.add(cb2);
        panel2.add(cb3);
        cb1.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (cb1.isSelected()) {
                    ta.append("复选框1被选中\n");
                }
                else {
                    ta.append("复选框1被去勾选\n");
                }
            }
        });
        c.add(panel2, BorderLayout.SOUTH);
        
        setSize(300, 500);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new CheckBoxTest();
    }
}

13.7.1 下拉列表框组件 P341

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.AbstractList;

import javax.swing.ComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;
import javax.swing.event.ListDataListener;

public class JComboBoxModelTest extends JFrame {
    //如果不自己实现ComboBoxModel，可以将Array传入来构造JComboBox
    //private String stringArray[] = {"a", "b", "c"};
    //private JComboBox<String> jc = new JComboBox<>(stringArray);
    
    JComboBox<String> jc = new JComboBox<>(new MyComboBox());
    JLabel jl = new JLabel("请选择证件:");
    
    public JComboBoxModelTest() {
        setTitle("在窗口中设置下拉列表框");
        Container c = getContentPane();
        setLayout(new BorderLayout());
        
        JPanel panel1 = new JPanel();
        panel1.setLayout(new BorderLayout());
        JTextArea ta = new JTextArea(20, 10);
        JScrollPane scrollPanel = new JScrollPane(ta);
        panel1.add(scrollPanel, BorderLayout.CENTER);
        c.add(panel1, BorderLayout.NORTH);
        
        JPanel panel2 = new JPanel();
        panel2.setLayout(new FlowLayout(1, 20, 10));
        jc.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent arg0) {
                ta.append((String)jc.getSelectedItem() + "\n");
            }
        });
        panel2.add(jl);
        panel2.add(jc);
        c.add(panel2, BorderLayout.SOUTH);
        
        setSize(300, 500);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JComboBoxModelTest();
    }
}

class MyComboBox extends AbstractList<String> implements ComboBoxModel<String> {
    String selectedItem = null;
    String test[] = {"身份证", "军人证", "学生证", "工作证"};
    
    @Override
    public String getElementAt(int index) {
        return test[index];
    }
    
    @Override
    public int getSize() {
        return test.length;
    }
    
    @Override
    public void setSelectedItem(Object item) {
        selectedItem = (String) item;
    }
    
    @Override
    public String getSelectedItem() {
        return selectedItem;
    }
    
    public int getIndex() {
        for (int i = 0; i < test.length; i++) {
            if (test[i].equals(getSelectedItem()))
                return i;
        }
        return 0;
    }
    
    @Override
    public void addListDataListener(ListDataListener l) {
        
    }

    @Override
    public void removeListDataListener(ListDataListener l) {
        
    }

    @Override
    public String get(int index) {
        return test[index];
    }

    @Override
    public int size() {
        return test.length;
    }
}

13.7.2 列表框组件 P343
//
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.FlowLayout;

import javax.swing.AbstractListModel;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

public class JListTest extends JFrame {
    private JList<String> jc = new JList<>(new MyListModel());
    private JLabel jl = new JLabel("请选择证件:");
    
    public JListTest() {
        setTitle("在窗口中设置下拉列表框");
        Container c = getContentPane();
        setLayout(new BorderLayout());
        
        JPanel panel1 = new JPanel();
        panel1.setLayout(new BorderLayout());
        JTextArea ta = new JTextArea(20, 10);
        JScrollPane scrollPanel = new JScrollPane(ta);
        panel1.add(scrollPanel, BorderLayout.CENTER);
        c.add(panel1, BorderLayout.WEST);
        
        JScrollPane js = new JScrollPane(jc);//也没有看到滚动条的列表效果
        JPanel panel2 = new JPanel();
        panel2.setLayout(new FlowLayout(1, 20, 10));
        jc.addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                // TODO Auto-generated method stub
                ta.append((String) jc.getSelectedValue() + "\n");//每次会把选择的值输出两次，不知道为什么？
            }
        });
        panel2.add(jl);
        panel2.add(js);
        c.add(panel2, BorderLayout.EAST);
        
        setSize(300, 500);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JListTest();
    }
}

class MyListModel extends AbstractListModel<String> {
    String selectedItem = null;
    String contents[] = {"身份证", "军人证", "学生证", "工作证", "驾驶证", "签证", "老年证"};
    
    @Override
    public String getElementAt(int index) {
        return (index < contents.length) ? contents[index] : null;
    }
    
    @Override
    public int getSize() {
        return contents.length;
    }
}

13.8 文本组件 P345
13.3.1 文本框组件
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;
import javax.swing.WindowConstants;

public class JTextFieldTest extends JFrame {
    public JTextFieldTest() {
        setTitle("在窗口中设置下拉列表框");
        Container c = getContentPane();
        setLayout(new BorderLayout());

        final JTextField jt = new JTextField("aaa", 20);
        
        //换成密码框
        //final JPasswordField jt = new JPasswordField("aaa", 20);
        //jt.setEchoChar('#');
        
        final JButton jb = new JButton("清除");
        jt.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent arg0) {
                jt.setText("触发事件");
            }
        });
        
        jb.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                jt.setText("");
                jt.requestFocus();
            }
        });
        
        c.add(jt, BorderLayout.NORTH);
        c.add(jb, BorderLayout.SOUTH);
        
        setSize(300, 200);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JTextFieldTest();
    }
}

13.8.2 密码框组件 P346
final JPasswordField jt = new JPasswordField("aaa", 20);
jt.setEchoChar('#');

13.8.3 文本域组件 P346
JTextArea jt = new JTextArea("文本域", 6, 6);
jt.setLineWrap(true);

13.8.4 给文本域设置背景图片 P347

13.8.5 给文本区设置背景图片 P348

13.9.1 设置窗体标题框图标 P349
protected void do_button_actionPerformed(ActionEvent e) {
    String resource = "";
    if (e.getSource == button1) {
        resource = "icon1.png";
    }
    if (e.getSource == button2) {
        resource = "icon2.png";
    }
    URL url = getClass().getResource(resource);
    setIconImage(Toolkit.getDefaultToolkit().getImage(url));
}
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第14章 高级处理事件 P355
14.1 键盘事件 P356
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class JTextFieldTest extends JFrame {
    public JTextFieldTest() {
        setTitle("在窗口中设置下拉列表框");
        Container c = getContentPane();
        setLayout(new BorderLayout());

        final JTextArea ja = new JTextArea("aaa", 10, 20);
        ja.addKeyListener(new KeyListener() {
            
            @Override
            public void keyTyped(KeyEvent e) {
                System.out.println("此次输入的是：" + e.getKeyChar());
            }
            
            @Override
            public void keyReleased(KeyEvent e) {
                String keyText = KeyEvent.getKeyText(e.getKeyCode());
                System.out.println("您释放的是：" + keyText);
                System.out.println();
            }
            
            @Override
            public void keyPressed(KeyEvent e) {
                String keyText = KeyEvent.getKeyText(e.getKeyCode());
                if (e.isActionKey()) { //是否为动作键，capital/break等
                    System.out.println("您按下的是动作键：" + keyText);
                } else {
                    System.out.println("您按下的是非动作键：" + keyText);
                    int keyCode = e.getKeyCode();
                    switch (keyCode) {
                    case KeyEvent.VK_CONTROL:
                        System.out.println("，Ctrl键被按下");
                        break;
                    case KeyEvent.VK_ALT:
                        System.out.println("，Alt键被按下");
                        break;
                    case KeyEvent.VK_SHIFT:
                        System.out.println("，Shift键被按下");
                        break;
                    }
                }
            }
        });
        
        c.add(ja, BorderLayout.NORTH);
        
        setSize(300, 200);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JTextFieldTest();
    }
}

14.2 鼠标事件 P357

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class JTextFieldTest extends JFrame {
    public JTextFieldTest() {
        setTitle("在窗口中设置下拉列表框");
        Container c = getContentPane();
        setLayout(new BorderLayout());

        final JTextArea ja = new JTextArea("aaa", 10, 20);
        ja.addKeyListener(new KeyListener() {
            
            @Override
            public void keyTyped(KeyEvent e) {
                System.out.println("此次输入的是：" + e.getKeyChar());
            }
            
            @Override
            public void keyReleased(KeyEvent e) {
                String keyText = KeyEvent.getKeyText(e.getKeyCode());
                System.out.println("您释放的是：" + keyText);
                System.out.println();
            }
            
            @Override
            public void keyPressed(KeyEvent e) {
                String keyText = KeyEvent.getKeyText(e.getKeyCode());
                if (e.isActionKey()) { //是否为动作键，capital/break等
                    System.out.println("您按下的是动作键：" + keyText);
                } else {
                    System.out.println("您按下的是非动作键：" + keyText);
                    int keyCode = e.getKeyCode();
                    switch (keyCode) {
                    case KeyEvent.VK_CONTROL:
                        System.out.println("，Ctrl键被按下");
                        break;
                    case KeyEvent.VK_ALT:
                        System.out.println("，Alt键被按下");
                        break;
                    case KeyEvent.VK_SHIFT:
                        System.out.println("，Shift键被按下");
                        break;
                    }
                }
            }
        });
        
        ja.addMouseListener(new MouseListener() {
            
            @Override
            public void mouseReleased(MouseEvent e) {
                System.out.print("鼠标按钮被释放，");
                int i = e.getButton();
                if (i == MouseEvent.BUTTON1) {
                    System.out.println("释放的是鼠标左键");
                }
                if (i == MouseEvent.BUTTON2) {
                    System.out.println("释放的是鼠标滚轮");
                }
                if (i == MouseEvent.BUTTON3) {
                    System.out.println("释放的是鼠标右键");
                }
            }
            
            @Override
            public void mousePressed(MouseEvent e) {
                System.out.print("鼠标按钮被按下，");
                int i = e.getButton();
                if (i == MouseEvent.BUTTON1) {
                    System.out.println("按下的是鼠标左键");
                }
                if (i == MouseEvent.BUTTON2) {
                    System.out.println("按下的是鼠标滚轮");
                }
                if (i == MouseEvent.BUTTON3) {
                    System.out.println("按下的是鼠标右键");
                }
            }
            
            @Override
            public void mouseExited(MouseEvent e) {
                System.out.println("光标移出组件");
            }
            
            @Override
            public void mouseEntered(MouseEvent e) {
                System.out.println("光标移入组件");
            }
            
            @Override
            public void mouseClicked(MouseEvent e) {//如果鼠标移出组件范围，单击事件不会触发
                System.out.print("单击了鼠标按键，");
                int i = e.getButton();
                if (i == MouseEvent.BUTTON1) {
                    System.out.println("单击的是鼠标左键");
                }
                if (i == MouseEvent.BUTTON2) {
                    System.out.println("单击的是鼠标滚轮");
                }
                if (i == MouseEvent.BUTTON3) {
                    System.out.println("单击的是鼠标右键");
                }
                int clickCount = e.getClickCount();
                System.out.println("单击次数为：" + clickCount);//双击鼠标时，第一次单击鼠标将触发一次单击事件
            }
        });
        
        c.add(ja, BorderLayout.NORTH);
        
        setSize(300, 200);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new JTextFieldTest();
    }
}

14.3 窗体事件 P359
14.3.1 捕获窗体焦点变化事件
14.3.2 捕获窗体状态变化事件
import java.awt.Frame;
import java.awt.event.WindowEvent;
import java.awt.event.WindowStateListener;

import javax.swing.JFrame;

public class WindowStateListener_Example extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    public static void main(String args[]) {
        WindowStateListener_Example frame = new WindowStateListener_Example();
        frame.setVisible(true);
    }
    public WindowStateListener_Example() {
        super();
        // 为窗体添加状态事件监听器
        addWindowStateListener(new MyWindowStateListener());
        setTitle("捕获窗体状态事件");
        setBounds(100, 100, 500, 375);
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    }
    private class MyWindowStateListener implements WindowStateListener {
        public void windowStateChanged(WindowEvent e) {
            int oldState = e.getOldState();// 获得窗体以前的状态
            int newState = e.getNewState();// 获得窗体现在的状态
            String from = "";// 标识窗体以前状态的中文字符串
            String to = "";// 标识窗体现在状态的中文字符串
            switch (oldState) {// 判断窗台以前的状态
                case Frame.NORMAL:// 窗体处于正常化
                    from = "正常化";
                    break;
                case Frame.MAXIMIZED_BOTH:// 窗体处于最大化
                    from = "最大化";
                    break;
                default:// 窗体处于最小化
                    from = "最小化";
            }
            switch (newState) {// 判断窗台现在的状态
                case Frame.NORMAL:// 窗体处于正常化
                    to = "正常化";
                    break;
                case Frame.MAXIMIZED_BOTH:// 窗体处于最大化
                    to = "最大化";
                    break;
                default:// 窗体处于最小化
                    to = "最小化";
            }
            System.out.println(from + "――>" + to);
        }
    }
}

14.3.3 捕获其他窗体事件

14.4 选项事件 P363
ComboBox.addItemListener(new ItemListener(){})

14.5 表格模型事件 P364
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;

public class TableModelEvent_Example extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    private JTable table;// 声明一个表格对象
    private DefaultTableModel tableModel;// 声明一个表格模型对象
    private JTextField aTextField;
    private JTextField bTextField;
    public static void main(String args[]) {
        TableModelEvent_Example frame = new TableModelEvent_Example();
        frame.setVisible(true);
    }
    public TableModelEvent_Example() {
        super();
        setTitle("表格模型事件示例");
        setBounds(100, 100, 650, 213);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        final JScrollPane scrollPane = new JScrollPane();
        getContentPane().add(scrollPane, BorderLayout.CENTER);
        
        String[] columnNames = { "A", "B" };
        String[][] rowValues = { { "A1", "B1" }, { "A2", "B2" },
                { "A3", "B3" }, { "A4", "B4" } };
        // 创建表格模型对象
        tableModel = new DefaultTableModel(rowValues, columnNames);
        // 为表格模型添加事件监听器
        tableModel.addTableModelListener(new TableModelListener() {
            public void tableChanged(TableModelEvent e) {
                int type = e.getType();// 获得事件的类型
                int row = e.getFirstRow() + 1;// 获得触发此次事件的表格行索引
                int column = e.getColumn() + 1;// 获得触发此次事件的表格列索引
                if (type == TableModelEvent.INSERT) {// 判断是否有插入行触发
                    System.out.print("此次事件由 插入 行触发，");
                    System.out.println("此次插入的是第 " + row + " 行！");
                    // 判断是否有修改行触发
                } else if (type == TableModelEvent.UPDATE) {
                    System.out.print("此次事件由 修改 行触发，");
                    System.out.println("此次修改的是第 " + row + " 行第 " + column
                            + " 列！");
                    // 判断是否有删除行触发
                } else if (type == TableModelEvent.DELETE) {
                    System.out.print("此次事件由 删除 行触发，");
                    System.out.println("此次删除的是第 " + row + " 行！");
                } else {
                    System.out.println("此次事件由 其他原因 触发！");
                }
            }
        });
        table = new JTable(tableModel);// 利用表格模型对象创建表格对象，等同于table = new JTable();table.setModel(tableModel);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        scrollPane.setViewportView(table);
        
        
        final JPanel panel = new JPanel();
        getContentPane().add(panel, BorderLayout.SOUTH);
        
        final JLabel aLabel = new JLabel("A：");
        panel.add(aLabel);
        
        aTextField = new JTextField(15);
        panel.add(aTextField);
        
        final JLabel bLabel = new JLabel("B：");
        panel.add(bLabel);
        
        bTextField = new JTextField(15);
        panel.add(bTextField);
        
        final JButton addButton = new JButton("添加");
        addButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String[] rowValues = { aTextField.getText(),
                        bTextField.getText() };
                tableModel.addRow(rowValues);// 向表格模型中添加一行
                aTextField.setText(null);
                bTextField.setText(null);
            }
        });
        panel.add(addButton);
        
        final JButton updButton = new JButton("修改");
        updButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                int selectedRow = table.getSelectedRow();
                if (selectedRow != -1) {
                    tableModel.setValueAt(aTextField.getText(), selectedRow, 0);
                    tableModel.setValueAt(bTextField.getText(), selectedRow, 1);
                }
            }
        });
        panel.add(updButton);
        
        final JButton delButton = new JButton("删除");
        delButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // 获得表格中的选中行
                int[] selectedRows = table.getSelectedRows();
                for (int row = 0; row < selectedRows.length; row++) {
                    // 从表格模型中移除表格中的选中行
                    tableModel.removeRow(selectedRows[row] - row);
                }
            }
        });
        panel.add(delButton);
    }
}

14.6 经典范例 P367
14.6.1 经典范例1：模拟相机拍摄
键盘移动操作KeyAdapter
14.6.2 经典范例2：打地鼠游戏
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第15章 多线程 P372
15.2 实现线程的两种方式 P374
15.2.1 继承Thread类
在main()方法中，使线程执行需要调用Thread类中的start()方法，start()方法调用被覆盖的run()方法，如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()方法之前，Thread对象只是一个实例，而不是一个真正的线程。
public class ThreadTest extends Thread {
    private int count = 10;
    private long timeInterval;
    
    public ThreadTest(long timeInterval) {
        this.timeInterval = timeInterval;
    }
    
    public void run() {
        while (true) {
            try {
                Thread.sleep(timeInterval);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(count + " ");
            if (--count == 0) {
                return;
            }
        }
    }
    
    public static void main(String args[]) {
        new ThreadTest(500).start();
        new ThreadTest(1000).start();
    }
}

15.2.2 实现Runnable接口
如果需要继承其他类（非Thread类）并使该程序可以使用线程，就需要使用Runnable接口。例如，一个扩展JFrame类的GUI程序不可能再继承Thread类，因为Java语言中不支持多继承，这时该类就需要实现Runnable接口使其具有使用线程的功能。
可以查询API，实质上Thread类就是实现了Runnable接口，其中的run()方法正是对Runnable接口中的run()方法的具体实现。

import java.awt.Container;
import java.net.URL;

import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.WindowConstants;



public class SwingAndThread extends JFrame {
    private JLabel jl = new JLabel();
    private static Thread t;
    private int count = 0;
    private Container container = getContentPane();
    
    public SwingAndThread() {
        setBounds(300, 200, 250, 100);
        container.setLayout(null);
        URL url = SwingAndThread.class.getResource("imageButton.jpg");
        Icon icon = new ImageIcon(url);
        jl.setIcon(icon);
        jl.setHorizontalAlignment(SwingConstants.LEFT);
        jl.setBounds(10, 10, 200, 50);
        jl.setOpaque(true);
        t = new Thread(new Runnable() {
            @Override
            public void run() {
                while (count <= 200) {
                    jl.setBounds(count, 10, 200, 50);
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    count += 4;
                    
                    if (count == 200) {
                        count = 10;//从0开始能恰好走到200，循环一次从10开始之后，走不到200，就退出while了
                    }
                }
                
            }
        });
        t.start();
        container.add(jl);
        setVisible(true);
        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new SwingAndThread();
    }
}

15.2.3 范例1：查看线程的运行状态 P377

public class ThreadState implements Runnable {
    public synchronized void waitForASecond() throws InterruptedException {
        wait(500);
    }
    
    public synchronized void waitForYears() throws InterruptedException {
        wait();
    }
    
    public synchronized void notifyNow() throws InterruptedException {
        notify();
    }
    
    public void run() {
        try {
            waitForASecond();
            waitForYears();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


public class Test {
    public static void main(String args[]) {
        try {
            ThreadState state = new ThreadState();
            Thread thread = new Thread(state);
            System.out.println("New thread: " + thread.getState());

            thread.start();
            System.out.println("Start thread: " + thread.getState());

            Thread.sleep(100);
            System.out.println("Wait for timer: " + thread.getState());

            Thread.sleep(1000);
            System.out.println("Wait for thread: " + thread.getState());

            state.notifyNow();
            System.out.println("Wake thread: " + thread.getState());

            Thread.sleep(1000);
            System.out.println("Stop thread: " + thread.getState());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

15.2.4 范例2：查看JVM中的线程名

import java.util.ArrayList;
import java.util.List;

public class ThreadList {
    private static ThreadGroup getRootThreadGroups() {
        ThreadGroup rootGroup = Thread.currentThread().getThreadGroup();
        ThreadGroup lastGroup = rootGroup;
        while (true) {
            if (rootGroup != null && rootGroup.getClass() != null) {
                rootGroup = rootGroup.getParent();
            }
            
            if (rootGroup != null) {
                lastGroup = rootGroup;
            }
            else {
                break;
            }
            
        }
        return lastGroup;
    }
    
    public static List<String> getThreads(ThreadGroup group) {
        List<String> threadList = new ArrayList<String>();
        Thread threads[] = new Thread[group.activeCount()];//5个活动线程
        int count = group.enumerate(threads, false);//这里却复制了4个活动线程到threads中
        for (int i = 0; i < count; ++i) {
            threadList.add(group.getName() + "线程组：" + threads[i].getName());
        }
        return threadList;
    }
    
    public static List<String> getThreadGroups(ThreadGroup group) {
        List<String> threadList = getThreads(group);
        ThreadGroup groups[] = new ThreadGroup[group.activeGroupCount()];//1个活动线程组
        int count = group.enumerate(groups, false);
        for (int i = 0; i < count; ++i) {
            threadList.addAll(getThreads(groups[i]));
        }
        return threadList;
    }
    
    public static void main(String args[]) {
        for (String string : getThreadGroups(getRootThreadGroups())) {
            System.out.println(string);
        }
    }
}
输出如下：
system线程组：Reference Handler
system线程组：Finalizer
system线程组：Signal Dispatcher
system线程组：Attach Listener
main线程组：main

15.3 线程的状态
虽然多线程看起来像同时执行，但事实上在同一时间点上只有一个线程被执行，只是线程之间切换较快，所以会使人产生线程是同时进行的假象。

15.4 操作线程的方法 P382
15.4.1 线程的休眠 
Thread.sleep(mills);
使用了sleep()方法的线程在一段时间内会醒来，但是并不能保证它醒来后进入运行状态，只能保证它进入就绪状态。

import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;

import javax.swing.JFrame;

public class SleepMethodTest extends JFrame {
    private Thread t;
    
    private static Color color[] = {Color.BLACK, Color.BLUE, Color.CYAN, Color.GREEN, Color.ORANGE, Color.YELLOW, Color.RED, 
        Color.PINK, Color.LIGHT_GRAY};
    
    private static final Random rand = new Random();
    
    private static Color getC() {
        return color[rand.nextInt(color.length)];
    }
    
    public SleepMethodTest() {
        t = new Thread(new Runnable() {
            int x = 30;
            int y = 50;
            
            @Override
            public void run() {
                while (true) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    
                    Graphics graphics = getGraphics();
                    graphics.setColor(getC());
                    graphics.drawLine(x, y, 100, y++);//绘制直线并递增垂直坐标
                    
                    if (y >= 80) {
                        y = 50;
                    }
                }
            }
        });
        
        t.start();
    }
    
    public static void init(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }
    
    public static void main(String args[]) {
        init(new SleepMethodTest(), 100, 100);
    }
}

15.4.2 线程的加入 P383
join()
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;

import javax.swing.JFrame;
import javax.swing.JProgressBar;

public class JoinTest extends JFrame {
    private Thread threadA;
    private Thread threadB;
    
    private final JProgressBar progressBar1 = new JProgressBar();
    private final JProgressBar progressBar2 = new JProgressBar();
    
    private int count = 0;
    
    public JoinTest() {
        //super();//不写会自动调用
        
        getContentPane().add(progressBar1, BorderLayout.NORTH);
        getContentPane().add(progressBar2, BorderLayout.SOUTH);
        
        progressBar1.setStringPainted(true);
        progressBar2.setStringPainted(true);
        
        threadA = new Thread(new Runnable() {
            int count = 0;
            
            @Override
            public void run() {
                while (true) {
                    progressBar1.setValue(++count);
                    try {
                        Thread.sleep(10);
                        threadB.join();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        threadA.start();
        
        threadB = new Thread(new Runnable() {
            int count = 0;
            
            @Override
            public void run() {
                while (true) {
                    progressBar2.setValue(++count);
                    try {
                        Thread.sleep(10);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    
                    if (count == 100) {
                        break;
                    }
                }
            }
        });
        threadB.start();
    }
    
    public static void init(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }
    
    public static void main(String args[]) {
        init(new JoinTest(), 100, 100);
    }
}

15.4.3 线程的中断 P385
提供在run()方法中使用无限循环的形式，然后使用一个布尔型标记循环的停止。

如果线程是因为使用了sleep()或wait()方法进入了就绪状态，这时可以使用Thread类的interrupt()方法使线程离开run()方法，同时结束线程，但是程序会抛出InterruptedException异常。

public class InterrupedTest implements Runnable {
    private boolean isContinue = true;
    public void run() {
        while (true) {
            //...
            if (isContinue) {
                break;
            }
        }
    }
    public void setContinue() {
        this.isContinue = true;
    }
}
//参考下例，用两个按钮来进行isContinue变量的设置
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

public class TestThread extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    JPanel jPanel1 = new JPanel();
    JButton startButton = new JButton();
    JButton stopButton = new JButton();
    MyThread thread = null;
    private boolean isContinue;
    public TestThread() {
        try {
            jbInit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void jbInit() throws Exception {
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        startButton.setText("start");
        startButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                startButton_actionPerformed(e);
            }
        });
        stopButton.setText("stop");
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                stopButton_actionPerformed(e);
            }
        });
        this.getContentPane().add(jPanel1, BorderLayout.CENTER);
        jPanel1.add(startButton);
        startButton.setBounds(36, 105, 82, 30);
        jPanel1.add(stopButton);
        stopButton.setBounds(160, 108, 100, 31);
    }
    
    void startButton_actionPerformed(ActionEvent e) {
        if (thread != null) {
            isContinue = true;
        }
        else {
            thread = new MyThread();
            thread.start();
        }
    }
    
    void stopButton_actionPerformed(ActionEvent e) {
        if (thread != null) {
            isContinue = false;
        }
        //thread = null;
    }
    
    public static void main(String[] args) {
        TestThread test = new TestThread();
        test.setBounds(300,300,300, 80);
        test.setVisible(true);
    }
    
    private class MyThread extends Thread {
        public MyThread() {
            isContinue = true;
        }
        
        public void run() {
            System.out.println("\n\n");
            while (true) {
                if (isContinue) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("Java 编程词典\thttp://www.mrbccd.com");
                }
            }
        }
    }
}



import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JProgressBar;

public class InterruptedSwing extends JFrame {
    private Thread threadA;
    
    public InterruptedSwing() {
        //super();
        final JProgressBar progressBar1 = new JProgressBar();
        getContentPane().add(progressBar1, BorderLayout.NORTH);
        
        progressBar1.setStringPainted(true);
        
        threadA = new Thread(new Runnable() {
            int count = 0;
            
            @Override
            public void run() {
                while (true) {
                    progressBar1.setValue(++count);
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.out.println("当前线程被中断");
                        System.out.println("Run exception");
                    }
                }
            }
        });
        threadA.start();
        
        try {
            Thread.sleep(10000);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Contructor exception");
        }
        
        threadA.interrupt();
    }
    
    public static void init(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }
    
    public static void main(String args[]) {
        init(new InterruptedSwing(), 100, 100);
    }
}
输出如下：
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptedSwing$1.run(InterruptedSwing.java:24)
    at java.lang.Thread.run(Unknown Source)
当前线程被中断
Run exception

15.4.4 线程的礼让 P386
使用yield()方法，给当前正处于运行状态下的线程一个提醒，告知它可以将资源礼让给其他线程，但这仅仅是一种暗示，没有任何一种机制保证当前线程会将资源礼让。
yield()方法使具有同样优先级的线程有进入可执行状态的机会，当当前线程放弃执行权时会再度回到就绪状态。对于支持多任务的操作系统来说，不需要调用yield()方法，因为操作系统会为线程自动分配CPU时间片来执行。

15.4.5 查看和修改线程的优先级 P386


15.4.6 休眠当前线程 P388

15.5 线程的优先级 P389
import java.awt.*;

import javax.swing.*;

public class PriorityTest extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    private Thread threadA;
    private Thread threadB;
    private Thread threadC;
    private Thread threadD;
    
    public PriorityTest() {
        getContentPane().setLayout(new GridLayout(4, 1));
        // 分别实例化4个线程
        final JProgressBar progressBar = new JProgressBar();
        final JProgressBar progressBar2 = new JProgressBar();
        final JProgressBar progressBar3 = new JProgressBar();
        final JProgressBar progressBar4 = new JProgressBar();
        getContentPane().add(progressBar);
        getContentPane().add(progressBar2);
        getContentPane().add(progressBar3);
        getContentPane().add(progressBar4);
        progressBar.setStringPainted(true);
        progressBar2.setStringPainted(true);
        progressBar3.setStringPainted(true);
        progressBar4.setStringPainted(true);
        threadA = new Thread(new MyThread(progressBar));
        threadB = new Thread(new MyThread(progressBar2));
        threadC = new Thread(new MyThread(progressBar3));
        threadD = new Thread(new MyThread(progressBar4));
        setPriority("threadA", 5, threadA);
        setPriority("threadB", 5, threadB);
        setPriority("threadC", 4, threadC);
        setPriority("threadD", 3, threadD);
    }
    
    // 定义设置线程的名称、优先级的方法
    public static void setPriority(String threadName, int priority,
            Thread t) {
        t.setPriority(priority); // 设置线程的优先级
        t.setName(threadName); // 设置线程的名称
        t.start(); // 启动线程
    }
    
    public static void main(String[] args) {
        init(new PriorityTest(), 100, 100);
    }
    
    public static void init(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }
    
    private final class MyThread implements Runnable { // 定义一个实现Runnable接口的类
        private final JProgressBar bar;
        int count = 0;
        
        private MyThread(JProgressBar bar) {
            this.bar = bar;
        }
        
        public void run() { // 重写run()方法
            while (true) {
                bar.setValue(count += 10); // 设置滚动条的值每次自增10
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("当前线程序被中断");
                }
            }
        }
    }
    
}

15.6 线程同步 P391
编写多线程程序时，应该考虑到线程安全问题。实质上线程安全问题来源于两个线程同时存取单一对象的数据。
//有问题的是这些线程都没有正常退出？
public class ThreadSafeTest implements Runnable {
    int num = 10;
    
    public void run() {
        while (true) {
            if (num > 0) {
                try {
                    Thread.sleep(100);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println("车票还有 " + num-- + "张");
            }
        }
    }
    public static void main(String[] args) {
        ThreadSafeTest t = new ThreadSafeTest();
        Thread tA = new Thread(t);
        Thread tB = new Thread(t);
        Thread tC = new Thread(t);
        Thread tD = new Thread(t);
        tA.start();
        tB.start();
        tC.start();
        tD.start();
    }
}
输出如下：
车票还有 10张
车票还有 9张
车票还有 8张
车票还有 7张
车票还有 6张
车票还有 5张
车票还有 4张
车票还有 3张
车票还有 2张
车票还有 1张
车票还有 0张
车票还有 -1张
车票还有 -2张


15.6.2 线程同步机制 P392
1. 同步块
Java中提供了同步机制，可以有效地防止资源冲突，同步机制使用synchronized关键字。

public class ThreadSafeTest implements Runnable {
    int num = 10;
    
    public void run() {
        while (true) {
            synchronized ("") {
                if (num > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println("车票还有 " + num-- + "张");
                }
            }
        }
    }
    public static void main(String[] args) {
        ThreadSafeTest t = new ThreadSafeTest();
        Thread tA = new Thread(t);
        Thread tB = new Thread(t);
        Thread tC = new Thread(t);
        Thread tD = new Thread(t);
        tA.start();
        tB.start();
        tC.start();
        tD.start();
    }
}
打印到最后没有出现负数，这是因为将资源放置在了同步块中。这个同步块也被称为临界区，它使用synchronized关键字，语法格式如下：
synchronized(Object) {
    //...
}
通常将共享资源的操作放置在synchronized定义的区域中，当其他线程也获取到这个锁时，必须等待锁被释放时才能进入该区域。Object为任意一个对象，每个对象都存在一个标志位，并具有两个值，分别为0和1。一个线程运行到同步块时首先检查该对象的标志位，如果为0状态，表明此同步块中存在其他线程在运行。这时该线程就处于就绪状态，直到处于同步块中的线程执行完同步块中的代码为止。这时该对象的标识位被设置为1，该线程才能执行同步块中的代码，并将Object对象的标识位设置为0，防止其他线程执行同步块中的代码。

2. 同步方法
在方法前面修饰synchronzied关键字的方法，其语法格式如下：
synchronized void f() {}





public class ThreadSafeTest implements Runnable {
    int num = 10;
    
    public void run() {
        while (true) {
            //增加如下语句，如果票数为0，则退出，否则所有线程会一直等待资源，无法结束退出
            if (num == 0) {
                System.out.println("Thread exit");
                break;
            }
            
            sellTicket();
        }
    }
    
    private synchronized void sellTicket() {
        if (num > 0) {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("车票还有 " + num-- + "张");
        }

    }
    
    public static void main(String[] args) {
        ThreadSafeTest t = new ThreadSafeTest();
        Thread tA = new Thread(t);
        Thread tB = new Thread(t);
        Thread tC = new Thread(t);
        Thread tD = new Thread(t);
        tA.start();
        tB.start();
        tC.start();
        tD.start();
    }
}
输出如下：
车票还有 10张
车票还有 9张
车票还有 8张
车票还有 7张
车票还有 6张
车票还有 5张
车票还有 4张
车票还有 3张
车票还有 2张
车票还有 1张
Thread exit
Thread exit
Thread exit
Thread exit

15.7 线程间的通信 P394
从同步的角度来说，调用sleep()方法的线程不释放锁，但调用wait()方法的线程释放锁。
wait()与notify()、notifyAll()方法只能在同步块或同步方法中使用。

//还是有些问题，有时候会走不下去
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JProgressBar;


public class Communicate extends JFrame {
    private Thread t1;
    private Thread t2;
    private final JProgressBar progressBar = new JProgressBar();
    private int count = 0;

    public Communicate() {
        getContentPane().add(progressBar, BorderLayout.NORTH);
        progressBar.setStringPainted(true);
        
        deValue();
        addValue();
        t1.start();
        
        try {
            Thread.currentThread().sleep(1000);//使当前线程休眠1000毫秒
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        t2.start();
    }
    
    private void addValue() {
        t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {                
                    if (count >= 100) {
                        System.out.println("进度条已满，递增线程等待");
                    }
                    
                    if (count == 0) {
                        progressBar.setValue(count += 100);
                        System.out.println("进度条的当前值为：" + count);
                        
                        //确保通知t2时，t2线程已经启动
                        try {
                            Thread.currentThread().sleep(5000);//使当前线程休眠100毫秒
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        
                        synchronized (t2) { //这里为什么要用t2？
                            System.out.println("进度条已有值，可以进行递减操作");
                            t2.notify();
                        }
                    }
                    
                    try {
                        Thread.currentThread().sleep(500);//使当前线程休眠100毫秒
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        
    }

    private void deValue() {
        t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    if (count == 0) {
                        synchronized (this) {
                            try {
                                wait();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    }
                    
                    count -= 20; 
                    progressBar.setValue(count);
                    System.out.println("进度条当前值为：" + count);
                    
                    try {
                        Thread.currentThread().sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
    }

    public static void init(JFrame frame, int width, int height) {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(width, height);
        frame.setVisible(true);
    }
    
    public static void main(String[] args) {
        init(new Communicate(), 150, 100);
    }
}

15.8.1 线程的插队运行 P396

public class EmergencyThread implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i < 6; ++i) {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("紧急情况：" + i + "号车出发！");
        }
    }
}


public class EmergencyThread implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i < 6; ++i) {
            try {
                Thread.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("紧急情况：" + i + "号车出发！");
        }
    }
}
输出如下：（不唯一）
正常情况：1号车出发！
紧急情况：1号车出发！
紧急情况：2号车出发！
紧急情况：3号车出发！
紧急情况：4号车出发！
紧急情况：5号车出发！
正常情况：2号车出发！
正常情况：3号车出发！
正常情况：4号车出发！
正常情况：5号车出发！
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第16章 网络通信 P400
TCP与UDP协议 P402
TCP协议是一种以固接连线为基础的黑方，它提供两台计算机间可选的数据传送。
UDP是无连接通信协议，不保证可选数据的传输，但能够向若干个目标发送数据，接收发自若干个源的数据。
一些防火墙和路由器会设置成不允许UDP数据包传输，因此若遇到UDP连接方面的问题，应先确定是否允许UDP协议。

16.1.3 端口和套接字 P402
端口被规定为一个在0~65535 之间的整数。HTTP服务一般使用80端口，FTP服务使用21端口。
通常0~1023 之间的端口数用于一些知名的网络服务和应用，用户的普通网络应用程序应该使用1024以上的端口数，以避免端口号与另一个应用或系统服务所用端口冲突。
网络程序中套接字（Socket）用于将应用程序与端口连接起来。


import java.net.InetAddress;
import java.net.UnknownHostException;


public class Address {
    public static void main(String args[]) {
        InetAddress ip;
        try {
            ip = InetAddress.getLocalHost();
            String localName = ip.getHostName();
            String localIp = ip.getHostAddress();
            System.out.println("本地主机名：" + localName);
            System.out.println("本机IP地址：" + localIp);
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
输出如下：
本地主机名：Ben-PC
本机IP地址：192.168.1.106

16.2.2 ServerSocket类 P407

16.2.3 TCP网络程序 P408
//服务器端程序
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;

import javax.swing.JOptionPane;


public class MyTcp {
    private BufferedReader reader;
    private ServerSocket server;
    private Socket socket;
    
    void getServer() {
        try {
            server = new ServerSocket(8998);
            server.setSoTimeout(5000);//设置超时时长
            System.out.println("服务器套接字已经创建成功");
            while (true) {
                System.out.println("等待客户机的连接");
                socket = server.accept();
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                getClientMessage();
            }
        } catch (SocketTimeoutException e) {
            System.out.println("连接超时...");
            JOptionPane.showMessageDialog(null, "连接超时...");//可以直接弹出提示面板
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void getClientMessage() {
        try {
            while (true) {
                System.out.println("客户机：" + reader.readLine());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        try {
            if (reader != null) {
                reader.close();
            }
            if (socket != null) {
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String args[]) {
        MyTcp tcp = new MyTcp();
        tcp.getServer();
    }
}

输出如下：
服务器套接字已经创建成功
等待客户机的连接

本实例是服务器端程序，当本实例运行后，如果在服务器没有停止运行的情况下再次运行本实例将发生异常，这是由于服务器程序使用的端口号已经被占用，所以在服务器程序没有停止的情况下再次运行就发生了异常。

//客户端程序
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;

import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.JTextField;


public class MyClient extends JFrame {
    private PrintWriter writer;
    Socket socket;
    private JTextArea ta = new JTextArea();
    private JTextField tf = new JTextField();
    Container cc;
    
    public MyClient(String title) {
        super(title);
        cc = this.getContentPane();
        cc.add(ta, "North");
        cc.add(tf, "South");
        tf.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String inputText = tf.getText();
                //如果是info，则显示客户端和服务器的IP及端口号
                if (inputText.equals("info")) { //字符串判断相等需要用euqals
                    InetAddress netAddress = socket.getInetAddress();
                    String netIp = netAddress.getHostAddress();
                    int netPort = socket.getPort();
                    
                    InetAddress localAddress = socket.getLocalAddress();
                    String localIp = localAddress.getHostAddress();
                    int localPort = socket.getLocalPort();
                    
                    System.out.print("远程服务器的IP地址：" + netIp + "\n");
                    System.out.print("远程服务器的端口号：" + netPort + "\n");
                    System.out.print("客户机本地的IP地址：" + localIp + "\n");
                    System.out.print("客户机本地的端口号：" + localPort + "\n");
//                    ta.append("远程服务器的IP地址：" + netIp + "\n");
//                    ta.append("远程服务器的端口号：" + netPort + "\n");
//                    ta.append("客户机本地的IP地址：" + localIp + "\n");
//                    ta.append("客户机本地的端口号：" + localPort + "\n");
                    
                } else {
                    writer.println(tf.getText());//将socket输出流中的内容输出到服务器端
                    ta.append(tf.getText() + '\n');
                }
                tf.setText("");    
            }
        });
    }
    
    private void connect() {
        ta.append("尝试连接\n");
        try {
            socket = new Socket("192.168.1.106", 8998);
            writer = new PrintWriter(socket.getOutputStream(), true);//创建socket输出流的打印对象
            ta.append("完成连接\n");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String args[]) {
        MyClient client = new MyClient("向服务器发送数据");
        client.setBounds(300, 260, 340, 220);
        client.setVisible(true);
        client.connect();
    }
}

为了使本实例能够正常运行，必须先运行16.3 的服务器端程序，并且实例的端口号要与例16.3 服务器端程序套接字的端口号一致，否则程序会发生错误。
当一台机器上安装了多个网络应用程序时，很可能指定的端口号已被占用，有时可能还会遇到以前很好的网络程序突然运行不起来了，这种情况很可能也是由于端口被其他程序占用了。此时可以运行netstat -help来获得帮助，使用命令netstat -an来查看该程序所使用的端口。P411

16.3 UDP程序设计基础 P413
DatagramSocket()
DatagramSocket(int port)
DatagramSocket(int port, InetAddress addr)
在接收程序时，必须指定一个端口号，不要让系统随机产生。可以使用第二种构造函数。在发送程序时，通常使用第一种构造函数，不指定端口号，这样系统就会为我们分配一个端口号。

//广播主机程序不断向外发出广播信息
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;

public class Weather extends Thread {
    String weather = "节目预报：八点有大型晚会，请收听";
    int port = 9898;
    InetAddress iAddress = null;
    MulticastSocket socket = null;
    public Weather() {
        try {
            iAddress = InetAddress.getByName("224.255.10.0");
            socket = new MulticastSocket(port);
            socket.setTimeToLive(1);
            socket.joinGroup(iAddress);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public void run() {
        while (true) {
            DatagramPacket packet = null;
            byte data[] = weather.getBytes();
            packet = new DatagramPacket(data, data.length, iAddress, port);
            System.out.println(new String(data));
            try {
                socket.send(packet);
                sleep(3000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String args[]) {
        Weather w = new Weather();
        w.start();
    }
}

//接收程序
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class Receive extends JFrame implements Runnable, ActionListener {
    int port;
    InetAddress group = null;
    MulticastSocket socket = null;
    JButton start = new JButton("开始接收");
    JButton stop = new JButton("停止接收");
    JTextArea inceAr = new JTextArea(10, 10);
    JTextArea inced = new JTextArea(10, 10);
    Thread thread;
    boolean b = false;
    
    public Receive() {
        super("广播数据报");
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        thread = new Thread(this);
        start.addActionListener(this);
        stop.addActionListener(this);
        
        inceAr.setForeground(Color.blue);
        JPanel north = new JPanel();
        north.add(start);
        north.add(stop);
        add(north, BorderLayout.NORTH);
        
        JPanel center = new JPanel();
        center.setLayout(new GridLayout(1, 2));
        center.add(inceAr);
        center.add(inced);
        add(center, BorderLayout.CENTER);
        
        validate();//刷新
        port = 9898;
        
        try {
            group = InetAddress.getByName("224.225.10.0");
            socket = new MulticastSocket(port);
            socket.joinGroup(group);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        setBounds(100, 50, 360, 380);
        setVisible(true);
    }
    
    public void run() {
        while (true) {
            byte data[] = new byte[1024];
            DatagramPacket packet = null;
            packet = new DatagramPacket(data, data.length, group, port);
            try {
                socket.setSoTimeout(2000);
                socket.receive(packet);
                String message = new String(packet.getData(), 0, packet.getLength());
                inceAr.setText("正在接收的内容：\n" + message);
                inced.append(message + "\n");
            } catch (Exception e) {
                e.printStackTrace();
            }
            
            if (b == true) {
                break;
            }
        }
    }
    
    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getSource() == start) {
            start.setBackground(Color.red);
            stop.setBackground(Color.yellow);
            if (!(thread.isAlive())) {
                thread = new Thread(this);
            }
            thread.start();
            b = false;
        }
        
        if (e.getSource() == stop) {
            start.setBackground(Color.yellow);
            stop.setBackground(Color.red);
            b = true;
        }
    }
    
    public static void main(String args[]) {
        Receive rec = new Receive();
        rec.setSize(460, 200);
    }
}
一直没有收到，不知道为什么？？？

16.4.1 聊天室服务端 P418
16.4.2 聊天室客户端 P419
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第17章 JDBC操作数据库 P424
没看

//------------------------------------------------------------------------------------------------
//Java从入门到精通 第18章 Swing高级组件 P452

18.1.1 创建表格 P453
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;

public class ExampleFrame_01 extends JFrame {
    public static void main(String args[]) {
        ExampleFrame_01 frame = new ExampleFrame_01();
        frame.setVisible(true);
    }
    
    public ExampleFrame_01() {
        super();
        setTitle("创建可以滚动的表格");
        setBounds(100, 100, 240, 150);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        String columnNames[] = {"A", "B"};
        String tableValues[][] = {{"A1", "B1"}, {"A2", "B2"}, {"A3", "B3"}, {"A4", "B4"}, {"A5", "B5"}};
        JTable table = new JTable(tableValues, columnNames);
        JScrollPane scrollPane = new JScrollPane(table);
        getContentPane().add(scrollPane, BorderLayout.CENTER);
    }
}

//直接添加到容器中 P454
import java.awt.BorderLayout;
import java.util.Vector;

import javax.swing.JFrame;
import javax.swing.JTable;
import javax.swing.table.JTableHeader;

public class ExampleFrame_01 extends JFrame {
    public static void main(String args[]) {
        ExampleFrame_01 frame = new ExampleFrame_01();
        frame.setVisible(true);
    }
    
    public ExampleFrame_01() {
        super();
        setTitle("创建可以滚动的表格");
        setBounds(100, 100, 240, 150);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Vector<String> columnNameV = new Vector<>();
        columnNameV.add("A");
        columnNameV.add("B");
        columnNameV.add("C");
        
        Vector<Vector<String>> tableValueV = new Vector<>();
        for (int row = 1; row < 6; ++row) {
            Vector<String> rowV = new Vector<>();
            rowV.add("A" + row);
            rowV.add("B" + row);
            rowV.add("C" + row);
            tableValueV.add(rowV);
        }
        JTable table = new JTable(tableValueV, columnNameV);
        getContentPane().add(table, BorderLayout.CENTER);
        JTableHeader tableHeader = table.getTableHeader();
        getContentPane().add(tableHeader, BorderLayout.NORTH);//没有这句，则不会显示出标题
        
        tableHeader.setReorderingAllowed(true);//可以设置列是否可以拖动重排
    }
}

//通过定制自己的表格，重载特定的方法实现表格的特定功能 P455
import java.awt.BorderLayout;
import java.awt.Color;
import java.util.Vector;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;

public class ExampleFrame_01 extends JFrame {
    public static void main(String args[]) {
        ExampleFrame_01 frame = new ExampleFrame_01();
        frame.setVisible(true);
    }
    
    public ExampleFrame_01() {
        super();
        setTitle("创建可以滚动的表格");
        setBounds(100, 100, 240, 150);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        final JScrollPane scrollPane = new JScrollPane();
        getContentPane().add(scrollPane, BorderLayout.CENTER);
        
        
        Vector<String> columnNameV = new Vector<>();
        columnNameV.add("A");
        columnNameV.add("B");
        columnNameV.add("C");
        
        Vector<Vector<String>> tableValueV = new Vector<>();
        for (int row = 1; row < 6; ++row) {
            Vector<String> rowV = new Vector<>();
            rowV.add("A" + row);
            rowV.add("B" + row);
            rowV.add("C" + row);
            tableValueV.add(rowV);
        }
        JTable table = new MyTable(tableValueV, columnNameV);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        table.setSelectionBackground(Color.YELLOW);
        table.setSelectionForeground(Color.RED);
        table.setRowHeight(30);
        scrollPane.setViewportView(table);
    }
    
    class MyTable extends JTable {
        public MyTable(Vector<Vector<String>> rowData, Vector<String> columnNames) {
            super(rowData, columnNames);
        }
        
        @Override
        public JTableHeader getTableHeader() {
            JTableHeader tableHeader = super.getTableHeader();
            tableHeader.setReorderingAllowed(false);
            DefaultTableCellRenderer hr = (DefaultTableCellRenderer) tableHeader.getDefaultRenderer();
            hr.setHorizontalAlignment(DefaultTableCellRenderer.RIGHT);
            return tableHeader;
        }
        
        @Override
        public boolean isCellEditable(int row, int column) {
            return false;
        }
        
        @Override
        public TableCellRenderer getDefaultRenderer(Class<?> columnClass) {
            DefaultTableCellRenderer cr = (DefaultTableCellRenderer) super.getDefaultRenderer(columnClass);
            cr.setHorizontalAlignment(DefaultTableCellRenderer.CENTER);
            return cr;
        }
    }
}

18.1.3 操纵表格 P458
获得表格的各种信息，如总行数、总列数，选定的行和列等

18.1.4 范例1：列表元素与提示信息 P460 范例2：监听列表单击事件
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.Label;
import java.awt.event.MouseEvent;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JScrollPane;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

public class TipFrame extends JFrame {
    private JScrollPane scrollPane = null;
    private JLabel label = null;
    
    public TipFrame() {
        setTitle("带有提示信息的列表");
        setBounds(100, 100, 500, 375);
        Container c = getContentPane();
        scrollPane = new JScrollPane();
        c.add(scrollPane, BorderLayout.NORTH);
        
        label = new JLabel();
        label.setFont(new Font("Arial", Font.BOLD, 15));
        c.add(label, BorderLayout.SOUTH);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        addWindowListener(new WindowListener() {
            
            @Override
            public void windowOpened(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowIconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeiconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeactivated(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosing(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosed(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowActivated(WindowEvent e) {
                String data[][] = new String[][] {
                        {"book1", "Edition1"},
                        {"book2", "Edition2"},
                        {"book3", "Edition3"},
                        {"book4", "Edition4"}};
                
                JList<Object> list = new ToolTipList(data);
                list.setFont(new Font("微软雅黑", Font.PLAIN, 16));
                scrollPane.setViewportView(list);
                list.addListSelectionListener(new ListSelectionListener() {
                    
                    @Override
                    public void valueChanged(ListSelectionEvent e) {
                        label.setText("Thanks for buying " + list.getSelectedValue());
                    }
                });
            }
        });
    }
    
    public static void main(String args[]) {
        new TipFrame();
    }
}


class ToolTipList extends JList<Object> {
    private static final long serialVersionUID = 3396510300808442967L;
    private Object[][] data;
    public ToolTipList(Object[][] data) {
        this.data = data;
        Object[] listData = new Object[data.length];
        for (int i = 0; i < listData.length; ++i) {
            listData[i] = data[i][0];
        }
        setListData(listData);
    }
    
    @Override
    public String getToolTipText(MouseEvent event) {
        int index = locationToIndex(event.getPoint());
        if (index > -1) {
            return "<html><font face=微软雅黑 size=16 color=red>" + data[index][1] + "</font></html>";
        } else {
            return super.getToolTipText(event);
        }
    }
}

18.2.1 利用表格模型创建表格 P462

import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableRowSorter;

public class ExampleFrame_01 extends JFrame {
    public static void main(String args[]) {
        ExampleFrame_01 frame = new ExampleFrame_01();
        frame.setVisible(true);
    }
    
    public ExampleFrame_01() {
        super();
        setTitle("创建可以滚动的表格");
        setBounds(100, 100, 240, 150);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        String columnNames[] = {"A", "B"};
        String tableValues[][] = {{"A1", "B1"}, {"A2", "B2"}, {"A3", "B3"}, {"A4", "B4"}, {"A5", "B5"}};
        
        DefaultTableModel tableModel = new DefaultTableModel(tableValues, columnNames);
        JTable table = new JTable(tableModel);
        table.setRowSorter(new TableRowSorter<>(tableModel));
        //JScrollPane scrollPane = new JScrollPane(table);//等于下面两句
        JScrollPane scrollPane = new JScrollPane();
        scrollPane.setViewportView(table);
        getContentPane().add(scrollPane, BorderLayout.CENTER);
    }
}

18.2.2 维护表格模型 P464
见 14.5 表格模型事件 P364

18.2.3 范例3：实现自动排序的列表 P466
import java.awt.*;
import java.util.TreeSet;

import javax.swing.*;

public class SortedListModelTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public static void main(String args[]) {
        new SortedListModelTest();
    }
    
    public SortedListModelTest() {
        setTitle("自动排序的列表");
        setBounds(100, 100, 500, 375);
        Container c = getContentPane();
        JScrollPane scrollPane = new JScrollPane();
        c.add(scrollPane, BorderLayout.NORTH);
        
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        SortedListModel model = new SortedListModel();
        model.add("a");
        model.add("f");
        model.add("c");
        model.add("d");
        model.add("e");
        model.add("b");
        
        JList<Object> list = new JList<>(model);
        scrollPane.setViewportView(list);
    }
}

class SortedListModel extends AbstractListModel<Object> {
    private static final long serialVersionUID = 3396510300808442967L;
    private TreeSet<Object> model = new TreeSet<Object>();
    
    @Override
    public Object getElementAt(int index) {
        return model.toArray()[index];
    }

    @Override
    public int getSize() {
        return model.size();
    }
    
    public void add(Object element) {
        if (model.add(element)) {
            fireContentsChanged(this, 0, getSize());//AbstractListModel 子类必须在列表的一个或多个元素发生更改之后调用此方法
        }
    }
}

18.2.4 范例4：可以预览字体的列表 P467
import java.awt.*;

import javax.swing.*;

public class FontTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public static void main(String args[]) {
        new FontTest();
    }
    
    public FontTest() {
        setTitle("自动排序的列表");
        setBounds(100, 100, 500, 700);
        Container c = getContentPane();
        JScrollPane scrollPane = new JScrollPane();
        c.add(scrollPane, BorderLayout.NORTH);
        
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        String fontNames[] = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
        DefaultListModel<Object> model = new DefaultListModel<>();
//        for (String fontName : fontNames) {
//            model.addElement(new Font(fontName, Font.PLAIN, 24));
//        }
        
        for (int i = 0; i < 10; ++i) {
            model.addElement(new Font(fontNames[i], Font.PLAIN, 24));
        }
        
        JList<Object> list = new JList<>(model);
        ListCellRenderer<Object> renderer = new FontListCellRenderer();
        list.setCellRenderer(renderer);
        scrollPane.setViewportView(list);
        
        revalidate();//需要调用面板的重新刷新操作，否则无法看到生成的字体
    }
}

class FontListCellRenderer implements ListCellRenderer<Object> {
    @Override
    public Component getListCellRendererComponent(JList<? extends Object> list,
            Object value, int index, boolean isSelected, boolean cellHasFocus) {
        DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer();
        JLabel renderer = (JLabel) defaultRenderer.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        Font font = (Font) value;
        renderer.setFont(font);
        renderer.setText(font.getFontName());
        return renderer;
    }
}

18.3.2 范例5：提供行标题栏的表格 P469

18.4 Swing树组件 P472
18.4.1 简单的树
左侧的树是直接创建的，中间的树是采用默认方式判断节点的，这两个树中名称为“一级节点B”的节点图标均为叶子节点图标，右侧的树是采用非默认方式判断节点的，该树中名称为“一级子节点B”的节点图标均为非叶子节点图标。
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.WEST);
        
        
        DefaultTreeModel treeModelDefault = new DefaultTreeModel(root);
        JTree treeDefault = new JTree(treeModelDefault);
        getContentPane().add(treeDefault, BorderLayout.CENTER);
        
        
        DefaultTreeModel treeModelPointed = new DefaultTreeModel(root, true);
        JTree treePointed = new JTree(treeModelPointed);
        getContentPane().add(treePointed, BorderLayout.EAST);
        
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

18.4.2 处理选中节点事件 P473


import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;


public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.CENTER);
        
        TreeSelectionModel treeSelectionModel = treeRoot.getSelectionModel();
        treeSelectionModel.setSelectionMode(TreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
        treeRoot.addTreeSelectionListener(new TreeSelectionListener() {
            @Override
            public void valueChanged(TreeSelectionEvent e) {
                if (!treeRoot.isSelectionEmpty()) {
                    TreePath selectionPaths[] = treeRoot.getSelectionPaths();
                    for (int i = 0; i < selectionPaths.length; i++) {
                        TreePath treePath = selectionPaths[i];
                        Object path[] = treePath.getPath();
                        for (int j = 0; j < path.length; j++) {
                            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path[j];
                            System.out.print(node.getUserObject() + (j == (path.length - 1) ? "" : "-->"));
                        }
                        System.out.println();
                    }
                    System.out.println();
                }
            }
        });
        
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}


18.4.3 遍历树节点 P475
前序遍历：根-左-右
中序遍历：左-根-右
后序遍历：左-右-根

以广度优先遍历和以深度优先遍历是一组相对的遍历方式。
因为按后序遍历和以深度优先遍历这两种遍历方式的具体遍历方法相同，所以图18.46 和图18.48 是相同的，实际上depthFirstEnumeration()方法只是调用了postorderEnumeration()方法。
//各种遍历方式 P477
import java.awt.BorderLayout;
import java.util.Enumeration;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.CENTER);
        
        Enumeration<DefaultMutableTreeNode> enumeration;
        //enumeration = root.preorderEnumeration();//前序遍历
        //enumeration = root.postorderEnumeration();//后序遍历
        //enumeration = root.breadthFirstEnumeration();//广度优先遍历
        //enumeration = root.depthFirstEnumeration();//深度优先遍历，输出与后序遍历一样
        enumeration = root.children();//遍历谝节点的子节点，获取直接子节点
        while (enumeration.hasMoreElements()) {
            DefaultMutableTreeNode node = enumeration.nextElement();
            for (int i = 0; i < node.getLevel(); ++i) {
                System.out.print("-----");
            }
            System.out.println(node.getUserObject());
        }
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

18.4.4 定制树 P477
P478 设置分层导航栏
import java.awt.BorderLayout;
import java.awt.Font;
import java.util.Enumeration;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreePath;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.CENTER);
        
        treeRoot.setRootVisible(false);//不显示树的根节点
        treeRoot.setRowHeight(20);//树节点的行高为20像素
        treeRoot.setFont(new Font("宋体", Font.BOLD, 14));//设置树节点的字体
        treeRoot.putClientProperty("JTree.lineStyle", "None");//节点间不采用连接线
        DefaultTreeCellRenderer treeCellRenderer = (DefaultTreeCellRenderer) treeRoot.getCellRenderer();//获得树节点的绘制对象
        treeCellRenderer.setLeafIcon(null);//设置叶子节点不采用图标
        treeCellRenderer.setClosedIcon(null);//设置节点折叠时不采用图标
        treeCellRenderer.setOpenIcon(null);//设置节点展开时不采用图标
        Enumeration<DefaultMutableTreeNode> enumeration = root.preorderEnumeration();//按前序遍历所有树节点
        while (enumeration.hasMoreElements()) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) enumeration.nextElement();
            if (!node.isLeaf()) {
                TreePath path = new TreePath(node.getPath());
                treeRoot.expandPath(path);
            }
        }
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

18.4.5 维护树模型 P479
//功能有些问题，不太能正常的增加修改和删除？
import java.awt.BorderLayout;
import java.awt.Font;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Enumeration;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.NORTH);
        
        JPanel panel = new JPanel();
        getContentPane().add(panel, BorderLayout.SOUTH);
        
        JTextField textField = new JTextField(10);
        panel.add(textField);
        
        DefaultTreeModel treeModel = new DefaultTreeModel(root);
        
        final JButton addButton = new JButton("添加");
        addButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                DefaultMutableTreeNode node = new DefaultMutableTreeNode(textField.getText());
                TreePath selectionPath = treeRoot.getSelectionPath();
                DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) selectionPath.getLastPathComponent();
                treeModel.insertNodeInto(node, parentNode, parentNode.getChildCount());
                TreePath path = selectionPath.pathByAddingChild(node);
                if (!treeRoot.isVisible(path)) {
                    treeRoot.makeVisible(path);
                }
            }
        });
        panel.add(addButton);
        
        final JButton updButton = new JButton("修改");
        updButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                TreePath selectionPath = treeRoot.getSelectionPath();
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) selectionPath.getLastPathComponent();
                node.setUserObject(textField.getText());
                treeModel.nodeChanged(node);
                treeRoot.setSelectionPath(selectionPath);
            }
        });
        panel.add(updButton);
        
        final JButton delButton = new JButton("删除");
        delButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) treeRoot.getLastSelectedPathComponent();
                if (!node.isRoot()) {
                    DefaultMutableTreeNode nextSelectedNode = node.getNextSibling();
                    if (nextSelectedNode == null) {
                        nextSelectedNode = (DefaultMutableTreeNode) node.getParent();
                        treeModel.removeNodeFromParent(node);
                        treeRoot.setSelectionPath(new TreePath(nextSelectedNode.getPath()));
                    }
                }
            }
        });
        panel.add(delButton);
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

18.4.6 处理展开节点事件 P481
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("根节点");
        DefaultMutableTreeNode nodeFirst = new DefaultMutableTreeNode("一级子节点A");
        root.add(nodeFirst);
        
        DefaultMutableTreeNode nodeSecond = new DefaultMutableTreeNode("二级子节点", false);
        nodeFirst.add(nodeSecond);
        
        root.add(new DefaultMutableTreeNode("一级子节点B"));
        JTree treeRoot = new JTree(root);
        getContentPane().add(treeRoot, BorderLayout.CENTER);
        
        treeRoot.addTreeWillExpandListener(new TreeWillExpandListener() {
            @Override
            public void treeWillExpand(TreeExpansionEvent e) {
                TreePath path = e.getPath();
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                System.out.println("节点\"" + node + "\"将要被展开！");
            }
            
            @Override
            public void treeWillCollapse(TreeExpansionEvent e) {
                TreePath path = e.getPath();
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                System.out.println("节点\"" + node + "\"将要被折叠！");
            }
        });
        
        treeRoot.addTreeExpansionListener(new TreeExpansionListener() {
            @Override
            public void treeExpanded(TreeExpansionEvent e) {
                TreePath path = e.getPath();
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                System.out.println("节点\"" + node + "\"已被展开！");
                System.out.println();
            }
            
            @Override
            public void treeCollapsed(TreeExpansionEvent e) {
                TreePath path = e.getPath();
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                System.out.println("节点\"" + node + "\"已被折叠！");
                System.out.println();
            }
        });
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

18.4.7 范例6：为树节点增加提示信息 P483
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.HashMap;
import java.util.Map;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.ToolTipManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellRenderer;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        JTree tree = new JTree();
        getContentPane().add(tree, BorderLayout.CENTER);
        
        addWindowListener(new WindowListener() {
            @Override
            public void windowOpened(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowIconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeiconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeactivated(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosing(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosed(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowActivated(WindowEvent e) {
                DefaultMutableTreeNode root = new DefaultMutableTreeNode("明日科技新书");
                DefaultMutableTreeNode parent1 = new DefaultMutableTreeNode("从入门到精通系列");
                parent1.add(new DefaultMutableTreeNode("《Java从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《PHP从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual Basic从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual C++从入门到精通》"));
                root.add(parent1);
                
                DefaultMutableTreeNode parent2 = new DefaultMutableTreeNode("编程词典系列");
                parent2.add(new DefaultMutableTreeNode("《Java编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《PHP编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual Basic编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual C++编程词典》"));
                root.add(parent2);
                
                DefaultTreeModel model = new DefaultTreeModel(root);
                tree.setModel(model);
                ToolTipManager.sharedInstance().registerComponent(tree);//为树注册提示信息管理器
                Map<DefaultMutableTreeNode, String> map = new HashMap<DefaultMutableTreeNode, String>();
                map.put(root, "明日科技");
                map.put(parent1, "电子工业");
                map.put(parent2, "人民教育");
                tree.setCellRenderer(new ToolTipNode(map));
            }
        });
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

class ToolTipNode implements TreeCellRenderer {
    private DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
    private Map<DefaultMutableTreeNode, String> map;
    public ToolTipNode(Map<DefaultMutableTreeNode, String> map) {
        this.map = map;
    }
    @Override
    public Component getTreeCellRendererComponent(JTree tree, Object value,
            boolean selected, boolean expanded, boolean leaf, int row,
            boolean hasFocus) {
        renderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
        renderer.setToolTipText("<html><font face=微软雅黑 size=16 color=red>" + map.get(value) + "</font></html>");
        return renderer;
    }
}

18.4.8 范例7：双击编辑树节点功能 P484
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.HashMap;
import java.util.Map;

import javax.swing.DefaultCellEditor;
import javax.swing.JFrame;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.ToolTipManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellEditor;
import javax.swing.tree.TreeCellRenderer;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        JTree tree = new JTree();
        getContentPane().add(tree, BorderLayout.CENTER);
        
        addWindowListener(new WindowListener() {
            @Override
            public void windowOpened(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowIconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeiconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeactivated(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosing(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosed(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowActivated(WindowEvent e) {
                DefaultMutableTreeNode root = new DefaultMutableTreeNode("明日科技新书");
                DefaultMutableTreeNode parent1 = new DefaultMutableTreeNode("从入门到精通系列");
                parent1.add(new DefaultMutableTreeNode("《Java从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《PHP从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual Basic从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual C++从入门到精通》"));
                root.add(parent1);
                
                DefaultMutableTreeNode parent2 = new DefaultMutableTreeNode("编程词典系列");
                parent2.add(new DefaultMutableTreeNode("《Java编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《PHP编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual Basic编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual C++编程词典》"));
                root.add(parent2);
                
                DefaultTreeModel model = new DefaultTreeModel(root);
                tree.setModel(model);
                ToolTipManager.sharedInstance().registerComponent(tree);//为树注册提示信息管理器
                Map<DefaultMutableTreeNode, String> map = new HashMap<DefaultMutableTreeNode, String>();
                map.put(root, "明日科技");
                map.put(parent1, "电子工业");
                map.put(parent2, "人民教育");
                tree.setCellRenderer(new ToolTipNode(map));
                
                JTextField textField = new JTextField();
                textField.setFont(new Font("微软雅黑", Font.PLAIN, 16));
                TreeCellEditor editor = new DefaultCellEditor(textField);
                tree.setEditable(true);
                tree.setCellEditor(editor);
                tree.setShowsRootHandles(true);//如果不设置上根节点的显示手柄，则没有办法将根节点折叠了，因为双击会编辑文本框 P477
            }
        });
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

class ToolTipNode implements TreeCellRenderer {
    private DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
    private Map<DefaultMutableTreeNode, String> map;
    public ToolTipNode(Map<DefaultMutableTreeNode, String> map) {
        this.map = map;
    }
    @Override
    public Component getTreeCellRendererComponent(JTree tree, Object value,
            boolean selected, boolean expanded, boolean leaf, int row,
            boolean hasFocus) {
        renderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
        renderer.setToolTipText("<html><font face=微软雅黑 size=16 color=red>" + map.get(value) + "</font></html>");
        return renderer;
    }
}

18.5.2 经典范例2：监听节点的选择事件 P486
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Font;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.HashMap;
import java.util.Map;

import javax.swing.DefaultCellEditor;
import javax.swing.JFrame;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.ToolTipManager;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellEditor;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;

public class TreeTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TreeTest() {
        JTree tree = new JTree();
        getContentPane().add(tree, BorderLayout.WEST);
        
        JTextArea textArea = new JTextArea(20, 20);
        getContentPane().add(textArea, BorderLayout.EAST);
        
        addWindowListener(new WindowListener() {
            @Override
            public void windowOpened(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowIconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeiconified(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowDeactivated(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosing(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowClosed(WindowEvent arg0) {
                // TODO Auto-generated method stub
                
            }
            
            @Override
            public void windowActivated(WindowEvent e) {
                DefaultMutableTreeNode root = new DefaultMutableTreeNode("明日科技新书");
                DefaultMutableTreeNode parent1 = new DefaultMutableTreeNode("从入门到精通系列");
                parent1.add(new DefaultMutableTreeNode("《Java从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《PHP从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual Basic从入门到精通》"));
                parent1.add(new DefaultMutableTreeNode("《Visual C++从入门到精通》"));
                root.add(parent1);
                
                DefaultMutableTreeNode parent2 = new DefaultMutableTreeNode("编程词典系列");
                parent2.add(new DefaultMutableTreeNode("《Java编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《PHP编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual Basic编程词典》"));
                parent2.add(new DefaultMutableTreeNode("《Visual C++编程词典》"));
                root.add(parent2);
                
                DefaultTreeModel model = new DefaultTreeModel(root);
                tree.setModel(model);
                ToolTipManager.sharedInstance().registerComponent(tree);//为树注册提示信息管理器
                Map<DefaultMutableTreeNode, String> map = new HashMap<DefaultMutableTreeNode, String>();
                map.put(root, "明日科技");
                map.put(parent1, "电子工业");
                map.put(parent2, "人民教育");
                tree.setCellRenderer(new ToolTipNode(map));
                
                JTextField textField = new JTextField();
                textField.setFont(new Font("微软雅黑", Font.PLAIN, 16));
                TreeCellEditor editor = new DefaultCellEditor(textField);
                tree.setEditable(true);
                tree.setCellEditor(editor);
                tree.setShowsRootHandles(true);//如果不设置上根节点的显示手柄，则没有办法将根节点折叠了，因为双击会编辑文本框 P477
                
                tree.addTreeSelectionListener(new TreeSelectionListener() {
                    @Override
                    public void valueChanged(TreeSelectionEvent e) {
                        TreePath path = tree.getSelectionPath();
                        if (path == null) {
                            return;
                        }
                        
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                        String text1 = "《Java从入门到精通》\n《PHP从入门到精通》\n《Visual Basic从入门到精通》\n《Visual C++从入门到精通》";
                        String text2 = "《Java编程词典》\n《PHP编程词典》\n《Visual Basic编程词典》\n《Visual C++编程词典》";
                        
                        if (node.toString().equals(parent1.toString())) {
                            textArea.setText(text1);
                        } else if (node.toString().equals(parent2.toString())) {
                            textArea.setText(text2);
                        }
                    }
                });
            }
        });
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new TreeTest();
    }
}

class ToolTipNode implements TreeCellRenderer {
    private DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
    private Map<DefaultMutableTreeNode, String> map;
    public ToolTipNode(Map<DefaultMutableTreeNode, String> map) {
        this.map = map;
    }
    @Override
    public Component getTreeCellRendererComponent(JTree tree, Object value,
            boolean selected, boolean expanded, boolean leaf, int row,
            boolean hasFocus) {
        renderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
        renderer.setToolTipText("<html><font face=微软雅黑 size=16 color=red>" + map.get(value) + "</font></html>");
        return renderer;
    }
}
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第19章 高级布局管理器 P488
19.1 箱式布局管理器 P489
import java.awt.BorderLayout;

import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;


public class BoxTest extends JFrame {
    private static final long serialVersionUID = 1L;

    public BoxTest() {
        Box topicBox = Box.createHorizontalBox();
        getContentPane().add(topicBox, BorderLayout.NORTH);
        topicBox.add(Box.createHorizontalStrut(5));//添加一个5像素宽的水平支柱
        JLabel topicLabel = new JLabel("主题：");
        topicBox.add(topicLabel);
        topicBox.add(Box.createHorizontalStrut(5));
        JTextField topicTextField = new JTextField(30);
        topicBox.add(topicTextField);
        
        //以下内容都由垂直box控制
        Box box = Box.createVerticalBox();
        getContentPane().add(box, BorderLayout.CENTER);
        box.add(Box.createVerticalStrut(5));
        
        Box contentBox = Box.createHorizontalBox();
        contentBox.setAlignmentX(1);//设置组件的水平调整值，靠右侧对齐；0是靠左侧对齐
        box.add(contentBox);
        
        contentBox.add(Box.createHorizontalStrut(5));//createHorizontalGlue()可以试下效果
        
        JLabel contentLabel = new JLabel("内容：");
        contentLabel.setAlignmentY(0);
        contentBox.add(contentLabel);
        contentBox.add(Box.createHorizontalStrut(5));
        
        JScrollPane scrollPane = new JScrollPane();
        scrollPane.setAlignmentY(0);
        contentBox.add(scrollPane);
        
        JTextArea contentTextArea = new JTextArea();
        scrollPane.setViewportView(contentTextArea);
        box.add(Box.createVerticalStrut(5));
        JButton submitButton = new JButton("确定");
        submitButton.setAlignmentX(1);
        box.add(submitButton);
        
        setSize(500, 600);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
    public static void main(String args[]) {
        new BoxTest();
    }
}

19.2 卡片布局管理器 P491
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class CardLayoutTest extends JFrame {
    private static final long serialVersionUID = 1L;
    private JPanel cardPanel;
    private CardLayout cardLayout;
    
    
    public CardLayoutTest() {
        super();
        setTitle("使用卡片布局管理器");
        setBounds(100, 100, 600, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);//创建一个采用卡片布局管理器的面板对象
        getContentPane().add(cardPanel, BorderLayout.CENTER);
        String labelNames[] = {"Card A", "Card B", "Card C"};
        for (int i = 0; i < labelNames.length; ++i) {
            final JLabel label = new JLabel(labelNames[i]);
            cardPanel.add(label, labelNames[i]);//向采用卡片布局管理器的面板中添加卡片
        }
        
        final JPanel buttonPanel = new JPanel();
        getContentPane().add(buttonPanel, BorderLayout.SOUTH);
        String buttonNames[] = {"First", "Previous", "Card A", "Card B", "Card C", "Next", "Last"};
        for (int i = 0; i < buttonNames.length; ++i) {
            final JButton button = new JButton(buttonNames[i]);
            button.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    String buttonText = button.getText();
                    if (buttonText.equals(buttonNames[0])) {
                        cardLayout.first(cardPanel);
                    }
                    else if (buttonText.equals(buttonNames[1])) {
                        cardLayout.previous(cardPanel);
                    }
                    else if (buttonText.equals(buttonNames[2])) {
                        cardLayout.show(cardPanel, buttonNames[2]);
                    }
                    else if (buttonText.equals(buttonNames[3])) {
                        cardLayout.show(cardPanel, buttonNames[3]);
                    }
                    else if (buttonText.equals(buttonNames[4])) {
                        cardLayout.show(cardPanel, buttonNames[4]);
                    }
                    else if (buttonText.equals(buttonNames[5])) {
                        cardLayout.next(cardPanel);
                    }
                    else {
                        cardLayout.last(cardPanel);
                    }
                }
            });
            buttonPanel.add(button);
        }
    }
    
    public static void main(String args[]) {
        new CardLayoutTest();
    }
}

19.3 网格组布局管理器 P493
//ExampleFrame_11.java
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;

public class ExampleFrame_11 extends JFrame {
    
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public static void main(String args[]) {
        ExampleFrame_11 frame = new ExampleFrame_11();
        frame.setVisible(true);
    }
    
    public ExampleFrame_11() {
        super();
        getContentPane().setLayout(new GridBagLayout());
        setTitle("使用进度条");
        setBounds(100, 100, 500, 375);
        setBounds(100, 100, 266, 132);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        final JLabel label = new JLabel();
        label.setForeground(new Color(255, 0, 0));
        label.setFont(new Font("", Font.BOLD, 16));
        label.setText("欢迎使用在线升级功能！");
        final GridBagConstraints gridBagConstraints = new GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridx = 0;
        getContentPane().add(label, gridBagConstraints);
        
        final JProgressBar progressBar = new JProgressBar();// 创建进度条对象
        progressBar.setStringPainted(true);// 设置显示提示信息
        progressBar.setIndeterminate(true);// 设置采用不确定进度条
        progressBar.setString("升级进行中......");// 设置提示信息
        final GridBagConstraints gridBagConstraints_1 = new GridBagConstraints();
        gridBagConstraints_1.insets = new Insets(5, 0, 0, 0);
        gridBagConstraints_1.gridy = 1;
        gridBagConstraints_1.gridx = 0;
        getContentPane().add(progressBar, gridBagConstraints_1);
        
        final JButton button = new JButton();
        button.setText("完成");
        button.setEnabled(false);
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });
        final GridBagConstraints gridBagConstraints_2 = new GridBagConstraints();
        gridBagConstraints_2.insets = new Insets(5, 0, 0, 0);
        gridBagConstraints_2.gridy = 2;
        gridBagConstraints_2.gridx = 1;
        getContentPane().add(button, gridBagConstraints_2);
        new Progress(progressBar, button).start();// 利用线程模拟一个在线升级任务
    }
    
    class Progress extends Thread {// 利用线程模拟一个在线升级任务
        private final int[] progressValue = { 6, 18, 27, 39, 51, 66, 81,
                100 };// 模拟任务完成百分比
        private JProgressBar progressBar;// 进度条对象
        private JButton button;// 完成按钮对象
        
        public Progress(JProgressBar progressBar, JButton button) {
            this.progressBar = progressBar;
            this.button = button;
        }
        
        public void run() {
            // 通过循环更新任务完成百分比
            for (int i = 0; i < progressValue.length; i++) {
                try {
                    Thread.sleep(1000);// 令线程休眠1秒
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                progressBar.setValue(progressValue[i]);// 设置任务完成百分比
            }
            progressBar.setIndeterminate(false);// 设置采用确定进度条
            progressBar.setString("升级完成！");// 设置提示信息
            button.setEnabled(true);// 设置按钮可用
        }
    }
}

//网格组件管理器P499，这么一个一个设置感觉效率很低？
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;

import javax.swing.JButton;
import javax.swing.JFrame;

public class GridBagLayoutTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public GridBagLayoutTest() {
        super();
        setTitle("使用网格布局管理器");
        setBounds(100, 100, 600, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        getContentPane().setLayout(new GridBagLayout());
        
        final JButton button = new JButton("A");
        final GridBagConstraints gridBagConstraints = new GridBagConstraints();
        gridBagConstraints.gridy = 0;//起始点为第1行
        gridBagConstraints.gridx = 0;//起始点为第1列
        //gridBagConstraints.insets = new Insets(0, 5, 0, 0);//设置组件左侧的最小距离
        gridBagConstraints.weightx = 10;//第1列的分布方式为10%
        gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;
        getContentPane().add(button, gridBagConstraints);
        
        final JButton button_1 = new JButton("B");
        final GridBagConstraints gridBagConstraints_1 = new GridBagConstraints();
        gridBagConstraints_1.gridy = 0;
        gridBagConstraints_1.gridx = 1;
        gridBagConstraints_1.insets = new Insets(0, 5, 0, 0);//设置组件左侧的最小距离
        gridBagConstraints_1.weightx = 20;//第1列的分布方式为20%
        gridBagConstraints_1.fill = GridBagConstraints.HORIZONTAL;
        getContentPane().add(button_1, gridBagConstraints_1);
        
        final JButton button_2 = new JButton("C");
        final GridBagConstraints gridBagConstraints_2 = new GridBagConstraints();
        gridBagConstraints_2.gridy = 0;
        gridBagConstraints_2.gridx = 2;
        gridBagConstraints_2.gridheight = 2;//组件占用两行
        gridBagConstraints_2.insets = new Insets(0, 5, 0, 0);
        gridBagConstraints_2.weightx = 30;//第1列的分布方式 为30%
        gridBagConstraints_2.fill = GridBagConstraints.BOTH;//同时调整组件的宽度和高度
        getContentPane().add(button_2, gridBagConstraints_2);
        
        final JButton button_3 = new JButton("D");
        final GridBagConstraints gridBagConstraints_3 = new GridBagConstraints();
        gridBagConstraints_3.gridy = 0;
        gridBagConstraints_3.gridx = 3;
        gridBagConstraints_3.gridheight = 4;//组件占用四行
        gridBagConstraints_3.insets = new Insets(0, 5, 0, 5);//设置组件左侧和右侧的最小距离
        gridBagConstraints_3.weightx = 40;//第1列的分布方式 为40%
        gridBagConstraints_3.fill = GridBagConstraints.BOTH;//同时调整组件的宽度和高度
        getContentPane().add(button_3, gridBagConstraints_3);
        
        final JButton button_4 = new JButton("E");
        final GridBagConstraints gridBagConstraints_4 = new GridBagConstraints();
        gridBagConstraints_4.gridy = 1;
        gridBagConstraints_4.gridx = 0;
        gridBagConstraints_4.gridwidth = 2;//组件占用两列
        gridBagConstraints_4.insets = new Insets(5, 0, 0, 0);//设置组件左侧和右侧的最小距离
        gridBagConstraints_4.fill = GridBagConstraints.HORIZONTAL;//同时调整组件的宽度和高度
        getContentPane().add(button_4, gridBagConstraints_4);
        
        final JButton button_5 = new JButton("F");
        final GridBagConstraints gridBagConstraints_5 = new GridBagConstraints();
        gridBagConstraints_5.gridy = 2;
        gridBagConstraints_5.gridx = 0;
        gridBagConstraints_5.insets = new Insets(5, 0, 0, 0);//设置组件左侧和右侧的最小距离
        gridBagConstraints_5.fill = GridBagConstraints.HORIZONTAL;//同时调整组件的宽度
        getContentPane().add(button_5, gridBagConstraints_5);
        
        final JButton button_6 = new JButton("G");
        final GridBagConstraints gridBagConstraints_6 = new GridBagConstraints();
        gridBagConstraints_6.gridy = 2;
        gridBagConstraints_6.gridx = 1;
        gridBagConstraints_6.gridwidth = 2;//组件占用两列
        gridBagConstraints_6.gridheight = 2;//组件占用两行
        gridBagConstraints_6.insets = new Insets(5, 5, 0, 0);//设置组件左侧和右侧的最小距离
        gridBagConstraints_6.fill = GridBagConstraints.BOTH;//同时调整组件的宽度和高度
        getContentPane().add(button_6, gridBagConstraints_6);
        
//        final JButton button_6 = new JButton("G");
//        final GridBagConstraints gridBagConstraints_6 = new GridBagConstraints();
//        gridBagConstraints_6.gridy = 2;
//        gridBagConstraints_6.gridx = 1;
//        gridBagConstraints_6.gridwidth = 2;//组件占用两列
//        gridBagConstraints_6.gridheight = 2;//组件占用两行
//        gridBagConstraints_6.insets = new Insets(5, 5, 0, 0);//设置组件上侧和右侧的最小距离
//        gridBagConstraints_6.fill = GridBagConstraints.VERTICAL;//同时调整组件的宽度和高度
//        gridBagConstraints_6.ipadx = 30;//增加组件的首选宽度，在默认基础上宽度增加value值，可以为负
//        gridBagConstraints_6.anchor = GridBagConstraints.EAST;//显示在东方
//        getContentPane().add(button_6, gridBagConstraints_6);
        
        final JButton button_7 = new JButton("G");
        final GridBagConstraints gridBagConstraints_7 = new GridBagConstraints();
        gridBagConstraints_7.gridy = 3;
        gridBagConstraints_7.gridx = 0;
        gridBagConstraints_7.insets = new Insets(5, 0, 0, 0);//设置组件左侧和右侧的最小距离
        gridBagConstraints_7.fill = GridBagConstraints.HORIZONTAL;//同时调整组件的宽度和高度
        getContentPane().add(button_7, gridBagConstraints_7);
    }
    
    public static void main(String args[]) {
        new GridBagLayoutTest();
    }
}


19.4 弹簧布局管理器 P499
import java.awt.Container;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SpringLayout;

public class SpringLayoutTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public SpringLayoutTest() {
        super();
        setTitle("使用弹簧布局管理器");
        setBounds(100, 100, 600, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        SpringLayout springLayout = new SpringLayout();
        Container contentPane = getContentPane();
        contentPane.setLayout(springLayout);//修改窗体容器为采用弹簧布局管理器
        
        JLabel topicLabel = new JLabel("主题：");
        contentPane.add(topicLabel);
        springLayout.putConstraint(SpringLayout.NORTH, topicLabel, 5, SpringLayout.NORTH, contentPane);//主题标签北侧->容器北侧
        springLayout.putConstraint(SpringLayout.WEST, topicLabel, 5, SpringLayout.WEST, contentPane);//主题标签西侧->容器西侧
        
        JTextField topicTextField = new JTextField();
        contentPane.add(topicTextField);
        //几个入参数理解为第一个对象(para2)的哪一侧(para1)到第二个对象(p5)的哪一侧(p4)的距离(正数为->，负数为<-)
        springLayout.putConstraint(SpringLayout.NORTH, topicTextField, 5, SpringLayout.NORTH, contentPane);//主题文本框北侧->容器北侧
        springLayout.putConstraint(SpringLayout.WEST, topicTextField, 5, SpringLayout.EAST, topicLabel);//主题文本框西侧->容器西侧
        springLayout.putConstraint(SpringLayout.EAST, topicTextField, -5, SpringLayout.EAST, contentPane);//主题文本框东侧->容器东侧
        
        JLabel contentLabel = new JLabel("内容：");
        contentPane.add(contentLabel);
        springLayout.putConstraint(SpringLayout.NORTH, contentLabel, 5, SpringLayout.SOUTH, topicTextField);
        springLayout.putConstraint(SpringLayout.WEST, contentLabel, 5, SpringLayout.WEST, contentPane);
        
        JScrollPane contentScrollPane = new JScrollPane();
        contentScrollPane.setViewportView(new JTextArea());
        contentPane.add(contentScrollPane);
        springLayout.putConstraint(SpringLayout.NORTH, contentScrollPane, 5, SpringLayout.SOUTH, topicTextField);
        springLayout.putConstraint(SpringLayout.WEST, contentScrollPane, 5, SpringLayout.EAST, contentLabel);
        springLayout.putConstraint(SpringLayout.EAST, contentScrollPane, -5, SpringLayout.EAST, contentPane);
        
        JButton resetButton = new JButton("清空");
        contentPane.add(resetButton);
        springLayout.putConstraint(SpringLayout.SOUTH, resetButton, -5, SpringLayout.SOUTH, contentPane);
        
        JButton submitButton = new JButton("确定");
        contentPane.add(submitButton);
        springLayout.putConstraint(SpringLayout.SOUTH, submitButton, -5, SpringLayout.SOUTH, contentPane);
        springLayout.putConstraint(SpringLayout.EAST, submitButton, -5, SpringLayout.EAST, contentPane);
        springLayout.putConstraint(SpringLayout.SOUTH, contentScrollPane, -5, SpringLayout.NORTH, submitButton);
        springLayout.putConstraint(SpringLayout.EAST, resetButton, -5, SpringLayout.WEST, submitButton);//如果不加这句话，则resetButton将会默认贴在左侧。如果-5错写成5，则会使两个组件相贴
        //改为下句将使清空按钮贴在左侧，确定按钮拉长至整个宽度
        //springLayout.putConstraint(SpringLayout.WEST, submitButton, 5, SpringLayout.EAST, resetButton);//如果不加这句话，则resetButton将会默认贴在左侧
        
        validate();//不加这句话无法刷新出来
    }
    
    public static void main(String args[]) {
        new SpringLayoutTest();
    }
}

19.4.2 使用弹簧和支柱 P502

import java.awt.Container;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.Spring;
import javax.swing.SpringLayout;

public class SpringLayoutTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public SpringLayoutTest() {
        super();
        setTitle("使用弹簧布局管理器");
        setBounds(100, 100, 600, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        SpringLayout springLayout = new SpringLayout();
        Container contentPane = getContentPane();
        contentPane.setLayout(springLayout);//修改窗体容器为采用弹簧布局管理器
        
        Spring vST = Spring.constant(20);//创建一个支柱
        Spring hSP = Spring.constant(20, 100, 500);//创建一个弹簧
        
        JButton lButton = new JButton("按钮L");
        contentPane.add(lButton);
        springLayout.putConstraint(SpringLayout.NORTH, lButton, vST, SpringLayout.NORTH, contentPane);
        springLayout.putConstraint(SpringLayout.WEST, lButton, hSP, SpringLayout.WEST, contentPane);
        
        JButton rButton = new JButton("按钮R");
        contentPane.add(rButton);
        springLayout.putConstraint(SpringLayout.NORTH, rButton, 0, SpringLayout.NORTH, lButton);//该语句表示rButton与lButton到北侧的距离一致，如果不设置，则rButton将会紧贴北侧
        springLayout.putConstraint(SpringLayout.EAST, rButton, Spring.scale(hSP, 10), SpringLayout.EAST, lButton);//中间距离按边距的两倍拉伸
        springLayout.putConstraint(SpringLayout.EAST, contentPane, hSP, SpringLayout.EAST, rButton);
    }
    
    public static void main(String args[]) {
        new SpringLayoutTest();
    }
}

19.4.3 利用弹簧控制组件大小 P503
import java.awt.Container;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.Spring;
import javax.swing.SpringLayout;
import javax.swing.SpringLayout.Constraints;

public class SpringLayoutTest extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public SpringLayoutTest() {
        super();
        setTitle("使用弹簧布局管理器");
        setBounds(100, 100, 600, 400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        SpringLayout springLayout = new SpringLayout();
        Container contentPane = getContentPane();
        contentPane.setLayout(springLayout);//修改窗体容器为采用弹簧布局管理器
        
        Spring vST = Spring.constant(20);//创建一个支柱
        Spring hSP = Spring.constant(20, 100, 500);//创建一个弹簧
        
        JButton lButton = new JButton("按钮L");
        contentPane.add(lButton);
        springLayout.putConstraint(SpringLayout.NORTH, lButton, vST, SpringLayout.NORTH, contentPane);
        springLayout.putConstraint(SpringLayout.WEST, lButton, hSP, SpringLayout.WEST, contentPane);
        
        JButton rButton = new JButton("按钮R");
        contentPane.add(rButton);
        springLayout.putConstraint(SpringLayout.NORTH, rButton, 0, SpringLayout.NORTH, lButton);//该语句表示rButton与lButton到北侧的距离一致，如果不设置，则rButton将会紧贴北侧
        springLayout.putConstraint(SpringLayout.EAST, rButton, Spring.scale(hSP, 10), SpringLayout.EAST, lButton);//中间距离按边距的两倍拉伸
        springLayout.putConstraint(SpringLayout.EAST, contentPane, hSP, SpringLayout.EAST, rButton);
        
        //用弹簧和支柱分别可以设置按钮为宽度可拉伸，高度不变
        Spring widthSP = Spring.constant(60, 300, 600);//创建一个弹簧
        Spring heightST = Spring.constant(60);//创建一个支柱
        
        Constraints lButtonCons = springLayout.getConstraints(lButton);//获取“按钮L”的Constraints对象
        lButtonCons.setWidth(widthSP);//设置控制组件宽度的弹簧
        lButtonCons.setHeight(heightST);//设置控制组件高度的支柱
        
        Constraints rButtonCons = springLayout.getConstraints(rButton);//获取“按钮R”的Constraints对象
        rButtonCons.setWidth(widthSP);
        rButtonCons.setHeight(heightST);
    }
    
    public static void main(String args[]) {
        new SpringLayoutTest();
    }
}

19.5.1 制作圆形布局管理器 P504

19.5.1 制作阶梯布局管理器 P505
//------------------------------------------------------------------------------------------------
//Java从入门到精通 第20章 高级布局管理器 P488 AWT绘图技术 P508
20.1.1 Graphics
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawCircle extends JFrame {
    private static final long serialVersionUID = 1L;
    private final int OVAL_WIDTH = 80;
    private final int OVAL_HEIGHT = 80;
    
    public DrawCircle() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(300, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setContentPane(new DrawPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new DrawCircle().setVisible(true);;
    }
    
    class DrawPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            super.paint(g);
            g.drawOval(10, 10, OVAL_WIDTH, OVAL_HEIGHT);
            g.drawOval(80, 10, OVAL_WIDTH, OVAL_HEIGHT);
            g.drawOval(150, 10, OVAL_WIDTH, OVAL_HEIGHT);
            g.drawOval(50, 70, OVAL_WIDTH, OVAL_HEIGHT);
            g.drawOval(120, 70, OVAL_WIDTH, OVAL_HEIGHT);//g.fillOval(120, 70, OVAL_WIDTH, OVAL_HEIGHT);//实心椭圆
        }
    }
}

Graphics类常用的图形绘制方法 P510

20.1.2 Graphics2D P511
Graphics2D继承Graphics类，实现了功能更强大的绘图操作的集合。
Graphics2D是推荐使用的绘图类，但是程序设计中提供的绘图对象大多是Graphics类的实例对象，这时应该使用强制类型转换将其转换为Graphics2D类型。
例如：
public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;//强制畸形转换为Graphics2D类型
    g2.……
}

P512
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public DrawFrame() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(300, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new CanvasPanel());
        this.setTitle("绘图实例2");
    }
    
    public static void main(String args[]) {
        new DrawFrame().setVisible(true);;
    }
    
    class CanvasPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            super.paint(g);
            Graphics2D g2 = (Graphics2D) g;
            Shape shapes[] = new Shape[4];
            shapes[0] = new Ellipse2D.Double(5, 5, 100, 100);//圆形，前两个参数分别为中心坐标，后两个参数为长短轴值，一样则为圆，不一样则为椭圆
            shapes[1] = new Rectangle2D.Double(110, 5, 100, 100);//矩形
            shapes[2] = new Rectangle2D.Double(15, 15, 80, 80);//矩形
            shapes[3] = new Ellipse2D.Double(120, 15, 80, 80);//圆形
            for (Shape shape : shapes) { //遍历图形数组
                Rectangle2D bounds = shape.getBounds2D();
                if (bounds.getWidth() == 80) {
                    g2.fill(shape);
                }
                else {
                    g2.draw(shape);
                }
            }
        }
    }
}

20.1.3 绘制指定角度的填充扇形 P513
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawSector extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public DrawSector() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(300, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setContentPane(new DrawSectorPanel());//add(new DrawSectorPanel());效果一样
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new DrawSector().setVisible(true);;
    }
    
    class DrawSectorPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            //super.paint(g);
            g.fillArc(40, 20, 80, 80, 0, 150);//6个参数分别为：坐标x，坐标y，width，height，起始角度，角度范围
            g.fillArc(140, 20, 80, 80, 180, -150);
            g.fillArc(40, 40, 80, 80, 0, -110);
            g.fillArc(140, 40, 80, 80, 180, 110);
        }
    }
}

20.1.4 绘制多边形 P513
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawSector extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public DrawSector() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new DrawPolygonPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new DrawSector().setVisible(true);;
    }
    
    class DrawPolygonPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            int x1[] = {100, 120, 180, 140, 150, 100, 50, 60, 20, 80};//多边形的横坐标，各个拐点的坐标位置
            int y1[] = {20, 85, 90, 120, 180, 140, 180, 120, 90, 85};//多边形的纵坐标
            int n1 = 10;//多边形的边数，与两个数组个数匹配上的
            g.fillPolygon(x1, y1, n1);//五角形

            //g.setColor(Color.RED);设置颜色为红色，包括填充颜色和边框颜色，之后都是这个颜色，除非再次setColor设置
            
            int x2[] = {210, 270, 310, 270, 210, 170};
            int y2[] = {20, 20, 65, 110, 110, 65};
            int n2 = 6;
            g.fillPolygon(x2, y2, n2);
            
            int x3[] = {180, 220, 260, 240, 260, 220, 180, 200};
            int y3[] = {120, 140, 120, 160, 200, 180, 200, 160};
            int n3 = 8;
            g.drawPolygon(x3, y3, n3);
        }
    }
}

20.2 绘图颜色与笔画属性 P514
20.2.3 为图形填充渐变色 P517
import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawSector extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public DrawSector() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new FillGradientPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new DrawSector().setVisible(true);;
    }
    
    class FillGradientPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            Rectangle2D.Float rect = new Rectangle2D.Float(20, 20, 280, 140);
            GradientPaint paint = new GradientPaint(20, 20, Color.BLUE, 100, 80, Color.RED, true);
            g2.setPaint(paint);
            g2.fill(rect);
        }
    }
}

20.2.4 设置笔画的粗细 P517
import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawSector extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public DrawSector() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new ChangeStrokeWidthPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new DrawSector().setVisible(true);;
    }
    
    class ChangeStrokeWidthPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            
            BasicStroke stroke = new BasicStroke(1);//宽度为1的笔画对象
            g2.setStroke(stroke);
            Ellipse2D.Float ellipse = new Ellipse2D.Float(20, 20, 100, 60);
            g2.draw(ellipse);
            
            stroke = new BasicStroke(4);
            g2.setStroke(stroke);
            ellipse = new Ellipse2D.Float(160, 20, 100, 60);
            g2.draw(ellipse);
            
            stroke = new BasicStroke(6);
            g2.setStroke(stroke);
            ellipse = new Ellipse2D.Float(20, 100, 100, 60);
            g2.draw(ellipse);
            
            stroke = new BasicStroke(8);
            g2.setStroke(stroke);
            ellipse = new Ellipse2D.Float(160, 100, 100, 60);
            g2.draw(ellipse);
            
        }
    }
}

20.3 绘制文本 P518

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Rectangle2D;
import java.util.Date;

import javax.swing.JFrame;

public class DrawString extends JFrame {
    private static final long serialVersionUID = 1L;
    private Shape rect;
    private Font font;
    private Date date;
    
    public DrawString() {
        rect = new Rectangle2D.Double(10, 10, 200, 80);
        font = new Font("宋体", Font.BOLD, 16);
        date = new Date();
        
        this.setSize(230, 140);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new CanvasPanel());
    }
    
    public static void main(String args[]) {
        new DrawString().setVisible(true);;
    }
    
    class CanvasPanel extends Canvas {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            super.paint(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.setColor(Color.CYAN);
            g2.fill(rect);
            g2.setColor(Color.BLUE);
            g2.setFont(font);
            g2.drawString("现在时间是", 20, 30);
            g2.drawString(String.format("%tr", date), 50, 60);
        }
    }
}

20.3.3 设置文本的字体 P520
import java.awt.Font;
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class TextFontFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TextFontFrame() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new ChangeTextFontPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new TextFontFrame().setVisible(true);;
    }
    
    class ChangeTextFontPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            String value = "明日编程词典社区";
            int x = 40;
            int y = 50;
            Font font = new Font("华文行楷", Font.BOLD + Font.ITALIC, 26);
            g.setFont(font);
            g.drawString(value, x, y);
            
            value = "http://community.mrbccd.com";
            x = 10;
            y = 100;
            font = new Font("宋体", Font.BOLD, 20);
            g.setFont(font);
            g.drawString(value, x, y);
        }
    }
}


20.3.4 设置文本的图形和颜色 P521
import java.awt.Color;
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class TextFontFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    
    public TextFontFrame() {
        super();
        initialize();
    }
    
    private void initialize() {
        this.setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new TextAndShapeColorPanel());
        this.setTitle("绘图实例");
    }
    
    public static void main(String args[]) {
        new TextFontFrame().setVisible(true);;
    }
    
    class TextAndShapeColorPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            String value = "只要努力――――";
            int x = 60;
            int y = 60;
            Color color = new Color(255, 0, 0);
            g.setColor(color);
            g.drawString(value, x, y);
            
            value = "一切皆有可能";
            x = 140;
            y = 100;
            color = new Color(0, 0, 255);
            g.setColor(color);
            g.drawString(value, x, y);
            
            color = Color.ORANGE;
            g.setColor(color);
            g.drawRoundRect(40, 30, 200, 100, 40, 30);//外圈
            g.drawRoundRect(45, 35, 190, 90, 36, 26);//内圈
        }
    }
}


20.4 图片处理 P522

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.net.URL;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class DrawImage extends JFrame {
    private static final long serialVersionUID = 1L;
    Image img;
    
    public DrawImage() {
        super();
        initialize();
        
        URL imaUrl = DrawImage.class.getResource("sjtu.jpg");
        img = Toolkit.getDefaultToolkit().getImage(imaUrl);
    }
    
    private void initialize() {
        this.setSize(800, 500);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        add(new CanvasPanel());
        this.setTitle("绘制图片");
    }
    
    public static void main(String args[]) {
        new DrawImage().setVisible(true);;
    }
    
    class CanvasPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paint(Graphics g) {
            super.paint(g);
            Graphics2D g2 = (Graphics2D) g;
            g2.drawImage(img, 0, 0, this);//四个参数：要显示的图片对象，水平位置，垂直位置，要通知的图像观察者
        }
    }
}

20.4.2 放大与缩小 P523

import java.awt.*;
import java.net.*;
import javax.swing.*;
public class ImageZoom extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    Image img;
    private JPanel contentPanel = null;
    private JSlider jSlider = null;
    private int imgWidth, imgHeight;
    private Canvas canvas = null;
    public ImageZoom() {
        initialize(); // 调用初始化方法
    }
    // 界面初始化方法
    private void initialize() {
        URL imgUrl = ImageZoom.class.getResource("sjtu.jpg");// 获取图片资源的路径
        img = Toolkit.getDefaultToolkit().getImage(imgUrl);// 获取图片资源
        canvas = new MyCanvas();
        this.setBounds(100, 100, 800, 600); // 设置窗体大小和位置
        this.setContentPane(getContentPanel()); // 设置内容面板
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("绘制图片"); // 设置窗体标题
    }
    // 内容面板的布局
    private JPanel getContentPanel() { //这是新写的方法，与JFrame的getContentPane()不一样
        if (contentPanel == null) {
            contentPanel = new JPanel();
            contentPanel.setLayout(new BorderLayout());
            contentPanel.add(getJSlider(), BorderLayout.SOUTH);
            contentPanel.add(canvas, BorderLayout.CENTER);
        }
        return contentPanel;
    }
    // 获取滑块组件
    private JSlider getJSlider() {
        if (jSlider == null) {
            jSlider = new JSlider();
            jSlider.setMaximum(1000);
            jSlider.setValue(100);
            jSlider.setMinimum(1);
            jSlider.addChangeListener(new javax.swing.event.ChangeListener() {
                public void stateChanged(javax.swing.event.ChangeEvent e) {
                    canvas.repaint();//将调用paint()方法
                }
            });
        }
        return jSlider;
    }
    // 主方法
    public static void main(String[] args) {
        new ImageZoom().setVisible(true);
    }
    // 画板类
    class MyCanvas extends Canvas {
        /**
         * 
         */
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            int newW = 0, newH = 0;
            imgWidth = img.getWidth(this); // 获取图片宽度
            imgHeight = img.getHeight(this); // 获取图片高度
            float value = jSlider.getValue();// 滑块组件的取值
            newW = (int) (imgWidth * value / 100);// 计算图片放大后的宽度
            newH = (int) (imgHeight * value / 100);// 计算图片放大后的高度
            g.drawImage(img, 0, 0, newW, newH, this);// 绘制指定大小的图片
        }
    }
}

repaint()方法将调用paint()方法，实现组件或画板的重画功能，类似于界面刷新

20.4.3 图片翻转 P525

import java.awt.*;
import java.net.URL;
import javax.swing.*;

public class PartImage extends JFrame {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    private Image img;
    private int dx1, dy1, dx2, dy2;
    private int sx1, sy1, sx2, sy2;
    private JPanel jPanel = null;
    private JPanel jPanel1 = null;
    private JButton jButton = null;
    private JButton jButton1 = null;
    private MyCanvas canvasPanel = null;
    
    private final int MaxWidth = 600;
    private final int MaxHeight = 400;
    
    public PartImage() {
        dx2 = sx2 = MaxWidth; // 初始化图像大小
        dy2 = sy2 = MaxHeight;
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        URL imgUrl = PartImage.class.getResource("sjtu.jpg");// 获取图片资源的路径
        img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源
        this.setBounds(100, 100, MaxWidth, MaxHeight + 60); // 设置窗体大小和位置
        this.setContentPane(getJPanel());
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("图片翻转"); // 设置窗体标题
    }
    
    // 获取内容面板的方法
    private JPanel getJPanel() {
        if (jPanel == null) {
            jPanel = new JPanel();
            jPanel.setLayout(new BorderLayout());
            jPanel.add(getControlPanel(), BorderLayout.SOUTH);
            jPanel.add(getMyCanvas1(), BorderLayout.CENTER);
        }
        return jPanel;
    }
    
    // 获取按钮控制面板的方法
    private JPanel getControlPanel() {
        if (jPanel1 == null) {
            GridBagConstraints gridBagConstraints = new GridBagConstraints();
            gridBagConstraints.gridx = 1;
            gridBagConstraints.gridy = 0;
            jPanel1 = new JPanel();
            jPanel1.setLayout(new GridBagLayout());
            jPanel1.add(getJButton(), new GridBagConstraints());
            jPanel1.add(getJButton1(), gridBagConstraints);
        }
        return jPanel1;
    }
    
    // 获取水平翻转按钮
    private JButton getJButton() {
        if (jButton == null) {
            jButton = new JButton();
            jButton.setText("水平翻转");
            jButton.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e) {
                    sx1 = Math.abs(sx1 - MaxWidth);
                    sx2 = Math.abs(sx2 - MaxWidth);
                    canvasPanel.repaint();
                }
            });
        }
        return jButton;
    }
    
    // 获取垂直翻转按钮
    private JButton getJButton1() {
        if (jButton1 == null) {
            jButton1 = new JButton();
            jButton1.setText("垂直翻转");
            jButton1.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e) {
                    sy1 = Math.abs(sy1 - MaxHeight);
                    sy2 = Math.abs(sy2 - MaxHeight);
                    canvasPanel.repaint();
                }
            });
        }
        return jButton1;
    }
    
    // 获取画板面板
    private MyCanvas getMyCanvas1() {
        if (canvasPanel == null) {
            canvasPanel = new MyCanvas();
        }
        return canvasPanel;
    }
    
    // 主方法
    public static void main(String[] args) {
        new PartImage().setVisible(true);
    }
    
    // 画板
    class MyCanvas extends JPanel {
        /**
         * 
         */
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            g.drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, this);// 绘制指定大小的图片
        }
    }
} // @jve:decl-index=0:visual-constraint="10,10"

20.4.4 图片旋转 P527

import java.awt.*;
import java.net.URL;
import javax.swing.*;

public class RotateImage extends JFrame {
    private static final long serialVersionUID = 1L;
    private Image img;
    private MyCanvas canvasPanel = null;
    
    public RotateImage() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        URL imgUrl = RotateImage.class.getResource("sjtu.jpg");// 获取图片资源的路径
        img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源
        canvasPanel = new MyCanvas();
        add(canvasPanel);
        this.setBounds(100, 100, 400, 350);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("图片旋转"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new RotateImage().setVisible(true);
    }
    
    // 画板
    class MyCanvas extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.rotate(Math.toRadians(5));
            g2.drawImage(img, 70, 10, 300, 200, this);
            g2.rotate(Math.toRadians(5));
            g2.drawImage(img, 70, 10, 300, 200, this);
            g2.rotate(Math.toRadians(5));
            g2.drawImage(img, 70, 10, 300, 200, this);
        }
    }
}


20.4.5 图片倾斜 P528
import java.awt.*;
import java.net.URL;
import javax.swing.*;

public class TiltImage extends JFrame {
    private static final long serialVersionUID = 1L;
    private Image img;
    private MyCanvas canvasPanel = null;
    
    public TiltImage() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        URL imgUrl = TiltImage.class.getResource("sjtu.jpg");// 获取图片资源的路径
        img = Toolkit.getDefaultToolkit().getImage(imgUrl); // 获取图片资源
        canvasPanel = new MyCanvas();
        add(canvasPanel);
        this.setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("图片倾斜"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new TiltImage().setVisible(true);
    }
    
    // 画板
    class MyCanvas extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            g2.shear(0.4, 0.2);//同时水平倾斜和竖起倾斜
            g2.drawImage(img, 0, 0, 300, 200, this);
        }
    }
}

20.4.6 图形的交运算 P530
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;

import javax.swing.*;

public class IntersectOperationImage extends JFrame {
    private static final long serialVersionUID = 1L;
    private IntersectOperationPanel jPanel = null;
    
    public IntersectOperationImage() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        jPanel = new IntersectOperationPanel();
        add(jPanel);
        this.setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("图片交"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new IntersectOperationImage().setVisible(true);
    }
    
    // 画板
    class IntersectOperationPanel extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            Rectangle2D.Float rect = new Rectangle2D.Float(30, 30, 160, 120);
            Ellipse2D.Float ellipse = new Ellipse2D.Float(20, 30, 180, 180);
            Area area1 = new Area(rect);
            Area area2 = new Area(ellipse);
            area1.intersect(area2);
            g2.draw(area1);
                
            Ellipse2D.Float ellipse1 = new Ellipse2D.Float(190, 20, 100, 140);
            Ellipse2D.Float ellipse2 = new Ellipse2D.Float(240, 20, 100, 140);
            Area area3 = new Area(ellipse1);
            Area area4 = new Area(ellipse2);
            area3.intersect(area4);
            g2.fill(area3);
        }
    }
}


20.4.7 图形的异或运算 P530
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;

import javax.swing.*;

public class ExclusiveOrOperationImage extends JFrame {
    private static final long serialVersionUID = 1L;
    private ExclusiveOrOperationPanel jPanel = null;
    
    public ExclusiveOrOperationImage() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        jPanel = new ExclusiveOrOperationPanel();
        add(jPanel);
        this.setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("图片异或"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new ExclusiveOrOperationImage().setVisible(true);
    }
    
    // 画板
    class ExclusiveOrOperationPanel extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            Ellipse2D.Float ellipse1 = new Ellipse2D.Float(20, 70, 160, 60);
            Ellipse2D.Float ellipse2 = new Ellipse2D.Float(120, 20, 60, 160);
            Area area1 = new Area(ellipse1);
            Area area2 = new Area(ellipse2);
            area1.exclusiveOr(area2);
            g2.fill(area1);
                
            Ellipse2D.Float ellipse3 = new Ellipse2D.Float(200, 70, 160, 60);
            Ellipse2D.Float ellipse4 = new Ellipse2D.Float(250, 20, 60, 160);
            Area area3 = new Area(ellipse3);
            Area area4 = new Area(ellipse4);
            area3.exclusiveOr(area4);
            g2.fill(area3);
        }
    }
}

20.5.1 绘制花瓣 P531
import java.awt.*;
import java.awt.geom.Ellipse2D;

import javax.swing.*;

public class DrawFlowerFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    private DrawFlowerPanel drawFlowerPanel = null;
    
    public DrawFlowerFrame() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        drawFlowerPanel = new DrawFlowerPanel();
        add(drawFlowerPanel);
        this.setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("绘制花瓣"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new DrawFlowerFrame().setVisible(true);
    }
    
    // 画板
    class DrawFlowerPanel extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            //平衡坐标轴，把(0, 0)坐标原点移到画板中中心位置
            g2.translate(drawFlowerPanel.getWidth() / 2, drawFlowerPanel.getHeight() / 2);
            
            //绘制绿色花瓣
            Ellipse2D.Float ellipse = new Ellipse2D.Float(30, 0, 70, 20);
            Color color = new Color(0, 255, 0);
            g2.setColor(color);
            g2.fill(ellipse);
            int i = 0;
            while (i < 8) {
                g2.rotate(30);//g2.rotate(Math.toRadians(30));这时候传入的是角度，则需要12个才能转满一圈。360度=2Pi弧度
                g2.fill(ellipse);
                ++i;
            }
            
            //绘制红色花瓣
            ellipse = new Ellipse2D.Float(20, 0, 60, 15);
            color = new Color(255, 0, 0);
            g2.setColor(color);
            g2.fill(ellipse);
            i = 0;
            while (i < 15) {
                g2.rotate(75);
                g2.fill(ellipse);
                ++i;
            }
            
            //绘制黄色花瓣
            ellipse = new Ellipse2D.Float(10, 0, 50, 15);
            color = new Color(255, 255, 0);
            g2.setColor(color);
            g2.fill(ellipse);
            i = 0;
            while (i < 8) {
                g2.rotate(30);
                g2.fill(ellipse);
                ++i;
            }
            
            //绘制红色中心点
            color = new Color(255, 0, 0);
            g2.setColor(color);
            ellipse = new Ellipse2D.Float(-10, -10, 20, 20);
            g2.fill(ellipse);
        }
    }
}


20.5.2 绘制艺术图案 P532

import java.awt.*;
import java.awt.geom.Ellipse2D;
import java.util.Random;

import javax.swing.*;

public class ArtDesignFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    private ArtDesignPanel drawFlowerPanel = null;
    
    public ArtDesignFrame() {
        initialize(); // 调用初始化方法
    }
    
    // 界面初始化方法
    private void initialize() {
        drawFlowerPanel = new ArtDesignPanel();
        add(drawFlowerPanel);
        this.setBounds(100, 100, 400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗体关闭模式
        this.setTitle("绘制花瓣"); // 设置窗体标题
    }
        
    // 主方法
    public static void main(String[] args) {
        new ArtDesignFrame().setVisible(true);
    }
    
    // 画板
    class ArtDesignPanel extends JPanel {
        private static final long serialVersionUID = 1L;

        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D) g;
            //平衡坐标轴，把(0, 0)坐标原点移到画板中中心位置
            g2.translate(drawFlowerPanel.getWidth() / 2, drawFlowerPanel.getHeight() / 2);
            
            Ellipse2D.Float ellipse = new Ellipse2D.Float(-80, 5, 160, 10);
            Random random = new Random();
            
            //drawRandomColor(g2, random, ellipse);
            int i = 0;
            while (i < 100) {
                drawRandomColor(g2, random, ellipse);
                ++i;
            }
        }
        
        private void drawRandomColor(Graphics2D g2, Random random, Ellipse2D.Float ellipse) {
            int R = random.nextInt(256);
            int G = random.nextInt(256);
            int B = random.nextInt(256);
            Color color = new Color(R, G, B);
            g2.rotate(10);
            g2.setColor(color);
            g2.draw(ellipse);
        }
    }
}
//------------------------------------------------------------------------------------------------
Eclipse导出的可执行jar包，用如下语句可直接运行：
java -jar ArtDesignFrame.jar
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第5课 Java核心语法详解
P168 所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都被默认地认为是final的。

P169 5.2.4 访问控制符
当一个类被声明为public时，它就具有了被其他包中的类访问的可能性，只要这些其他包中的类在程序中使用import语句引入public类，就可以访问和引用这个类。每个Java程序的主类都必须是public类，也是基于相同的原因。
//HelloJava.java
package mypackage;

public class HelloJava {
    public static void show() {
        HelloJavaImpl.show();
    }
    
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        HelloJava.show();
    }
}

class HelloJavaImpl {
    public static void show() {
        System.out.println("hello, world!");
    }
}

//Test.java
import mypackage.HelloJava;
import mypackage.HelloJavaImpl;//编译错误，私有类将不可见，无法引用

public class Test
{
    public static void main(String args[])
    {
        HelloJava.show();
    }
}

P170 用protected修饰的成员变量可以被3种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类。使用protected修饰符的主要作用是允许其他包中该类的子类来访问父类的特定属性。

默认访问控制符，该类只能被同一个包中的类访问和引用，而不可以被其他包中的类使用，这种访问特性又称为包访问性。
同样道理，类内的变量或方法如果没有访问控制符来限定，也就具有包访问性。

P180 赋值使等号（=）左边的值等于右边的值，这一点对于基本数据类型（如前面的int a和b）是显尔易见的。对于非基本数据类型（如Point对象），赋值修改的是对象引用，而不是对象本身。因此，x和y引用同一个对象，所以对x执行的所有方法与对y执行的方法都作用于同一个对象。
import java.awt.Point;

public class Test
{
    public static void main(String args[])
    {
        int a = 1;
        int b = 2;
        Point x = new Point(0, 0);
        Point y = new Point(1, 1);
        System.out.println("a is " + a);
        System.out.println("b is " + b);
        System.out.println("x is " + x);
        System.out.println("y is " + y);
        
        System.out.println("改变位置...");
        a = b;
        a++;
        x = y;
        x.setLocation(5, 5);
        System.out.println("a is " + a);
        System.out.println("b is " + b);
        System.out.println("x is " + x);
        System.out.println("y is " + y);
    }
}
输出如下：
a is 1
b is 2
x is java.awt.Point[x=0,y=0]
y is java.awt.Point[x=1,y=1]
改变位置...
a is 3
b is 2
x is java.awt.Point[x=5,y=5]
y is java.awt.Point[x=5,y=5]

P188 当向方法传递一个基本数据类型时，传递的是一个值。当传递的是一个对象时，则按引用传递。

import java.io.IOException;

public class Test
{
    public static void main(String args[]) throws IOException {
        char a;
        outer: //必须先在这里定义，否则break outer和continue outer无法识别
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    a = (char) System.in.read();
                    if (a == 'b') {
                        break outer;//直接跳出所有循环
                    }
                    if (a == 'c') {
                        continue outer;//跳到outer标号处
                    }
                }
            }
    }
}
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第6课 Java面向对象编程
//6.1 封装 P203
public class HelloWorld
{
    private String world = "World";

    public void setWorld(String world)
    {
        this.world = world;
    }

    public void say()
    {
        System.out.println("Hello " + world + "!");
    }

    public static void main(String args[])
    {
        HelloWorld inst = new HelloWorld();
        inst.setWorld("China");
        inst.say();

        //main函数是HelloWorld中的函数，所以可以直接访问其私有变量world，在其他类中则无法用此方法来访问其私有变量，建议在可能的情况下尽可能使用方法调用
        String value = new HelloWorld().world;
        System.out.println(value);
    }
}

//6.2 继承 P204
6.2.1 继承的概念――超类和子类
class Car
{
    int v;
    void drive()
    {
        System.out.println("Car 速度：" + v);
    }
}

class Bus extends Car
{
    int p;
    void carry()
    {
        System.out.println("Bus 载人：" + p);
    }
    
    void sum()
    {
        System.out.println("Bus 速度：" + v);
        System.out.println("Bus 载人：" + p);
    }
}

public class TestCar
{
    public static void main(String args[])
    {
        Car car = new Car();
        car.v = 60;
        Bus bus = new Bus();
        bus.v = 40;
        bus.p = 20;
        
        car.drive();
        bus.drive();
        bus.carry();
        bus.sum();
    }
}
输出如下：
Car 速度：60
Car 速度：40
Bus 载人：20
Bus 速度：40
Bus 载人：20

6.2.2 子类不能访问私有成员与方法
一个被定义成private的类成员为此类私有，它不能被该类外的所有代码访问，包括子类。

6.2.3 父类与子类的相互转换 P207
可以将子类的引用赋给父类的对象，也可以再通过强制类型转换将父类再转换成子类类型。
Bus bus = new Bus();
Car car = bus;
Bus bus2 = (Bus)Car;

6.2.4 使用this和super
（1）this
引用当类的变量或方法
（2）super
它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时）。
（3）this(实参)
引用当前类的构造函数
（4）super(参数)
调用基类中的某一个构造函数

6.2.5 多态――方法的覆盖（override）、重载（overload）、重写（overwrite）

6.2.6 必须被继承的类――抽象类（abstract）
abstract class Car//只有抽象类才能定义抽象方法，所以这里的abstract不能缺少
{
    int v;
    abstract void drive();//这里的abstract可以不定义，则必须要给drive()定义实现，但是要求Car类必须继承
}

class Bus extends Car
{
    int p;
    void drive()//这里不能再加abstract
    {
        System.out.println("Bus 速度：" + v);
    }
    
    void carry()
    {
        System.out.println("Bus 载人：" + p);
    }
    
    void sum()
    {
        System.out.println("Bus 速度：" + v);
        System.out.println("Bus 载人：" + p);
    }
}

public class TestCar
{
    public static void main(String args[])
    {
        Bus bus = new Bus();
        bus.v = 40;
        bus.p = 20;
        
        bus.drive();
        bus.carry();
        bus.sum();
    }
}

6.2.7 不能被继承的类――最终类（final）
1. final类的定义
--final类不能被继承，没有子类，final类中的方法默认是final的
--final方法不能被子类的方法覆盖，但可以被继承
--final成员变量表示常量，只能被赋值一次，赋值后值不再改变
--final不能用于修饰构造方法
父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。（这句话不是很对）
class Car
{
    int v;
    private void drive()//final private void drive()这样定义也可以，但是如果定义为final public void drive()则子类无法覆盖
    {
        System.out.println("Car drive");
    }
}

class Bus extends Car
{
    int p;
    void drive()//可以这样定义drive
    {
        System.out.println("Bus 速度：" + v);
    }
    
    void carry()
    {
        System.out.println("Bus 载人：" + p);
    }
    
    void sum()
    {
        System.out.println("Bus 速度：" + v);
        System.out.println("Bus 载人：" + p);
    }
}

public class TestCar
{
    public static void main(String args[])
    {
        Bus bus = new Bus();
        bus.v = 40;
        bus.p = 20;
        
        bus.drive();
        bus.carry();
        bus.sum();
    }
}

2. final方法的定义 P214
如果一个类不允许子类覆盖某个方法，则可以把这个方法声明为final方法。
使用final方法原因有两个：
--把方法锁定，防止任何继承类修改它的意义和实现。
--高效，编译器在遇到调用final方法时会转入内嵌机制，大大提高执行效率。
对于final static类型成员变量，static使得变量只存在一个副本，final使得它不能改变。
3. 关于final成员赋值的规定
--final成员能且只能被初始化一次
--final成员必须在声明时或者在构造方法中被初始化，而不能在其他的地方被初始化。

6.3 多重继承――接口类 P214
Java语言规范中，一个方法的特征仅包括方法的名字、参数的数目和类型，而不包括方法的返回类型、参数的名字及所抛出来的异常。在Java编译器检查方法的重载时，会根据这些条件判断两个方法是否是重载方法。但在Java编译器检查方法的转换时，则会进一步检查两个方法（分超类型和子类型）的返回值类型和抛出的异常是否相同。
接口继承和实现继承的规则不同，一个类只有一个直接父类，但可以实现多个接口。

6.3.2 接口的创建与实现
接口特性如下：
--接口中的方法可以有参数列表和返回类型，但不能任何方法体。
--接口中可以包含字段，但是会被隐式地声明为static和final。
--接口中的字段只是被存储在该接口的静态存储区域内，而不属于该接口。
--接口中的方法可以被声明为public或不声明，但结果都会按照public类型处理。
--实现一个接口时，需要将被定义的方法声明为public类型，否则为访问类型，Java编译器不允许这种情况。
--如果没有实现接口中的所有方法，那么创建的仍然是一个接口。
--扩展一个接口来生成新的接口应使用关键字extends，实现一个接口使用implements。
Java接口可以是public的，静态的和final属性。
public interface 接口名
{
    public static int a = 1;
    public final int b = 2;
}
可以通过implements关键字实现多个接口，那么该类必须实现这些接口的所有接口方法。

6.3.3 接口与抽象类的区别 P216
（1）抽象类可以提供实现方法，接口不能提供
（2）抽象类只能继承一个，而可以实现多个接口
结合（1）（2）点中抽象类和Java接口的各自优势，最精典的设计模式就出来了：声明类型的工作仍然由Java接口承担，但是同时给出一个Java抽象类，且实现了琮个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，也就是说在层次结构中，Java接口在最上面，然后紧跟着抽象类，这就将两者的最大优点都能发挥到极致了。这个模式就是“默认适配模式”。
//(1)定义顶层接口
public interface ClassName1
{
    public void func1();
}
//(2)定义实现抽象类
public abstract class ClassName2
{
    public void func2()
    {
        
    }
}
//(3)定义实现类
public class ClassName3 extends ClassName2 implements ClassName1
{
    public void func1()//实现接口函数
    {
        func2();//调用抽象类函数
    }
}

接口在某些地方和抽象类有相似的地方，但是采用哪种方式来声明类主要参照以下两点：
--如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。
--如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。

6.4.4 上机作业 P220
写一个计算器，实现加，减，乘，除
//（1）计算器接口类
package calculator;

public interface ICalculator
{
    public int calculate(String expression);
}

//（2）计算器抽象类
package calculator;

public abstract class AbstractCalculator
{
    public int[] split(String expression, String deliString)
    {
        String array[] = expression.split(deliString);
        int arrayInt[] = new int[2];
        arrayInt[0] = Integer.parseInt(array[0]);
        arrayInt[1] = Integer.parseInt(array[1]);
        return arrayInt;
    }
}

//（3）计算器实现类：加、减、乘除，以及默认计算类
//加法计算类
package calculator.impl;

import calculator.ICalculator;
import calculator.AbstractCalculator;

public class Plus extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression)
    {
        int arrayInt[] = split(expression, "\\+");//String.split函数中的入参是正则表达式，+和*有特殊含义，所有要用将其转义
        return arrayInt[0] + arrayInt[1];
    }
}

//减法计算类
package calculator.impl;

import calculator.ICalculator;
import calculator.AbstractCalculator;

public class Minus extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression)
    {
        int arrayInt[] = split(expression, "-");
        return arrayInt[0] - arrayInt[1];
    }
}

//乘法计算类
package calculator.impl;

import calculator.ICalculator;
import calculator.AbstractCalculator;

public class Multiply extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression)
    {
        int arrayInt[] = split(expression, "\\*");//String.split函数中的入参是正则表达式，+和*有特殊含义，所有要用将其转义
        return arrayInt[0] * arrayInt[1];
    }
}

//除法计算类
package calculator.impl;

import calculator.AbstractCalculator;
import calculator.ICalculator;

public class Devide extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression)
    {
        int arrayInt[] = split(expression, "/");
        return arrayInt[0] / arrayInt[1];
    }
}

//默认计算类
package calculator.impl;

import calculator.AbstractCalculator;
import calculator.ICalculator;

public class Default extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression)
    {
        System.out.println("Input is illegal!");
        return 0;
    }
}

//（4）测试类
package calculator;

import java.io.Console;
import java.util.Scanner;

import calculator.impl.Plus;
import calculator.impl.Minus;
import calculator.impl.Multiply;
import calculator.impl.Devide;
import calculator.impl.Default;

public class Test
{
    public static void main(String args[])
    {
        while (true)
        {
            //System.out.println("Ready to input:");
            //String expression = System.console().readLine();//书中的这种方法抛出了空指针异常
            String expression = readDataFromConsole("Ready to input:");
            if (expression.equals("exit"))
            {
                break;
            }
            
            ICalculator calculator;
            if (expression.indexOf("+") != -1)
            {
                calculator = new Plus();
            }
            else if (expression.indexOf("-") != -1)
            {
                calculator = new Minus();
            }
            else if (expression.indexOf("*") != -1)
            {
                calculator = new Multiply();
            }
            else if (expression.indexOf("/") != -1)
            {
                calculator = new Devide();
            }
            else
            {
                calculator = new Default();
            }
            
            int value = calculator.calculate(expression);
            System.out.println(expression + "=" + value);
        }
    }
    
    private static String readDataFromConsole(String prompt)
    {
//        Console console = System.console();
//        if (console == null) //编译能过，运行时每次都为null，抛异常
//        {  
//            throw new IllegalStateException("Console is not available!");  
//        }  
//        return console.readLine(prompt);  
        Scanner scanner = new Scanner(System.in);//有个scanner未close的提示
        System.out.println(prompt);  
        return scanner.nextLine();  
    }
}
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第7课 Java面向对象编程扩展 P225
7.1.1 静态类与非静态类的区别 P225
静态的类都是在运行时静态地加载到内存中的（一开始运行首先从静态的类开始），所以也不需要对它们进行初始化，也没有实例，因此在类的内部也不能用this。
如果是静态内部类的话，静态内部类不能操作访问外部数据，静态内部类的实例生成不需要从外部生成相关类。

7.1.2 静态方法
调用一个静态方法就是“类名.方法名”
一般来说，静态方法常常为应用程序中的其他类提供一些实用工具所用，在Java的类库中大量的静态方法正是出于此目的而定义的。

7.1.4 静态代码块
static变量有点类似于C中的全局变量的概念，值得探讨的是静态变量的初始化问题。
静态代码块在系统启动时就执行了输出，在static {后面跟着一段代码，这是用来显式地初始化静态变量，这段代码只会初始化一次，且在类被第一次装载时。
另外，static定义的变量会优先于任何其他非static变量，不论其出现的顺序如何。并且在涉及到继承的时候，会先初始化父类的static变量，然后是子类的，以此类推。
class StaticClass
{
    public static int i = 0;
    public StaticClass()
    {
        i = 15;
    }
    public StaticClass(int n)
    {
        i = n;
    }
    public static void inc()
    {
        i++;
    }
}

public class Test
{
    StaticClass v = new StaticClass(10);
    static StaticClass v1, v2;
    
    //静态代码块在系统启动时执行
    static
    {
        System.out.println("初始化：v1.c = " + v1.i + ", v2.i = " + v2.i);
        v1 = new StaticClass(27);
        System.out.println("初始化：v1.c = " + v1.i + ", v2.i = " + v2.i);
        v2 = new StaticClass(15);
        System.out.println("初始化：v1.c = " + v1.i + ", v2.i = " + v2.i);
    }
    
    public static void main(String args[])//main方法必须定义在与文件名称一致的public类中
    {
        Test test = new Test();
        System.out.println("test.i = " + test.v.i);
        System.out.println("v1.c = " + v1.i + ", v2.i = " + v2.i);
        v1.inc();
        System.out.println("v1.c = " + v1.i + ", v2.i = " + v2.i);
        System.out.println("test.i = " + test.v.i);
    }
}
输出如下：
初始化：v1.c = 0, v2.i = 0
初始化：v1.c = 27, v2.i = 27
初始化：v1.c = 15, v2.i = 15
test.i = 10
v1.c = 10, v2.i = 10
v1.c = 11, v2.i = 11
test.i = 11


7.1.5 静态内部类
static在类的内部定义静态变量、静态方法和静态代码块的使用情形，它还可以修饰class的定义。
通常一个普通类不允许声明为静态的，只有一个内部类才可以。这时这个声明为静态的内部类可以直接作为一个普通类来使用，而不需要实例化一个外部类。
如下代码所示，定义了一个静态内部类InnerClass，只需要通过“外部类.内部类”的形式引用该类
class Test
{
    //定义一个静态内部类
    public static class InnerClass
    {
        public InnerClass()
        {
            System.out.println("InnerClass");
        }
        public void print(String string)
        {
            System.out.println(string);
        }
    }
    
    public static void main(String args[])
    {
        Test.InnerClass ic = new Test.InnerClass();//引用静态内部类
        ic.print("this is a string");
    }
}
输出如下：
InnerClass
this is a string

7.2 Java匿名类（Anonymous Class） P228
public class A
{
    public void f()
    {
        class B extends Thread//定义一个内部类
        {
            public void run() {...}//具体实现
        }

        class C implements Runnable//定义一个内部接口
        {
            public void run() {...}//具体实现
        }
        
        B b = new B();
        C c = new C();
    }
}
在方法中再定义内部类往往显得累赘，于是上面的代码就可以用匿名内部类重写成：
public class A
{
    public void f()
    {
        Thread b = new Thread()//匿名内部类
        {
            public void run() {...}//具体实现
        }
        
        Runnable c = new Runnable()//匿名内部接口
        {
            public void run() {...}//具体实现
        }
    }
}
匿名内部类通过用在GUI编程添加事件监听器中，目的是简化代码编写。

7.2.1 匿名类的定义 P229
从技术上说，匿名类可被视为非静态的内部类，所以它们具有和方法内部声明的非静态内部类一样的权限和限制。如果要执行的任务需要一个对象，但却不值得创建全新的对象（原因可能是所需的类过于简单，或者是由于它只在一个方法内部使用），匿名类就显得非常有用。匿名类尤其适合在Swing应用程序中快速创建事件处理程序。
匿名类是不能有名称的类，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。这就要采用另一种形式的new语句，如下：
new<类或接口><类的主体>
这种形式的new语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口。它还创建那个类的一个新实例，并把它作为语句的结果而返回。要扩展的类和要实现的接口是new语句的操作数，后跟匿名类的主体。如果匿名类对另一个类进行扩展，它的主体可以访问类的成员、覆盖它的方法等，这和其他任何标准的类都是一样的。如果匿名类实现了一个接口，它的主体必须实现接口的方法。
匿名类的声明是在编译时进行的，实例化在运行时运行。这意味着for循环中的一个new语句会创建相同的匿名类的几个实例，而不是创建几个不同匿名类的一个实例。

7.2.2 匿名类的使用实例
7.2.3 使用匿名类处理Swing事件

7.3 Java内部类（Inner Class）P231
匿名类，属于内部类的一种。内部类即是定义在另一个类的内部的类。Java内部类（Inner Class），实际上类似的概念在C++里就是嵌套类（Nested Class）。

7.3.1 内部类的含义
“内部类”是在另一个类的内部声明的类。从Java1.1 开始，可在一个类中声明另一个类。包装了内部类声明的类就称为“外部类”。Java语言规范允许定义以下几种内部类：
--在另一个类或者一个接口中声明一个类
--在另一个接口或者一个类中声明一个接口（可以不用实现接口中的内部接口）
--在一个方法中声明一个类
--类和接口声明可以嵌套任意深度

内部类是在一个类的内部嵌套定义的类，它可以是其他类的成员，也可以在一个语句块的内部定义，还可以在表达式内部匿名定义。
内部类有如下特性：
--一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称，名字不能与包含它的类名相同。
--可以使用包含它的类的静态和实例成员变量，也可以使用它所在的方法的局部变量。
--可以定义为abstract
--可以声明为private或protected
--若被声明为static，就变成了顶层类，不能再使用局部变量。
--若想在Inner Class中声明任何static成员则该Inner Class必须声明为static。

（1）内部类的可视范围
内部类的可视范围是它的直接外嵌类（这一点和嵌套静态类不同，嵌套静态类在其外嵌类之外也是可视的），也就是说内部类可以直接引用外嵌类中的任何成员。因为内部类五外嵌类的实例相关，所以内部类拥有两个this指针，一个指向内部类的实例本身，一个指向外嵌类实例。
（2）使用内部类的好处
封装性好：直接通过操作得到内部类内容，甚至连这个内部类名字都没有看见。一个内部类对象可以访问创建它的外部类对象的内部，甚至包括私有变量。
在Java中的内部类和接口加在一起，可以解决常被C++程序员抱怨Java中存在的一个问题――没有多继承。实际上，C++的多继承设计起来很复杂，而Java通过内部类另上接口，可以很好地实现多继承的效果。
（3）内部类的用途
内部类的一个主要用途是用于GUI的事件处理程序

7.3.2 内部类的使用实例 P232

interface IContent
{
    String getContent();
}

interface IAddress
{
    String getAddress();
}

class Mail
{
    //邮件内部内部类
    private class Content implements IContent
    {
        private String content;
        
        private Content(String content)
        {
            this.content = content;
        }
        
        public String getContent()
        {
            return content;
        }
    }
    
    //接收地址内部类
    protected class Address implements IAddress
    {
        private String address;
        
        private Address(String address) 
        {
            this.address = address;
        }
        
        public String getAddress()
        {
            return address;
        }
    }
    
    public IContent getContent(String s)
    {
        return new Content(s);
    }
    
    public IAddress getAddress(String s)
    {
        return new Address(s);
    }
}


public class TestMail
{
    public static void main(String args[])//main方法必须定义在与文件名称一致的public类中
    {
        Mail mail = new Mail();
        IContent content = mail.getContent("这是邮件正文");//取得邮件正文实例
        IAddress address = mail.getAddress("bigben0204@163.com");//取得接收地址实例
    }
}
在这个例子里，类Content和Address被定义在了类Mail内部，并且由protected和private修饰符来控制访问级别。在后面的mail方法里，直接用IContent content和IAddress address进行操作，你甚至连这两个内部类的名字都没有看见。这样，内部类的第一个好处就体现出来了――隐藏了你不想让别人知道的操作，好封装性。
同时，也发现了在外部类作用范围之外得到内部类对象的一第一个方法，那就是利用其外部类的方法创建并返回。


7.3.3 局部内部类 P233
前面定义的内部类是在类内部定义的，还可以是局部的，即它可以定义在一个方法，或者一个代码块之内。
当内部类定义放在函数内部时，class前不能够使用private、protected和public修饰符，因为此时的类仅仅在该代码块作用可见，不需要对外部开发可视权限。
interface IContent
{
    String getContent();
}

interface IAddress
{
    String getAddress();
}

class Mail
{
    public IContent getContent(String s)
    {
        //邮件内部内部类
        class Content implements IContent//如果定义成局部类，则不能用修饰符public/protected/private，只能用abstract/final
        {
            private String content;
            
            private Content(String content)
            {
                this.content = content;
            }
            
            public String getContent()
            {
                return content;
            }
        }
        
        return new Content(s);
    }
    
    public IAddress getAddress(String s)
    {
        //接收地址内部类
        class Address implements IAddress
        {
            private String address;
            
            private Address(String address) 
            {
                this.address = address;
            }
            
            public String getAddress()
            {
                return address;
            }
        }
        
        return new Address(s);
    }
}


public class TestMail
{
    public static void main(String args[])//main方法必须定义在与文件名称一致的public类中
    {
        Mail mail = new Mail();
        IContent content = mail.getContent("这是邮件正文");//取得邮件正文实例
        IAddress address = mail.getAddress("bigben0204@163.com");//取得接收地址实例
    }
}

还可以将内部类放在代码块中，如果s不为空则定义内部类并返回实例，否则返回空。不能在if之外创建这个内部类的对象，因为这已经超出了它的作用域。不过在编译的时候，内部类Content、Address和其他类一样同时被编译，只不过它有自己的作用域，超出了这个范围就无效，除此之外它和其他内部类并没有什么区别。

7.3.4 内部类引用外部类对象 P235
根据内部类的含义可知，内部类的对象还可以引用外部对象。例子不写了，内部类引用外部类的私有数据成员变量。
一个内部类对象可以访问创建它的外部类对象的内容，甚至包括私有变量！这是一个非常有用的特性。要想实现这个功能，内部类对象就必须有指向外部类对象的引用。Java编译器创建内部类对象时，隐式地把其外部类对象的引用也传了进去并一直保存着。这样就使得内部类对象始终可以访问其外部类对象，同时这也是为什么在外部类作用范围之外要创建内部类对象必须先创建其外部类对象的原因。
如果内部类里的一个成员变量与外部类的一个成员变量同名，即外部类的同名成员变量被屏蔽了，Java里用如下格式表达外部类的引用：
外部类名.this.外部变量名
对于上面的变量，如果使用与Address内部同名的变量address，那么在Address内部需要使用“Mail.this.address”来引用它。

在创建非静态内部类对象时，一定要先创建相应的外部类对象，因为非静态内部类对象有着指向其外部类对象的引用。

和普通的类一样，内部类也可以有静态的。不过和非静态内部类相比，区别就在于静态内部类没有了指向外部的引用。这实际上和C++中的嵌套类很相似了，Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用这一点上。
除此之外，在任何非静态内部类中，都不能有静态数据、静态方法或者另外一个静态内部类（内部类的嵌套可以不止一层）。不过静态内部类却可以拥有这一切。

7.4 Java异常类（Exception Class） P237
在编程过程中，首先应当尽可能去避免错误和异常发生，对于不可避免、不可预测的情况则考虑在异常发生时如何处理。Java对异常的处理是按异常分类处理的，不同异常有不同的分类，每种异常都对应一个类型（class），每个异常都对应一个异常（类的）对象。
--异常类有两个来源：一是Java语言本身定义的一些基本异常类型；二是用户通过继承Exception类或者子类自己定义的异常。
--异常的对象有两个来源：一是Java运行时环境自动抛出系统生成的异常，而不管你是否愿意捕获和处理，它总要被抛出，如除数为0的异常；二是程序员自己抛出的异常，这个异常可以是程序员自己定义的，也可以是Java语言中定义的，用throw关键字抛出异常，这种异常常常用来向调用者汇报异常的一些信息。异常是针对方法来说的，抛出、声明抛出、捕获和处理异常都是在方法中进行的。

7.4.1 Java的异常层次结构
Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。Java API中定义的异常类分为两大类，即错误Error和异常Exception。
Throwable类是所有异常和错误的超类，它有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常（Runtime Exception）和非运行时异常，这两种异常有很大区别，也称为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。
1. Error与Exception
--Error是程序无法处理的错误，比如OutOfMemory Error、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。常见的有程序进入死循环、内存泄漏等。这种情况，程序运行时本身无法解决，只能通过其他方法干预。
--Exception是程序本身可以处理的异常，这种异常分为运行时异常和非运行时异常。在程序中应当尽可能去处理这些异常。常见的有除数为0、数组越界等。这种情况，不像错误那样，程序运行时本身可以解决，由异常代码调整程序运行方向，使程序仍可继续运行直至直至正常结束。
2. 运行时异常和非运行时异常

每一个类的含义P230
（1）Throwable getCause()/getMessage()/printStackTrace()
（2）Exception
（3）Error
（4）RuntimeException
（5）ThreadDeath

--算术异常类：ArithmeticException
--空指针异常类：NullPointerException
--类型强制转换异常：ClassCassException
--数组负下标异常：NegativeArrayException
--数组下标越界异常：ArrayIndexOutOfBoundsException
--违背安全原则异常：SecurityException
--文件已结束异常：EOFException
--文件未找到异常：FileNotFoundException
--字符串转换为数字异常：NumberFormatException
--操作数据库异常：SQLException
--输入/输出异常：IOException
--方法未找到异常：NoSuchMethodException

7.4.2 异常的捕捉处理机制 P240
1. 异常处理的基本语法
try、catch、finally、throw、throws
finally语句块：紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，而不管try语句块是否发生异常，目的是给程序一个补救的机会，体现了Java语言的健壮性。
//如下，即使未进入catch语句块中，finally中的语句还是会执行到
public class TestMail
{
    public static void main(String args[])//main方法必须定义在与文件名称一致的public类中
    {
        int r = 30;
        try
        {
            if (r <= 20)
            {
                throw new Exception("程序异常：\n半径为：" + r + "\n半径不能小于20。");
            }
            else
            {
                return;
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            return;
        }
        finally
        {
            System.out.println("before return");
        }
    }
}
输出如下：
before return

再如下，如果没有发生异常，则finally语句还是会按顺序执行
public class TestMail
{
    public static void main(String args[])//main方法必须定义在与文件名称一致的public类中
    {
        int r = 30;
        try
        {
            if (r <= 20)
            {
                throw new Exception("程序异常：\n半径为：" + r + "\n半径不能小于20。");
            }
//            else
//            {
//                return;
//            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            //return;
        }
        finally
        {
            System.out.println("before return");
        }
        System.out.println("last sentence");
    }
}
输出如下：
before return
last sentence

2. try、catch、finally语句块应注意的问题
--try、catch、finally 3 个语句块均不能单独使用，3 者可以组成try...catch...finally、try...catch、try...finally3种结构，catch语句可以有一个或多个，finally语句最多一个。
--try、catch、finally 3 个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在3个块中都可以访问，则需要将变量定义到这些块的外面。
--使用多个catch块时，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下的。

3. throw、throws关键字
throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。
throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣一般在catch块中打印一下堆栈信息进行勉强处理。
--throw是语句抛出一个异常；throws是方法抛出一个异常。方法抛出异常类可以声明多个，用逗号分隔。
--throws可以单独使用，throw不能。
--throw要么和try...catch...finally语句配套使用，要么与throws配套使用。但throws可以单独使用，然后再由处理异常的方法捕获。
一个简单的例子：
public static void test() throws Exception
{
    throw new Exception("方法test()中的Exception");
}

7.4.3 使用异常和自定义异常 P241
1. 使用已有的异常类
try
{
    
}
catch(IOException ioe)
{
    
}
catch(SQLException sqle)
{
    
}
finally
{
    
}
2. 自定义异常类
public class MyException extends Exception
{
    public MyException() {}
    public MyException(String msg)
    {
        super(msg);
        System.out.println(msg);
    }
}
在异常类中，可以覆盖或重载父类Exception中的函数，用心实现自己的代码。
3. 使用自定义的异常
用throws声明方法可能抛出自定义的异常，并用throw语句在适当的地方抛出自定义的异常。
public void test() throws MyException
{
    ...
    if (...)
    {
        throw new MyException();
    }
}
也可以将异常转型（也叫转译），使得异常更易读易于理解。所谓转型，即在捕捉到某一个异常时，抛出另外的一个自定义的异常，这样是为了外部更加统一地接收异常。
public void test() throws MyException
{
    ...
    try
    {
        ...
    }
    catch (SQLException e)
    {
        ...
        throw new MyException();
    }
}

7.5.4 上机作业参考 P245
（1）添加异常类：
//CalculatorException.java
package calculator;

public class CalculatorException extends Exception
{
    public CalculatorException(String msg)
    {
        super("数字转换异常：" + msg);
    }
}

（2）捕获AbstractCalulator中的java.lang.NumberFormatException异常，并转译成CalculatorException异常抛出。
package calculator;

public abstract class AbstractCalculator
{
    public int[] split(String expression, String deliString) throws CalculatorException
    {
        String array[] = expression.split(deliString);
        int arrayInt[] = new int[2];
        
        try
        {
            arrayInt[0] = Integer.parseInt(array[0]);
            arrayInt[1] = Integer.parseInt(array[1]);
        }
        catch (NumberFormatException e)
        {
            throw new CalculatorException(e.getMessage());
        }
        
        return arrayInt;
    }
}

（3）加减乘除计算因增加计算函数抛出异常处理。
package calculator.impl;

import calculator.CalculatorException;
import calculator.ICalculator;
import calculator.AbstractCalculator;

public class Plus extends AbstractCalculator implements ICalculator
{
    @Override
    public int calculate(String expression) throws CalculatorException
    {
        int arrayInt[] = split(expression, "\\+");//String.split函数中的入参是正则表达式，+和*有特殊含义，所有要用将其转义
        return arrayInt[0] + arrayInt[1];
    }
}

接口类ICalulator的接口函数抛出异常：
package calculator;

public interface ICalculator
{
    public int calculate(String expression) throws CalculatorException;
}

（4）测试类Test中捕捉计算类抛出的自定义异常，输出到控制台：
package calculator;

import java.io.Console;
import java.util.Scanner;

import calculator.impl.Plus;
import calculator.impl.Minus;
import calculator.impl.Multiply;
import calculator.impl.Devide;
import calculator.impl.Default;

public class Test
{
    public static void main(String args[])
    {
        while (true)
        {
            //System.out.println("Ready to input:");
            //String expression = System.console().readLine();
            String expression = readDataFromConsole("Ready to input:");
            if (expression.equals("exit"))
            {
                break;
            }
            
            ICalculator calculator;
            if (expression.indexOf("+") != -1)
            {
                calculator = new Plus();
            }
            else if (expression.indexOf("-") != -1)
            {
                calculator = new Minus();
            }
            else if (expression.indexOf("*") != -1)
            {
                calculator = new Multiply();
            }
            else if (expression.indexOf("/") != -1)
            {
                calculator = new Devide();
            }
            else
            {
                calculator = new Default();
            }
            
            try
            {
                int value = calculator.calculate(expression);
                System.out.println(expression + "=" + value);
            }
            catch (CalculatorException e)
            {
                System.out.println(e);
            }
        }
    }
    
    private static String readDataFromConsole(String prompt)
    { 
        Scanner scanner = new Scanner(System.in);  
        System.out.println(prompt);  
        return scanner.nextLine();  
    }
}
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第8课 Java编码规范与样式 P249
8.1.1 文件的命名
如果在源程序中包含有公共类的定义，则该源文件名必须与该公共类的名字完全一致，字母的大小写都必须一样。这是Java语言的一个严格的规定，如果不遵守，在编译时就会出错。因此，在一个Java源程序中至多只能有一个公共类的定义。如果源程序中不包含公共类的定义，则该文件名可以任意取名。如果在一个源程序中有多个类定义，则在编译时将为每个类生成一个.class文件。
//NoPublicClass.java
package calculator;

class DbTest
{
    public void show()
    {
        System.out.println("this is dbTest");
    }
}

class DbTest2
{
    public void show()
    {
        System.out.println("this is dbTest2");
    }
}

//Test.java
package calculator;

public class Test
{
    public static void main(String args[])
    {
        DbTest dbTest = new DbTest();//在同一个包中的源程序类可以直接引用，即便没有加public访问控制符
        dbTest.show();
    }
}
类的访问控制符只有public、abstract、final三种。后两种不说了，public类才能被其他包import进并使用，不加public则无法被其他包使用，只能在本包中使用。

8.1.2 包的命名
包的命名采用完整的英文描述符，应该都是由小写字母组成的。由于Java面向对象编程的特性，每一名Java程序员都可以编写属于自己的Java包，为了保障每个Java包命名的唯一性，要求程序员在自己定义的包的名称之前加上唯一的前缀。
包名按照域名的范围从大到小逐步列出，恰好和Internet上的域名命名规则相反，如：
net.sourceforge
com.ibm.util
com.sun.eng
com.apple.quicktime

8.1.3 类的命名 P250
类名是一个名词，采用大小写混合的方式，每个单词的首字母大写。
--类名由大写字母形状，其他字母小写，如Test
--类名由多个单词组成，每个单词首字母均应大写，如TestPage
--如果类名中包含单词缩写，则缩写词的每个字母均应大写，如XMLExample（个人感觉XmlExample更好一些）
还有一点命名技巧，由于类是设计用来代表对象的，所以在命名类时应尽量选择名词。

8.1.4 变量的命名
小写字母开头，后面单词用大写字母开头

8.1.5 常量的命名
类的常量是使用static final 来修饰的变量。但为了与普通的变量相区别，常量的名字应该都使用大写字母，并且指出该常量完整含义。如果其中包含多个单词，要以“_”连接，如：
static final int MIN_WIDTH = 4;
static final int MAX_WIDTH = 999;
static final int GET_THE_CPU = 1;

Tips：在Java代码中，无论什么时候，均提倡使用常量取代数字、固定字符串。也就是说，程序中除0、1以外，尽量不应该出现其他数字。常量可以集中在程序开始部分定义，或者在更宽的作用域内定义，如静态类的静态变量。

8.1.6 数组的命名 P251
数组也是变量，因此首先应该遵循变量的命名规则。数组应该总是用下面的方式来命名的：
byte[] buffer;
而不是：
byte buffer[];//但是是在C++中只有这种数组命名方式，所以统一这样命名不可以吗？

8.1.7 方法的命名
方法名的定义应该使用有意义的标识符。Java中方法名以小写字母开头，名字一般都使用动宾结构的数组，开始的动词字母小写，后跟一个首字母大写的名词，也可以在动宾结构中加入修饰词。
所有的布尔型获取函数必须用单词is做前缀，如：
public boolean isPersistent();
public boolean isString();

8.2 Java排版规范 P252
8.2.1 空格
8.2.2 空行
空行将逻辑相关的代码段分隔开，以提高可读性。
--如果一个文件中有几个类，类之间必须使用空行（建议用2个空行）。
--类的成员变量和类方法之间必须有空行（建议用2个空行）。
--在两个方法之间必须使用空行进行分隔（建议用2个空行）。
--对于那些属于同一语句块，但从逻辑上讲完成了不同功能的语句，应该用一个空行分开。
Tips：}语句永远单独作为一行。

8.2.3 缩进 P255
缩进排版通常以4个空格作为一个单位
--每个语句块向后缩进4个空格位置
--在语句很长的情况下，关于换行的缩进
    每一行Java代码都应该限制在80个字符以内。当一行代码过长时，要考虑折行。折行后，第2行的开头应当与第1行语句同等地位的词缩进对齐（使用“Tab”键无法对齐时，不要减小缩进的空格数目，而是错开，以“Tab”键缩进的空格为准）。换多行时，第2行以后的各行一定要对齐。
--注释应该和被注释的代码的缩进列数相同

8.2.4 页宽
尽量避免一行的长度超过80个字符。在任何情况下，越长的语句应该在一个逗号或者一个操作符后折行。

8.3 Java注释规范

8.4 Java文件样式 P257
8.4.2 包与引入
如果有package行，则它必须出现在除注释外的第一行。import行要跟在package的后面，之间空一行。import中标准的包名要在本地的包名之前，而且按照字母顺序排序。如果import行中包含了同一个包中的不同子目录，则应该用*来处理。
8.4.6 构造函数
它应该用递增的方式写（比如，参数多的写在后面）

8.4.8 toString()方法
一般情况下，每一个类都应该定义toString()方法，方便外部的类调用输出
public String toString()
{}

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第9课 Java输入/输出流 P267
9.1.1 标准输入/输出类System
System类包含3个静态成员变量，都是关于输入和输出的变量。
static PrintStream out;//标准输出流
static PrintStream err;//标准错误输出流
static InputStream in;//标准输入流

1. out标准输出流――输出消息到控制台
System.out.println(data);
out对象的类型是PrintStream。该类提供了一系列的是print()函数，用于输出各种类型的数据，包括基本数据类型、对象数据类型和数组，函数列表如下：
void print(boolean b);
void print(char c);
void print(char[] s);//打印字符数组
void print(double d);
void print(float f);
void print(int i);
void print(long l);
void print(Object obj);
void print(String s);
另外，还提供了对应的换行输出函数 
void println(xxx xxx);
如果要输出一个换行，则可以直接使用下面的函数：
void println();
除此之外，还可以使用下面的方法直接输出字节数据（字节数据就是本章后面将要讲到的字节流）：
void write(byte[] buf, int off, int len);//将len字节从指定的初始偏移量为off的byte数组写入此流
void write(int b);//将指定的字节写入此流

2. err标准错误输出流――输出错误消息到控制台 P269
err是“标准”错误输出流。此流已打开并准备接收输出数据：
System.err.println(data);

Tips：标准输出和标准出错的一个区别是：标准输出往往是带缓存的，而标准出错没有缓存（默认设置，可以改）。所以如果你用标准出错打印出来的东西可以马上显示在屏幕上，而标准输出打印出来的东西可能要再积累几个字符才能一起打印出来。总地来说，System.out用于正常的输出，也就是程序真正想输出的内容；而System.err用于出错信息的输出，也就是你本来不期待看到的东西。

3. in标准输入流――接收键盘输入
in是“标准”输入流。in对象的类型是InputStream，它提供了两个方法。
（1）read()方法读取一个字节
read()用于从控制台读入一个字节（8bit）。

public class TestSystemInRead
{
    public static void main(String args[])
    {
        try
        {
            int c;
            while ((c = System.in.read()) != 0)
            {
                System.out.write(c);
            }
        }
        catch (Exception e)
        {
        }
    }
}
（2）read(byte[] b)读取一个字节数组
上面的函数一次仅仅能够读取一个字节。可以使用read(byte[] b)来读取一个字节数组。首先创建了一个长度为100的字节数组，表示一次可以读取100个字节，然后使用read(byte[] b)读取100个字节到byte中，再调用write()函数输出这个字节数组到控制台中。

public class TestSystemInReadByte
{
    public static void main(String args[])
    {
        try
        {
            byte[] b = new byte[100];//如果输入的字符串长度大于100，多余的字节就会被抛弃。
            System.in.read(b);
            System.out.write(b, 0, 100);
            //可以将读入的字节数组b转化为字符串输出
            //String str = new String(b);
            //System.out.println(str);
        }
        catch (Exception e)
        {
        }
    }
}

//循环输入
public class TestSystemInReadByte
{
    public static void main(String args[])
    {
        try
        {
            while (true)
            {
                byte[] b = new byte[100];
                System.in.read(b);
                String str = new String(b);
                System.out.println(str);
            }
        }
        catch (Exception e)
        {
        }
    }
}

Tips：System.in的read()函数读取，是在控制台中按回国后开始执行的。因此，如果在上面的程序中使用read()函数读取一个字节时，不是在用户输入一个字符后读取的，而是在按回车键后一次性读取的。

9.1.2 控制台读写类Console P271
上节程序读入字节数组，再转化为String，实现复杂。长度有100的限制，小于100会使用方框代替，大于100将会被抛弃。还必须捕捉异常。

public class TestConsole
{
    public static void main(String args[])
    {
        while (true)
        {
            String str = System.console().readLine();//用Eclipse将会抛出console空指针异常，使用cmd运行java TestConsole可以正常运行
            System.out.println(str);
        }
    }
}
这里使用了System.console()函数取得了Console对象，然后使用readLine()函数即可读取一行字符串的输入。该函数在用户执行回车时调用。
--不需要捕捉异常，该函数没有抛出异常。
--不需要将字节数组转化成字符串，直接读入的就是字符串。
--程序执行中，可以完整地读取一行输入并完整输出，不会有抛弃和方框填充。

（1）Console类及输出消息方法
Console类包含多个方法，可访问与当前Java虚拟机关联的基于字符的控制台设备（如果有），常指的就是键盘。
虚拟机是否具有控制台取决于底层平台，还取决于调用虚拟机的方式。如果虚拟机从一个交互式命令行开始启动，且没有重定向标准输入和输出流，那么其控制台将存在，通常连接到键盘并从虚拟机启动的地方显示。如果虚拟机是自动启动的（如，由后台作业调度程序启动），它通常没有控制台。如果此虚拟机具有控制台，那么它将由此类唯一的实例（可通过调用System.console()方法获得）表示。如果没有可用的控制台设备，对该方法的调用将返回null。
Tips：这就是为什么我们在执行如上程序时只能在控制台中执行，而不能在Eclipse中执行的原因。

该类用于从控制台读取消息，也可以输出消息，其输出方法是：
System.console().printf(str);
它的读写操作是同步的，以保证关键操作能完整完成。因此调用方法readLine()、printf()时可能阻塞。
（2）读取密码
如果应用程序需要读取密码或其他安全数据，则应该使用readPassword()或readPassword(String, Object)，并在执行后手工将返回的字符数组归零，以最大限度地缩短内存中敏感数据的生存期。

public class TestConsolePassword
{
    public static void main(String args[])
    {
        while (true)
        {
            char password[] = System.console().readPassword();//System.console().readPassword("[%s]", "Please input password");将有"[Please input password]"作为提示信息显示在控制台窗口中
            System.out.println(password);
        }
    }
}
输出如下：
D:\Program Files\eclipseJava workspace\LearningProject\bin>java TestConsolePassword

hello

it is amazing

9.2 文件基本处理 P273
9.2.1 文件操作类File
（1）创建File实例
--File(String pathname)
File path = new File("D:/demo");
File file = new File("D:/demo/test.txt");
--File(String parent, String child)
File file = new File("D:/demo", "test.txt")
--File(URI uri)
File file = new File("file://D:/demo/test.txt");
--File(File parent, String child)：根据parent抽象路径名和child路径名字符串创建一个新File实例。
File file = new File(path, "test.txt");

（2）判断是目录还是文件
isDirectory()：是否是目录
isFile()：是否是文件
如：
if (path.isDirectory())
{
    
}
if (file.isFile())
{
    
}

（3）检查目录或文件是否存在
if (path.exists())
{
    
}
if (file.exists())
{
    
}

（4）创建目录或文件
当目录或文件不存在时，可以通过下面的方法来创建目录或空文件。
--mkdir()：创建一个目录
--mkdirs()：创建所有目录
--createNewFile()：创建一个文件
其中，创建多层目录的时候要用mkdirs()，mkdir()只能在已有目录下创建一个子目录，而对于createNewFile()则需要捕捉IOException。如：
if (!path.exists())
{
    path.mkdir();
    path.mkdirs();
}
if (!file.exists())
{
    try
    {
        file.createNewFile();
    }
    catch (IOException e)
    {
        
    }
}
（5）查看目录下的文件列表，并输出路径名
对于目录来说，可以使用listFiles()取得该目录下的文件列表，它返回的是一个File类型的数组，可以循环该数组取得每一个文件对象，并使用getAbsolutePath()取得该对象的路径名。
如下所示：
File[] filelist = path.listFiles();
for (int i = 0; i < filelist.length; ++i)
{
    System.out.println(filelist[i].getAbsolutePath());
}

//例
import java.io.File;

public class TestConsolePassword
{
    public static void main(String args[])
    {
        File path = new File("f:\\PTDownload");
        File[] fileList = path.listFiles();//将会得到所有文件和文件夹，包括隐藏文件夹
        for (File f : fileList)
        { 
            System.out.println(f.getAbsolutePath());
        }
    }
}
输出如下：
f:\PTDownload\f
f:\PTDownload\Rise.of.the.Tomb.Raider.CHT.CHS.RF.X360.GOD.WITH.TU2.DLC-ALI213
f:\PTDownload\使命召唤.BD1280超清中英双字.mp4
f:\PTDownload\八面埋伏.BD超清中英双字.mkv
f:\PTDownload\头脑特工队BD1280高清国英双语中字.mkv
f:\PTDownload\港HD1280国语中字.mp4
f:\PTDownload\滚蛋吧！肿瘤君.HD1280超清国语中英双字.mp4
f:\PTDownload\猫和老鼠之巨人大冒险BD中字.rmvb
f:\PTDownload\福尔摩斯先生BD1280高清中英双字.rmvb
f:\PTDownload\美式极端BD1280高清中英双字.rmvb

（6）重命名文件名
对于文件，可以使用renameTo()函数重命名一个新的文件名，参数为一个新File实例。例如：
File newFile = new File("D:/demo/test2.txt");
if (file.isFile())
{
    file.renameTo(newFile);
}

（7）删除目录或文件
对于目录或文件对象，可以执行delete()函数来删除目录或文件。如果对目录执行删除，则将会删除该目录下的所有文件和目录。例如：
path.delete();
file.delete();

9.2.2 文件搜索类FileFilter与FilenameFilter P275
按特定要求找出所有文件，可以使用两个文件搜索类FileFilter与FilenameFilter，它们都是接口，只需要我们编写自己的实现类来实现它们的函数accept()即可。FileFilter的主要作用就是检测文件是否存在，FileFilter和FilenameFilter唯一的不同是，FileFilter提供文件对象的访问方法，而FilenameFilter是按照目录和文件名的方式来工作的。
FileFilter的过滤函数接口，用户的实现类只需要实现该函数，对不同的文件进行过滤即可：
boolean accept(File file);

而FilenameFilter的过滤函数是按照目录和文件名来进行的：
boolean accept(File directory, String name);

1. FileFilter的使用
一个简单的例子是搜索特定的文件扩展名，可以使用FilenameFilter，但是出来的结果会让你很难判断到底是目录还是。要解决这个问题，需要使用FileFilter对象。
//ExtensionFilter.java
package test.file;

import java.io.File;
import java.io.FileFilter;

public class ExtensionFilter implements FileFilter
{
    private String extension;
    
    public ExtensionFilter(String extension)
    {
        this.extension = extension;
    }

    @Override
    public boolean accept(File file)
    {
        if (file.isDirectory())
        {
            return false;
        }
        
        String name = file.getName();
        //扩展名前的符号“.”
        int index = name.lastIndexOf(".");
        if (index == -1)//没有扩展名则返回false
        {
            return false;
        }
        else if (index == name.length() - 1)//以点号结尾则返回false
        {
            return false;
        }
        else
        {
            return extension.equals(name.substring(index + 1));
        }
    }
}

//TestFile.java
package test.file;

import java.io.File;

public class TestFile
{
    public static void main(String[] args)
    {
        File file = new File("f:/PTDownload");
        ExtensionFilter mp4Filter = new ExtensionFilter("mp4");
        File[] files = file.listFiles(mp4Filter);
        for (int i = 0; i < files.length; ++i)
        {
            System.out.println(files[i].getAbsolutePath());
        }
    }
}
输出如下：
f:\PTDownload\使命召唤.BD1280超清中英双字.mp4
f:\PTDownload\港HD1280国语中字.mp4
f:\PTDownload\滚蛋吧！肿瘤君.HD1280超清国语中英双字.mp4

2. FilenameFilter的使用 P277
FilenameFilter的过滤参数accept()则直接根据目录和文件名进行过滤，与FileFilter相比，多了一个文件名参数。如下例子过滤扩展名为.gif,.jpg,.png的文件。
//ImageFilter.java
package test.file;

import java.io.File;
import java.io.FilenameFilter;

public class ImageFilter implements FilenameFilter
{
    public boolean isGif(String filename)
    {
        if (filename.toLowerCase().endsWith(".gif"))
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    public boolean isJpg(String filename)
    {
        if (filename.toLowerCase().endsWith(".jpg"))
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    public boolean isPng(String filename) 
    {
        if (filename.toLowerCase().endsWith(".png"))
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    
    @Override
    public boolean accept(File dir, String filename)
    {
        return (isGif(filename) || isJpg(filename) || isPng(filename));
    }
}

//TestFile.java
package test.file;

import java.io.File;

public class TestFile
{
    public static void main(String[] args)
    {
        File file = new File("d:/Program Files/eclipseJava workspace/LearningProject/src");
        ImageFilter imageFilter= new ImageFilter();
        File[] images = file.listFiles(imageFilter);
        for (int i = 0; i < images.length; ++i)
        {
            System.out.println(images[i].getAbsolutePath());
        }
    }
}
输出如下：
d:\Program Files\eclipseJava workspace\LearningProject\src\imageButton.jpg
d:\Program Files\eclipseJava workspace\LearningProject\src\img.jpg
d:\Program Files\eclipseJava workspace\LearningProject\src\sjtu.jpg
d:\Program Files\eclipseJava workspace\LearningProject\src\wxPython.jpg

//上述ImageFilter.java中有较多的重复代码，重构后如下：
package test.file;

import java.io.File;
import java.io.FilenameFilter;

public class ImageFilter implements FilenameFilter
{
    @Override
    public boolean accept(File dir, String filename)
    {
        return (isGif(filename) || isJpg(filename) || isPng(filename));
    }
    
    private boolean isExtensionType(String filename, String extension)
    {
        return filename.toLowerCase().endsWith(extension);
    }
    
    private boolean isGif(String filename)
    {
        return isExtensionType(filename, ".gif");
    }
    
    private boolean isJpg(String filename)
    {
        return isExtensionType(filename, ".jpg");
    }
    
    private boolean isPng(String filename) 
    {
        return isExtensionType(filename, ".Png");
    }
}

Tips：通常建议使用FilenameFilter类进行文件过滤。

9.2.3 文件随机读写类RandomAccessFile P279
RandomAccessFile类能够随机访问文件，它将文件内容存储在一个大型byte数组中。它存在着指向该隐含byte数组的光标或索引，称为文件指针，该指针位置可以通过seek方法设置。
通常，如果此类中的所有读取例程在读取所需数量的字节之前已到达文件末尾，则抛出EOFException（是一种IOException）。如果由于某些原因无法读取任何字节，而不是读取所需数量的字节之前已到达文件末尾，则抛出IOException，而不是EOFException。需要特别指出，如果流已被关闭，则可能抛出IOException。
1. 打开与关闭文件
--RandomAccessFile(File file, String mode)
--RandomAccessFile(String name, String mode)
第一种通过一个File对象创建，第二种则直接指向文件名。其中的参数mode表示对目标文件的访问模式，可选值如表9-1 所示：
r
rw
rws
rwd
Tips：“rwd”模式可用于减少执行的“I/O”操作数量。使用“rwd”仅要求更新写入存储的文件的内容；使用“rws”要求更新要写入的文件内容及其元数据，这通常要求至少一个以上的低级别I/O操作。

采用读写模式打开文件的方法：
RandomAccessFile file = new RandomAccessFile("D:/demo/test.txt", "rw");
在完成对文件的一系列操作之后，还需要使用close()函数关闭文件：
file.close();
Tips：打开文件后必须关闭，否则该文件会被占用。

打开文件后，还可以在文件的长度范围内设置指针位置
（1）读取文件长度
可以使用length()取得文件的长度，该数值是该文件的字节数，如下例所示：
long size = file.length();
System.out.println("filesize:" + size);
（2）设置文件指针位置
打开文件后，默认的读取指针指向文件的最开始处，即0。RandomAccessFile类之所以是访问类，就是因为它能够自动定位读取的指针。此时可以使用seek(long pos)方法来定位读取位置。
file.seek(4);//设置开始指针位置为4
Tips：如果设置的指针位置超过了文件的字节数长度，那么会默认定位到文件的末尾。

2. 读取文件
打开文件后，即可从该文件中读取数据。
（1）读取一个数据字节：read()
read()函数从该文件的当前指针位置读取一个字节，可以将该字节转化为字符输出，如下：
int c = file.read();
System.out.println((char)c);
每调用一次read()函数，读取的指针就会往后移动一个字节的位置。
（2）读取字节数组：read(byte[] b)
该函数能够一次读取多个字节，读取的长度为字节数组b的长度，如下：
byte[] b = new byte[3];
file.read(b);
String str = new String(b);
System.out.println(str);
（3）灵活读取字节数组：read(byte[] b, int off, int len)
可以使用参数off指定填充数组的起始位置，并使用len指定从文件中讲稿的字节长度，如下：
byte[] b2 = new byte[3];
file.read(b2, 1, 2);
String str2 = new String(b2);
System.out.println(str2);
Tips：len必须不能大于从off开始所剩余的数组的长度，否则会出现数组越界的异常IndexOutOfBoundsException。
（4）读取固定类型的数值 P281
（5）读取一行字符串：readLine()
上面的读取函数都是读入的byte类型的字节，也就是按位读取的。读取文件的一行可以使用readLine()，它返回String类型的字符串，如下：
System.out.println(file.readLine());
（6）读取中文字符：readUTF()
System.out.println(file.readUTF());
//abc.txt
abc=你好
def:天气不错
opq    :    什么


//TestFile.java
package test.file;

import java.io.IOException;
import java.io.RandomAccessFile;

public class TestFile
{
    public static void main(String[] args) throws IOException
    {
        RandomAccessFile file = null;
        try
        {
            file = new RandomAccessFile("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/abc.txt", "r");
            int c = file.read();
            System.out.println((char)c);
            
            byte[] b = new byte[3];
            file.read(b);
            String str = new String(b);
            System.out.println(str);
            
            System.out.println(file.readLine());//当前行剩余字符读取出来，不包含该行已读取的字符
            System.out.println(file.readLine());
        }
        catch (Exception e)
        {
            System.err.println(e.getMessage());
        }
        finally
        {
            if (file != null)
            {
                file.close();
            }
        }
    }
}
输出如下：
a
bc=
????
def:?ì?????í

3. 写入文件 P281
（1）写入一个数据字节：write()
在该文件的当前指针位置写入一个字节，并覆盖原有的字节。如下：
file.write(100);
每调用一次write()函数，读取的指针就会往后移动一个字节的位置。
（2）写入字节数组：write(byte[] b)
一次性写入多个字节，写入的长度为字节数组b的长度。
byte[] bw = new byte[3];
bw[0] = 100;//字符d的ASCII码
bw[1] = 101;//e
bw[2] = 102;//f
file.write(bw);
执行后，会在指针位置写入“def”3个字符。
（3）灵活写入字节数组：read(byte[] b, int off, int len)
可以使用参数off指定写入数组的起始位置，并使用len指定从数组中写入的字节长度。如下：
file.write(bw, 1, 2);//写入从1开始，长度为2的数组，即ef
Tips：len必须不能大于从off开始所剩余的数组的长度，否则会出现数组越界的异常IndexOutOfBoundsException。
（4）写入固定类型的数值
（5）写入一个字符串：writeBytes()与writeChars()
需要写入一个字符串，此时可以使用writeBytes()。如下：
file.writeBytes("AA");
还可以使用writeChars()写入一个字符串，与writeBytes()不同的是，writeChars()写入的每一个字符老师按照双字节写入的，即一个字符占用2个字节。如下：
file.writeChars("DD");
这句话实际上是写入了“DD”4个字节，高位以0填充。
（6）写入中文字符：writeUTF()
file.writeUTF("中国");//写入中文字符

9.3 输入/输出流 P282
Java IO最关键的4个父类是：InputStream（输入字节流）、OutputStream（输出字节流）、Reader（输入字符流）、Writer（输出字符流）。都是public abstract class类。
InputStream、OutputStream对于数据的传送是以字节“byte”为单位的，而Reader和Writer对于数据的传送是以字符“character”为单位的。java.io包中的类大体上可以分为两大类，一类是以byte处理为主的Stream类，它们都是以XXXStream方式命名的；一类是以character处理为主的Read/Writer类，它们都是以XXXReader或XXXWriter的方式命名的。

9.3.1 流的动作原理
所谓流，就是数据的有序排列，而流可以是从某个源（称为流源）出来，到某个目的地去的。
--根据流的方向的不同，可以分成输入流和输出流，一个程序从输入流读取数据向输出流写数据。
--根据流的数据类型不同，又可以分为字节流和字符流，字节流可以实现向字符流的转换。

流处理器所处理的流必定都有流的输入源，而如果将流类所处理的流源分类的话，基本可以分成两大类。
--第一类：数组、String、File等，这一种叫原始流源。
--第二类：同样类型的流用做链接流类的流源，叫链接流源。

9.3.2 输入字节流InputStream P285
1. 字节数组作为输入源――ByteArrayInputStream
ByteArrayInputStream(byte[] buf);
ByteArrayInputStream(byte[] buf, int offset, int length);

//
import java.io.ByteArrayInputStream;
import java.io.IOException;

public class TestByteArrayInputStream
{
    public static void main(String[] args) throws IOException
    {
        byte[] buf = new byte[3];
        buf[0] = 100;
        buf[1] = 101;
        buf[2] = 102;//'f'
        try
        {
            ByteArrayInputStream is = new ByteArrayInputStream(buf);
            
            byte[] b = new byte[3];
            is.read(b);
            System.out.println(new String(b));
            
            is.close();
        }
        catch (IOException e)
        {
            
        }
    }
}
输出如下：
def

从该类的使用实例来看，它只是将字节数组转换为另一个字节数组，从表面上看好像并没有什么实际意义。实际上，它将字节数组转化成了流式读取，这样就可以通过流的方式从内存中读取一个字节，而不需要直接操作数组，这就是转化的好处。同时，它还为字符流提供了输入源。
Tips：对流操作的代码进行了IOException异常的捕捉，凡是涉及输入流、输出流操作的，都需要进行异常捕捉。

2. 文件作为输入源――FileInputStream
FileInputStream从文件系统中的某个文件中获得输入字节，适用于读取如图像数据之类的原始字节流。它可以通过如下的两种方式创建：
FileInputStream(File file);
FileInputStream(String name);

//
import java.io.FileInputStream;
import java.io.IOException;

public class TestFileInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream is = new FileInputStream("D:/Program Files/eclipseJava workspace/LearningProject/dbTest/b.txt");
            while (is.available() > 0)
            {
                int c = is.read();
                System.out.print((char)c);
            }
            
            is.close();
        }
        catch (IOException e)
        {
            
        }
    }
}

3. 对象作为输入源――ObjectInputStream
ObjectOutputStream和ObjectInputStream分别与FileOutputStream和FileInputStream一起使用时，可以为应用程序提供对对象图形的持久存储。
例如，要从由ObjectOutputStream的示例写入的文件中读取数据，可通过如下代码实现：
FileInputStream fis = new FileInputStream("t.tmp");
ObjectInputStream ois = new ObjectInputStream(fis);

int i = ois.readInt();
String today = (String)ois.readObject();
Date date = (Date)osi.readObject();

ois.close();

Tips：由于文件test.tmp是写入类调用ObjectOutputStream写入的对象，每一个对象的写入都是有顺序的，因此这里的读取也必须采用同样的顺序。如果唾弃不一致，将会产生对象类型转换异常java.io.OptionalDataException，这是IOException的子类。

4. 字符串作为输入源――StringBufferInputStream P289
StringBufferInputStream(String s);

5. 管道输入流――PipedInputStream
创建管道输入流的实例时，需要以管道输出流的实例作为输入：
PipedInputStream(PipedOutputStream src);//使其连接到管道输出流
也可以创建一个未连接的管道输入流：
PipedInputStream();//创建尚未连接的PipedInputStream
然后调用PipedInputStream类的connect建立与输出流的连接：
void connect(PipedOutputStream src);//使此管道输入流连接到管道输出流src

//
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class TestPipedInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            PipedOutputStream os = new PipedOutputStream();
            PipedInputStream is = new PipedInputStream(os);
            
            byte[] b = new byte[] {'d', 'e', 'f'};
            os.write(b);
            
            while (is.available() > 0)
            {
                int c = is.read();
                System.out.print((char)c);
            }
            
        }
        catch (IOException e)
        {
            
        }
    }
}
输出如下：
def
Tips：该实例演示了PipedOutputStream的创建和使用。通常管道的使用不像这里的一样，简单地建立流的连接，这样实际上并没有意义。管道流通常用在多线程的系统中，一个线程可以随时往输出流管道写入数据，另一个线程可以随时从输入流管道读取数据，达到异步传输数据。

6. 串联输入源――SequenceInputStream
允许你连接多个InputStream流，表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。
不仅可以串联两个数据源，也可以串联一个Enumeration类型的数据源列表，分别使用下面的构造函数创建：
SequenceInputStream(InputStream s1, InputStream s2);
SequenceInputStream(Enumeration<? extends InputStream> e);
//c.txt中的内容为什么没有显示出来？

import java.io.FileInputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.Enumeration;
import java.util.Vector;

public class TestSequenceInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream fis1 = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/b.txt");
            FileInputStream fis2 = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/c.txt");
            Vector<FileInputStream> vector = new Vector<FileInputStream>();
            vector.add(fis1);
            vector.add(fis2);
            Enumeration<FileInputStream> e = vector.elements();
            
            SequenceInputStream is = new SequenceInputStream(e);
            
            while (is.available() > 0)
            {
                int c = is.read();
                System.out.print((char)c);
            }
            
            is.close();
        }
        catch (IOException e)
        {
            
        }
    }
}
b.txt:
It is a nice day.
How are you?
c.txt:
My name is Han Meimei.
What is your name?

输出如下：
It is a nice day.
How are you?

Tips：串联的数据源列表中，可以包含各种InputStream实现类的数据流对象。

7. 过滤输入流――FilterInputStream P292

8. 缓存输入流――BufferedInputStream
为另一个输入流添加一些功能，即缓存输入的能力。
如果需要一个具有缓存的文件输入流，则应当组合使用FileInputStream和BufferedInputStream，这将会提高读取的效率。
//

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class TestBufferedInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream is = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/b.txt");
            BufferedInputStream bis = new BufferedInputStream(is);
            
            while (bis.available() > 0)
            {
                int c = bis.read();
                System.out.print((char) c);
            }
            
            bis.close();
            is.close();
        }
        catch (IOException e)
        {
            
        }
    }
}
Tips：输入流对象的关闭顺序必须与其创建的顺序相反，后面的输出流也是如此。

9. 数据输入流――DataInputStream

Tips：DataInputStream对于多线程访问不一定是安全的。线程安全是可选的，它由此类方法的使用者负责。

10. 行号输入流――LineNumberInputStream
一般不直接使用此类，而使用其他Stream的嵌套间接对它进行使用，如：
LineNumberInputStream lis = new LineNumberInputStream(new FileInputStream("source"));
要演示的功能是，按照文件的行读取，输出每一行的秸和内容。因此，为了读取一行内容，我们可以通过DataInputStream进行输入流过滤，获得readLine()的功能。
//
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.LineNumberInputStream;

public class TestLineNumberInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream fis = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/b.txt");//文件的最后一行一定要是个空换行符，否则最后一行没有读到换行符，则最后一行的行号不会加1
            LineNumberInputStream lis = new LineNumberInputStream(fis);//此类弃用，不建议使用
            DataInputStream dis = new DataInputStream(lis);
            
            String line;
            while ((line = dis.readLine()) != null)
            {
                System.out.println(lis.getLineNumber() + ":" + line);
            }
            
            dis.close();
            lis.close();
            fis.close();
        }
        catch (IOException e)
        {
            
        }
    }
}
输出如下：
1:It is a nice day.
2:How are you?
3:Hello, world!

Tips：从JDK1.1 开始，对字符流的首选方法是通过新字符流类LineNumberReader进行操作。

11. 推回输入流――PushbackInputStream P295
PushbackInputStream为另一个输入流添加性能，即“推回（pushback）”或“取消读取（unread）”一个字节的能力。在代码片段可以很方便地读取由特定字节值分隔的不定数量的数据字节时，这很有用：在读取终止字节后，代码片段可以“取消读取”该字节，这样，输入流上的下一个读取将会重新读取被推回的字节。
//运行该程序将会重复输出第一个字符。

import java.io.FileInputStream;
import java.io.IOException;
import java.io.PushbackInputStream;

public class TestPushbackInputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream fis = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/b.txt");
            PushbackInputStream pis = new PushbackInputStream(fis);//该类弃用，不建议使用
            
            int c = pis.read();
            System.out.print((char)c);
            
            pis.unread(c);
            c = pis.read();
            System.out.print((char)c);
            
            pis.close();
            fis.close();
        }
        catch (IOException e)
        {
            
        }
    }
}

12. 总结 P296
讲解了11种InputStream的实现，它们的功能各有不同。根据功能，可以分为3类。
（1）根据输入源的不同选用的类
--数组：ByteArrayInputStream
--文件：FileInputStream
--对象：ObjectInputStream
--字符串：StringBufferInputStream
（2）根据流的串联选择的类
--管道：PipeInputStream
--序列：SequenceInputStream
（3）对流进行过滤选择的类
--过滤：FilterInputStream
--缓存：BufferedInputStream
--数据：DataInputStream
--行号：LineNumberInputStream
--推回：PushbackInputStream

根据实际应用的需要，使用最多的是FileInputStream和BufferedInputStream的结合，即在读取文件时使用缓存读取，这样可以提高读取文件的效率。StringBufferInputStream也是一种比较常用的类，通常可能需要我们根据某一个字符串来创建一个输入流。
无论选择哪一种，除了输入源的类之外，其他的类都拥有以InputStream类型为参数的构造函数，即可以对输入流进行多次包装，这样这个流就拥有了多个功能。如程序9-18 ，既需要读取行号，又需要读取一行，因此就使用了三层包装。

9.3.3 输出字节流OutputStream P297
1. 字节数组作为输出流――ByteArrayOutputStream
2. 文件作为输出源――FileOutputStream
3. 对象作为输出源――ObjectOutputStream P299
4. 管道输出流――PipedOutputStream
PipedOutputStream可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入PipedOutputStream对象，并由其他线程从连接的PipedInputStream读取。不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。
package test.file;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class TestPipedOutputStream
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            Sender t1 = new Sender();
            PipedOutputStream out = t1.getOutStream();
            
            Receiver t2 = new Receiver();
            PipedInputStream in = t2.getInputStream();
            
            out.connect(in);
            
            new Thread(t1).start();
            new Thread(t2).start();
        }
        catch (IOException e)
        {
            
        }
    }
}

class Sender extends Thread
{
    private PipedOutputStream out = new PipedOutputStream();
    
    public PipedOutputStream getOutStream()
    {
        return out;
    }
    
    public void run()
    {
        String s = new String("hello, receiver, how are you");
        try
        {
            out.write(s.getBytes());
            out.close();
        }
        catch (IOException e)
        {
            System.out.println(e.getMessage());
        }
    }
}

class Receiver extends Thread
{
    private PipedInputStream in = new PipedInputStream();
    
    public PipedInputStream getInputStream()
    {
        return in;
    }
    
    public void run()
    {
        String s = null;
        byte[] buf = new byte[1024];
        try
        {
            int len = in.read(buf);
            s = new String(buf, 0, len);
            System.out.println("from:\n" + s);
            in.close();
        }
        catch (Exception e)
        {
            System.out.println(e.getMessage());
        }
    }
}
输出如下：
from:
hello, receiver, how are you

运行程序，即可实现发送者线程往接收者线程发送数据的功能，它们分别使用了管道输入流和输出流。

Tips：程序9-23 是管道流应用的常用模式，在多线程的数据流传输中，都离不开这两个类。本例通过两个子线程进行发送和接收，这种模式可以作为以后实际开发中的模板来使用。

5. 过滤输出流――FilterOutputStream P302
6. 缓存输出流――BufferedOutputStream P302
7. 数据输出流――DataOutputStream P303
8. 格式化输出流――PrintStream P304

9. 总结 P307
讲解了8种OutputStream的实现，它们的功能各有不同。根据它们的功能，可以分为3类。
（1）根据输出源的不同选用的类
--数组：ByteArrayOutputStream
--文件：FileOutputStream
--对象：ObjectOutputStream
（2）根据流的串联选择的类
--管道：PipeOutputStream
（3）对流进行过滤选择的类
--过滤：FilterOutputStream
--缓存：BufferedOutputStream
--数据：DataOutputStream
--格式化：PrintStream

9.3.4 输入字符流Reader P307
1. 字符数组作为输入源――CharArrayReader
//
import java.io.CharArrayReader;
import java.io.IOException;

public class TestCharArrayReader
{
    public static void main(String[] args) throws IOException
    {
        char[] buf = new char[] {'a', 'b', 'c'};
        try
        {
            CharArrayReader is = new CharArrayReader(buf);

            char[] b = new char[3];
            is.read(b);
            System.out.println(new String(b));

            is.close();
        }
        catch (IOException e)
        {
            // TODO: handle exception
        }
    }
}
从该类的使用实例来看，它只是将字符数组转换为了字符数组，并没有什么实际意义。实际上，它将字符数组转化成了流式读取，这样就可以通过流式的方式从内存中读取一个字符，而不需要直接数组，这就是转化的好处。

2. 文件作为输入源――FileReader P309
//
import java.io.FileReader;
import java.io.IOException;

public class TestFileReader
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileReader is = new FileReader("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/abc.txt");

            while (is.ready())
            {
                int c = is.read();
                System.out.print((char)c);
            }
            //这里的while写法同下
            // int c;
            // while ((c = is.read()) > 0)
            // {
                // System.out.print((char)c);
            // }
            
            is.close();
        }
        catch (IOException e)
        {
            
        }
    }
}
Tips：该程序能够正确输出中文文，因为FileReader是按照字符读取的；而FileInputStream会输出乱码，因为它是按照字节读取的。所以，如果要读取中文文件，请使用FileReader。

3. 字符串作为输入源――StringReader
4. 管道输入流――PipedReader P310
5. 缓存输入流――BufferedReader P312
如果需要一个具有缓存的文件输入流，则应当组合使用FileReader和BufferedReader，这将会提高读取的效率。
FileReader is = new FileReader("D:/demo/test.txt");
BufferedReader bis = new BufferedReader(is);

6. 行号输入流――LineNumberReader P312
可认为行在遇到以下符号之一时结束：换行符（'\n'）、回车符（'\r'）、回车符后紧跟换行符。
LineNumberReader继承自BufferedReader。
FileReader fis = new FileReader("D:/demo/test.txt");
LineNumberReader lis = new LineNumberReader(fis);
String line;
while((line = lis.readLine()) != null)
{
    System.out.println(lis.getLineNumber() + ":" + line);
}
lis.close;
fis.close;

7. 过滤输入流――FilterReader P313
8. 推回输入流――PushbackReader P313

9. 总结 P314
以上8种Reader的实现，功能各有不同。根据它们的功能，可以分为3类。
（1）根据输入源的不同选用的类
--数组：CharArrayReader
--文件：FileReader
--字符串：StringReader
（2）根据流的串联选择的类
--管道：PipedReader
（3）对流进行过滤选择的类
--过滤：FilterReader
--缓存：BufferedReader
--行号：LineNumberReader
--推回：PushbackReader

9.3.5 输出字符流Writer P315
1. 字符数组作为输出源――CharArrayWriter P316
2. 文件作为输出源――FileWriter
3. 字符串作为输出源――StringWriter
4. 管道输出流――PipedWriter P317
Tips：程序9-37 是管道流应用的常用模式，在多线程的数据流传输中，都离不开这两个类。本例通过两个子线程进行发送和接收，这种模式可以作为以后实际开发中的模板来使用。
5. 过滤输出流――FilterWriter
6. 缓存输出流――BufferedWriter P319
BufferedWriter将文本写入字符输出流，缓存各个字符，从而提供单个字符、数组和字符串的高效写入。该类提供了newLine()方法，它使用平台自己的行分隔符概念，此概念由系统属性line.separator定义。并非所有平台都使用新行符（'\n'）来终止各行，因此调用此方法来终止每个输出行要优于直接写入新行符。
通常Writer将其输出立即发送到底层字符或字节流。除非要求提示输出，否则建议用BufferedWriter包装所有其write()操作可能开销很高的Writer（如FileWriters和OutputStreamWriters）。
//
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class TestBufferedWriter
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileWriter os = new FileWriter("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/test.txt");
            BufferedWriter bos = new BufferedWriter(os);
            
            char[] buf = new char[] {'a', 'b', '中'};
            bos.write(buf);
            bos.newLine();
            bos.write("你好吗？");
            bos.write("hello, world");
            
            bos.close();
            os.close();
        }
        catch (IOException e)
        {
            // TODO: handle exception
        }
    }
}


7. 格式化输出流――PrintWriter P320
package test.file;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;

public class TestPrintWriter
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileWriter fos = new FileWriter("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/test.txt");
            PrintWriter pos = new PrintWriter(fos);
            
            pos.format("%1$tY年%1$tm月%1$td日%1$tH时%1$tm分%1$tS秒", new Date());
            pos.println();
            pos.println(12345);
            pos.println(true);
            pos.println(1000.0f);
            
            pos.close();
            fos.close();
        }
        catch (IOException e)
        {
            // TODO: handle exception
        }
    }
}
生成文件内容如下：
2015年12月05日00时12分11秒
12345
true
1000.0

8. 总结 P321
讲解了7种Writer的实现，功能各不相同。根据功能，分为3类：
（1）根据输出源的不同选用的类
--数组：CharArrayWriter
--文件：FileWriter
--字符串：StringWriter
（2）根据流的串联选择的类
--管道：PipeWriter
（3）对流进行过滤选择的类
--过滤：FilterWriter
--缓存：BufferedWriter
--格式化：PrintWriter

9.3.6 字节流与字符流的转换
以字符为导向的stream基本上有与之相对的以字节为导向的stream。两个对应类实现的功能相同，只是操作时的导向不同。如CharArrayReader和ByteArrayInputStream的作用都是把内存中的一个缓存区作为流使用，所不同的是前者每次从内存中读取一个字符的信息，而后者每次从内存中读取一个字节。（原书此处描述有误，byte字节，char字符）
字节流和字符流之间的区别却可以联系起来。InputStreamReader负责把输入字节流转换为输入字符流，OutputStreamReader负责把输出字节流转换为输出字符流。
1. 字节输入流转换为字符输入流 P322
//
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class TestInputStreamReader
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileInputStream fis = new FileInputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/test.txt");//以字节方式读取文件
            InputStreamReader is = new InputStreamReader(fis);//将读取的字节转换成为字符
            BufferedReader bis = new BufferedReader(is);
            
            while (bis.ready())
            {
                int c = bis.read();
                System.out.print((char)c);
            }
            
            bis.close();
            is.close();
            fis.close();
        }
        catch (IOException e)
        {
            // TODO: handle exception
        }
    }
}

Tips：该程序与直接使用FileReader读取文件内容并使用BufferedReader包装的效果相同，都能够输出带中文的文件内容。但是此处是通过字节流来读取文件的，中间经过了字节流向字符流的转换；而FileReader是通过字符流来读取文件的，没有经过流的转换。所以通过FileReader的方式比该程序中的转换方式效率会高一些。

2. 字节输出流转换为字符输出流 P323
//
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

public class TestOutputStreamWriter
{
    public static void main(String[] args) throws IOException
    {
        try
        {
            FileOutputStream fos = new FileOutputStream("d:/Program Files/eclipseJava workspace/LearningProject/dbTest/test.txt");//以字节的方式写入文件
            OutputStreamWriter os = new OutputStreamWriter(fos);//将字符转换为字节
            BufferedWriter bos = new BufferedWriter(os);
            
            char[] buf = new char[] {'a', 'b', '中'};
            bos.write(buf);
            
            bos.close();
            os.close();
            fos.close();
        }
        catch (IOException e)
        {
            // TODO: handle exception
        }
    }
}
Tips：该程序与直接使用FileWriter写入文件内容并使用BufferWriter包装的效果相同，都能够写入带中文的文件内容。但是此处是通过字节流来写入文件的，中间经过了字符流向字节流的转换；而FileWriter是通过字符流来写入文件的，没有经过流的转换。所以通过FileWriter的方式比该程序中的转换方式效率会高一些。

9.4.3 上机作业 P328
1. 文件编辑器VI
//
package vi;

import java.io.File;
import java.io.RandomAccessFile;
import java.util.Scanner;

public class VI
{
    public static void main(String[] args)
    {
        String pathname = "D:/Downloads";//这里写"D:"，将会解析不到正常的路径，下面的file.getCanonicalPath()会拿到当前程序所在的文件路径
        while (true)
        {
            try
            {
                // String str = System.console().readLine();
                String str = readDataFromConsole();

                if (str.equals("list"))
                {
                    File path = new File(pathname);
                    File[] filelist = path.listFiles();
                    for (File file : filelist)
                    {
                        String filepath = file.getCanonicalPath();
                        if (file.isDirectory())
                        {
                            System.out.println("目录：" + filepath);
                        }
                        else
                        {
                            System.out.println("文件：" + filepath);
                        }
                    }
                }
                else if (str.startsWith("cd"))
                {
                    String[] param = str.split(" ");// 如果文件夹的名字中有空格，这里将没有办法正常解析
                    pathname = param[1];
                }
                else if (str.startsWith("mkdir"))
                {
                    String[] param = str.split(" ");
                    File path = new File(pathname + "/" + param[1]);
                    path.mkdir();
                }
                else if (str.startsWith("vi")) // 追加内容
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    if (!file.exists())
                    {
                        file.createNewFile();
                    }

                    RandomAccessFile afile = new RandomAccessFile(file, "rw");
                    afile.seek(afile.length());
                    afile.writeUTF(param[2]);//写入的文件会带有两个未知符号
                    afile.close();
                }
                else if (str.startsWith("more")) // 显示内容，这里无法支持中文显示
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    RandomAccessFile afile = new RandomAccessFile(file, "rw");
                    String line;
                    while ((line = afile.readLine()) != null)
                    {
                        System.out.println(line);
                    }
                    afile.close();
                }
                else if (str.equals("pwd"))
                {
                    System.out.println(pathname);
                }
                else if (str.equals("bye"))
                {
                    System.exit(0);;
                }
                else
                {
                    System.out.println("输入命令不支持，请输入其它指令：");
                }
            }
            catch (Exception e)
            {
                System.out.println("命令解析有误，请重新输入：");
                e.printStackTrace();
            }
        }
    }

    private static String readDataFromConsole()
    {
        Scanner scanner = new Scanner(System.in);//有个scanner未close的提示
        return scanner.nextLine();
    }
}
运行该程序，可以往文本文件中写入英文字符串，也可以显示英文文本内容，但是不能够写入和显示中文，中文会显示乱码。


2. 字节流文本编辑器 ByteVI.java P331
//
package vi;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.Scanner;

public class ByteVI
{
    public static void main(String[] args)
    {
        String pathname = "D:/Downloads";//这里写"D:"，将会解析不到正常的路径，下面的file.getCanonicalPath()会拿到当前程序所在的文件路径
        while (true)
        {
            try
            {
                // String str = System.console().readLine();
                String str = readDataFromConsole();

                if (str.equals("list"))
                {
                    File path = new File(pathname);
                    File[] filelist = path.listFiles();
                    for (File file : filelist)
                    {
                        String filepath = file.getCanonicalPath();
                        if (file.isDirectory())
                        {
                            System.out.println("目录：" + filepath);
                        }
                        else
                        {
                            System.out.println("文件：" + filepath);
                        }
                    }
                }
                else if (str.startsWith("cd"))
                {
                    String[] param = str.split(" ");// 如果文件夹的名字中有空格，这里将没有办法正常解析
                    pathname = param[1];
                }
                else if (str.startsWith("mkdir"))
                {
                    String[] param = str.split(" ");
                    File path = new File(pathname + "/" + param[1]);
                    path.mkdir();
                }
                else if (str.startsWith("vi")) // 追加内容
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    if (!file.exists())
                    {
                        file.createNewFile();
                    }

                    FileOutputStream os = new FileOutputStream(file, true);//第二个参数append，表示是否追加方式
                    BufferedOutputStream bos = new BufferedOutputStream(os);
                    PrintStream pos = new PrintStream(bos);
                    pos.print(param[2]);
                    
                    pos.close();
                    bos.close();
                    os.close();
                }
                else if (str.startsWith("more")) // 显示内容，这里无法支持中文显示
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    FileInputStream is = new FileInputStream(file);
                    BufferedInputStream bis = new BufferedInputStream(is);
                    
                    while (bis.available() > 0)
                    {
                        int c = bis.read();
                        System.out.print((char)c);
                    }
                    
                    bis.close();
                    is.close();
                }
                else if (str.equals("pwd"))
                {
                    System.out.println(pathname);
                }
                else if (str.equals("bye"))
                {
                    System.exit(0);;
                }
                else
                {
                    System.out.println("输入命令不支持，请输入其它指令：");
                }
            }
            catch (Exception e)
            {
                System.out.println("命令解析有误，请重新输入：");
                e.printStackTrace();
            }
        }
    }

    private static String readDataFromConsole()
    {
        Scanner scanner = new Scanner(System.in);//有个scanner未close的提示
        return scanner.nextLine();
    }
}
运行该程序，可以文本中文件中写入中英文字符串，也可以显示英文文本内容，但不能显示中文内容。能够写入中文是因为PrintStream类的print()函数实现了对中文的写入。

3. 字符流文本编辑器CharVI.java P332
package vi;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Scanner;

public class ByteVI
{
    public static void main(String[] args)
    {
        String pathname = "D:/Downloads";//这里写"D:"，将会解析不到正常的路径，下面的file.getCanonicalPath()会拿到当前程序所在的文件路径
        while (true)
        {
            try
            {
                // String str = System.console().readLine();
                String str = readDataFromConsole();

                if (str.equals("list"))
                {
                    File path = new File(pathname);
                    File[] filelist = path.listFiles();
                    for (File file : filelist)
                    {
                        String filepath = file.getCanonicalPath();
                        if (file.isDirectory())
                        {
                            System.out.println("目录：" + filepath);
                        }
                        else
                        {
                            System.out.println("文件：" + filepath);
                        }
                    }
                }
                else if (str.startsWith("cd"))
                {
                    String[] param = str.split(" ");// 如果文件夹的名字中有空格，这里将没有办法正常解析
                    pathname = param[1];
                }
                else if (str.startsWith("mkdir"))
                {
                    String[] param = str.split(" ");
                    File path = new File(pathname + "/" + param[1]);
                    path.mkdir();
                }
                else if (str.startsWith("vi")) // 追加内容
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    if (!file.exists())
                    {
                        file.createNewFile();
                    }

                    FileWriter fos = new FileWriter(file, true);//第二个参数append，表示是否追加方式
                    BufferedWriter bos = new BufferedWriter(fos);
                    PrintWriter pos = new PrintWriter(bos);
                    pos.print(param[2]);
                    
                    pos.close();
                    bos.close();
                    fos.close();
                }
                else if (str.startsWith("more")) // 显示内容，这里无法支持中文显示
                {
                    String[] param = str.split(" ");
                    File file = new File(pathname, param[1]);

                    FileReader is = new FileReader(file);
                    BufferedReader bis = new BufferedReader(is);
                    
                    String line;
                    while ((line = bis.readLine()) != null)//用readLine函数比一个一个字符读取快
                    {
                        System.out.println(line);
                    }
//                    while (bis.ready())
//                    {
//                        int c = bis.read();
//                        System.out.print((char)c);
//                    }
                    
                    bis.close();
                    is.close();
                }
                else if (str.equals("pwd"))
                {
                    System.out.println(pathname);
                }
                else if (str.equals("bye"))
                {
                    System.exit(0);;
                }
                else
                {
                    System.out.println("输入命令不支持，请输入其它指令：");
                }
            }
            catch (Exception e)
            {
                System.out.println("命令解析有误，请重新输入：");
                e.printStackTrace();
            }
        }
    }

    private static String readDataFromConsole()
    {
        Scanner scanner = new Scanner(System.in);//有个scanner未close的提示
        return scanner.nextLine();
    }
}
运行该程序，既可以往文本文件中写入中英文字符串，又可以显示中英文文本内容。这就是字符流的最大优点，能够实现中文的处理。

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第10课 Java多线程编程 P335
10.1.1 进程与线程的区别 P336
（1）多个进程
每一个进程都可以独立启动，它们都代表一个独立的进程，各自都拥有各自的内存空间，内存空间之间相互独立没有共享，各自也能够并行运行。
（2）多个线程
线程也称为轻型进程（LWP）。线程只能在单个进程的作用域内活动，所以创建线程比创建进程要廉价得多。因为线程允许协作和数据交换，并且在计算资源方面非常廉价，所以线程比进程更可取。
线程，运行在一个进程中，因此它们拥有同一块内存区域，可以共享内存中的数据。它们可以并行执行，但实际上在CPU的调用上是各自分割时间片的，并且是顺序执行的。

10.1 2 线程的概念模型
线程是彼此互相独立的、能独立运行的子任务，并且每个线程都有自己的调用栈。所谓的多任务是通过周期性地将CPU时间片切换到不同的子任务，虽然从微观上看来，单核的CPU上只运行一个子任务，但从宏观来看，每个子任务似乎是同时连续运行的。

多任务是指在一个系统中可以同时运行多个程序，即有多个独立运行的任务，每个任务对应一个进程，同进程一样，一个线程也有从创建、运行到消亡的过程，称为线程的生命周期。用线程的状态（state）表明线程处在生命周期的哪个阶段。线程有创建、可运行、运行中、阻塞、死亡5种状态。通过线程的控制与调用可使线程在这几种状态间转化，每个程序至少自动拥有一个线程，称为主线程。当程序加载到内存时，启动主线程。

10.1.3 线程的运行状态 P337
线程的状态表示线程正在进行的活动及在此时间段内所能完成的任务。线程有创建、可运行、运行中、阻塞、死亡5种状态。一个具有生命的线程，总是处于这5种状态之一。
--新建状态：使用new运算符创建一个线程后，该线程仅仅是一个空对象，系统没有分配资源，称该线程牌创建状态（new thread）。
--可运行状态：使用start()方法启动一个线程后，系统为该线程分配除了CPU外的所需资源，使用该线程处于可运行状态（Runnable）。
--运行状态：Java运行系统通过调度选中一个Runnable的线程，使其占有CPU并转为运行中状态（Running），此时，系统真正执行线程的run()方法。
--阻塞状态：一个正在运行的线程因某种原因不能继续运行时，进入阻塞状态（Blocked）。
--死亡状态：线程结束后是死亡状态（Dead）。

独占方式
分时方式

10.2 线程的开发方法 P338

暂时先不看
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第11课 Java常用实体类 P373
11.1.1 系统类System P373
1. 访问系统属性
System共有两种访问系统属性的方法。
（1）第一种：取得所有系统属性列表 P374

package test.System;

import java.util.Enumeration;
import java.util.Properties;

public class SystemTest
{
    public static void main(String[] args)
    {
        Properties properties = System.getProperties();
        Enumeration<Object> e = properties.keys();
        while (e.hasMoreElements())
        {
            String key = (String)e.nextElement();
            String value = properties.getProperty(key);
            System.out.println(key + "=" + value);
        }
    }
}
输出如下：
java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=E:\Program Files\Java\jre1.8.0_25\bin
java.vm.version=25.25-b02
java.vm.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
path.separator=;
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=CN
user.script=
sun.java.launcher=SUN_STANDARD
sun.os.patch.level=
java.vm.specification.name=Java Virtual Machine Specification
user.dir=D:\Program Files\eclipseJava workspace\LearningProject
java.runtime.version=1.8.0_25-b18
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=E:\Program Files\Java\jre1.8.0_25\lib\endorsed
os.arch=x86
java.io.tmpdir=C:\Users\Ben\AppData\Local\Temp\
line.separator=

java.vm.specification.vendor=Oracle Corporation
user.variant=
os.name=Windows 8.1
sun.jnu.encoding=GBK
java.library.path=E:\Program Files\Java\jre1.8.0_25\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;E:/Program Files/Java/jre1.8.0_25/bin/client;E:/Program Files/Java/jre1.8.0_25/bin;E:/Program Files/Java/jre1.8.0_25/lib/i386;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;e:\Program Files\QuickStart;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;e:\Program Files\Java\jdk1.8.0_25\bin;;c:\;;.
java.specification.name=Java Platform API Specification
java.class.version=52.0
sun.management.compiler=HotSpot Client Compiler
os.version=6.3
user.home=C:\Users\Ben
user.timezone=
java.awt.printerjob=sun.awt.windows.WPrinterJob
file.encoding=GBK
java.specification.version=1.8
java.class.path=D:\Program Files\eclipseJava workspace\LearningProject\bin
user.name=Ben
java.vm.specification.version=1.8
sun.java.command=test.System.SystemTest
java.home=E:\Program Files\Java\jre1.8.0_25
sun.arch.data.model=32
user.language=zh
java.specification.vendor=Oracle Corporation
awt.toolkit=sun.awt.windows.WToolkit
java.vm.info=mixed mode
java.version=1.8.0_25
java.ext.dirs=E:\Program Files\Java\jre1.8.0_25\lib\ext;C:\Windows\Sun\Java\lib\ext
sun.boot.class.path=E:\Program Files\Java\jre1.8.0_25\lib\resources.jar;E:\Program Files\Java\jre1.8.0_25\lib\rt.jar;E:\Program Files\Java\jre1.8.0_25\lib\sunrsasign.jar;E:\Program Files\Java\jre1.8.0_25\lib\jsse.jar;E:\Program Files\Java\jre1.8.0_25\lib\jce.jar;E:\Program Files\Java\jre1.8.0_25\lib\charsets.jar;E:\Program Files\Java\jre1.8.0_25\lib\jfr.jar;E:\Program Files\Java\jre1.8.0_25\classes
java.vendor=Oracle Corporation
file.separator=\
java.vendor.url.bug=http://bugreport.sun.com/bugreport/
sun.io.unicode.encoding=UnicodeLittle
sun.cpu.endian=little
sun.desktop=windows
sun.cpu.isalist=pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86

（2）取得某一个系统属性的值 P376
如果知道要查询特性系统属性的值，可以直接使用System.getProperties(key)直接取得该键的值。如下：
package test.System;

public class SystemTest
{
    public static void main(String[] args)
    {
        String osname = System.getProperty("os.name");
        String osversion = System.getProperty("os.version");
        String javaname = System.getProperty("java.vm.name");
        String javaversion = System.getProperty("java.version");
        System.out.println("操作系统名称=" + osname);
        System.out.println("操作系统版本=" + osversion);
        System.out.println("JVM名称=" + javaname);
        System.out.println("Java版本=" + javaversion);
    }
}
输出如下：
操作系统名称=Windows 8.1
操作系统版本=6.3
JVM名称=Java HotSpot(TM) Client VM
Java版本=1.8.0_25

这几个值在上面的列表都出现过。
如果查找的系统属性的键不存在，将返回null值，此时可以使用下面的函数来设置变量不存在时的默认值：
String osname = System.getProperty("os.name", "Windows XP");
第二个参数即为不存在时返回的默认值。
除了查询，还可以修改这个值，如：
System.setProperty("java.version2", "aa");
该函数设置的值并不会写入操作系统，只会对当前运行程序后面执行的代码产生影响。如果该函数放在getProperties()前你会发现列表中有该属性，如果放在它之后，列表中就没有。
除此之外，还可以一次性设置多个属性：
System.setProperties(Properties props);
输入的值props是一个Properties类型的变量即可。
还可以移除指定键指示的系统属性，如：
System.clearProperties("java.version2");

当然，除了查询外，修改和删除我们通常不使用，只有在做Java安装程序这一类特殊程序时才会使用到。

package test.System;

public class SystemTest
{
    public static void main(String[] args)
    {
        String javaversion2 = System.getProperty("java.version2", "no key");
        System.out.println("Java版本2=" + javaversion2);
        
        System.setProperty("java.version2", "aa");
        javaversion2 = System.getProperty("java.version2");
        System.out.println("Java版本2=" + javaversion2);
        
        System.clearProperty("java.version2");
        javaversion2 = System.getProperty("java.version2", "no key");
        System.out.println("Java版本2=" + javaversion2);
    }
}
输出如下：
Java版本2=no key
Java版本2=aa
Java版本2=no key

2. 访问环境变量 P377
有两种访问系统环境变量的方法。
（1）第一种：取得所有环境变量列表
使用System.getenv()函数将取得一个Map对象，该对象包含了所有环境变量的键值对。
package test.System;

import java.util.Iterator;
import java.util.Map;

public class TestSystemEnv
{
    public static void main(String[] args)
    {
        Map<String, String> map = System.getenv();
        Iterator<String> it = map.keySet().iterator();
        while (it.hasNext())
        {
            String key = it.next();
            String value = map.get(key);
            System.out.println(key + "=" + value);
        }
    }
}
输出如下：
USERDOMAIN_ROAMINGPROFILE=DESKTOP-18O9S0P
LOCALAPPDATA=C:\Users\Ben\AppData\Local
PROCESSOR_LEVEL=6
COMMANDER_EXE=E:\Program Files\TotalCMD64\Totalcmd64.exe
COMMANDER_DRIVE=E:
USERDOMAIN=DESKTOP-18O9S0P
FPS_BROWSER_APP_PROFILE_STRING=Internet Explorer
LOGONSERVER=\\MicrosoftAccount
#envTSLOGsss19592=148315072
SESSIONNAME=Console
ALLUSERSPROFILE=C:\ProgramData
PROCESSOR_ARCHITECTURE=x86
VS120COMNTOOLS=D:\Program Files\Microsoft Visual Studio 12.0\Common7\Tools\
PSModulePath=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\;C:\Program Files\Intel\
SystemDrive=C:
COMMANDER_INI=E:\Program Files\TotalCMD64\wincmd.ini
APPDATA=C:\Users\Ben\AppData\Roaming
MOZ_PLUGIN_PATH=E:\Program Files\Foxit Software\Foxit Reader\plugins\
USERNAME=Ben
ProgramFiles(x86)=C:\Program Files (x86)
CommonProgramFiles=C:\Program Files (x86)\Common Files
Path=E:/Program Files/Java/jre1.8.0_25/bin/client;E:/Program Files/Java/jre1.8.0_25/bin;E:/Program Files/Java/jre1.8.0_25/lib/i386;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;e:\Program Files\QuickStart;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;e:\Program Files\Java\jdk1.8.0_25\bin;;c:\;
FPS_BROWSER_USER_PROFILE_STRING=Default
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC
OS=Windows_NT
PROCESSOR_ARCHITEW6432=AMD64
COMPUTERNAME=DESKTOP-18O9S0P
PROCESSOR_REVISION=5e03
CLASSPATH=.;c:\Program Files\Java\jdk1.8.0_25\lib;
CommonProgramW6432=C:\Program Files\Common Files
ComSpec=C:\Windows\system32\cmd.exe
ProgramData=C:\ProgramData
ProgramW6432=C:\Program Files
COMMANDER_PATH=E:\Program Files\TotalCMD64
HOMEPATH=\Users\Ben
SystemRoot=C:\Windows
TEMP=C:\Users\Ben\AppData\Local\Temp
HOMEDRIVE=C:
PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 94 Stepping 3, GenuineIntel
USERPROFILE=C:\Users\Ben
TMP=C:\Users\Ben\AppData\Local\Temp
CommonProgramFiles(x86)=C:\Program Files (x86)\Common Files
ProgramFiles=C:\Program Files (x86)
PUBLIC=C:\Users\Public
NUMBER_OF_PROCESSORS=8
windir=C:\Windows
=::=::\

这些环境变量的值可以通过Windows的系统环境变量设置来修改。

（2）第二种：取得某一个属性变量的值
如果知道要查询环境变量键，可以直接使用System.getenv(key)直接取得该键的值。如下所示：
package test.System;

public class TestSystemEnv
{
    public static void main(String[] args)
    {
        String javahome = System.getenv("JAVA_HOME");
        String path = System.getenv("PATH");
        String classpath = System.getenv("CLASSPATH");
        System.out.println("javahome=" + javahome);
        System.out.println("path=" + path);
        System.out.println("classpath=" + classpath);
    }
}
输出如下：
javahome=null
path=E:/Program Files/Java/jre1.8.0_25/bin/client;E:/Program Files/Java/jre1.8.0_25/bin;E:/Program Files/Java/jre1.8.0_25/lib/i386;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;e:\Program Files\QuickStart;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;e:\Program Files\Java\jdk1.8.0_25\bin;;c:\;
classpath=.;c:\Program Files\Java\jdk1.8.0_25\lib;

3. 加载文件和库 P379
如果需要加载动态库文件名或系统库，可以使用下面的函数。
--函数load(String filename)的作用是，从作为动态库的本地文件系统中以指定的文件名加载代码文件，文件名参数必须是完整的路径名，调用System.load(name)实际上等效于调用：
Runtime.getRuntime().load(name);
例如：
System.load("/home/avh/lib/libX11.so");
Runtime.getRuntime().load("/home/avh/lib/libX11.so");
--函数loadLibrary(String libname)的作用是，加载由libname参数指定的系统库，将库名映射到实际系统库的方法取决于系统，调用System.loadLibrary(name)实际上等效于调用：
Runtime.getRuntime().loadLibrary(name);
方法System.loadLibrary(String)是调用此方法的一种传统而便捷的方式。如果在某个类实现中使用本机方法（JNI调用），则标准的策略是将本机代码放入一个库文件中（称为LibFile），然后在类声明放入一个静态的初始值设定值：
static {
    System.loadLibrary("LibFile");
}
当加载并初始化这个类时，也将加载实现本机方法所需的本机代码。如果用相同库名多次调用此方法，则忽略第二次及后续的调用。

4. 快速复制数组 P380
可能使用System的函数arraycopy()快速地进行数组复制。
void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
如果dest为null，则抛出NullPointerException异常。
如果src为null，则抛出NullPointerException异常，并且不会修改目标数组。

package test.System;

public class TestSystemArrayCopy
{
    public static void main(String[] args)
    {
        int[] a = new int[10];
        for (int i = 0; i < 10; ++i)
        {
            a[i] = i + 1;
        }
        
        int[] b = new int[5];
        System.arraycopy(a, 2, b, 1, 4);
        
        for(int i = 0; i < 5; ++i)
        {
            System.out.println("b" + "=" + b[i]);
        }
    }
}
输出如下：
b=0
b=3
b=4
b=5
b=6

5. 取得系统时间 P381
System还有一个最常用的函数，就是取得当前系统时间的函数System.currentTimeMillis()。该函数返回的是毫秒时间，是一个long型整数，例如1221960727312。
该函数在进行系统性能监控时最常用到。可以在监控的前面和后面分别添加该函数，以计算这段代码执行的毫秒级时间，比如：
long start = System.currentTimeMillis();
//要监控的代码段
long end = System.currentTimeMillis();
System.out.print(end - start);
两个变量start和end，可以计算出执行的时间长度，这两个变量必须在同一个函数中，有时要监控的代码分布在各个类中，这时可以直接使用下面的代码输出该代码执行的时刻时间：
System.out.println("当前时间……" + System.currentTimeMillis());
会在程序执行的过程中输出一系列时间，可以看出在哪些代码执行的进度是多少，分析出哪一段代码执行的时间长。

除此之外，还可以使用System.nanoTime()返回最精确的可用系统计时器的当前值，以毫微秒为单位。此方法只能用于测量已过的时间。
如，测试某些代码执行的时间长度：
long startTime = System.nanoTime();
//...
long estimatedTime = System.nanoTime() - startTime;
可见，System.nanoTime()比System.currentTimeMillis()更精确。

//P382
package test.System;

public class TestSystemTime
{
    public static void main(String[] args)
    {
        long startMillisTime = System.currentTimeMillis();
        long startNanoTime = System.nanoTime();
        System.out.println("startMillisTime=" + startMillisTime);
        System.out.println("startNanoTime=" + startNanoTime);
        
        int[] a = new int[10];
        for (int i = 0; i < 10; ++i)
        {
            a[i] = i + 1;
        }
        
        int[] b = new int[5];
        System.arraycopy(a, 2, b, 1, 4);
        
        for(int i = 0; i < 5; ++i)
        {
            System.out.println("b" + "=" + b[i]);
        }
        long endMillisTime = System.currentTimeMillis();
        long endNanoTime = System.nanoTime();
        System.out.println("endMillisTime=" + endMillisTime);
        System.out.println("endNanoTime=" + endNanoTime);
        
        System.out.println("MillisTime: " + (endMillisTime - startMillisTime));
        System.out.println("NanoTime:" + (endNanoTime - startNanoTime));
    }
}
输出如下：
startMillisTime=1457859199354
startNanoTime=11571300768943
b=0
b=3
b=4
b=5
b=6
endMillisTime=1457859199356
endNanoTime=11571300995050
MillisTime: 2
NanoTime:226107

6. 系统退出命令 P383 
System.exit(int status)用来终止当前正在运行的Java虚拟机。非0状态码表示异常终止。该方法调用Runtime类中的exit()方法。可以调用System.exit(0)来正常退出系统。
package test.System;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class TestSystemExit
{
    public static void main(String[] args)
    {
        try
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String line;
            while ((line = br.readLine()) != null)
            {
                System.out.println(line);
                if (line.equals("bye"))
                {
                    System.exit(0);
                }
            }
            br.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
Tips：System.exit(0)换成break也能够退出。System.exit(0)的作用不止这一种情况，在复杂的Java应用程序中，它可以强制所有的程序都退出系统，这就是它与使用break不同的地方。

7. 执行垃圾回收 P384
System.gc()用于运行垃圾回收器。
调用System.gc()实际上等效于调用：
Runtime.getRuntime().gc();
Tips：切不可在代码中频繁地调用垃圾回收。

11.1.2 运行时类Runtime P385
System的很多函数都等价于Runtime.getRuntime()，实际上System是依赖于Runtime类的。
Runtime类不同于System类，它的函数大部分都不是静态的，只有一个静态函数getRuntime()。每个Java应用程序都有一个Runtime类实例，使应用程序能够与其运行的环境相连接，可以通过该函数取得一个Runtime的实例，应用程序不能创建自己的Runtime类实例，然后再调用该类的其他函数。
（1）查看系统内存
package test.Runtime;

public class TestRuntimeMemory {
    public static void main(String[] args) {
        System.out.println("内存总量：" + Runtime.getRuntime().totalMemory());
        System.out.println("最大内存量：" + Runtime.getRuntime().maxMemory());
        System.out.println("空闲内存量：" + Runtime.getRuntime().freeMemory());
    }
}
输出如下：
内存总量：16252928
最大内存量：259522560
空闲内存量：15470896
这里内存数值单位是字节byte

（2）终止JVM虚拟机
使用exit(int status)通过启动虚拟机的关闭序列，终止当前正在运行的Java虚拟机。还有一个方法halt(int status)，用来强行终止正在运行的Java虚拟机。
halt()方法是强制性、不安全的，通常建议使用exit()，只有在迫不得已的情况下才使用halt()，如网络连接断掉这种不可控因素。

（3）运行系统程序
打开记事本：
package test.Runtime;

public class TestRuntimeExec {
    public static void main(String[] args) {
        try {
            Runtime.getRuntime().exec("notepad");
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}

打开word：
Runtime.getRuntime().exec("cmd /c start Winword");

执行批处理：通过批处理文件来执行一系列的任务，如执行Ant脚本等，对于编写的脚本文件run.bat，可以使用下面方式运行。
Runtime.getRuntime().exec("cmd.exe /C start d:/demo/run.bat");

还可以使用Process类的waitFor()函数来等待当前进程的执行，如有必要，一直要等到由该Process对象表示的进程已经终止。如下所示，可以根据10.2.1 节一行获得进程的输入流，等待进程运行结束后再继续Java主线程的运行：
Process p = Runtime.getRuntime().exec("d:/demo/run.bat");
InputStream in = p.getInputStream();
String line = null;
BufferedReader reader = new BufferedReader(new InputStreamReader(in));
while ((line = reader.readLine()) != null) {
    System.out.println(line);
}
in.close();
p.waitFor(); //等待进程结束

这在实际的开发中是需要的。如编写了一个Ant脚本，用来编译一批Java类，只有编译结束后，才能够继续执行下面的代码，来调用刚才Ant脚本编译后的class类文件，显然必须等待进程结束后才能够继续执行。

（4）使用关闭钩子 P386
关闭钩子应该快速地完成其工作，当程序调用exit时，虚拟机应该迅速地关闭并退出。由于用户注销或系统关闭而终止虚拟机时，底层的操作系统可能只允许在固定的时间内关闭并退出。因此在关闭钩子中尝试进行任何经用户交互或执行长时间的计算都是不明智的。
如下程序演示了添加关闭钩子的方法，在方法addShutDownHook()中定义了一个匿名内部类，其函数体run()中可以用来编写系统退出进需要执行的代码，比如系统数据的缓存等。
package test.Runtime;

import java.util.Scanner;

public class TestRuntimeHook {
    public static void main(String[] args) {
        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                System.out.println("系统正在退出……");
            }
        });

        while (true) {
            String line = readDataFromConsole();
            System.out.println(line);
            if (line.equals("bye")) {
                System.exit(0);
            }
        }
    }
    
    private static String readDataFromConsole()
    {
        Scanner scanner = new Scanner(System.in);//有个scanner未close的提示
        return scanner.nextLine();
    }
}

11.2 Java字符串处理类 P388 
大量字符串实例的随意创建，给系统的效率带来了很大问题。
做测试，对比String类和StringBuffer的执行效率。
package test.Str;

public class TestStringProficience {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        String str = "";
        for (int i = 0; i < 10000; ++i) {
            str += "," + i;
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
输出如下：
139
耗时139ms

package test.Str;

public class TestStringProficience {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        StringBuffer str = new StringBuffer();
        for (int i = 0; i < 10000; ++i) {
            str.append(",").append(i);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
输出如下：
1
耗时1ms

11.2.1 字符串类String P389
字符串是常量，它们的值在创建之后不能更改，字符串缓存区支持可变的字符串，因为String对象是不可变的，所以可以共享。
字符串的字义很简单，直接给一个字符串类型的变量赋值即可，如：
String str = "abc";
等价于：
char data[] = {'a', 'b', 'c'};
String str = new String(data);

String类包括的方法可用于检查字符串的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符串转换为大写或小写。
（1）提取单个字符
String str = "hello, world!";
System.out.println(str.charAt(10));

（2）提取子字符串
System.out.println(str.substring(1));//取到末尾
System.out.println(str.substring(0, 4));//取到索引endIndex - 1处，因为，该子字符串的长度为endIndex - beginIndex
为确保endIndex不越界，可以使用下面函数取得字符串长度：
int length();
再根据长度查找：substring(0, str.length() - 1);

（3）比较字符串
boolean equals(Object anObject);
boolean equalsIgnoreCase(String str);
Tips：
equals()用来比较两个字符串的值，而不是比较其对象是否相同。如果使用==比较两个字符串对象a==b，那么只有在这两个实例指向同一个字符串对象时才返回true。
//一个测试程序如下：
package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        String str2 = "hello";
        System.out.println(str == str2);//true
        
        StringBuffer sb = new StringBuffer();
        sb.append(str);
        String strFromSb = sb.toString();
        
        System.out.println(str == strFromSb);//false
        System.out.println(str.equals(strFromSb));//true
    }
}

有时可能比较两个字符串的大小，以便进行排序，可以使用如下两个函数：
int compareTo(String anotherString); //按字典顺序比较两个字符串
int compareToIngoreCase(String str); //忽略大小写

package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        String str2 = "helln";
        String str3 = "hellp";
        System.out.println(str.compareTo(str2));//1，可以简单的理解为用方法调用的字符串去减参考字符串，o比n大1，减的结果为1
        System.out.println(str.compareTo(str3));//-1，o比p小1，减的结果为-1
    }
}
比较结果为一个整数，有3种情况：
--按字典顺序此String对象位于参数字符串之前，则比较结果为一个负整数。
--按字典顺序此String对象位于参数字符串之后，则比较结果为一个正整数。
--两个字符串相等，则结果为0；compareTo只在方法equals(Object)返回true时才返回0。
（4）定位字符串
startsWith
endsWith

package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        System.out.println(str.startsWith("he"));//true
        System.out.println(str.startsWith("ll", 0));//false
        System.out.println(str.startsWith("ll", 2));//true
        System.out.println(str.endsWith("lo"));//true，只有一种形式，没有带offset的形式
    }
}

使用下面函数，取得指定字符或字符串在原有字符串中的位置：
indexOf
lastIndexOf

如果索引值为-1 ，表示不包含该字符或子字符串。
//
package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        System.out.println(str.indexOf('e'));//1
        System.out.println(str.indexOf("l"));//2
        System.out.println(str.indexOf("l", 3));//3
    }
}

（5）匹配字符串 P390
有一个更通用的函数，可以根据正则表达式来进行匹配：
boolean matches(String regex);//告知此字符串是否匹配给定的正则表达式

Tips：
正则表达式的写法将在第13课中讲解。

（6）拆分字符串
将字符串按照某一个子字符串分为一个字符串数组，可以使用函数：
String[] split(String regex);//根据给定正则表达式的匹配拆分此字符串
//
package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        String strArray[] = str.split("e");
        for (String s : strArray) {
            System.out.println(s);
        }
    }
}
输出如下：
h
llo

（7）替换字符串
replace
replaceAll
replaceFirst

//
package test.Str;

public class TestString {
    public static void main(String[] args) {
        String str = "hello";
        System.out.println(str.replace('e', 'c'));
        System.out.println(str.replaceAll("e", "f"));
        System.out.println(str.replaceFirst("l", "m"));
    }
}

（8）转换大小写
String toLowerCase();
String toUpperCase();

（9）格式化输出
String类还提供了两个静态函数，用来对字符串进行格式化输出：
static String format(Locale l, String format, Ojbect... args);//使用指定的语言环境、格式字符串和参数返回一个格式化字符串
static String format(String format, Object...args);//使用指定的格式字符串和参数返回一个格式化字符串
该格式化函数与格式化输出流PrintStream和PrintWriter用法相同。静态方法，可以直接引用，下面举一个例子：
//
package test.Str;

import java.util.Date;

public class TestString {
    public static void main(String[] args) {
        String str = String.format("%1$tY年%1$tm月%1$td日 %1$tH时%1$tm分%1$tS秒", new Date());
        System.out.println(str);
    }
}
输出如下：
2016年06月10日 18时06分30秒

11.2.2 字符串分隔类StringTokenizer P391
//
package test.Str;

import java.util.StringTokenizer;

public class TestString {
    public static void main(String[] args) {
        StringTokenizer st = new StringTokenizer("this is a test");
        while (st.hasMoreTokens()) {
            System.out.println(st.nextToken());
        }
    }
}
输出如下：
this
is
a
test

StringTokenizer是出于兼容性的原因而被保留的遗留类（虽然在新代码中并不鼓励使用它），建议所有寻求此功能的人使用String的split()方法或java.util.regex包。
//用String.split()方法，输出同上
package test.Str;

public class TestString {
    public static void main(String[] args) {
        String[] result = "this is a test".split("\\s");
        for (int i = 0; i < result.length; ++i) {
            System.out.println(result[i]);
        }
    }
}

11.2.3 线程安全的可变字符串类StringBuffer P392
StringBuffer是一个线程安全的可变字符串类，类似于String的字符串，不同的是它通过某些方法调用可以改变该序列的长度和内容。它可将字符串缓存区安全地用于多个线程，可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。
StringBuffer();
StringBuffer(String str);
StringBuffer上的主要操作是append()和insert()方法。append()方法始终将这些字符添加到缓存区的末端；而insert()方法则在指定的点添加字符。
//
package test.Str;

public class TestString {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("abc");
        sb.insert(2, "def");
        System.out.println(sb);//abdefc
    }
}
append可以添加boolean,char,char[]（以及带偏移量的）,CharSequence（int start, int end）,double,float,int,long,Object,String。insert拥有同样类型的列表。
同样的，可以使用下面的方法删除一个或多个字符
StringBuffer deleteCharAt(int index);
StringBuffer delete(int start, int end);//删除从start到end-1位置的字符

StringBuffer sb = new StringBuffer("abc");
sb.deleteCharAt(1);//不需要赋值，也可以赋值
System.out.println(sb);//ac

除此之外，StringBuffer还拥有与String同样的函数，如charAt(),indexOf(),lastIndexOf(),substring(),replace()等，它还提供了函数toString()来转化为String对象。

11.2.4 可变字符串类StringBuilder P393
StringBuilder是一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步。该类被设计用做StringBuffer的一个简易替换，用在字符串缓存区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，这比StringBuffer要快。
在StringBuilder上的主要操作是append()和insert()方法，可重载这些方法，以接受任意类型的数据。
如果builder引用StringBuilder的实例，则builder.append(x)和builder.insert(builder.length(), x)具有相同的效果。每个字符串生成器都有一定的容量，只要字符串生成器所包含的字符序列的长度没有超出此容量，就无须分配新的内部缓存区。如果内部缓存区溢出，则此容量自动增大。
Tips：
将StringBuilder的实例用于多个线程是不安全的。如果需要在多个线程中使用字符串，则建议使用StringBuffer。

11.2.5 选择String、StringBuffer与StringBuilder
三者最大的区别如下：
--String是字符串常量
--StringBuffer是字符串变量（线程变量）
--StringBuilder是字符串变量（非线程安全）
简单地说，String类型和StringBuffer类型的主要性能区别其实在于，String是不可变的对象，因此在每次对String类型进行改变的时候，其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，速度是一定会相当慢的。
如果是使用StringBuffer类，结果就不一样了，每次结果都会对StringBuffer对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用StringBuffer，特别是字符串对象经常改变的情况下。而在某些特别情况下，String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会StringBuffer对象慢，而特别是以下字符串对象生成，String对象效率是远要比StringBuffer快的：
String str = "This is only a" + " simple" + " test";
StringBuffer builder = new StringBuffer("This is only a").append(" simple").append(" test");
生成str对象的速度简直太快了，而这个时候StringBuffer居然速度上根本一点都不占优势。其实这是JVM的一个把戏，实际上：
String str = "This is only a" + " simple" + " test";
就是：
String str = "This is only a simple test";
让你以不需要太多的时间。但要注意的是，如果字符串是来自另外的String对象的话，速度就没那么快了，如：
String str2 = "This is only a";
String str3 = " simple";
String str2 = " test";
String str2 = str2 + str3 + str4;

对于这3个类的使用，按照以下情况去选择：
--如果你偶尔对简单的字符串常量进行拼接，那么可以使用String，它足够简单而且轻量级。
--如果你需要经常进行字符串拼接、累加操作，请使用StringBuffer或StringBuilder。
--如果是在单线程的环境中，建议使用StringBuilder，它要比StringBuffer快；如果是在多线程的环境中，建议使用StringBuffer，它是线程安全的。
因此，StringBuilder实际上是我们的首选，只有在多线程时才可以考虑使用StringBuffer，只有在字符串的拼接足够简单时才使用String。

11.3 Java日期处理类 P396
11.3.1 日期类 Date
（1）创建日期
package test.Date;

import java.util.Date;

public class TestDate {
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date);
        
        long cur = System.currentTimeMillis();
        Date date2 = new Date(cur);
        System.out.println(date2);
    }
}
输出如下：
Mon Jun 13 23:21:39 CST 2016
Mon Jun 13 23:21:39 CST 2016
（2）修改日期
（3）比较日期
（4）输出日期
默认实现了一个toString函数

11.3.2 日期格式化类SimpleDateFormat P397
ToRead

11.3.3 日历类Calendar P399
ToRead

11.4 Java数字处理类P400
11.4.1 数学函数类 Math P401
Math类包含用于执行基本数学运算的方法，如初等指数、对象、平方根和三角函数。提供了一系列的静态方法，用来执行各种数学函数，它提供的数学函数列表如下：
--绝对值函数
--最大值和最小值函数
--取整函数
--弦与切函数
--幂与开方函数
--对数函数
--角度函数
--随机函数

11.4.2 随机数类 Random P402
new Random();
Random(long seed);
Tips：使用种子创建的随机生成器，可以在每次设置不同的种子，这样就会产生不同的随机数生成器，保证不会出现相同顺序的随机数，通常我们会使用系统的当前时间毫秒数作为种子。
Random(System.currentTimeMillis());

可以使用下面函数产生各种类型的数据：
--整型数
--浮点数
--布尔值
--字节数组

很多应用程序使用Math.random()，该方法更易于使用，生成的是double数值，如：
public class TestMath {
    public static void main(String[] args) {
        System.out.println(Math.random());
    }
}
输出如下：
0.3454156494983418
将该数值乘以一个大的数值将它变为整数，即可作为整数随机数来使用。

11.4.3 基本数据类型转换 P403
Java提供了8种基本数据类型，同样，Java也为这些基本数据类型提供了相应的对象数据类型：
基本数据类型：
byte
short
int
long
float
double
char
boolean
对象数据类型：
Byte
Short
Integer
Long
Float
Double
Character
Boolean

这8种数据类型，除了Charater和Boolean不是数字外，其它的都是数字，因为Java为它们的这一共性提供了一个抽象的父类Number。
抽象类Number是BigDecimal、BigInteger、Byte、Double、Float、Integer、Long和Short类的超类，其中BigDecimal和BigInteger分别表示不可变的，任意精度的有符号十进制数和整数。在这些子类中，最常使用的是Double、Float、Integer、Long这4个类，通常需要使用它们来将字符串转换为浮点型或整型数值。
（1）根据字符串转换浮点数
Double类提供了一个静态的parse方法，Float类也提供了一个静态的parse方法。
package test.Number;

public class TestNumber {
    public static void main(String[] args) {
        double d = Double.parseDouble("123.456");
        float f = Float.parseFloat("123.456");
        System.out.println(d);
        System.out.println(f);
    }
}
输出如下：
123.456
123.456

（2）根据字符串转换整型数
Long类和Integer类，也都提供了一个静态的parse函数来将字符串转化为long和int类型数值：
package test.Number;

public class TestNumber {
    public static void main(String[] args) {
        long l = Long.parseLong("123456");
        int i = Integer.parseInt("123");
        System.out.println(l);
        System.out.println(i);
    }
}
输出如下：
123456
123

Integer类还提供了转换为二进制、八进制和十六进制的函数
package test.Number;

public class TestNumber {
    public static void main(String[] args) {
        String binaryStr = Integer.toBinaryString(10);
        System.out.println(binaryStr);
        
        String octalStr = Integer.toOctalString(10);
        System.out.println(octalStr);
        
        String hexStr = Integer.toHexString(10);
        System.out.println(hexStr);
    }
}
输出如下：
1010
12
a
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第12课 Java常用集合类 P407
12.1 集合类概述 P408
12.1.1 Iterator与Enumeration P408
1. 枚举（Enumeration）接口
Enumeration接口定义了可以对一个对象的类集中的元素进行枚举（一次获得一个）的方法。已经被Iterator所替代，对于新程序来说是过时的，然而它仍被几种从以前版本遗留下来的类（例如Vector、Hashtable和Properties）所定义的方法使用。
要查看Vector中的所有对象，一个办法是用Vector的get(int index)方法，不过这样效率比较低，另一个方法是用Vector的elements()方法返回一个Enumeration对象。
//
import java.util.Enumeration;
import java.util.Vector;

public class TestEnum {
    static public void main(String args[]) {
        Vector<String> strVec = new Vector<>();
        strVec.add("hello");
        strVec.add("world");
        strVec.add("nice day");

        Enumeration<String> enumeration = strVec.elements();
        while (enumeration.hasMoreElements()) {
            String s = enumeration.nextElement();
            System.out.println(s);
        }
    }
}
输出如下：
hello
world
nice day

2. 迭代器（Iterator）接口
推荐使用Iterator对Collection集合进行迭代。迭代器代替了Java集合框架（Java Collections Framework）中的Enumeration。
Collection接口中定义了iterator()方法，用于返回在此Collection的元素上进行迭代的迭代器。
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

public class TestEnum {
    static public void main(String args[]) {
        Vector<String> strVec = new Vector<>();
        strVec.add("hello");
        strVec.add("world");
        strVec.add("nice day");

        Iterator<String> iter = strVec.iterator();
        while (iter.hasNext()) {
            String s = iter.next();
            System.out.println(s);
        }
    }
}
输出如下：
hello
world
nice day

import java.util.Iterator;
import java.util.Vector;

public class TestEnum {
    static public void main(String args[]) {
        Vector<String> strVec = new Vector<>();
        strVec.add("hello");
        strVec.add("world");
        strVec.add("nice day");

        Iterator<String> iter = strVec.iterator();
        while (iter.hasNext()) {
            String s = iter.next();
            if (s.equals("world")) {
                iter.remove();
            }
        }
        System.out.print(strVec);
    }
}
输出如下：
[hello, nice day]

Tips：从使用方法上来看Iterator与Enumeration类似。Iterator添加了一个可选的移除操作，并使用较短的方法名。新实现应该优先考虑使用Iterator接口。

12.1.2 Collections与Collection P409
--Collection是个java.util下的接口，提供了对集合对象进行基本操作的通用接口方法。在Java类库中有很多具体的实现，接口的意义是为各种具体的集合提供了最大化的统一操作方式。
--Collections是个java.util下的实体类，它包含有各种有关集合操作的静态方法，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作，就像一个工具类，服务于Java的Collection框架。
因此，Collections是对Collection集合类进行各种操作的服务类。
1. Collection
该接口为其实现类提供了统一的操作接口方法。
--新增一个或多个元素
add
addAll
--删除一个或多个元素
remove
removeAll
clear
isEmpty
size
--判断是否包含一个或多个元素
contains
containsAll
--产生元素集体的数组对象
iterator
toArray
<T>T[] toArray(T[] a);//返回数组的运行时类型与指定数组的运行时类型相同
实现该接口的子类都可以使用这些函数

2. Collections
Collections完全由在Collection上进行或返回Collection的静态方法组成。它包含在Collection上操作的多态算法，即“包装器”，包装器返回由指定Collection支持的新Collection，以及少数其他内容。
该类提供了一系列功能的静态操作函数。
--新增：
boolean addAll(Collection<? super T> c, T...elements);
--填充：
void fill(List<? super T> list, T obj);//使用指定元素替换指定列表中的所有元素
--复制
void copy(list<? super T> dest, List<? super T> src);
--替换
boolean replaceAll(List<T> list, T oldVal, T newVal);
--排序
void sort(List<T> list);
void sort(List<T> list, Comparator<? super T> c);
--搜索
int binarySearch(List<? extends Comparable<? super T> list, T key);//使用二分搜索法搜索指定列表，以获得指定对象
int binarySearch(List<? extends T> list, T key, Comparator<? super T> c);//使用二分搜索法搜索指定列表，以获得指定对象
--查找位置：
int indexOfSubList(List<?> source, List<?> target);
int lastIndexOfSubList(List<?> source, List<?> target);
--求最大或最小元素
max(Collection<? extends T> coll);//根据元素的自然顺序，返回给定Collection的最大元素
max(Collection<? extends T> coll, Comparator<? super T> comp);//根据指定比较器产生的顺序，返回给定Collection的最大元素
min(Collection<? extends T> coll);
min(Collection<? extends T> coll, Comparator<? super T> comp);

12.1.3 Arrays与数组 P411
在Java所有的“存储及随机访问一连串对象”的做法中，数组是最有效率的一种。普通的数组也有它的缺点：效率高，但容量固定且无法动态改变；无法判断其中实际存有多少元素，length只是告诉我们数组的容量。
Arrays类，专门用来操作数组。它拥有一组静态函数，包含用来操作数组（如排序和搜索）的各种方法。这些函数操作的数组都是Java基本数据类型的数组，具体的函数用法有很多，以操作整型数组为例讲解：
--填入 fill()
--复制 copyOf()
--比较 equals()
--搜索 binarySearch()
--排序 sort()
其中的数组赋值功能与System.arraycopy()相似。
public class TestEnum {
    static public void main(String args[]) {
        int array[] = new int[5];
        System.out.print(array.length);//5
    }
}

12.1.4 Dictionary字典 P411
Dictionary是字典类，它是任何可将键映射到相应值的类（如Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个Dictionary对象中，每个键最多与一个值相关联。给定一个Dictionary和一个键，就可以查找所关联的元素。任何非null对象都可以用做键或值。
该抽象类提供了以下抽象方法，用来实现对Dictionary实例的枚举、查找、删除、保存操作，并可以取得数组大小，判断是否为空：
枚举：abstract Enumeration<V> elements();
聚会：abstract V get(Object key);
判断为空：abstract boolean isEmpty();
键枚举：abstract Enumeration<K> keys();
设值：abstact V put(K key, V value);
删除：abstract V remove(Object key);
取得大小：abstract int size();

这些函数是抽象的，它的子类必须实现它们。目前DIctionary类只有Hashtable在使用，因此在Hashtable中就提供了以上这些抽象函数的具体实现。Properties继承自Hashtable，因此它也拥有这些函数的功能。
Tips：此类已过时。新的实现应该实现Map接口，而不是扩展此类。

12.1.5 Queue队列 P412
从图12-1 中可以看出，实现Collection接口的第一个类是Queue队列类，该接口还有一个抽象子类AbstractQueue，继而有一系列的实现类，如优先队列PriorityQueue，还有ArrayBlockingQueue、XXX。
1. Queue队列接口
Queue除了基本的Collection操作外，还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（null或false，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的Queue实现设计的；在大多数实现中，插入操作不会失败。
插入 add offer
获取移除 remove poll
获取不移除 element peek

remove()和poll()方法可移除和返回队列的头，到底从队列中移除哪个元素是队列排序策略的功能，而该策略在各种实现中是不同的。remove()和poll()方法仅在队列为空时其行为有所不同：remove()方法抛出一个异常，而poll()方法则返回null。
element()和peek()返回但不移除队列的头。

2. AbstractQueue抽象类
此类提供某些Queue操作的抽象实现。？（不是特别懂）

3. 优先级PriorityQueue P413
一个基于优先级堆的无办优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。不允许使用null元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象。
此队列的头是按指定排序方法确定的最小元素。如果多个元素都是最小值，则头是其中一个元素――选择方法是任意的。队列获取操作poll()、remove()、peek()和element()访问处于队列头的元素。
优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无须指定容量增加策略的细节。
此类及其迭代器实现了Collection和Iterator接口的所有可选方法。方法iterator()中提供的迭代器不保证以任何特定的顺序遍历优先级队列中的元素。如果需要按顺序遍历，请考虑使用Arrays.sort(pq.toArray())。
如下例：
import java.util.PriorityQueue;
import java.util.Queue;

public class TestEnum {
    static public void main(String args[]) {
        Queue queue = new PriorityQueue<>();
        queue.add("abc");
        queue.add("111");
        queue.add("def");
        System.out.println(queue.poll());
        System.out.println(queue.element());
    }
}
输出如下：
111
abc

由于它按照自然排序，因此输出结果为111，abc。（ANSI码中，111排在abc前）
Tips：此实现不是同步的。如果多个线程中的任意线程修改了队列，则这些线程不应同时访问PriorityQueue实例。相反，请使用线程安全的PriorityBlockingQueue类。
queue.add("222");
queue.add("111");
queue.add("333");
System.out.println(queue.poll());
System.out.println(queue.poll());
System.out.println(queue.element());
输出为：
111
222
333

12.2 列表类List P414
List接口对Collection进行了简单的扩充，具体实现类常用的有ArrayList和LinkedList。
--ArrayList是一种类似数组的形式进行存储，随机访问速度极快。
--LinkedList的内部实现是链表，适合于在链表中间需要频繁进行插入和删除操作。

12.2.1 抽象类AbstractList与AbstractSequentialList P414
AbstractList提供List接口的抽象实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。对于连续的访问数据（如链表），应优先使用AbstractSequentialList，而不是此类。
在继承AbstractList时：
--如果要实现不可修改的列表，只需扩展此类，并提供get(int)和size()方法的实现。
--要实现可修改的列表，必须另外重写set(int,E)方法。
--如果列表为可变大小，则必须另外重写add(int,E)和remove(int)方法。
目前继承自AbstractList的实现类有ArrayList和Vector。
AbstractSequentialList与在列表的列表迭代器上实现“随机访问”方法的AbstractList类相对立。即AbstractList的迭代器方法是随机访问方法，AbstractSequentialList的迭代器方法不是随机访问方法。

12.2.2 链表LinkedList P415
LinkedList是List接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括null）。除了实现List接口外，LinkedList类还为在列表的开头及结尾get()、remove()和add()元素提供了统一的命名方法。这些操作允许将链接列表用做堆栈、队列或双端队列。如下：
addFirst
addLast

boolean offerFirst
boolean offerLast

getFirst
getLast

removeFirst
removeLast

peekFirst//获取不移除
peedLast

pollFirst//获取移除
pollLast

所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表。

import java.util.LinkedList;

public class TestList {
    static public void main(String args[]) {
        LinkedList list = new LinkedList();
        list.add("abc");
        list.add("111");
        list.add("def");
        System.out.println(list.getFirst());
        System.out.println(list.getLast());
    }
}
输出如下：
abc
def
Tips：此实现不是同步的。如果多个线程同时访问一个链接列表，而其中至少一个线程从结构上修改了该列表，则它必须保持外部同步。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示：
List list = Collections.synchronizedList(new LinkedList(...));

12.2.3 可变数组 ArrayList P416
ArrayList是List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，还提供一些方法来操作内部用来存储列表的数组的大小（此大大致上等同于Vector类，除了此类是不同步的）。
每个ArrayList实例都有一个容量，指用来存储列表元素的数组的大小，它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。可以使用默认构造函数创建容量为10的列表，也可以初始化指定容量大小。
ArrayList();//构造一个初始容量为10的空列表
ArrayList(int initialCapacity);//构造一个具有指定初始容量的空列表

的添加大量元素前，可以使用ensureCapacity操作来增加ArrayList实例的容量。可以减少递增式再分配的数量。其函数形式如下：
void ensureCapacity(int minCapacity);//增加容量

//
import java.util.ArrayList;

public class TestList {
    static public void main(String args[]) {
        ArrayList list = new ArrayList(20);
        list.add("abc");
        list.add("111");
        list.add("def");
        list.ensureCapacity(100);
        System.out.println(list.size());
    }
}
输出如下：
3
Tips：此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。最好在创建时完成，以防止意外对列表进行不同步的访问：
List list = Collections.synchronizedList(new ArrayList(...));

12.2.4 向量Vector P416
Vector类可以实现可增长的对象数组，与数组一样，可以使用整数索引进行访问。但是，Vector的大小可以根据需要增大或者缩小，以适应创建Vector后进行添加或移除项的操作。
import java.util.Vector;

public class TestList {
    static public void main(String args[]) {
        Vector v = new Vector();
        v.addElement("one");
        v.addElement("two");
        v.addElement("three");
        v.addElement("two");
        System.out.println(v);

        v.removeElement("two");//只能删除掉第一个
        System.out.println(v);

        v.addElement(111);//在不指定泛型类型的情况下，可以放入任意类型对象，如果v声明为Vector<String>，则此处编译报错
        System.out.println(v);
    }
}
输出如下：
[one, two, three, two]
[one, three, two]
[one, three, two, 111]

//
import java.util.Vector;

public class TestList {
    static public void main(String args[]) {
        Vector v = new Vector(4);
        v.add("test0");
        v.add("test1");
        v.add("test0");
        v.add("test2");
        v.add("test2");

        v.remove("test0");
        v.remove(0);
        int size = v.size();
        System.out.println("size:" + size);

        for (int i = 0; i < v.size(); ++i) {
            System.out.println(v.get(i));
        }
        // for (Object s : v) { //这里不能用String，类型不匹配
            // System.out.println(s);
        // }
    }
}
输出如下：
size:3
test0
test2
test2

Vector在参数传递中发挥着举足轻重的作用，通常都使用Vector作为参数传递的对象。

12.2.5 堆栈 P418
Stack类表示后进先出（LIFO）的对象堆栈。通过5个操作对类Vector进行了扩展，允许将向量视为堆栈。提供了通常的push()和pop()操作，以及取堆栈顶点的peek()方法、测试堆栈是否为空的empty()方法、在堆栈中查找项并确定到堆栈顶距离 的search()的方法。
import java.util.EmptyStackException;
import java.util.Stack;

public class TestList {
    static public void main(String args[]) {
        Stack st = new Stack();
        System.out.println("stack:" + st);
        st.push(new Integer(42));
        System.out.println("push(42)");
        System.out.println("stack:" + st);

        st.push(new Integer(43));
        System.out.println("push(43)");
        System.out.println("stack:" + st);

        System.out.print("pop -> ");
        Integer i = (Integer) st.pop();
        System.out.println(i);
        System.out.println("stack:" + st);

        Integer i1 = (Integer) st.pop();
        System.out.println(i1);
        System.out.println("stack:" + st);

        try {
            st.pop();
        } catch (EmptyStackException e) {
            System.out.println("empty stack");
        }
    }
}
输出如下：
stack:[]
push(42)
stack:[42]
push(43)
stack:[42, 43]
pop -> 43
stack:[42]
42
stack:[]
empty stack

12.3 集合类Set P419
Set接口也是Collection的一种扩展，与List不同的是，Set中的对象元素不能重复。常用具体实现有HashSet和TreeSet类。
--HashSet能快速定位一个元素，但是放到HashSet中的对象需要实现hashCode()方法，它使用哈希码的算法。
--TreeSet则将放入其中的元素按序存放，这就要求放入其中的对象是可排序的，这就用到了集合框架提供的另外两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具有相同的排序算法，就不需要分别在每个类中重复定义相同的排序算法，只要实现Comparator接口即可。集合框架中还有两个很实用的公用类：Collections和Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用的方法，Arrays则是对一个数组进行类似的操作。

12.3.1 抽象类AbstractSet与接口SortedSet
Set有一个抽象类和接口，分别是AbstractSet和SortedSet。AbstractSet为实现哈希做准备，SortedSet为实现具有排序功能的TreeSet做准备。
1. AbstractSet通过扩展此类来实现一个Set的过程与通过扩展AbstractCollection来实现Collection的过程是相同的，除了此类的子类中的所有方法和构造方法都必须服从Set接口所强加的额外限制（例如，add()方法不允许将一个对象的多个实例添加到一个Set中）。
Tips：此类并没有重写AbstractCollection类中的任何实现，它仅仅添加了equals()和hashCode()的实现。

2. 排序接口SortedSet
SortedSet进一步提供了关于元素的总体排序的Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序Set时提供的Comparator进行排序。所有这些元素都必须是可互相比较的。
所有通用有序Set实现类都应该提供4个“标准”构造方法。
--void（无参数）构造方法：它创建一个空的有序Set，按照元素的自然顺序进行排序。
--带有一个Comparator类型参数的构造方法：它创建一个空的有序Set，根据指定的比较器进行排序。
--带有一个Collection类型参数的构造方法：它创建一个新的有序Set，其元素与参数相同，按照元素的自然顺序进行排序。
--带有一个SortedSet类型参数的构造方法：它创建一个新的有序Set，其元素和排序方法与输入的有序Set相同。
TreeSet就是一个排序接口SortedSet的实现。

12.3.2 哈希集合HashSet P420
HashSet由哈希表（实现上是一个HashMap实例）支持，为基本操作提供了稳定性能，这些基本操作包括add()、remove()、contains()和size()，假定哈希函数将这些元素正确地分布在桶中。对此set()进行迭代所需的时间与HashSet实例的大小（元素的数量）和底层HashMap实例（桶的数量）的“容量”的和成比例。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。
为了在该类的实例中保存数据，数据对象必须拥有hashCode()函数。如下例：
//
import java.util.HashSet;
import java.util.Iterator;

class Student {
    private int num;
    private String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return num * name.hashCode();
    }

    public boolean equals(Student student) {
        return num == student.num && name.equals(student.name);
    }
}

public class TestHashSet {
    static public void main(String args[]) {
        HashSet<Student> hs = new HashSet<>();
        hs.add(new Student(1, "zhangsan"));
        hs.add(new Student(2, "lisi"));
        hs.add(new Student(3, "wangwu"));
        hs.add(new Student(1, "zhangsan"));

        Iterator<Student> iter = hs.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
输出如下：
Student{num=3, name='wangwu'}
Student{num=2, name='lisi'}
Student{num=1, name='zhangsan'}
Student{num=1, name='zhangsan'}

由此可见，HashSet是一类特殊的List，它添加的元素必须实现hashCode()函数。
Tips：此实现不是同步的。如果多个线程同时访问一个哈希Set，而其中至少一个线程修改了该Set，那么它必须保持外部同步。这通常是通过对自然封装该Set的对象执行同步操作来完成的。如果不慧这样的对象，则应该使用Collections.synchronizedSet方法来“包装”Set。最好在创建时完成这一操作，以防止对该Set进行意外的非同步访问。
Set s = Collections.synchronizedSet(new HashSet(...));

12.3.3 树集合TreeSet P421
TreeSet是基于TreeMap的NavigableSet袜。使用元素的自然顺序对元素排序，或根据创建Set时提供的Comparator进行排序，取决于使用的构造方法。此实现为基本操作（add、remove和contains）提供受保证的log(n)时间开销。
自己写的类要能够添加到TreeSet中进行排序，该类需要实现Comaprable接口。如下：
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeSet;

class Student implements Comparable {
    private int num;
    private String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public int compareTo(Object o) {
        Student s = (Student) o;
        //如下比较是我自己加的
        if (this.num < s.num) {
            return -1;
        } else if (this.num > s.num) {
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}

public class TestHashSet {
    static public void main(String args[]) {
        TreeSet<Student> hs = new TreeSet<>();
        hs.add(new Student(3, "wangwu"));
        hs.add(new Student(1, "zhangsan"));
        hs.add(new Student(2, "lisi"));
        System.out.println(hs.add(new Student(1, "zhangsan2")));//增加失败

        Iterator<Student> iter = hs.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
输出如下：
false
Student{num=1, name='zhangsan'}
Student{num=2, name='lisi'}
Student{num=3, name='wangwu'}

//原书中代码
import java.util.Iterator;
import java.util.TreeSet;

class Student implements Comparable {
    private int num;
    private String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public int compareTo(Object o) {
        Student s = (Student) o;
        int ret = num > s.num ? 1 : (num == s.num ? 0 : -1);
        if (ret == 0) {
            ret = name.compareTo(s.name);//如果编号一样，再使用name比较
        }
        return ret;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}

public class TestHashSet {
    static public void main(String args[]) {
        TreeSet<Student> hs = new TreeSet<>();
        hs.add(new Student(3, "wangwu"));
        hs.add(new Student(1, "zhangsan"));
        hs.add(new Student(2, "lisi"));
        System.out.println(hs.add(new Student(1, "zhangsan2")));

        Iterator<Student> iter = hs.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
输出如下：
true
Student{num=1, name='zhangsan'}
Student{num=1, name='zhangsan2'}
Student{num=2, name='lisi'}
Student{num=3, name='wangwu'}

由此可见，TreeSet是一类特殊的List，它添加的元素必须实现可比较的接口。

//另外使用额外的构造器的代码
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

class Student {
    protected int num;//修改为protected，同一个文件里的类就可以访问到
    protected String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}

class StudentComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        int ret = s1.num > s2.num ? 1 : (s1.num == s2.num ? 0 : -1);
        if (ret == 0) {
            ret = s1.name.compareTo(s2.name);
        }
        return ret;
    }
}

public class TestHashSet {
    static public void main(String args[]) {
        TreeSet<Student> hs = new TreeSet<>(new StudentComparator());
        hs.add(new Student(3, "wangwu"));
        hs.add(new Student(1, "zhangsan"));
        hs.add(new Student(2, "lisi"));
        hs.add(new Student(1, "zhangsan2"));

        Iterator<Student> iter = hs.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
输出如下：
Student{num=1, name='zhangsan'}
Student{num=1, name='zhangsan2'}
Student{num=2, name='lisi'}
Student{num=3, name='wangwu'}

//还可以修改为这种匿名类的形式
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

class Student {
    protected int num;//修改为protected，同一个文件里的类就可以访问到
    protected String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}

public class TestHashSet {
    static public void main(String args[]) {
        TreeSet<Student> hs = new TreeSet<>(new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                int ret = o1.num > o2.num ? 1 : (o1.num == o2.num ? 0 : -1);
                if (ret == 0) {
                    ret = o1.name.compareTo(o2.name);
                }
                return ret;
            }
        });
        hs.add(new Student(3, "wangwu"));
        hs.add(new Student(1, "zhangsan"));
        hs.add(new Student(2, "lisi"));
        hs.add(new Student(1, "zhangsan2"));

        Iterator<Student> iter = hs.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }
    }
}
Tips：此实现不是同步的。如果多个线程同时访问一个TreeSet，而其中至少一个线程修改了该Set，那么它必须保持外部同步。这一般是通过对自然封装该Set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用Collections.synchronizedSortedSet方法来“包装”该Set。此操作最好在创建时进行，以防止对Set进行意外的非同步访问：
SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));

12.4 映射类Map P423
Map是一种把键对象和值对象进行关联的容器，而一个值对象又可以是一个Map。对于键对象来说，像Set一样，一个Map容器中的键对象不允许重复，这是为了保持查找结果的一致：如果有两个键对象一样，想得到那个键对象所对应的值对象时就有问题了。所以键的唯一性很重要，也是符合集合的性质的。当然在使用过程中，某个键所对对应的值对象可能会发生变化，这时会按照最后一次修改的值对象与键对应。
Map有两种比较常用的实现：HashMap和TreeMap。
--HashMap也用到了哈希码的算法，以便快速查找一个键。
--TreeMap是对键按序存放，因此它便有一些扩展的方法，如firstKey()、lastKey()等，还可以从TreeMap中指定一个范围以取得其子Map。
键和值的关联很简单，用put(Object key, Object value)方法。用get(Object key)可得到与此key对象所对应的值对象。

12.4.1 抽象类AbstractMap与接口SortedMap、NavigableMap
Map有一个抽象类和两个接口，分别是AbstractMap、SortedMap和NavigableMap，NavigableMap是SortedMap的子接口。Abstract为实现哈希做准备，SortedMap为实现具有排序功能的TreeMap做准备。
1. 哈希抽象类AbstractMap
此类提供Map接口的抽象实现，以最大限度地减少实现此接口所需的工作。它实现了对Hash映射的几种操作。
--保存键值V put(K key, V value);
--删除键值V remove(Object key);：如果存在一个键的映射关系，则将其从此映射中移除。
--取得键值V get(Object key);：返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回null。
--取得键集合Set<K> keySet();：返回此映射中包含的键的Set视图。
要实现不可修改的映射，编程人员只需要扩展此类并提供entrySet()方法的实现即可，该方法将返回映射的映射关系Set视图。通常，返回的set()将依次在AbstractSet上实现。此set()不支持add()或remove()方法，其迭代器也不支持remove()方法。
要实现可修改的映射，编程人员必须另外重写此类的put()方法（否则将抛出UnsupportedOperationException），entrySet().iterator()返回的迭代器也必须另外实现其remove()方法。

2. 排序接口SortedMap
该接口进一步提供关于键的总体排序的Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的Comparator进行排序。它为排序后的映射增加了如下两个函数，分别用于取得第一个和最后一个键：
K firstKey();
K lastKey();
插入有序映射的所有键都必须实现Comparable接口（或者被指定的比较器接受）。另外，所有这些键都必须是可互相比较的：对有序映射的中任意两个键k1和k2执行k1.compareTo(k2)（或comparator.compare(k1,k2)）都不得抛出ClassCastException。试图违反此限制将导致违反规则的方法或者构造方法调用抛出ClassCastException。

3. 导航接口NavigableMap
该接口扩展自SortedMap，具有针对给定搜索目标返回最接近匹配项的导航方法。方法lowerEntry()、floorEntry()、ceilingEntry()、higherEntry()分别返回小于、小于等于、大于等于、大于给定键的键关联的Map.Entry对象，如果不存在这样的键，则返回null。类似的，方法lowerKey()、floorKey()、ceilingKey()、higherKey()只返回关联的键。所有这些方法是为查找条目而不是遍历条目设计的。
此外，此接口还定义了firstEntry()、pollFirstEntry()、lastEntry()和pollLastEntry()方法，它们返回或移除最小和最大的映射关系（如果存在），否则返回null。

12.4.2 树映射TreeMap
TreeMap既继承了哈希抽象类AbstractMap，又实现了排序接口SortedMap和导航接口NavigableMap。它是基于红黑树（Red-Black tree）算法的实现。该映射根据其键的自然顺序进行排序，或者根据创建临山时提供的Comparator进行排序，具体取决于使用的构造方法：
TreeMap();
TreeMap(Comparator<? super K> comparator);
此实现为containsKey()、get()、put()和remove()操作提供受保证的log(n)时间开销。
与TreeSet相似，自己写的类要能够添加到TreeMap中进行排序，也需要实现Comparable接口或Comparator。
//
import java.util.Iterator;
import java.util.TreeMap;

class Student {
    protected int num;//修改为protected，同一个文件里的类就可以访问到
    protected String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }
}

public class TestTreeMap {
    static public void main(String args[]) {
        TreeMap<String, Student> tmap = new TreeMap<>();
        tmap.put("A", new Student(3, "wangwu"));
        tmap.put("B", new Student(1, "zhangsan"));
        tmap.put("C", new Student(2, "lisi"));
        tmap.put("D", new Student(1, "zhangsan2"));

        Iterator<String> iter = tmap.keySet().iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            Student value = tmap.get(key);
            System.out.println(key + "=" + value);
        }
        System.out.println(tmap);
    }
}
输出如下：
A=Student{num=3, name='wangwu'}
B=Student{num=1, name='zhangsan'}
C=Student{num=2, name='lisi'}
D=Student{num=1, name='zhangsan2'}
{A=Student{num=3, name='wangwu'}, B=Student{num=1, name='zhangsan'}, C=Student{num=2, name='lisi'}, D=Student{num=1, name='zhangsan2'}}

由此可见，TreeMap是一类特殊的Map，它添加的元素必须实现可比较的接口。
Tips：此实现不是同步的。如果多个线程同时访问一个映射，并且其中至少一个线程从结构上修改了该映射（结构上的修改是指添加或删除一个或多个映射关系的操作；仅改变与现有 键关系的值不是结构上的修改），则其必须保持外部同步。这一般是通过对自然封装该映射的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用Collections.synchronizedSortedMap()方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的不同步访问，如下所示：
SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));

12.4.3 哈希映射HashMap P426
该类是基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许使用null值和null键（除了非同步和允许使用null之外，HashMap类与Hashtable大致相同）。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作get()和put()提供稳定的性能。迭代Collection视图所需的时间与HashMap实例的“容量”（桶的数量）及其大小（键――值映射关系数）成比较。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。
HashMap的实例有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。如果当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行rehash()操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
通常，默认加载因子（0.75 ）在时间和空间成本上寻求一种折中。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数HashMap类的操作中，包括get和put操作，都反映了这一点）。在设置初始容量时应该考虑到在映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash操作。
该类提供了3个可用的构造函数：
HashMap();//初始容量16，默认加载因子0.75
HashMap(int initialCapacity);//指定初始容量，默认加载因子0.75
HashMap(int initialCapacity, float loadFactor);//指定初始容量，指定加载因子

如果很多映射关系要存储在HashMap实例中，则相对于按需执行自动的rehash操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。
与HashSet相似，自己写的类要能够添加到HashMap中，也需要实现hashCode()函数。
//
import java.util.HashMap;
import java.util.Iterator;

class Student {
    protected int num;//修改为protected，同一个文件里的类就可以访问到
    protected String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return num * name.hashCode();
    }
}

public class TestHashMap {
    static public void main(String args[]) {
        HashMap<String, Student> tmap = new HashMap<>();
        tmap.put("B", new Student(1, "zhangsan"));
        tmap.put("C", new Student(2, "lisi"));
        tmap.put("A", new Student(3, "wangwu"));
        tmap.put("D", new Student(1, "zhangsan2"));

        Iterator<String> iter = tmap.keySet().iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            Student value = tmap.get(key);
            System.out.println(key + "=" + value);
        }
        System.out.println(tmap);
    }
}
输出如下：
A=Student{num=3, name='wangwu'}
B=Student{num=1, name='zhangsan'}
C=Student{num=2, name='lisi'}
D=Student{num=1, name='zhangsan2'}
{A=Student{num=3, name='wangwu'}, B=Student{num=1, name='zhangsan'}, C=Student{num=2, name='lisi'}, D=Student{num=1, name='zhangsan2'}}

由此可见，HashMap是一类特殊的Map，它添加的元素必须实现hashCode()函数。
Tips：此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关系的值不是结构上的修改），则它必须保持外部同步。这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用Collections.synchronizedMap()方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下：
Map m = Collections.synchronizedMap(new HashMap(...));

12.4.4 链表哈希映射LinkedHashMap P427
该类是Map接口的哈希表和链接列表实现的，具有可预知的迭代顺序。此实现与HashMap的不同之处在于前者维护着一个运行于所有条目的双重链接列表，此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。如果在映射中重新插入键，则插入顺序不受影响。
此实现可以让客户避免未指定的、由HashMap（及Hashtable）所提供的通常为杂乱无章的排序工作，同时无须增加与TreeMap相关的成本。使用它可以生成一个与原来顺序相同的映射副本，而与原映射的实现无关：
void foo(Map m) {
    Map copy = new LinkedHashMap(m);
}
该类提供特殊的构造方法来创建链接哈希映射，该哈希映射的迭代顺序就是最后访问其条目的顺序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射很适合构造LRU缓存。调用put()或get()方法将会访问相应的条目（假定调用完成后它还存在）。putAll()方法以指定映射的条目集迭代器提供的键――值映射关系的顺序，为指定映射的每个映射关系生成一个条目访问。
下面的函数用于构造一个带指定初始容量、加载因子和排序模式的空LinkedHashMap实例：
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder);
--initialCapacity：初始容量。
--loadFactor：加载因子。
--accessOrder：排序模式，如果对于访问顺序，则为true；如果对于插入顺序，则为false。
允许null元素，与HashMap一样，可以为基本操作（add、contains和remove）提供稳定的性能，假定哈希函数将元素正确地分布到桶中。由于增加了维护链接列表的开支，其性能很可能比HashMap稍逊一筹，不过这一点例外：LinkedHashMap的Collection视图迭代时间与映射的大小成比例。HashMap迭代时间很可能开支较大，因为它所需要的时间与其容量成比例。
链接的哈希映射具有两个影响其性能的参数：初始容量和加载因子。它们的定义与HashMap极其相似。为初始容量选择非常高的值对此类的影响比对HashMap要小，因为此类的迭代时间不受容量的影响。
//
import java.util.Iterator;
import java.util.LinkedHashMap;

class Student {
    protected int num;//修改为protected，同一个文件里的类就可以访问到
    protected String name;

    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "num=" + num +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public int hashCode() {
        return num * name.hashCode();
    }

    public boolean equals(Student student) {
        return num == student.num && name.equals(student.name);
    }
}

public class TestLinkedHashMap {
    static public void main(String args[]) {
        LinkedHashMap<String, Student> tmap = new LinkedHashMap<>();
        tmap.put("B", new Student(1, "zhangsan"));
        tmap.put("C", new Student(2, "lisi"));
        tmap.put("A", new Student(3, "wangwu"));
        tmap.put("D", new Student(1, "zhangsan2"));

        Iterator<String> iter = tmap.keySet().iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            Student value = tmap.get(key);
            System.out.println(key + "=" + value);
        }
        System.out.println(tmap);
    }
}
Tips：此实现不是贴满的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用Collections.synchronizedMap()方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问。
Map m = Collections.synchronizedMap(new LinkedHashMap(...));

12.4.5 弱哈希映射 WeakHashMap P428

12.4.6 哈希表Hashtable P429
此类实现一个哈希表，该哈希表将键映射到相应的值。任何非null对象都可以用做键或值。为了成功地在哈希表中存储和获取对象，用做键的对象必须实现hashCode方法和equals方法。
Hashtable的实例有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。注意，哈希表的状态为open，在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时及是否调用rehash()方法的具体细节则依赖于该实现。
通常，默认加载因子（0.75 ）在时间和空间成本上寻求一个折中。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数Hashtable操作中，包括get和put操作，都反映了这一点）。
初始容量主要控制空间消耗与执行rehash操作所需要的时间损耗之间的平衡。如果初始容量大于Hashtable所包含的最大条目数除以加载因子，则永远不会发生rehash操作。但是，将初始容量设置太高可能会浪费空间。
如果很多条目要存储在一个Hashtable中，那么与根据需要执行自动rehashing操作来增大表的容量的做法相比，使用足够大的初始容量创建哈希表或者可以更有效地插入条目。
//
import java.util.Hashtable;
import java.util.Iterator;

public class TestHashtable {
    static public void main(String args[]) {
        Hashtable<String, Integer> numbers = new Hashtable<>();
        numbers.put("one", 1);
        numbers.put("two", 2);
        numbers.put("three", 1);

        Iterator<String> iter = numbers.keySet().iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            Integer value = numbers.get(key);
            System.out.println(key + "=" + value);
        }
        System.out.println(numbers);
    }
}
输出如下：
two=2
one=1
three=1
{two=2, one=1, three=1}
Tips：Hashtable是同步的。

12.4.7 属性Properties P430
Properties类表示了一个持久的属性集。Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。
因为Properties继承于Hashtable，所以可对Properties对象应用put()和putAll()方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是String的项。相反，应该使用setProperty()方法。如果在“不安全”的Properties对象（即包含非String的键或值）上调用store()或save()方法，则该调用将失败。如果在“不安全”的Properties对象（即包含非String的键）上调用propertyNames()或list()方法，则该调用将失败。
Tips：Properties主要提供了对属性文件的读取和写入功能，在第14课讲解。
Tips：此类是线程安全的：多个线程可享单个Properties对象而无须进行外部同步。

12.5 对比与选择 P430

12.5.3 Map选择：Hashtable、HashMap、WeakHashMap P433
（1）Hashtable类
由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果用自定义的类当做key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即obj1.equals(obj2)==true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好hashCode()方法，这样能加快哈希表的操作。
如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个，Hashtable是同步的。
（2）HashMap类
HashMap是非同步的，并且允许null，null value和null key。将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因为，如果迭代操作的性能相当重要的话，则不要将HashMap的初始化容量设得过高或者load factor过低。

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第13课 Java正则表达式 P437
13.1 正则表达式语法 P437
13.1.2 正则表达式的匹配字符
Tips：本文采用/expression/的形式，其中的expression即为正则表达式。

/.\b./在匹配“@@@abc”时，匹配结果是：成功；匹配到的内容是：@a P441

“\b”与“^”和“$”类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是“\w”范围，另一边是非“\w”的范围。

（7）向后引用 P442
正则表达式还有一个最重要的特性――后向引用：就是将匹配成功的字符串的某部分进行存储，供以后引用。将一个正则表达式模式或部分模式两边添加圆括号，将导致这部分表达式存储到一个临时缓存区中。如果不想存储，也可以使用非捕获元字符“?:”、“?=”、“?!”来忽略这部分正则表达式的保存。
^(?:Chapter|Section)[1-9][0-9]{0,1}$ 中的?:表达并不想存储括号中的子表达式，括号只是为了匹配|左右两部分

如下三个都为非捕获元：
?:：消除括号中的匹配缓存
?=：为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串
?!：为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串

所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓存区编号从1开始，连续编号直至最大99个子表达式。每个缓存区都可以使用“\n”访问，其中n为一个标识特定缓存区的一位或两位十进制数。

后向引用有以下两个应用：
（1）向后引用一个最简单的应用，确定文字中连续出现两个相同单词的位置。
如It is the cost of of gasoline going up up?
表达式
/\b([a-z]+) \1\b/
这个示例中，子表达工是圆括号之间的每一项。所捕获的表达式包括一个或多个字母字符，即由“[a-z]+”所指定的。第二部分是对前面所捕获的子匹配的引用，也就是由附加表达式所匹配的第二次出现的单词。“\1 ”用来指定第一个子匹配。单词边界元字符确保只检测单独的单词。如果不这样，诸如“is issued”或“this is”这样的短语都会被该表达式不正确地识别。
该正则表达式可以匹配of of和up up
使用上面所示的正则表达式，下面的代码可以使用子匹配信息，在一个文字字符串中将连续出现两次的相同单词替换为一个相同的单词：
var ss = "It is the cost of of gasoline going up up?.\n";
var re = /\b([a-z]+) \1\b/
var rv = ss.replace(re, "$1");
在replace方法中使用“$1”来引用 所保存的第一个子匹配。如果有多个子匹配，则可以用“$2”、“$3”等继续引用 。

//如下代码没有替换成？初步分析Java的匹配是全字符匹配
public class TestStringRegex {
    static public void main(String args[]) {
        String ss = "It is the cost of of gasoline going up up?.\n";
        String re = "/\b([a-z]+) \1\b/";
        System.out.println(ss.replace(re, "$1"));
    }
}
//如下返回true，reg="It"则false
public class TestStringRegex {
    static public void main(String args[]) {
        String str = "It is the cost of of gasoline going up up?.";
        String reg = ".*";
        System.out.println(str.matches(reg));
    }
}

（2）向后引用的另一个用途是将一个通用资源指示符（URI）分解为组件部分。假定希望将下述的URI分解为协议（ftp、http、etc），域名地址及页面/路径：
http://msdn.microsoft.com:80/scripting/default.htm
下面的正则表达式可以提供这个功能：
/(\w+):\/\/([^/:]+)(:\d*)?[^# ]*/ //感觉第二个括号中/匹配有问题，不需要加转义符\吗？
将该正则表达式应用于上面所示的URI后，子匹配包含下述内容：
$1 包含 "http"
$2 包含 "msdn.microsoft.com"
$3 包含 ":80"
$4 包含 "/scripting/default.htm"

13.1.3 正则表达式的匹配规则 P444
[0-9\.\-] //匹配所有的数字，句号和减号。减号有特殊的区间含义，所以如果要匹配减号，需要有转义符
[ \f\r\t\n] //匹配所有的白字符

/^[[:alpha:]]{3}$/ //所有的3个字母的单词 这里的alpha不太懂？

特殊字符“?”与{0,1}是相等的，它们都代表着“0个或1个前面的内容”或“前面的内容是可选的”。
特殊字符“*”与{0,}是相等的，它们都代表着“0个或多个前面的内容”。
字符“+”与{1,}是相等的，表示“1个或多个前面的内容”。

在修饰匹配次数的特殊符号后再加一个“?”号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能“不匹配”。这种匹配原则叫做“非贪婪”模式，也叫做“勉强”模式。如果少匹配就会导致整个表达式失败的时候，与贪婪模式类似，非贪婪模式会最小限度地再匹配一些，以使整个表达式匹配成功。

（5）匹配时反向引用规则 P447
表达式在匹配时，表达式引擎会将小括号“()”包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。
小括号包含的表达式所匹配到的字符串不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面括号内的子匹配已经匹配到的字符串。引用方法是“\”加上一个数字。“\1 ”引用第1对括号内匹配到的字符串，“\2 ”引用第2对括号内匹配到的字符串，以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号“(”在前，那这一对就先排序号。

例2：
/(\w)\1{4,}/ 要求\w范围的字符至少重复5次
/\w{5,}/ 表示至少有5个字符
例3：<(\w+)\s*(\w+(=('|").*?\4)?\s*)*>.*?</\1>在匹配 
<td id='td1' style="bgcolor:while"></td>
时，匹配结果是成功。如果<td>与</td>不配对，则会匹配失败；如果改成其他标签配对，也可以匹配成功。

（6）预搜索与懒惰搜索规则 P448
前面讲到了几个代表抽象意义的特殊符号：^ $ \b。它们本身不匹配任何字符，只是对字符串的两头或者字符之间的缝隙附加了一个条件。将介绍另外一种对“两头”或者“缝隙”附加条件的更加灵活的表示方法。
1) 正向预搜索：(?=xxxxx) (?!xxxxx)
格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的“缝隙”或者“两头”附加的条件是：所在缝隙的右侧，必须能够匹配上xxxxx这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似“\b”，本身不匹配任何字符。“\b”只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
例1：表达式/windows(?=NT|98)/在匹配windows98, windowsNT时，将只匹配windows，其它字样则不被匹配
例2：表达式/(\w)((?=\1\1\1)(\1))+/
在匹配字符串aaa ffffff 999999999 时，将可以匹配6个"f"的前4个，可以匹配9个"9"的前7个。这个表达式可以解读成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。
（可以理解为：一个字符+(一个缝隙+该字符)*至少一次重复，该缝隙要求右侧有3个该字符，最终缝隙不占结果字符）

格式："(?!xxxxx)"，所在缝隙的右侧，不能匹配xxxxx这部分表达式。
例3：表达式/((?!\bstop\b).)+/
在匹配akldfj kajrlekfdsj adf stop ifdlsa fdksla时，将从头一直匹配到“stop”之前的位置，如果字符串中没有“stop”，则匹配整个字符串。
例4：表达式/do(?!\w)/在匹配字符串“done, do, dog”时，只能匹配“do”。本条举例中，“do”后边使用(?!\w)和使用\b效果是一样的。

2) 反向预搜索：(?<=xxxxx) (?<!xxxxx)
这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的“左侧”，两种格式分别要求必须能够匹配和不能够匹配指定表达式，而不是去判断右侧。与“正向预搜索”一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。
例5：表达式(?<=\d{4})\d+(?=\d{4})在匹配1234567890123456时，将匹配除了前4个数字和后4个数字之外的中间8个数字。

3) 限制性重复
即{min,max}语法。
可以用\b[1-9][0-9]{3}\b匹配1000~9999 之间的数字。\b[1-9][0-9]{2,4}匹配一个在100~99999 之间的数字。

想匹配单个标签
This is a <EM>first</EM> test.
用<.+>将匹配<EM>first</EM>
用<.+?>来防止贪婪性，将匹配<EM>和</EM>

6) 惰性扩展的一个替代方案，用：<[^>]+>
之所以说这是一个更好的方案在于使用惰性重复时，引擎会在找到一个成功匹配前对每一个字符进行回溯。而使用取反字符集则不需要进行回滚。

13.1.4 全部符号汇总表 P449

13.1.5 常用正则表达式举例 P451

13.2 Java正则表达式详解 P452
13.2.1 使用String类的匹配功能
Java中使用正则表达式的方法非常多，最简单的就是和字符串一起使用。
（1）匹配――matches()方法
matches方法可以判断当前的字符串是否匹配给定的正则表达式。如果匹配，返回true，否则返回false。
//
public class TestStringRegex {
    static public void main(String args[]) {
        String str = "lzb_box@163.com";
        String reg = "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*";
        System.out.println(str.matches(reg));//true
    }
}
输出结果：true。表明该地址是合法的。Java中需要使用\\表示一个\

（2）拆分――split()方法
public String[] split(String regex);
public String[] split(String regex, int limit);
其中，limit参数控制模式应用的次数，因此影响所得数组的长度。
若n大于0，模式最多应用n-1 次，数组的长度将不会大于n，最后一项将包含所有超出最后匹配的定界符的输入。
如果n为非正，模式将被应用尽可能多的次数，而且数组可以是任何长度。
如果n为0，模式将被应用尽可能多的次数，数组可以是任何长度，并且结尾空字符串被丢弃。
//
public class TestStringRegex {
    static public void main(String args[]) {
        String s = "GET /index.html HTTP/1.1";
        String ss[] = s.split(" +");
        for (String str : ss) {
            System.out.println(str);
        }
    }
}
输出：
GET
/index.html
HTTP/1.1

第二种重载形式中有一个limit参数，假设为2：
public class TestStringRegex {
    static public void main(String args[]) {
        String s = "GET /index.html HTTP/1.1";
        String ss[] = s.split(" +", 2);
        for (String str : ss) {
            System.out.println(str);
        }
    }
}
输出：
GET
/index.html HTTP/1.1

（3）替换――replaceAll()和replaceFirst()方法
//
public class TestStringRegex {
    static public void main(String args[]) {
        String str = "lzb_box@163.com";
        String reg = "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*";
        System.out.println(str.replaceAll(reg, "Email"));//true
    }
}
输出：
Email

13.2.2 使用正则表达式库Pattern和Matcher P453
（1）Pattern表达式
Pattern为字符串的正则表达式，可以直接根据一个正则表达式创建一个Pattern实例：
Pattern p = Pattern.compile("a*b");
当编译模式时，可以设置一个或多个标志，例如：
Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE);

下面6个标志：
--CASE_INSENSITIVE
--UNICODE_CASE
--MULTILINE
--UNIX_LINES
--DOTALL
--CANON_EQ

(2)Matcher匹配器
然后使用Pattern对象获得Matcher匹配器对象，创建匹配器后，执行3种不同的匹配操作。
--matches()方法尝试将整个输入序列与该模式匹配。
--lookingAt()尝试将输入序列从头开始与该模式匹配。
--find()方法扫描输入序列以查找与该模式匹配的下一个子序列。
每个方法都返回一个表示成功或失败的布尔值。
//
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    static public void main(String args[]) {
        Pattern p = Pattern.compile("a*b");
        Matcher m = p.matcher("aaaaab");//这里aaaabc将无法匹配，因为matches是整个输入序列与该模式匹配
        boolean b = m.matches();
        System.out.println(b);//true

        //m.reset("aaaaabc"); b2 = m.lookingAt();
        Matcher m2 = p.matcher("aaaaabc");//lookingAt从头匹配，如果daaaabc将无法匹配
        boolean b2 = m2.lookingAt();
        System.out.println(b2);//true

        //m.reset("aaaaab"); b3 = m.find();
        Matcher m3 = p.matcher("aaaaab");
        boolean b3 = m3.find();
        System.out.println(b3);//true
    }
}

在仅使用一次正则表达式，可以方便地通过此类定义matches()方法，此方法编译表达式并在单个调用中将输入序列与其匹配，如：
boolean b = Pattern.matches("a*b", "aaaab");
它等效于上面三个matches语句，尽管对于重复的匹配而言它效率不高，因为它不允许重用已编译的模式。
如果要多次使用一种模式，编译一次后重用此模式比每次都调用此方法效率更高。

--matches:整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置。
--lookingAt:部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。
--find:部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。
--reset:给当前的Matcher对象配上个新的目标，目标是就该方法的参数；如果不给参数，reset会把Matcher设到当前字符串的开始处。
//
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    public static void main(String[] args){
        Pattern pattern = Pattern.compile("\\d{3,5}");
        String charSequence = "123-34345-234-00";
        Matcher matcher = pattern.matcher(charSequence);

        //虽然匹配失败，但由于charSequence里面的"123"和pattern是匹配的,所以下次的匹配从位置4开始
        print(matcher.matches());
        //测试匹配位置
        matcher.find();
        print(matcher.start());

        //使用reset方法重置匹配位置
        matcher.reset();//重载函数可以设置匹配字符串

        
        //find()
        //第一次find匹配以及匹配的目标和匹配的起始位置
        print(matcher.find());
        print(matcher.group()+" - "+matcher.start());
        //第二次find匹配以及匹配的目标和匹配的起始位置
        print(matcher.find());
        print(matcher.group()+" - "+matcher.start());

        
        //lookingAt()
        //第一次lookingAt匹配以及匹配的目标和匹配的起始位置
        print(matcher.lookingAt());
        print(matcher.group()+" - "+matcher.start());

        //第二次lookingAt匹配以及匹配的目标和匹配的起始位置
        print(matcher.lookingAt());
        print(matcher.group()+" - "+matcher.start());
    }

    public static void print(Object o){
        System.out.println(o);
    }
}
输出：
false
4
true
123 - 0
true
34345 - 4
true
123 - 0
true
123 - 0

13.2.3 正则表达式库的4个功能 P454
使用Matcher的匹配函数，共包括以下4种常用功能：
--查询――find()
如果查找时忽略大小写，写成：
Pattern p = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);

--提取――group()
调用group()函数提取的是获取整个匹配字符串，group(1)是第一个小括号子串内容，group(2)是第二个小括号子串内容，以此类推：
//
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile(".(\\d{3,5})-(\\d{3,5})..");
        String charSequence = "abcd-123-34345-234-00";
        Matcher matcher = pattern.matcher(charSequence);

        if (matcher.find()) {
            System.out.println(matcher.group());//整个匹配字符串内容
            System.out.println(matcher.group(0));//同group()

            for (int i = 1; i <= matcher.groupCount(); ++i) {
                System.out.println(matcher.group(i));
            }
        }
    }
}
输出如下：
-123-34345-2
123
34345

//
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    public static void main(String[] args) {
        String regEx = ".+\\\\(.+)$";
        String str = "c:\\dir\\dir2\\name.txt";
        Pattern p = Pattern.compile(regEx);
        Matcher m = p.matcher(str);
        boolean rs = m.find();

        System.out.println(m.group());
        System.out.println(m.group(0));//同group()

        for (int i = 1; i <= m.groupCount(); i++) {
            System.out.println(m.group(i));
        }
    }
}
输出如下：
c:\dir\dir2\name.txt
c:\dir\dir2\name.txt
name.txt

如果没有小括号包括的子串，则groupCount()为0，group()和group(0)仍是整个匹配的字符串。

--分隔――split():
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    public static void main(String[] args) {
        String regEx = "::";
        Pattern p = Pattern.compile(regEx);
        String[] r = p.split("xd::abc::cde");
        for (int i = 0; i < r.length; ++i) {
            System.out.println(r[i]);
        }
    }
}
输出：
xd
abc
cde

更简单的方法：
String str = "xd::abc::cde";
String[] r = str.split("::");

--替换――replaceAll()：
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TestPatternRegex {
    public static void main(String[] args) {
        String regEx = "a+";
        Pattern p = Pattern.compile(regEx);
        Matcher m = p.matcher("aaabbced a ccdeaaa");
        String s = m.replaceAll("A");
        System.out.println(s);
    }
}
输出：
Abbced A ccdeA

写成空串，可达到删除的功能，如：
String s = m.replaceAll("");

13.3.3 课后上机作业 P456
--分析某一网页URL地址的内容，取出其中的所有网页链接地址并输出。
根据网页内容，使用Pattern创建一个正则表达式，用以匹配以“href="”开头的、以“"”结尾的字符串。形如下面的链接代码中的地址：
<a href="http://XXXX/" target=_blank>
再取得Matcher，循环执行find()查找，输出其中的网页地址：
//
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class UrlAnalyzer {

    public String getUrlContent(String url) {
        StringBuffer content = new StringBuffer();

        InputStream is = null;
        BufferedReader br = null;
        try {
            URL httpUrl = new URL(url);
            HttpURLConnection connection = (HttpURLConnection) httpUrl.openConnection();
            connection.connect();

            is = connection.getInputStream();
            br = new BufferedReader(new InputStreamReader(is));
            String str = "";
            while ((str = br.readLine()) != null) {
                content.append(str);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                br.close();
                is.close();
            } catch (Exception e1) {
                e1.printStackTrace();
            }
        }

        return content.toString();
    }

    public List<String> getUrlList(String urlContent) {
        List<String> urlList = new ArrayList<>();
        Pattern p = Pattern.compile("(href=\")(http://.*?)(\")");
        Matcher m = p.matcher(urlContent);
        while (m.find()) {
            //String url2 = m.group();
            //urlList.add(url2.replace("href=\"", "").replace("\"", ""));
            //书中给的2行样例代码可以用如下语句代码，直接从group中获取
            urlList.add(m.group(2));
        }
        return urlList;
    }
}

public class TestPatternRegex {
    public static void main(String[] args) {
        UrlAnalyzer urlAnalyzer = new UrlAnalyzer();
        String urlContent = urlAnalyzer.getUrlContent("http://www.damai.cn/sh");
        //System.out.println(urlContent);
        List<String> urlList = urlAnalyzer.getUrlList(urlContent);
        //System.out.println(urlList);
        for (String url : urlList) {
            System.out.println(url);
        }
    }
}
输出：
http://dui.dmcdn.cn/??dm_2014/common/public-min.css,dm_2015/index/css/style-min.css,dm_2015/city/css/city-min.css,dm_2015/city/css/calendar-min.css
http://www.damai.cn/redirect.aspx?type=login
http://www.damai.cn/redirect.aspx?type=reg
http://my.damai.cn/
http://my.damai.cn/account/myinfo.aspx
http://order.damai.cn/index.aspx
http://my.damai.cn/trade/ewallet/myEwallet.aspx
......

这只是其中一部分网页链接。通常所示的搜索引擎蜘蛛，就是通过这种办法来进行网页内容分析的，对网页里链接的页面再进行抓取，即为深度抓取。分析的层次越深，则抓取尝试也越深，即通常所说的抓取深度。
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第14课 Java正则表达式 P459

14.1.6 总结 P462
JDOM和DOM在性能测试时表现不佳。
SAX表现较好，依赖于它特定的解析方式。
DOM4J性能最好。如果不考虑可移植性，则可以采用DOM4J。

14.2 使用XML库
建立一个books.xml放在src包下的xml包中，如下：
<?xml version="1.0" encoding="gb2312"?>
<books>
    <book isbn="7506342605">
        <name>《水浒传》</name>
        <price>80</price>
        <author>施耐庵</author>
        <year>元末</year>
    </book>
    <book isbn="7020008720">
        <name>《西游记》</name>
        <price>90</price>
        <author>吴承恩</author>
        <year>明代</year>
    </book>
    <book isbn="7111103033">
        <name>《三国演义》</name>
        <price>75</price>
        <author>罗贯中</author>
        <year>元末</year>
    </book>
    <book isbn="7807074930">
        <name>《红楼梦》</name>
        <price>79</price>
        <author>曹雪芹</author>
        <year>清代</year>
    </book>
</books>

14.2.1 使用DOM读取XML文件 P463
package test;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;

public class TestDOM {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //DOM工厂
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

            //DOM解析器
            DocumentBuilder builder = factory.newDocumentBuilder();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = builder.parse(file);

            //取得根节点
            Element root = doc.getDocumentElement();

            //取得子节点列表
            NodeList books = root.getChildNodes();
            for (int i = 0; i < books.getLength(); i++) {
                Node book = books.item(i);

                if (book.getNodeType() == Node.ELEMENT_NODE) {
                    //取得属性值
                    String isbn = book.getAttributes().getNamedItem("isbn").getNodeValue();
                    System.out.print(isbn);

                    for (Node node = book.getFirstChild(); node != null; node = node.getNextSibling()) {
                        if (node.getNodeType() == node.ELEMENT_NODE) {
                            if (node.getNodeName().equals("name")) {
                                String name = node.getFirstChild().getNodeValue();//获取text值，需要先获取FirstChild
                                System.out.print("\t" + name);
                            } else if (node.getNodeName().equals("price")) {
                                String price = node.getFirstChild().getNodeValue();
                                System.out.print("\t" + price);
                            } else if (node.getNodeName().equals("author")) {
                                String author = node.getFirstChild().getNodeValue();
                                System.out.print("\t" + author);
                            } else if (node.getNodeName().equals("year")) {
                                String year = node.getFirstChild().getNodeValue();
                                System.out.println("\t" + year);
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
输出：
7506342605    《水浒传》    80    施耐庵    元末
7020008720    《西游记》    90    吴承恩    明代
7111103033    《三国演义》    75    罗贯中    元末
7807074930    《红楼梦》    79    曹雪芹    清代
20

Tips：DOM只提供了解析XML文件的功能，不能使用它来写入一个XML文件。

14.2.2 使用SAX读取XML文件 P466
第二种选择是事件API，即SAX。这个概念是上述对象模型方式的一种反映。这种方法不根据XML语法定义通用的数据模型，其解析器依赖应用程序程序员建立定制的数据模型。
//
package test;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;
import java.util.Stack;

public class TestSAX extends DefaultHandler {
    Stack<String> tags = new Stack<>();

    public TestSAX() {
        super();
    }

    //接收元素中字符数据的通知
    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        String tag = (String) tags.peek();
        if (tag.equals("name")) {
            System.out.print("\t" + new String(ch, start, length));
        } else if (tag.equals("price")) {
            System.out.print("\t" + new String(ch, start, length));
        } else if (tag.equals("author")) {
            System.out.print("\t" + new String(ch, start, length));
        } else if (tag.equals("year")) {
            System.out.println("\t" + new String(ch, start, length));
        }
    }

    //接收文档开始的通知
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        if (qName.equals("book")) {
            System.out.print(attributes.getValue("isbn"));
        }
        tags.push(qName);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //SAX工厂
            SAXParserFactory factory = SAXParserFactory.newInstance();

            //SAX解析器
            SAXParser parser = factory.newSAXParser();

            //parse file
            File file = new File("src/xml/books.xml");
            TestSAX sax = new TestSAX();
            parser.parse(file, sax);
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }
}
输出：
7506342605    《水浒传》    
            80    
            施耐庵    
            元末
    
    
    
    
7020008720    《西游记》    
            90    
            吴承恩    
            明代
    
    
    
    
7111103033    《三国演义》    
            75    
            罗贯中    
            元末
    
    
    
    
7807074930    《红楼梦》    
            79    
            曹雪芹    
            清代
    
    
    

Time eclipsed: 17

由于SAX是基于事件模型，DefaultHandler接口提供了一系列的事件接口，我们只需要在不同的事件接口中实现自己的代码就可以实现对XML的解析了。这些事件主要可分成如下几类：
--文档、元素或命名空间开始通知事件：
    void startDocument();
    void startElement(...);
    void startPrefixMapping(...);
--文档、元素或命名空间结束通知事件：
    void endDocument();
    void endElement(...);
    void endPrefixMapping(...);
--数据通知事件：
    void characters(...);
--错误通知事件：
    void warning(SAXParseException e);
    void errors(SAXParseException e);
    void fatalError(SAXParseException e);
    
我们只需要在对应的通知事件实现函数中捕捉当前元素的数据信息即可。如上所示实例中，仅仅实现了开始元素和数据通知事件。
--如果元素是book元素，即输出ISBN号。
--如果是book的子元素，即输出各子元素的文本。

Tips：SAX保提供了解析XML文件的功能，不能使用它来写入一个XML文件。

14.2.3 使用JDOM读写XML文件 P468
package test;

import org.jdom2.Element;
import org.jdom2.input.SAXBuilder;
import org.jdom2.Document;

import java.io.File;
import java.util.List;

public class TestJDOM {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //取得解析器
            SAXBuilder builder = new SAXBuilder();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = builder.build(file);

            //取得根节点
            Element root = doc.getRootElement();

            //取得子节点列表
            List<Element> books = root.getChildren();
            for (int i = 0; i < books.size(); i++) {
                Element book = books.get(i);

                //取得属性值
                String isbn = book.getAttributeValue("isbn");
                System.out.print(isbn);

                String name = book.getChild("name").getText();//等价于book.getChildText("name");
                String price = book.getChild("price").getText();
                String author = book.getChild("author").getText();
                String year = book.getChild("year").getText();

                System.out.print("\t" + name);
                System.out.print("\t" + price);
                System.out.print("\t" + author);
                System.out.println("\t" + year);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }
}
输出：
7506342605    《水浒传》    80    施耐庵    元末
7020008720    《西游记》    90    吴承恩    明代
7111103033    《三国演义》    75    罗贯中    元末
7807074930    《红楼梦》    79    曹雪芹    清代
Time eclipsed: 39

JDOM是一个开源项目，它基于树型结构，利用纯Java技术对XML文档实现解析、生成、序列化及多种操作。把SAX和DOM的功能有效地结合起来。
JDOM由以下几个包组成：
--org.jdom
Tips：在JDOM里文档（Document）类由org.jdom.Document来表示。这要与org.w3c.dom中的Document区别开。
--org.jdom.adapters：包含了与DOM适配的Java类。
--org.jdom.filter：XML文档的过滤器类。
--org.jdom.input：读取XML文档的类。
--org.jdom.output：写入XML文档的类。
--org.jdom.transform：将JDOM XML文档接口转换为其XML文档接口。
--org.jdom.xpath：对XML文档XPath操作的类、JDOM类的说明。

由于JDOM提供了DOM和SAX两种实现，使用如下方式创建Document对象：
--DOMBuilder创建
--SAXBuilder创建
新版本中DOMBuilder已经去掉DOMBuilder.builder()，用SAX效率会比较快。

除了可以根据一个File对象创建，还可以将一个字符串讲稿解析，方法是：首先将字符串使用StringReader转化为Reader对象，然后调用build()函数解析。如下例：
String textXml = "<books><book isbn=\"7506342605\"><name>《水浒传》</name><price>80</price><author>施耐庵</author><year>元末</year></book><book isbn=\"7020008720\"><name>《西游记》</name><price>90</price><author>吴承恩</author><year>明代</year></book><book isbn=\"7111103033\"><name>《三国演义》</name><price>75</price><author>罗贯中</author><year>元末</year></book><book isbn=\"7807074930\"><name>《红楼梦》</name><price>79</price><author>曹雪芹</author><year>清代</year></book></books>";
Reader in = new StringReader(textXml);
Document doc = builder.build(in);

JDOM还提供了几个特殊的功能：写入XML文件、DTD验证、Schema验证、XPath读取等。
（1）写入XML
使用XMLOutputter输出到文件，如下例，可以直接使用XMLOutputter对象输出到某一个文件输出流：
package test;

import org.jdom2.Document;
import org.jdom2.input.SAXBuilder;
import org.jdom2.output.XMLOutputter;

import java.io.File;
import java.io.FileOutputStream;

public class TestJDOM {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //取得解析器
            SAXBuilder builder = new SAXBuilder();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = builder.build(file);

            FileOutputStream fos = new FileOutputStream("src/xml/output.xml");
            XMLOutputter outp = new XMLOutputter();
            outp.output(doc, fos);//但是生成的文件是UTF-8 格式
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }
}

上例输出到文件输出流，也可以输出到某一个Socket客户端：
outp.output(doc, socket.getOutputStream());

也可以输出到作为输出流类的System.out对象中：
//FileOutputStream fos = new FileOutputStream("src/xml/output.xml");
XMLOutputter outp = new XMLOutputter();
outp.output(doc, System.out);
//fos.close();

除了能够输出到OutputStream对象，还能够输出到Writer对象，如下：
FileWriter fos = new FileWriter("src/xml/output.xml");
XMLOutputter outp = new XMLOutputter();
outp.output(doc, fos);
fos.close();

（2）DTD验证 P472

（3）Schema验证 P472

（4）XPaht支持 P472
使用时先用XPath类的静态方法newInstance(String xpath)得到XPath对象，然后调用selectNodes(Object context)方法或selectSingleNode(Object context)方法，前者根据XPath语句返回一组节点（List对象），后者根据一个XPath语句返回符合条件的第一个节点（Object类型）。
如下两行：
//取得根节点
Element root = doc.getRootElement();

//取得子节点列表
List<Element> books = root.getChildren();

用XPath替换：
//取得根节点
XPath root = XPath.newInstance("//book");//代码此行报错，并且XPath是不推荐使用的

//取得子节点列表
List<?> books = root.selectNodes(doc);
for (int i = 0; i < books.size(); i++) {
    Element book = (Element) books.get(i);
}

XPath可以随意查询各种合法的XPath。

14.2.4 使用DOM4J读写XML文件 P472
package test;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;

public class TestDOM4J {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //取得解析器
            SAXReader reader = new SAXReader();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = reader.read(file);

            //取得根节点
            Element root = doc.getRootElement();

            //取得子节点列表
            for (int i = 0; i < root.nodeCount(); i++) {
                //取得某一个子节点
                Element book = (Element) root.node(i);//这里报错，类型转换有误？

                //取得属性值
                String isbn = book.attributeValue("isbn");
                System.out.print(isbn);

                String name = book.node(0).getText();
                String price = book.node(1).getText();
                String author = book.node(2).getText();
                String year = book.node(3).getText();

                System.out.print("\t" + name);
                System.out.print("\t" + price);
                System.out.print("\t" + author);
                System.out.println("\t" + year);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }
}

//CSDN博客的DOM4J使用参考样例
http://blog.csdn.net/yyywyr/article/details/38359049
package test;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.util.Iterator;
import java.util.List;

public class TestDOM4J {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //取得解析器
            SAXReader reader = new SAXReader();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = reader.read(file);

            //取得根节点
            Element root = doc.getRootElement();

            listNodes(root);
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }

    public static void listNodes(Element node) {
        System.out.println("当前节点的名称：" + node.getName());

        List<Attribute> list = node.attributes();

        for (Attribute attribute : list) {
            System.out.println("属性 " + attribute.getName() + ":" + attribute.getValue());
        }

        if (!(node.getTextTrim().equals(""))) {
            System.out.println("节点名称 " + node.getName() + ":" + node.getText());
        }

        Iterator<Element> iterator = node.elementIterator();
        while (iterator.hasNext()) {
            Element e = iterator.next();
            listNodes(e);
        }
    }
}
输出：
当前节点的名称：books
当前节点的名称：book
属性 isbn:7506342605
当前节点的名称：name
节点名称 name:《水浒传》
当前节点的名称：price
节点名称 price:80
当前节点的名称：author
节点名称 author:施耐庵
当前节点的名称：year
节点名称 year:元末
当前节点的名称：book
属性 isbn:7020008720
当前节点的名称：name
节点名称 name:《西游记》
当前节点的名称：price
节点名称 price:90
当前节点的名称：author
节点名称 author:吴承恩
当前节点的名称：year
节点名称 year:明代
当前节点的名称：book
属性 isbn:7111103033
当前节点的名称：name
节点名称 name:《三国演义》
当前节点的名称：price
节点名称 price:75
当前节点的名称：author
节点名称 author:罗贯中
当前节点的名称：year
节点名称 year:元末
当前节点的名称：book
属性 isbn:7807074930
当前节点的名称：name
节点名称 name:《红楼梦》
当前节点的名称：price
节点名称 price:79
当前节点的名称：author
节点名称 author:曹雪芹
当前节点的名称：year
节点名称 year:清代
Time eclipsed: 85

DOM4J是非常优秀的Java XML API。越来越多的Java软件都在使用DOM4J来读写XML。
DOM4J提供了几个特殊的功能：XPath支持、字符串与XML的转换、XML输出。

（1）读取并解析XML文档 P474
读取XML文档主要依赖于org.dom4j.io包，其中提供了DOMReader和SAXReader两类不同方式，调用方式是一样的。这就是依赖接口的好处。
reader.read方法是重载的，可以从InputStream、File、URL等多种不同的源来读取，得到的Document对象就代表了整个XML。
（2）XPath支持 P474
DOM4J对XPath有良好的支持，如访问一个节点，可直接用XPath选择。
List list = document.selectNodes("//foo/bar");
Node node = document.selectSingleNode("//foo/bar/author");
String name = node.valueOf("@name");

想查找XHTML文档中所有的超链接，下面代码可以实现：
List list = document.selectNodes("//a/@href");
for (Iterator iter = list.iterator(); iter.hasNext(); ) {
    Attribute attr = (Attribute) iter.next();
    String url = attribute.getValue();
}

（3）字符串与XML的转换
//XML转字符串
String text = document.asXML();
//字符串转XML
String text = "<person><name>James</name></person>";
Document document = DocumentHelper.parseText(text);

（4）文件输出
一个简单的输出方法是将一个Document或任何的Node通过write方法输出：
//取得解析器
SAXReader reader = new SAXReader();

//解析文件
File file = new File("src/xml/books.xml");
Document doc = reader.read(file);

FileWriter out = new FileWriter("src/xml/outputByDom4J.xml");
doc.write(out);//输出为gbk格式的
out.close();

如果想改变输出的格式，如美化输出或缩减格式，可以用XMLWriter类：
package test;

import org.dom4j.Document;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class TestDOM4J {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        try {
            //取得解析器
            SAXReader reader = new SAXReader();

            //解析文件
            File file = new File("src/xml/books.xml");
            Document doc = reader.read(file);

            write(doc);
        } catch (Exception e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time eclipsed: " + (end - start));
    }

    public static void write(Document document) throws IOException {
        XMLWriter writer = new XMLWriter(new FileWriter("src/xml/outputByDom4J.xml"));
        writer.write(document);
        writer.close();
    }
    
    //会生成缩进为2空格的文件
    public static void write(Document document) throws IOException {
        OutputFormat format = OutputFormat.createPrettyPrint();
        XMLWriter writer = new XMLWriter(new FileWriter("src/xml/outputByDom4J.xml"), format);//XMLWriter writer = new XMLWriter(System.out, format);会输出到Console
        writer.write(document);
        writer.close();
    }
    
    //生成只有一行内容的XML
    public static void write(Document document) throws IOException {
        OutputFormat format = OutputFormat.createCompactFormat();
        XMLWriter writer = new XMLWriter(new FileWriter("src/xml/outputByDom4J.xml"), format);
        writer.write(document);
        writer.close();
    }
    //<?xml version="1.0" encoding="UTF-8"?>
    //<books><book isbn="7506342605"><name>《水浒传》</name><price>80</price><author>施耐庵</author><year>元末</year></book><book isbn="7020008720"><name>《西游记》</name><price>90</price><author>吴承恩</author><year>明代</year></book><book isbn="7111103033"><name>《三国演义》</name><price>75</price><author>罗贯中</author><year>元末</year></book><book isbn="7807074930"><name>《红楼梦》</name><price>79</price><author>曹雪芹</author><year>清代</year></book></books>
}
输出为UTF-8 的

14.2.5 使用StAX读取XML文件 P475
Tips：从以上程序可以看出，它的方式与SAX思路完全相同，只是SAX使用了事件函数，StAX使用了分支事件。

14.3 属性文件读写 P478
除了XML文件以外，通常属性文件多用来作为系统的配置文件使用。属性文件都是以键值对的形式出现：
username=admin
password=123

14.3.1 读写属性文件的方法
Java中提供了一个java.util.Properties工具类，继承自Hashtable（见第12章）。使用Properties类可以方便地从一个.properties属性文件中读取设置参数，示例如下：
//
package test;

import java.io.FileInputStream;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

public class TestProperties {

    public static void main(String[] args) {
        try {
            Properties properties = new Properties();
            properties.load(new FileInputStream("src/properties/test.properties"));
            String value = properties.getProperty("username");
            System.out.println("username:" + value);

            Set keySet = properties.keySet();
//            for (Object s : keySet) {
//                System.out.println(s + ":" + properties.getProperty((String) s));
//            }
            //遍历所有key值
            for (Iterator it = keySet.iterator(); it.hasNext(); ) {
                String key = (String) it.next();
                System.out.println(key + ":" + properties.getProperty(key));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
username:admin
password:123
username:admin

如果properties文件打包到一个JAR或WAR文件中，可以使用ClassLoader的getResourceAsStream()方法得到一个InputStream对象，示例如下：
ClassLoader cl = this.getClass().getClassLoader();
InputStream is = c.getResourceAsStream("com/company/application/application.properties");

存储这些参数时，需要得到一个OutputStream对象，然后使用Properties的stores()方法。

14.3.2 读写文件实例 P479
//
package test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Iterator;
import java.util.Properties;

public class TestProperties {

    public static void main(String[] args) {
        try {
            Properties properties = new Properties();
            FileInputStream fis = new FileInputStream("src/properties/test.properties");
            properties.load(fis);

            Iterator<?> keys = properties.keySet().iterator();
            for ( ; keys.hasNext(); ) {
                String key = (String) keys.next();
                String value = properties.getProperty(key);
                System.out.println(key + "=" + value);
            }

            //写入文件
            FileOutputStream fos = new FileOutputStream("src/properties/config.properties");
            properties.store(fos, "my testproperties");//第二个参数是comments
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
password=123
username=admin

#my testproperties
#Tue Jul 12 23:08:09 CST 2016
password=123
username=admin

Tips：这种做法通常用来保存系统变量使用。系统修改了参数保存在properties文件中，系统启动时再加载这些属性。

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第15课 Java GUI库对比 P485
15.2.1 AWT实例 
略过没看？

15.2.2 Swing实例 P490
package test;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class HelloSwing extends JFrame {

    public static void main(String[] args) {
        new HelloSwing().run();
    }

    private void run() {
        configureJFrame();
        createButton();

        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        setVisible(true);
    }

    private void configureJFrame() {
        setTitle("Hello Swing");
        getContentPane().setLayout(new FlowLayout());
        setSize(new Dimension(200, 200));
        setLocation(0, 0);
    }

    private void createButton() {
        Button button = new Button("Open");

        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                createDialog();
            }
        });

        getContentPane().add(button, BorderLayout.NORTH);
    }

    private void createDialog() {
        JOptionPane.showMessageDialog(HelloSwing.this, "This is a dialog", "dialog", JOptionPane.INFORMATION_MESSAGE);
    }
}

Swing实现Hello World实例，只需要少量的代码，而且实现的界面也比AWT美观。

15.2.3 SWT实例 P492
略过没看？

15.2.4 JFace实例 P494
略过没看？

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第16课 AWT图形界面开发 P499
略过没看？
16.1 AWT界面组件 P499
（1）组件（Component）
Java图形用户界面的最基本组成部分是组件（Component），组件是一个可以以图形化的方式显示在屏幕上并能与用户进行交互的对象，如一个按钮，一个标签等。组件不能独立地显示出来，必须将组件放在一定的容器中才可以显示出来。
类java.awt.Component是许多组件类的父类，Component类中封装了组件通用的方法和属性，如图形组件对象、大小、显示位置、前景色和背景色、边界、可见性等。因此许多组件类也就继承了Component类的成员方法和成员变量。
（2）容器（Container）
容器java.awt.Container是Component的子类，因此容器本身也是一个组件，它具有组件的所有性质，但是它主要功能是容纳其他组件和容器。一个容器可以容纳多个组件，并使它们成为一个整体。所有容器都可以通过add()方法向容器中添加组件。
每个容器都有一个布局管理器（LayoutManager），当容器需要对某个组件进行定位或判断其大小时，就会调用其对应的布局管理器。
在程序中安排组件的位置和大小时，应该注意以下两点：
--在容器中的布局管理器负责各个组件的大小和位置，用户无法在这种情况下设置组件的这些属性，如果试图使用Java语言提供的setLocation()、setSize()、setBounds()等方法，都会被布局管理器覆盖。
--如果用户确实需要亲自设置组件大小或位置，则应取消该容器的布局管理器，方法为setLayout(null)。

16.1.2 窗口与对话框 P501
从组件树（P499）可以看出，共有3种类型的容器：窗口Window、面板Panel、滚动面板ScrollPane。Window的实现类有窗体类Frame和对话框类Dialog，ScrollPane的实现类有Applet（第21课讲解）。
（1）绘制窗体Frame
一般生成一个窗口，通常是用Window的子类Frame来进行实例化，而不是直接用Window类。每个Frame对象实例化后，都是没有大小和不可以见的。因此必须调用setSize()来设置大小（宽度和高度），调用setVisible(true)来设置窗口可见。
//
package test;

import java.awt.Color;
import java.awt.Frame;

public class TestFrame extends Frame {

    public static void main(String[] args) {
        TestFrame fr = new TestFrame("Test Frame");
        fr.setSize(200, 200);
        fr.setBackground(Color.red);
        fr.setVisible(true);
    }

    public TestFrame(String str) {
        super(str);
    }
}

（2）使用面板Panel
Panel是一个容器，放在Frame组件内，可以用于包装一组组件。作用是可以将Panel设置单独的布局，然后将该Panel作为一个单独的组件放在Frame中：
package test;

import java.awt.Color;
import java.awt.Frame;
import java.awt.Panel;

public class TestFrame extends Frame {

    public TestFrame(String str) {
        super(str);
    }

    public static void main(String[] args) {
        TestFrame fr = new TestFrame("Test Frame");
        fr.setSize(200, 200);
        fr.setBackground(Color.red);
        fr.setLayout(null);

        Panel pan = new Panel();
        pan.setSize(100, 100);
        pan.setBackground(Color.yellow);
        fr.add(pan);
        fr.setVisible(true);
    }
}

（3）对话框Dialog P503
Dialog不同于Frame，是一个显示提示信息的对话框。创建对话框时必须拥有一个Frame依赖类，表示从属于某一个窗体的对话框，并可以设置大小、布局。

（4）文本对话框

16.1.3 基本组件 P504
（1）文本Label
（2）按钮Button P505
Button b = new Button("退出");
按钮被单击后，会产生ActionEvent事件，需要使用ActionListener接口进行监听和处理事件。ActionEvent的对象调用getActionCommand()方法可以得到按钮的标识名，默认按钮名为label。用setActionCommand()可以为按钮设置组件标识符。
package test;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Checkbox;
import java.awt.Color;
import java.awt.Dialog;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

public class TestDialog extends Frame {

    public TestDialog(String str) {
        super(str);
    }

    public static void main(String[] args) {
        TestDialog fr = new TestDialog("Test Frame");
        fr.setSize(200, 200);
        fr.setBackground(Color.white);
        fr.createButton();
        fr.createCheckbox();
        fr.setVisible(true);
    }

    private void createCheckbox() {
        Checkbox checkbox = new Checkbox("China");
        checkbox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                String state = "deselected";
                if (e.getStateChange() == ItemEvent.SELECTED) {
                    state = "selected";
                }
                System.out.println(e.getItem() + " " + state);
            }
        });

        add(checkbox, BorderLayout.SOUTH);
    }

    private void createButton() {
        Button button = new Button("Open");
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                createDialog();
            }
        });
        add(button, BorderLayout.NORTH);
    }

    private void createDialog() {
        final Dialog dialog = new Dialog(TestDialog.this, "Dialog", true);
        dialog.setSize(267, 117);
        dialog.setLayout(new GridLayout(2, 1));

        dialog.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                dialog.dispose();
            }
        });

        Panel topPanel = new Panel();
        Label label = new Label("This is a dialog");
        topPanel.add(label, BorderLayout.NORTH);
        dialog.add(topPanel);
        dialog.setVisible(true);
    }
}

（3）复选框 Checkbox P505 参考上例
用getStateChange()获取当前状态。使用getItem()获得被修改复选框的字符串对象

（4）复选框组 CheckboxGroup P506
    private void createCheckboxGroup() {
        CheckboxGroup group = new CheckboxGroup();
        Checkbox checkbox1 = new Checkbox("Beijing", group, true);
        Checkbox checkbox2 = new Checkbox("Shanghai", group, false);
        Checkbox checkbox3 = new Checkbox("Guangzhou", group, false);
        add(checkbox1);
        add(checkbox2);
        add(checkbox3);
    }
    
（5）下拉列表 Choice P506

（6）文本框 TextField P506
显示一个输入的文本框，回车键按下时，发生ActionEvent事件，通过ActionListener中的actionPerformed()方法对事件进行相应处理，使用getText()方法取得文本域的输入，使用setEditable(boolean)设置只读属性。

（7）文本区域TextArea P507

（8）列表List P507

（9）画布 Canvas P507
一个应用程序必须继承Canvas类才能获得有用的功能，如创建一个自定义组件。如果想在画面上完成一些图形处理，则Canvas类中的paint()方法必须被重写。Canvas组件监听各种鼠标、键盘事件。当在组件中输入字符时，必须先调用requestFocus()方法。
package test;

import java.awt.Canvas;
import java.awt.Frame;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

public class TestCanvas implements KeyListener, MouseListener {
    Canvas c;
    String s = "";

    @Override
    public void keyTyped(KeyEvent e) {
        System.out.println("KeyTyped");
        s += e.getKeyChar();
        c.getGraphics().drawString(s, 0, 20);
    }

    @Override
    public void mouseClicked(MouseEvent e) {
        System.out.println("MouseClicked");
        c.requestFocus();
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {

    }

    @Override
    public void mouseEntered(MouseEvent e) {

    }

    @Override
    public void mouseExited(MouseEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    public static void main(String[] args) {
        Frame f = new Frame("Test Canvas");
        TestCanvas testCanvas = new TestCanvas();
        testCanvas.c = new Canvas();
        f.add("Center", testCanvas.c);

        f.setSize(150, 150);
        testCanvas.c.addMouseListener(testCanvas);
        testCanvas.c.addKeyListener(testCanvas);
        f.setVisible(true);
    }
}

16.1.4 菜单组件 P508
（1）菜单栏 MenuBar
要添加菜单组件，首先需要添加菜单栏MenuBar。MenuBar只能被添加到Frame对句中，作为整个菜单树的根基。如下：
MenuBar mb = new MenuBar();
setMenuBar(mb);

（2）菜单 Menu 
Menu m1 = new Menu("File");
Menu m1 = new Menu("Edit");
Menu m1 = new Menu("Help");
mb.add(m1);
mb.add(m2);
mb.setHelpMenu(m3);//设置帮助菜单

（3）菜单选项 MenuItem P509
MenuItem mi1 = new MenuItem("Open");
MenuItem mi1 = new MenuItem("Exit");
m1.add(mi1);
m1.addSeparator();
m1.add(mi2);

MenuItem对象可以添加ActionListener事件，完成相应的监听操作。
//示例代码
package test;

import java.awt.Frame;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestMenu extends Frame {
    public static void main(String[] args) {
        TestMenu tm = new TestMenu();
        tm.setTitle("Test Menu");
        tm.setSize(200, 200);
        tm.setVisible(true);

        MenuBar mb = new MenuBar();
        tm.setMenuBar(mb);

        Menu m1 = new Menu("File");
        Menu m2 = new Menu("Edit");
        Menu m3 = new Menu("Help");
        mb.add(m1);
        mb.add(m2);
        mb.setHelpMenu(m3);

        MenuItem mi1 = new MenuItem("Open");
        MenuItem mi2 = new MenuItem("Save");
        MenuItem mi3 = new MenuItem("Exit");
        m1.add(mi1);
        m1.add(mi2);
        m1.addSeparator();
        m1.add(mi3);

        mi1.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Open Event");
            }
        });

        mi3.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });
    }
}

16.2 AWT布局管理器 P509
在使用布局管理器之前，需要注意以下几点：
--Frame是一个顶级容窗口，Frame的默认布局管理器为BorderLayout。
--Panel无法单独显示，必须添加到某个容器中。Panel的默认布局管理器为FlowLayout。
--当把Panel作为一个组件添加到某个容器中后，该Panel仍然可以有自己的布局管理器。可以利用Panel使得BorderLayout中某个区域显示多个组件，达到设计复杂用户界面的目的。
--如果采用无布局管理器setLayout(null)，则必须使用setLocation()、setSize()、setBounds()等方法手工设置组件的大小和位置，此方法会导致平台相关，不鼓励使用。

16.2.1 流式布局 FlowLayout P510
FlowLayout是Panel、Applet的默认布局管理器。其组件的放置规则是从上到下，从左到右进行放置。
package test;

import java.awt.Button;
import java.awt.FlowLayout;
import java.awt.Frame;

public class TestFlowLayout {
    public static void main(String[] args) {
        Frame f = new Frame("Test FlowLayout");
        f.setLayout(new FlowLayout());

        Button button1 = new Button("OK");
        Button button2 = new Button("Open");
        Button button3 = new Button("Close");

        f.add(button1);
        f.add(button2);
        f.add(button3);
        f.setSize(300, 100);
        f.setVisible(true);
    }
}
默认打开三个按钮都在同一行，窗口修改变窄，则按钮跑到第二行去了。该布局组件的大小不变，相对位置会发生变化。

16.2.2 区域布局 BorderLayout P511
BorderLayout是Window、Frame和Dialog的默认布局管理器。分成5个区域：North、South、East、West和Center，每个区域只能放置一个组件。
使用BorderLayout的时候，如果容器的大小变化，变化规律为：组件的相对位置不变，大小发生变化。如容器变高了，则North、South区域不变，West、Center、East区域变高；如果容器变宽了，则West、East区域不变，North、Center、South区域变宽。
package test;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Frame;

public class TestBorderLayout {
    public static void main(String[] args) {
        Frame f = new Frame("Test FlowLayout");
        f.setLayout(new BorderLayout());

        f.add(BorderLayout.NORTH, new Button("North"));
        f.add(BorderLayout.SOUTH, new Button("South"));
        f.add(BorderLayout.EAST, new Button("East"));
        f.add(BorderLayout.WEST, new Button("West"));
        f.add(BorderLayout.CENTER, new Button("Center"));
        f.setSize(300, 200);
        f.setVisible(true);
    }
}
不一定所有的区域都有组件，如果四周的区域没有组件，则由Center区域去补充，但是如果Center区域没有组件，则保持空白。

16.2.3 网格布局 GridLayout P512
GridLayout使容器中各个组件呈网格状布局，平均占据容器的空间，创建该布局时需要指定风格的行数和列数，然后依次添加各个组件时，会按照先行后列的顺序依次添加。
package test;

import java.awt.Button;
import java.awt.Frame;
import java.awt.GridLayout;

public class TestGridLayout {
    public static void main(String[] args) {
        Frame f = new Frame("Test FlowLayout");
        f.setLayout(new GridLayout(3, 2));

        f.add(new Button("1"));
        f.add(new Button("2"));
        f.add(new Button("3"));
        f.add(new Button("4"));
        f.add(new Button("5"));
        f.add(new Button("6"));

        f.setSize(200, 200);
        f.setVisible(true);
    }
}

16.2.4 卡片布局 CardLayout P513
CardLayout卡片布局管理器能够帮助用户处理两个以至更多的成员共享同一显示空间，它把容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件，当然每层都可以利用Panel来实现复杂的用户界面。
package test;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.CardLayout;
import java.awt.Color;
import java.awt.Frame;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestCardLayout extends Frame implements ActionListener {
    private static final long serialVersionUID = 1L;
    CardLayout cardLayout = new CardLayout();
    Panel panelCard = new Panel();

    public TestCardLayout(String str) {
        super(str);
        setSize(400, 200);

        panelCard.setLayout(cardLayout);
        Panel panel1 = new Panel();
        Panel panel2 = new Panel();
        Panel panel3 = new Panel();
        Panel panel4 = new Panel();

        panel1.setBackground(Color.red);
        panel2.setBackground(Color.green);
        panel3.setBackground(Color.blue);
        panel4.setBackground(Color.black);

        panelCard.add(panel1, "1");//字符串1~4不太知道什么作用，不加也没什么问题
        panelCard.add(panel2, "2");
        panelCard.add(panel3, "3");
        panelCard.add(panel4, "4");
        add(panelCard, BorderLayout.CENTER);

        //创建按钮
        Button button1 = new Button("First Page");
        Button button2 = new Button("Previous Page");
        Button button3 = new Button("Next Page");
        Button button4 = new Button("Last Page");

        button1.addActionListener(this);
        button2.addActionListener(this);
        button3.addActionListener(this);
        button4.addActionListener(this);

        Panel panelButton = new Panel();
        panelButton.add(button1);
        panelButton.add(button2);
        panelButton.add(button3);
        panelButton.add(button4);
        add(panelButton, BorderLayout.NORTH);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("First Page")) {
            cardLayout.first(panelCard);
        } else if (e.getActionCommand().equals("Previous Page")) {
            cardLayout.previous(panelCard);
        } else if (e.getActionCommand().equals("Next Page")) {
            cardLayout.next(panelCard);
        } else if (e.getActionCommand().equals("Last Page")) {
            cardLayout.last(panelCard);
        }
    }

    public static void main(String[] args) {
        new TestCardLayout("Test CardLayout");
    }
}
单击4个按钮实现卡片的切换。
这种卡片程序通常用在需要多页显示的界面中。
Tips：GridBagLayout是所有AWT布局管理器当中最复杂的，也是功能最强大的。它提供了众多的可配置选项，你几乎可以完全地控制容器的布局方式。

16.2.5 容器的嵌套 P515
容器的嵌套都是使用Panel来完成的，每一个Panel可以设置布局，在一个Panel中可以添加多个组件，然后将该Panel作为一个整体添加到其他的组件中。
前方中16.1.2 节Panel组件的实例，就是嵌套的实例。其中Frame是一个顶层容器，Panel是一个面板容器，Panel被放入Frame中，就属于嵌套。

16.3 AWT事件处理 P515
16.3.1 事件授权模型 P515
事件处理的过程中，主要涉及以下3类对象：
--Event――事件：用户对界面操作在Java语言上的描述，以类的形式出现，如键盘操作对应的事件类是KeyEvent。
--Event Source――事件源：事件发生的场所，通常就是各个组件，如按钮Button。
--Event Handler――事件处理者：接收事件对象并对其进行处理的对象。

授权模型把事件的处理委托给外部的处理实例进行处理，实现 了将事件源和监听器分开的西岭雪山。事件处理者（监听器）通常是一个类，该类如果要能够处理某种类型的事件，就必须实现与该事件类型相对的接口。
使用授权处理模型进行事件处理的一般方法归纳如下：
--对于某种类型的事件XXXEvent，要想接收并处理这类事件，必须定义相应的事件监听器类，该类需要实现与该事件相对应的接口XXXListener。
--事件源实例化以后，必须进行授权，注册该类事件的监听器，使用addXXXListener(XXXListener)方法来注册监听器

16.3.2 授权模型：事件类型 P516
AWT提供了以下事件类型（大部分在java.awt.events包中）：

AWT事件共有10类，可以归为两大类：低级事件和高级事件。
（1）低级事件 P517
低级事件是指基于组件和容器的事件，当一个组件上发生事件，如：鼠标的进入、单击、拖放等，或组件的窗口开关等，触发了组件事件。
--ComponentEvent――组件事件：组件尺寸的变化、移动。
--ContainerEvent――容器事件：组件增加、移动。
--WindowEvent――窗口事件：关闭窗口、窗口闭合、图标化。
--FocusEvent――焦点事件：焦点的获得和丢失。
--KeyEvent――键盘事件：键按下、释放。
--MouseEvent――鼠标事件：鼠标单击、移动。

（2）高级事件
高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此类事件的类，如在TextField中按Enter键会触发ActionEvent事件、滑动滚动条触发AdjustmentEvent事件，或是选中项目列表的某一条就会触发ItemEvent事件。
--ActionEvent――动作事件：按钮按下，在TextField中按“Enter”键。
--AdjustmentEvent――调节事件：在滚动条上移动滑块以调节数值。
--ItemEvent――项目事件：选择项目，不选择项目改变。
--TextEvent――文本事件：文本对象改变。

16.3.3 授权模型：事件监听器 P517
每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法。通常对于AWT来说（也适用于Swing和SWT），每个事件类型都有一个相关的XXXListener接口（XXXAdapter的实现可能为空），其中XXX是去掉Event后缀的事件名，用来把事件传递给处理程序。应用程序会为自己感兴趣的事件的事件源（GUI组件或部件）进行注册。
如与键盘事件KeyEvent相对应的接口是：
public interface KeyListener extends EventListener {

    /**
     * Invoked when a key has been typed.
     * See the class description for {@link KeyEvent} for a definition of
     * a key typed event.
     */
    public void keyTyped(KeyEvent e);

    /**
     * Invoked when a key has been pressed.
     * See the class description for {@link KeyEvent} for a definition of
     * a key pressed event.
     */
    public void keyPressed(KeyEvent e);

    /**
     * Invoked when a key has been released.
     * See the class description for {@link KeyEvent} for a definition of
     * a key released event.
     */
    public void keyReleased(KeyEvent e);
}

又例如窗口事件接口：
public interface WindowListener extends EventListener {
    /**
     * Invoked the first time a window is made visible.
     */
    public void windowOpened(WindowEvent e);

    /**
     * Invoked when the user attempts to close the window
     * from the window's system menu.
     */
    public void windowClosing(WindowEvent e);

    /**
     * Invoked when a window has been closed as the result
     * of calling dispose on the window.
     */
    public void windowClosed(WindowEvent e);

    /**
     * Invoked when a window is changed from a normal to a
     * minimized state. For many platforms, a minimized window
     * is displayed as the icon specified in the window's
     * iconImage property.
     * @see java.awt.Frame#setIconImage
     */
    public void windowIconified(WindowEvent e);

    /**
     * Invoked when a window is changed from a minimized
     * to a normal state.
     */
    public void windowDeiconified(WindowEvent e);

    /**
     * Invoked when the Window is set to be the active Window. Only a Frame or
     * a Dialog can be the active Window. The native windowing system may
     * denote the active Window or its children with special decorations, such
     * as a highlighted title bar. The active Window is always either the
     * focused Window, or the first Frame or Dialog that is an owner of the
     * focused Window.
     */
    public void windowActivated(WindowEvent e);

    /**
     * Invoked when a Window is no longer the active Window. Only a Frame or a
     * Dialog can be the active Window. The native windowing system may denote
     * the active Window or its children with special decorations, such as a
     * highlighted title bar. The active Window is always either the focused
     * Window, or the first Frame or Dialog that is an owner of the focused
     * Window.
     */
    public void windowDeactivated(WindowEvent e);
}

不同类型的事件由不同的监听器监听，每一种监听器都提供了各种处理函数接口方法，在该方法中编写事件的处理代码。P518
不同的组件拥有不同的事件类型，比如文本框有键盘输入事件、按钮有鼠标单击事件等，因此不同的组件也对应了不同的监听器类型。 P519

16.3.4 使用事件监听器 P519
要使用监听器来监听事件，必须进行注册。AWT的组件类中提供注册和注销监听器的方法。
--注册监听器：
public void add<ListenerType>(<ListenerType>listener);
--注销监听器：
public void remove<ListenerType>(<ListenerType>listener);

要实现监听器的注册与注销，有3种方式：
（1）实现监听器接口
这种方法是创建一个类，要求其实现XXXListener接口，在该类中根据需要实现相应的事件处理函数。
下例演示了实现监听器接口的方式。类TestListener实现了3个监听器接口MouseMotionListener、MouseListener和WindowListener，用以监听鼠标移动、鼠标单击及窗体事件。
package test;

import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;

public class TestListener implements MouseMotionListener, MouseListener, WindowListener {
    private Frame f;
    private TextField textField;

    public static void main(String[] args) {
        TestListener testListener = new TestListener();
        testListener.go();
    }

    public void go() {
        f = new Frame("Listener Sample");
        f.add(new Label("Manupalute Mouse"), BorderLayout.NORTH);
        textField = new TextField(30);
        f.add(textField, BorderLayout.SOUTH);//f.add(textField, "South");
        f.addMouseMotionListener(this);
        f.addMouseListener(this);
        f.addWindowListener(this);
        f.setSize(300, 200);
        f.setVisible(true);
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {
        String s = "Mouse pressed";
        textField.setText(s);
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        String s = "Mouse released";
        textField.setText(s);
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        String s = "Mouse entering";
        textField.setText(s);
    }

    @Override
    public void mouseExited(MouseEvent e) {
        String s = "Mouse leaving";
        textField.setText(s);
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        String s = "Mouse position: X=" + e.getX() + " Y=" + e.getY();
        textField.setText(s);
    }

    @Override
    public void mouseMoved(MouseEvent e) {
        String s = "Mouse moving";
        textField.setText(s);
    }

    @Override
    public void windowOpened(WindowEvent e) {

    }

    //为了使窗口能正常关闭、程序正常退出，需要实现windowClosing方法
    @Override
    public void windowClosing(WindowEvent e) {
        System.exit(1);
    }

    @Override
    public void windowClosed(WindowEvent e) {

    }

    @Override
    public void windowIconified(WindowEvent e) {

    }

    @Override
    public void windowDeiconified(WindowEvent e) {

    }

    @Override
    public void windowActivated(WindowEvent e) {

    }

    @Override
    public void windowDeactivated(WindowEvent e) {

    }
}

上例几个特点：
--可以声明实现多个接口，接口之间用逗号隔开
--可以由同一个对象监听一个事件源上发生的多种事件
f.addMouseMotionListener(this);
f.addMouseListener(this);
f.addWindowListener(this);

对象f上发生的多个事件都将被同一个监听器接收和处理。
--事件处理者和事件源处在同一个类中。在本例中事件源是Frame f，事件处理者是类TestListener，其中事件源Frame f是类的成员变量。
--可以通过事件对象获得详细资料，如本例中就通过事件对象获得了鼠标发生时的坐标值。
Tips：Java语言类层次非常分明，因而只支持单继承，为了实现多重继承能力，Java用接口来实现，一个类可以实现多个接口，这种机制比多重继承具有更简单、灵活、更强的功能。在AWT中就经常用到声明和实现多个接口。记住无论实现了几个接口，接口中已定义的方法必须一一实现，如果对某事件不进行处理，可以不具体实现其方法，而用空的方法体来代替。但却必须把所有的方法都要写上。

（2）使用内部类 P522
内部类（Inner Class）是被定义于另一个类中的类，使用内部类的主要原因如下：
--一个内部类的对象可访问外部类的成员方法和变量，包括私有的成员。
--实现事件监听器时，采用内部类、匿名类编程非常容易实现其功能。
--编写事件驱动程序，内部类很方便。

因此内部类所能够应用的地方往往是在AWT的事件处理机制中。
package test;

import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

public class TestInnerClass {
    private Frame f;
    private TextField textField;

    public TestInnerClass() {
        f = new Frame("Test InnerClass");
        textField = new TextField(30);
    }

    public static void main(String[] args) {
        TestInnerClass testListener = new TestInnerClass();
        testListener.createFrame();
    }

    public void createFrame() {//这里private也没有关系，因为main函数也是在这个类中，如果是别的类需要访问，则必须是public
        f.add(new Label("Manupalute Mouse"), BorderLayout.NORTH);
        f.add(textField, BorderLayout.SOUTH);//f.add(textField, "South");

        //参数为内部类对象
        f.addMouseMotionListener(new MyMouseMotionListener());
        f.setSize(300, 200);
        f.setVisible(true);
    }

    private class MyMouseMotionListener implements MouseMotionListener {
        @Override
        public void mouseDragged(MouseEvent e) {
            String s = "Mouse dragging: X=" + e.getX() + " Y=" + e.getY();
            textField.setText(s);
        }

        @Override
        public void mouseMoved(MouseEvent e) {

        }
    }
}

（3）使用匿名类 P523
当一个内部类的类声名只是在创建此类对象时用了一次，而且要产生的新类需要继承于一个已有的父类或实现一个接口，才能考虑用匿名类（Anonymous Class），由于匿名类本身无名，因此它也就不存在构造方法，它需要显式地调用一个无参的父类的构造方法，并且重写父类的方法，所谓的匿名就是该类连名字都没有，只是显式地调用一个无参的父类的构造方法。
package test;

import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

public class TestAnonymousClass {
    private Frame f;
    private TextField textField;

    public TestAnonymousClass() {
        f = new Frame("Test InnerClass");
        textField = new TextField(30);
    }

    public static void main(String[] args) {
        TestAnonymousClass testListener = new TestAnonymousClass();
        testListener.createFrame();
    }

    private void createFrame() {
        f.add(new Label("Manupalute Mouse"), BorderLayout.NORTH);
        f.add(textField, BorderLayout.SOUTH);//f.add(textField, "South");

        //参数为内部类对象
        f.addMouseMotionListener(new MouseMotionListener() {
            @Override
            public void mouseDragged(MouseEvent e) {
                String s = "Mouse dragging: X=" + e.getX() + " Y=" + e.getY();
                textField.setText(s);
            }

            @Override
            public void mouseMoved(MouseEvent e) {

            }
        });
        f.setSize(300, 200);
        f.setVisible(true);
    }
}

16.3.5 使用事件适配器 P524
Java语言为一些Listener接口提供了适配器（Adapter）类。可以通过继承事件所对应的Adapter类，重写需要的方法即可，无关方法不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序。但是，由于Java的单一继承机制，当需要多种监听器或此类已有父类时，就无法采用事件适配器了。
java.awt.event包中定义的事件适配器类包括以下几个：
--ComponentAdapter组件适配器。
--ContainerAdapter容器适配器。
--FocusAdapter焦点适配器。
--KeyAdapter键盘适配器。
--MouseAdapter鼠标适配器。
--MouseMotionAdapter鼠标运行适配器。
--WindowAdapter窗口适配器。

WindowAdapter是一个抽象类，但是它实现了WindowListener的所有方法（都是空实现）。
16-19 中的内部类，它实现了接口MouseMotionListener。由于它只需要实现一个监听器，因此可以通过继承适配器的方式，这样就可以省略不需要的事件函数代码。
package test;

import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

public class TestAdapter {
    private Frame f;
    private TextField textField;

    public TestAdapter() {
        f = new Frame("Test InnerClass");
        textField = new TextField(30);
    }

    public static void main(String[] args) {
        TestAdapter testListener = new TestAdapter();
        testListener.createFrame();
    }

    private void createFrame() {
        f.add(new Label("Manupalute Mouse"), BorderLayout.NORTH);
        f.add(textField, BorderLayout.SOUTH);//f.add(textField, "South");

        //参数为内部类对象
        f.addMouseMotionListener(new MyMouseMotionListener() {
        });
        f.setSize(300, 200);
        f.setVisible(true);
    }

    private class MyMouseMotionListener extends MouseMotionAdapter {
        @Override
        public void mouseDragged(MouseEvent e) {
            String s = "Mouse dragging: X=" + e.getX() + " Y=" + e.getY();
            textField.setText(s);
        }
    }
}

16.4.3 Java文本编辑器 P528
package test;

import javafx.scene.layout.Pane;

import java.awt.BorderLayout;
import java.awt.Dialog;
import java.awt.FileDialog;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.MenuShortcut;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class TextEditor extends WindowAdapter implements ActionListener {
    private Frame frame;
    private TextArea textArea;
    private String fileName;

    @Override
    public void windowClosing(WindowEvent e) {
        System.exit(0);
    }

    public void createEditor() {
        //添加菜单项
        MenuBar menuBar = new MenuBar();

        Menu menuFile = new Menu("File");
        MenuItem menuItemNew = new MenuItem("New", new MenuShortcut(KeyEvent.VK_N));
        menuFile.add(menuItemNew);
        MenuItem menuItemOpen = new MenuItem("Open", new MenuShortcut(KeyEvent.VK_O));
        menuFile.add(menuItemOpen);
        MenuItem menuItemSave = new MenuItem("Save", new MenuShortcut(KeyEvent.VK_S));
        menuFile.add(menuItemSave);
        menuFile.add("Save as...");//内部实现会生成一个Label为该字符串的MenuItem
        menuFile.addSeparator();
        menuFile.add("Exit");
        menuFile.addActionListener(this);//点击事件是注册在Menu上的
        menuBar.add(menuFile);

        Menu menuHelp = new Menu("Help");
        menuHelp.add("About");
        menuHelp.addActionListener(this);
        menuBar.setHelpMenu(menuHelp);

        //主窗口
        frame = new Frame("Java Text Editor");
        frame.setMenuBar(menuBar);
        textArea = new TextArea();
        frame.add("Center", textArea);
        frame.addWindowListener(this);//注册窗口关闭监听器
        frame.setSize(600, 400);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        TextEditor textEditor = new TextEditor();
        textEditor.createEditor();
    }

    //菜单选择事件
    @Override
    public void actionPerformed(ActionEvent e) {
        try {
            if (e.getActionCommand() == "New") {
                textArea.setText("");
                fileName = null;
            } else if (e.getActionCommand() == "Open") {
                //Select a file
                fileName = getFileName("Open");
                if (fileName == null) {
                    return;
                }

                //Read file
                FileReader fileReader = new FileReader(fileName);
                BufferedReader br = new BufferedReader(fileReader);
                String str = "";
                while (br.ready()) {
                    int c = br.read();
                    str += (char) c;
                }
                textArea.setText(str);
                br.close();
                fileReader.close();
                frame.setTitle("Java Text Editor - " + fileName);
            } else if (e.getActionCommand() == "Save") {
                if (textArea.getText().equals("")) {
                    return;
                }
                if (fileName == null) {
                    fileName = getFileName("Save");
                }

                //取消时，将得到null
                if (fileName == null) {
                    return;
                } else {
                    saveFile(fileName, false);
                }
            } else if (e.getActionCommand() == "Save as...") {
                fileName = getFileName("Save as");

                //取消时，将得到null
                if (fileName == null) {
                    return;
                } else {
                    saveFile(fileName, false);
                }
            } else if (e.getActionCommand() == "Exit") {
                System.exit(0);
            } else if (e.getActionCommand() == "About") {
                //显示关于对话框
                final Dialog dialog = new Dialog(frame, "About", true);
                dialog.setSize(267, 117);
                //dialog.setLayout(new GridLayout(2, 1));//这里就一个topPanel，不需要设置GridLayout

                //窗口关闭事件
                dialog.addWindowListener(new WindowAdapter() {
                    @Override
                    public void windowClosing(WindowEvent e) {
                        dialog.dispose();
                    }
                });

                //显示消息
                Panel topPanel = new Panel();
                
                Label label = new Label("Java Text Editor - Author: DingBen");
                topPanel.add(label, BorderLayout.NORTH);
                
                // Label labelAuthor = new Label("Java Text Editor - Author: DingBen");
                // Label labelVersion = new Label("Version 1.0");
                // Label labelDate = new Label("Release Date: 2016-7-27");
                // topPanel.setLayout(new GridLayout(3, 1));

                // topPanel.add(labelAuthor);
                // topPanel.add(labelVersion);
                // topPanel.add(labelDate);
                
                dialog.add(topPanel);
                dialog.setVisible(true);
            }
        } catch (FileNotFoundException e1) {

        } catch (IOException e1) {

        }
    }

    private void saveFile(String selectFileName, boolean overwrite) throws IOException {
        File file = new File(selectFileName);
        FileWriter fos = new FileWriter(file, overwrite);
        BufferedWriter bos = new BufferedWriter(fos);
        PrintWriter pos = new PrintWriter(bos);
        //写入对象数据
        pos.print(textArea.getText());

        pos.close();
        bos.close();
        fos.close();
    }

    private String getFileName(String dialogTitle) {
        FileDialog fileDialog = new FileDialog(frame, dialogTitle, 0);
        fileDialog.setVisible(true);
        if (fileDialog.getDirectory() == null)
        {
            return null;
        }
        else {
            String selectedFileName = fileDialog.getDirectory() + fileDialog.getFile();//getDirectory中最后带着分隔符
            return selectedFileName;
        }
    }
}

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第17课 AWT多媒体编程 P535
17.1 图像处理――java.awt.image P535
17.1.1 加载图像
AWT可以很简单地两种格式的图像：GIF和JPEG。Toolkit类提供了两个getImage()方法来加载图像。
--Image getImage(URL url);
--Image getImage(String filename);
Toolkit是一个组件类，取得Toolkit的方法是：
Toolkit toolkit = Toolkit.getDefaultToolkit();
对于继承了Frame的类来说，可以直接使用下面的方法取得：
Toolkit toolkit = getToolkit();
下面是两个加载图片的实例：
Toolkit toolkit = Toolkit.getDefaultToolkit();
Image image1 = toolkit.getImage("imageFile.gif");
Image image2 = toolkit.getImage(new URL("http://.../people.gif"));
如果你的类是Applet，可以使用Applet的两个getImage()方法来直接加载图片：
Image getImage(URL url);
Image getImage(URL url, String name);

17.1.2 显示图像 P536
通过传递到paint()方法的Graphics对象可以很容易地显示图像。Graphics类声明了下面的4个drawImage()方法。它们都返回一个boolean值，虽然这个值很少被使用。如果图像已经被完全加载并且因此被完全绘制，返回值是true，否则，返回值是false。
组件可以指定this作为图像观察者的原因是，Component类实现了ImageObserver接口。当图像数据被加载时，它的实现会调用repaint()方法。
例如下面代码在组件区域的左上角(0, 0)以原始大小显示一个图像。
g.drawImage(myImage, 0, 0, this);
下面的代码在坐标(90, 0)处显示一个被缩放为宽300像素高62像素的图像。
g.drawImage(myImage, 90, 0, 300, 62, this);

17.1.3 实例一：显示图片 P536
编写一个窗体，用来加载图像并进行显示。该类继承自Frame，可以直接使用getToolkit()方法来取得Toolkit对象，然后使用getImage()来取得一张本地图片文件，最后在paint()中使用Graphics的drawImage()即可显示该图像。
package test;

import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Image;

public class ShowImage extends Frame {
    private String fileName;

    public ShowImage(String fileName) {
        setSize(470, 350);
        setVisible(true);
        this.fileName = fileName;
    }

    @Override
    public void paint(Graphics g) {
        //取得图片对象
        Image image = getToolkit().getImage(fileName);
        //画图
        g.drawImage(image, 50, 50, this);
    }

    public static void main(String[] args) {
        new ShowImage("src/image/1.jpg");
    }
}

17.1.4 实例二：缩放图片 P537
通过getImage()方法取得的是java.awt.Image类型的对象，也可以使用javax.imageio.ImageIO类的read()取得一个图像，返回的是BufferedImage对象。
BufferedImage ImageIO.read(Url);
BufferedImage是Image的子类，它描述了具有可访问图像数据缓存区的Image，可以通过该类来实现图片的缩放。
//
package test;

import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGImageEncoder;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;

public class ZoomImage {
    public void zoom(String file1, String file2) {
        try {
            File file = new File(file1);
            Image src = javax.imageio.ImageIO.read(file);//构造Image对象，返回的BufferedImage对象，是Image的子类
            int width = src.getWidth(null);
            int height = src.getHeight(null);

            BufferedImage tag = new BufferedImage(width / 2, height / 2, BufferedImage.TYPE_INT_RGB);
            tag.getGraphics().drawImage(src, 0, 0, width / 2, height / 2, null);//绘制缩小的图

            //写入图片
            FileOutputStream out = new FileOutputStream(file2);//输出到文件流
            JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
            encoder.encode(tag);
            out.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        String file1 = "src/image/1.jpg";
        String file2 = "src/image/half1.jpg";
        new ZoomImage().zoom(file1, file2);
    }
}
运行该程序，即可生成一个长宽为原图一半的新图片。如果大家对图像处理有更高的要求，可以关注一下开源项目。如JMagick，可以使用JMagick实现图片的复制、信息获取、斜角、特效、组合、改变大小、加边框、旋转、切片、改变格式、去色等功能。

17.2 二维图像绘制――Java2D P538
Java2D的绘图过程：
（1）取得Graphics2D对象。
（2）设置Graphics2D属性。
（3）创建绘制对象。
（4）绘制对象。
17.2.1 Java2D简介

17.2.2 取得Graphics2D对象 P540
绘制图形时，可以在Graphics对象或者Graphics2D对象上进行，它们都代表了需要绘图的区域，选择哪个取决于是否要使用所增加的Java2D的图形功能。但要注意，所有的Java2D图形操作都必须在Graphics2D对象上调用。Graphics2D是Graphics的子类。
绘图的第一个步骤是创建Graphics2D对象，可以将Graphics转换为该对象：
public void paintComponent(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;
}
或者
public void paint(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;
}

17.2.3 设置Graphics2D属性 P540

（1）设置填充方式 P541
如果需要对图像显示渐层式的颜色，可以设定Paint为GradientPaint的实例。
GradientPaint gp = new GradientPaint(180, 190, Color.yellow, 220, 210, Color.red, true);
g2.setPaint(gp);
（2）设置画笔颜色
BasicStroke pen = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND);
g2.setStroke(pen);

17.2.4 创建绘制对象 P541
Java2D中进行绘图时，不是采用对应的方法来袜，而是为要实现某种形状创建出相应的形状对象。这可以通过使用java.awt.geom包中的类来定义所要创建的形状。如线条Line2D.Float类、矩形Rectangle2D.Float或者Rectangle2D.Double类、椭圆Ellipse2D.Float、圆弧Arc2D.Float类等。
如下例所示：
Line2D.Float line = new Line2D.Float(20, 300, 200, 300);//直线
CubicCurve2D.Float cubic = new CubicCurve2D.Float(40, 100, 120, 50, 170, 270, 220, 100);//曲线
Ellipse2D.Float shape = new Ellipse2D.Float(200, 200, 60, 60);//椭圆

17.2.5 绘制对象 P542
针对不同的对象，可以使用不同的方法进行绘制。
--可以使用Graphics2D类中的方法draw()用于绘制轮廓，用fill()方法用于填充。它们都以前面所创建的图形对象作为参数。
--Java2D中的字符串的绘制仍然采用drawString()方法，有如下两个方法：
drawString(String s, float x, float y);
drawString(String str, int x, int y);
--绘制轮廓：draw(Shape s)。其中的Shape接口在Graphics2D中被定义。

新的Java2D Shape类都有“2D”后缀。这些新的形状使用浮点值（而不是整数）来描述其几何形状。
--Polygon类（int[] xpoints, int[] ypoints, int npoints）;
--RectangularShape抽象类，其子类有Arc2D、Ellipse2D、Rectangle2D。
--QuadCurve2D（二次贝塞尔样条曲线）。
--CubicCurve2D（三次贝塞尔样条曲线）。
--Area（区域）。
--GeneralPath（由直线、二次样条曲线、三次样条曲线所构成）。
--Line2D。

17.2.6 实例一：绘制图形 P542
//绘制直线、曲线及椭圆图形的实例：
package test;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Frame;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Panel;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;

public class DrawShape {
    public DrawShape() {
        Frame f = new Frame("Test Graphics2D");
        f.setSize(500, 500);
        f.setVisible(true);

        Panel p = new MyPanel();
        f.add(p);
    }

    private class MyPanel extends Panel {
        @Override
        public void paint(Graphics g) {
            //取得Graphics2D对象
            Graphics2D g2 = (Graphics2D) g;

            //设置渐进色
            GradientPaint gp = new GradientPaint(180, 190, Color.yellow, 220, 210, Color.red, true);
            g2.setPaint(gp);
            g2.setStroke(new BasicStroke(2.0f));//设定粗细

            //创建直线
            Line2D.Float line = new Line2D.Float(20, 300, 200, 300);
            g2.draw(line);

            //创建曲线
            CubicCurve2D.Float cubic = new CubicCurve2D.Float(70, 100, 120, 50, 170, 270, 220, 100);
            g2.draw(cubic);

            //创建椭圆
            Ellipse2D.Float shape = new Ellipse2D.Float(200, 200, 60, 60);
            g2.fill(shape);//g2.draw(shape);
        }
    }

    public static void main(String[] args) {
        new DrawShape();
    }
}

17.2.7 实例二：显示文字 P543
通过Java2D可以显示更细致的文字，下面程序显示出外边为淡蓝色的字符串：
package test;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Panel;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;

public class DrawString {
    public DrawString() {
        Frame f = new Frame("Test Graphics2D");
        f.setSize(500, 500);
        f.setVisible(true);

        Panel p = new MyPanel();
        f.add(p);
    }

    private class MyPanel extends Panel {
        @Override
        public void paint(Graphics g) {
            //取得Graphics2D对象
            Graphics2D g2 = (Graphics2D) g;

            //显示文字
            FontRenderContext fontRenderContext = g2.getFontRenderContext();
            TextLayout textLayout = new TextLayout("Test Characters", new Font("Modern", Font.BOLD + Font.ITALIC, 20), fontRenderContext);

            //线形
            Shape shape = textLayout.getOutline(AffineTransform.getTranslateInstance(50, 180));
            g2.setColor(Color.blue);
            g2.setStroke(new BasicStroke(2.0f));
            g2.draw(shape);
            g2.setColor(Color.red);//g2.setColor(Color.white);
            g2.fill(shape);
        }
    }

    public static void main(String[] args) {
        new DrawString();
    }
}

17.2.8 实例三：显示图像 P544
通常希望图形有滤镜的效果，必须使用可以处理图形的绘图软件。在2D API中则提供了一些简单的方法，可以直接用程式码来对图形进行滤镜效果的控制。
//没看到效果？
package test;

import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Panel;
import java.awt.Toolkit;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;

public class DrawImage {

    public void draw() {
        Frame f = new Frame("Test Graphics2D");
        f.setSize(500, 500);
        f.setVisible(true);

        String filename = "src/image/1.jpg";
        //Panel p = new MyPanel();
        f.add(new Panel() {
            @Override
            public void paint(Graphics g) {
                //取得Graphics2D对象
                Graphics2D g2 = (Graphics2D) g;

                float[] elements = {0.0f, -1.0f, 0.0f, -1.0f, 0.0f, -1.0f, 0.0f};

                //加载图片
                Image img = Toolkit.getDefaultToolkit().getImage(filename);
                int w = img.getWidth(this);
                int h = img.getHeight(this);
                BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);

                //创建Graphics2D对象
                Graphics2D big = bi.createGraphics();
                big.drawImage(img, 0, 0, this);

                //阴影处理
                BufferedImageOp biop = null;
                AffineTransform at = new AffineTransform();
                BufferedImage bimg = new BufferedImage(img.getWidth(this), img.getHeight(this), BufferedImage.TYPE_INT_RGB);
                Kernel kernel = new Kernel(3, 3, elements);
                ConvolveOp cop = new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);
                cop.filter(bi, bimg);
                biop = new AffineTransformOp(at, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);

                //显示图像
                g2.drawImage(bimg, biop, 0, 0);
            }
        });
    }

    public static void main(String[] args) {
        new DrawImage().draw();
    }
}

17.3 音频录制与播放――JavaSound P545
暂时没有看？

17.4 视频拍照与播放――JMF多媒体库 P563
暂时没有看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第18课 Swing图形界面开发 P577
18.1 Swing界面组件 P577
Swing组件有如下几个特点：
--所有的Swing组件都继承自AWT的组件Component，都是AWT的派生类。
--所有的Swing件件都以字母“J”形状，以与AWT中的组件相区分。
--Swing组件对AWT的功能进行了扩展，包括容器、容器、工具栏、菜单栏、组件。

18.1.2 窗口与对话框 P579
（1）窗体JFame
package test;

import javax.swing.JFrame;

public class TestJFrame extends JFrame {

    public TestJFrame() {
        setTitle("Test JFrame");
        setLocation(20, 20);
        // Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();//获得屏幕大小
        // setLocation(screenSize.width / 2 - 300 / 2, screenSize.height / 2 - 200 / 2);//定位的位置是窗体的左上角，用屏幕长宽减去窗体的一半长宽，定位在屏幕正中央
        setSize(300, 200);
        setVisible(true);
        
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置该属性，关闭窗口时退出程序
        // this.addWindowListener(new WindowAdapter() { //添加窗口关闭处理事件，实现一个WindowAdapter的匿名类
            // @Override
            // public void windowClosing(WindowEvent e) {
                // System.out.println("Procedure exit.");
                // System.exit(0);
            // }
        // });
        
        //设置跨平台的感观，没看到有什么效果
        String strLookFeel = UIManager.getCrossPlatformLookAndFeelClassName();
        try {
            UIManager.setLookAndFeel(strLookFeel);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new TestJFrame();
    }
}

（2）内部窗体JInternalFrame P580
JInternalFrame是轻量级组件，不能单独出现，必须依附在顶层组件上。能够利用Java提供的Look and Feel功能做出完全不同于原有操作系统所提供的窗口外形，比JFrame更具有弹性。
JInternalFrame构造函数：
--title：窗口标题。
--resizable：可改变窗口大小。
--closable：可关闭窗口。
--maximizable：可最大化不可最小化窗口。
--iconifiable：可最大最小化的窗口。
如果某一个参数不存在，表示不具有该项功能。
package test;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JInternalFrame;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestJInternalFrame extends JFrame implements ActionListener {
    public TestJInternalFrame() {
        super("Test JInternalFrame");
        JButton b = new JButton("Open JInternalFrame");
        b.addActionListener(this);
        add(b, BorderLayout.SOUTH);
        setSize(350, 350);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        JInternalFrame internalFrame = new JInternalFrame("JInternalFrame", true, true, true, true);
        internalFrame.setLocation(20, 20);
        internalFrame.setSize(100, 100);
        internalFrame.setVisible(true);
        add(internalFrame);
        try {
            internalFrame.setSelected(true);
        } catch (java.beans.PropertyVetoException e1) {
            e1.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new TestJInternalFrame();
    }
}

（3）图层容器 JLayeredPane P582
JLayeredPane图层允许组件在需要时互相重叠，它将该深度范围分成几个不同的层。

（4）虚拟桌面容器JDesktopPane P583
JDesktopPane用于创建多文档界面或虚拟桌面的容器。用户可创建JInternalFrame对象并将其添加到JDesktopPane。JDesktopPane扩展了JLayeredPane，以管理可能的重叠内部窗体。
package test;

import javax.swing.JButton;
import javax.swing.JDesktopPane;
import javax.swing.JFrame;
import javax.swing.JInternalFrame;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestJDesktopPane extends JFrame implements ActionListener {
    private JDesktopPane desktopPane = new JDesktopPane();
    int count = 1;

    public TestJDesktopPane() {
        super("Test JInternalFrame");
        JButton b = new JButton("Open JInternalFrame");
        b.addActionListener(this);

        Container contentPane = getContentPane();
        contentPane.add(b, BorderLayout.SOUTH);
        contentPane.add(desktopPane, BorderLayout.CENTER);//这里不用getContentPane没看到有什么不同，为什么要获取到contentPane？

        setSize(350, 350);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        JInternalFrame internalFrame = new JInternalFrame("JInternalFrame" + count, true, true, true, true);
        ++count;

        internalFrame.setLocation(20, 20);
        internalFrame.setSize(200, 200);
        internalFrame.setVisible(true);
        desktopPane.add(internalFrame);
        try {
            internalFrame.setSelected(true);
        } catch (java.beans.PropertyVetoException e1) {
            e1.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new TestJDesktopPane();
    }
}

（5）对话框JDialog P584
对话框与框架（JFrame）有一些相似。对话框出现时，可以设定禁止其他窗口的输入，直到这个对话框被关闭。

package test;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestJDialog extends JFrame implements ActionListener {
    public TestJDialog() {
        super("Test JDialog");
        JButton b = new JButton("Open JDialog");
        b.addActionListener(this);

        Container contentPane = getContentPane();
        contentPane.add(b, BorderLayout.SOUTH);

        setSize(350, 350);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("Open JDialog")) {
            JDialog jDialog1 = new JDialog(this, "Dialog", true);//设置为false，则可以互相切换
            jDialog1.setSize(200, 200);
            jDialog1.setLocation(450, 450);
            jDialog1.setVisible(true);
        }
    }

    public static void main(String[] args) {
        new TestJDialog();
    }
}

（6）文件选择对话框 JFileChooser P585
package test;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;

public class TestJFileChooser extends JFrame implements ActionListener {
    public TestJFileChooser() {
        super("Test JFileChooser");
        JButton b = new JButton("Open JFileChooser");
        b.addActionListener(this);

        Container contentPane = getContentPane();
        contentPane.add(b, BorderLayout.SOUTH);

        setSize(350, 350);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("Open JFileChooser")) {
            JFileChooser jFileChooser = new JFileChooser();
            jFileChooser.setMultiSelectionEnabled(true);

            //图片过滤器
            FileNameExtensionFilter filter = new FileNameExtensionFilter("JPG & GIF Images", "jpg", "gif");//这是个可变参数构造函数，可以传递多个后缀参数
            jFileChooser.setFileFilter(filter);
            jFileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);//选择文件
            jFileChooser.setDialogTitle("Open JPEG file");//设置窗口标题
            int result = jFileChooser.showOpenDialog(this);//打开“打开文件”对话框
            if (result == JFileChooser.APPROVE_OPTION) {
                File[] fileList = jFileChooser.getSelectedFiles();
                for (File file : fileList) {
                    System.out.println(file.getAbsolutePath());
                }
            }
        }
    }

    public static void main(String[] args) {
        new TestJFileChooser();
    }
}

（7）颜色选择对话框 P586
JColorChooser提供一个用于允许用户操作和选择颜色的控制器窗格。
//
package test;

import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JFrame;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestJColorChooser extends JFrame implements ActionListener {
    public TestJColorChooser() {
        super("Test JColorChooser");
        JButton b = new JButton("Open JColorChooser");
        b.addActionListener(this);

        Container contentPane = getContentPane();
        contentPane.add(b, BorderLayout.SOUTH);

        setSize(350, 350);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("Open JColorChooser")) {
            Color color = JColorChooser.showDialog(this, "Choose Color", Color.red);
            System.out.println(color.getRGB());
        }
    }

    public static void main(String[] args) {
        new TestJColorChooser();
    }
}

18.1.3 基本组件 P587
Tips：以下输入组件都可以使用getText()取得组件的内容。
（1）文本JLabel
显示一段文本，创建如下：
Label label = new Label("this is a label");
调用容器的add()方法即可将label添加到容器中。
（2）按钮JButton
（3）复选框JCheckBox
（4）单选框JRadioButton
（5）文本框JTextField P588
（6）密码框JPasswordField
（7）文本域JTextArea
（8）文本文件域JTextPane
JTextPane可以编辑文本和图标，可以使用如下方法将编辑器与一个文本文档关联：
void setDocument(Document doc);
也可以将一个图标插入文档中，以替换当前选择的内容：
void insertIcon(Icon g);
（9）HTML编辑域JEditorPane
可以编纯文本、HTML和RTF内容，可以调用下面的方法来设置显示一个HTML页面：
pane.setPage(e.getURL());
也可以向下面这样取得其中的HTML内容：
HTMLDocument doc = (HTMLDocument) pane.getDocument();
（10）列表JList
String[] data = {"one", "two", "three"};
JList list = JList(data);
（11）滚动条JScrollBar P588
滚动条可以添加到任何的容器中，如下：
Container mainPane = this.getContentPane();
JScrollBar vscroll = new JScrollBar(JScrollBar.VERTICAL);
mainPane.add(vscroll, BordreLayout.EAST);

（12）进度条JProgressBar P589
创建进度条示例：
progressBar = new JProgressBar(0, task.getLengthOfTask());
progressBar.setValue(0);
progressBar.setStringPainted(true);

更新进度条值：
progressBar.setValue(task.getCurrent());

下面示例将进度条设置为不确定模式，然后在知道任务长度后切换回确定模式：
progressBar = new JProgressBar();
progressBar.setIndeterminate(true);//设置为不确定模式
progressBar.setMaximum(newLength);//设置最大值
progressBar.setValue(newValue);//设置当前值
progressBar.setIndeterminate(false);//设置为确定模式

（13）滑标组件 JSlider P589
滑块可以显示主刻度标记及主刻度之间的次刻度标记。刻度标记之间的值的个数由setMajorTickSpacing()和setMinorTickSpacing()来控制。刻度标记和绘制由setPaintTicks()控制。滑块可以在固定时间间隔（或在任意位置）沿滑块刻度打印文本标签。标签的绘制由setLabelTable()来setPaintLabels()控制。
package test;

import javax.swing.JFrame;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.BorderLayout;
import java.awt.Container;

public class TestJSlider extends JFrame {
    public TestJSlider() {
        super("Test JSlider");
        JSlider jSlider = new JSlider(0, 100, 0);
        //主刻度
        jSlider.setMajorTickSpacing(10);
        //次刻度
        jSlider.setMinorTickSpacing(5);
        jSlider.setPaintTicks(true);
        jSlider.setPaintLabels(true);
        jSlider.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                if (e.getSource() instanceof JSlider) {
                    System.out.println("Tick: " + ((JSlider) e.getSource()).getValue());
                }
            }
        });

        Container contentPane = getContentPane();
        contentPane.add(jSlider, BorderLayout.SOUTH);

        setSize(350, 350);
        setVisible(true);
    }

    public static void main(String[] args) {
        new TestJSlider();
    }
}

（14）表格组件 JTable P590
暂时没看？

（15）树形组件 JTree P593
JTree是Swing里面比较复杂的组件之一，这个类的实例代表一整棵树，而一棵树由许多节点组成。JTree中的每一个节点都必须实现TreeNode这个Interface，我们可以自己来实现，当然Swing也为我们提供了一个DefaultMutableTreeNode的实现。
package test;

import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.BorderLayout;
import java.awt.Container;

public class TestJTree extends JFrame {
    public TestJTree() {
        super("Test JSlider");

        DefaultMutableTreeNode root = new DefaultMutableTreeNode("China");
        DefaultMutableTreeNode child1 = new DefaultMutableTreeNode("Beijing");
        DefaultMutableTreeNode child2 = new DefaultMutableTreeNode("Shanghai");
        DefaultMutableTreeNode cc = new DefaultMutableTreeNode("Haiding");

        JTree jt = new JTree(root);
        root.add(child1);
        root.add(child2);
        child1.add(cc);

        jt.addTreeSelectionListener(new TreeSelectionListener() {
            @Override
            public void valueChanged(TreeSelectionEvent e) {
                DefaultMutableTreeNode n = (DefaultMutableTreeNode) jt.getLastSelectedPathComponent();
                if (n == null) {
                    return;
                }

                String content = (String) n.getUserObject();
                System.out.println(content);
            }
        });

        Container contentPane = getContentPane();
        contentPane.add(jt, BorderLayout.CENTER);

        setSize(350, 350);
        setVisible(true);
    }

    public static void main(String[] args) {
        new TestJTree();
    }
}

18.1.4 菜单栏组件 P594
（1）菜单栏 JMenuBar
添加菜单组件，首先需要添加菜单栏JMenuBar。MenuBar只能被添加到JFrame对象中，作为整个菜单树的根基。如下：
JMenuBar mb = new JMenuBar();
setJMenuBar(mb);

（2）菜单JMenu
JMenu m1 = new JMenu("File");
JMenu m2 = new JMenu("Edit");
JMenu m3 = new JMenu("Help");
mb.add(m1);
mb.add(m2);
mb.add(m3);

（3）菜单选项 JMenuItem
JMenuItem mi1 = new JMenuItem("Open");
JMenuItem mi2 = new JMenuItem("Save");
JMenuItem mi3 = new JMenuItem("Exit");
m1.add(mi1);
m1.add(mi2);
m1.addSeparator();
m1.add(mi3);

除此之外，还可以添加复选框和单选按钮选项：
JCheckBoxMenuItem mi4 = new JCheckBoxMenuItem("Modify");
JRadioButtonMenuItem mi5 = new JRadioButtonMenuItem("Bold");
m2.add(mi4);
m2.add(mi5);

JMenuItem对象可以添加ActionListener事件，例其能够完成相应的监听操作。如下：
mi1.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Open event");
    }
});

//
package test;

import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JRadioButtonMenuItem;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TestJMenu extends JFrame {
    public TestJMenu() {
        super("Test JMenu");
        JMenuBar mb = new JMenuBar();
        setJMenuBar(mb);

        JMenu m1 = new JMenu("File");
        JMenu m2 = new JMenu("Edit");
        JMenu m3 = new JMenu("Help");
        mb.add(m1);
        mb.add(m2);
        mb.add(m3);

        JMenuItem mi1 = new JMenuItem("Open");
        JMenuItem mi2 = new JMenuItem("Save");
        JMenuItem mi3 = new JMenuItem("Exit");
        m1.add(mi1);
        m1.add(mi2);
        m1.addSeparator();
        m1.add(mi3);

        JCheckBoxMenuItem mi4 = new JCheckBoxMenuItem("Modify");
        JRadioButtonMenuItem mi5 = new JRadioButtonMenuItem("Bold");
        m2.add(mi4);
        m2.add(mi5);

        mi1.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Open event");
            }
        });

        setSize(350, 350);
        setVisible(true);
    }

    public static void main(String[] args) {
        new TestJMenu();
    }
}

（4）弹出菜单 JPopupMenu P595
JPopupMenu是弹出菜单的实现。
下面代码创建一个JPopupMenu：
JPopupMenu jp = new JPopupMenu();
创建带有标题的JPopupMenu：
JPopupMenu jp = new JPopupMenu("Popup menu");

与JMenu一样，可以使用add()方法和insert()方法向JPopupMenu中添加或者插入JMenuItem与JComponent。JPopupMenu对添加到其中的每一个菜单项都赋予一个整数索引，并根据弹出式菜单的布局管理器调整菜单项显示的顺序。还可以使用addSeparator()方法添加分隔线，并且JPopupMenu也会为该分隔线指定一个整数索引。
通过调用弹出式菜单触发器对应的show()方法来显示弹出式菜单，show()方法会在菜单显示之前对其location和invoker属性加以设定。因此，应该检查所有的MouseEvent事件，看其是否是弹出式菜单触发器，然后在合适的时候显示弹出式菜单，下面的showJPopupMenu方法在收到适当的触发器事件时就会显示弹出式菜单，如下：

//
package test;

import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class TestJPopupMenu extends JFrame {
    public TestJPopupMenu() {
        super("Test JPopupMenu");

        JPopupMenu popupMenu = new JPopupMenu();
        JMenuItem copy = new JMenuItem("Copy");
        JMenuItem paste = new JMenuItem("Paste");
        JMenuItem exit = new JMenuItem("Exit");
        popupMenu.add(copy);
        popupMenu.add(paste);
        popupMenu.addSeparator();
        popupMenu.add(exit);

        this.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                //if (e.isPopupTrigger()) {//这个不知道如何触发
                    //如果当前事件与鼠标事件相关，则弹出菜单
                    popupMenu.show(e.getComponent(), e.getX(), e.getY());
                //}
            }
        });

        this.setBounds(100, 100, 250, 150);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //this.setSize(350, 350);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        new TestJPopupMenu();
    }
}

18.1.5 工具栏组件 JToolBar P596
JToolBar提供了一个用来显示常用的Action或控件的组件。用户可以将工具栏拖到单独的窗口中（除非floatable属性被设置为false）。为了正确执行拖动，建议将JToolBar实例添加到容器的四“边”中的一边（其中容器的布局管理器为BorderLayout）。并且不在其他四“边”中添加任何子级。
下面实例实现了一个工具栏，包含3个按钮，并设置为可以拖动的，如下：
package test;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import java.awt.BorderLayout;
import java.awt.FlowLayout;

public class TestJToolBar extends JFrame {
    public TestJToolBar() {
        JToolBar bar = new JToolBar();
        JButton button1 = new JButton("New");
        JButton button2 = new JButton("Print");
        JButton button3 = new JButton("Exit");
        bar.add(button1);
        bar.add(button2);
        bar.addSeparator();
        bar.add(button3);

        bar.setFloatable(true);//可拖动
        bar.setToolTipText("Tool Bar");//提示

        JPanel panel = new JPanel();
        panel.setLayout(new FlowLayout(FlowLayout.LEFT));
        panel.add(bar);
        this.add(panel, BorderLayout.NORTH);

        this.setTitle("Test JToolBar");
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setSize(300, 200);
        this.setVisible(true);
    }

    public static void main(String[] args) {
        new TestJToolBar();
    }
}

18.2 Swing 布局管理器 P597
（1）BoxLayout
允许垂直或水平布置多个组件的布局管理器。垂直排列的组件在重新调整框架的大小时仍然被垂直排列。
BoxLayout管理器是用axis参数构造的，该参数指定了将进行的布局类型。
BoxLayout(Container target, int axis);
axis有以下4个选择：
--X_AXIS：从左到右水平布置组件
--Y_AXIS：从上到下垂直布置组件
--LINE_AXIS：根据容器的CompnentOrientation属性，按照文字在一行中的排列方式布置组件。如果容器的ComponentOrientation表示水平，则将组件水平放置，否则将它们垂直放置。对于水平方向，如果容器的ComponentOrientation表示从左到右，则组件从左到右放置，否则将它们从右到左放置。对于垂直方向，组件总是从上到下放置的。
--PAGE_AXIS：上LINE_AXIS相反
对于所有方向，组件按照将它们添加到容器中的顺序排列。

（2）GroupLayout P598
（3）OverlayLayout P598
（4）JScrollPaneLayout P598
（5）SpringLayout P598
（6）ViewportLayout P598

18.3 Swing事件处理 P598

18.4.3 Java文件编辑器 P600
package test;

import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;

public class JTextEditor extends WindowAdapter implements ActionListener {
    private JFrame frame;//主窗体
    private JTextArea textArea;//文件输入区域
    private String fileName;//打开的文件名

    public void createEditor() {
        //建立文件菜单
        JMenuBar menuBar = new JMenuBar();
        JMenu menuFile = new JMenu("File");
        //新建菜单
        JMenuItem menuNew = new JMenuItem("New");
        menuNew.addActionListener(this);
        menuFile.add(menuNew);
        //打开菜单
        JMenuItem menuOpen = new JMenuItem("Open");
        menuOpen.addActionListener(this);
        menuFile.add(menuOpen);
        //保存菜单
        JMenuItem menuSave = new JMenuItem("Save");
        menuSave.addActionListener(this);
        menuFile.add(menuSave);
        //另存为菜单
        JMenuItem menuSaveAs = new JMenuItem("Save as...");
        menuSaveAs.addActionListener(this);
        menuFile.add(menuSaveAs);
        //退出菜单
        JMenuItem menuExit = new JMenuItem("Exit");
        menuExit.addActionListener(this);
        menuFile.add(menuFile);

        menuBar.add(menuFile);

        JMenu menuHelp = new JMenu("Help");
        JMenuItem menuAbout = new JMenuItem("About");
        menuAbout.addActionListener(this);
        menuHelp.add(menuAbout);
        menuBar.add(menuHelp);

        //主窗口
        frame = new JFrame("Java Text Editor");
        frame.setJMenuBar(menuBar);
        textArea = new JTextArea();
        frame.add("Center", textArea);
        frame.addWindowListener(this);//frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);？
        frame.setSize(600, 400);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        JTextEditor te = new JTextEditor();
        te.createEditor();
    }

    @Override
    public void windowClosing(WindowEvent e) {
        System.exit(0);
    }

    //菜单选择事件
    @Override
    public void actionPerformed(ActionEvent e) {
        try {
            if (e.getActionCommand() == "New") {
                textArea.setText("");
            } else if (e.getActionCommand() == "Open") {
                //选择文件
                JFileChooser dlg = new JFileChooser();
                int result = dlg.showOpenDialog(frame);
                if (result == JFileChooser.APPROVE_OPTION) {
                    File file = dlg.getSelectedFile();
                    fileName = file.getAbsolutePath();

                    //读取文件
                    FileReader fr = new FileReader(fileName);
                    BufferedReader br = new BufferedReader(fr);
                    String str = "";
                    while (br.ready()) {
                        int c = br.read();
                        str += (char) c;
                    }
                    textArea.setText(str);
                    br.close();
                    fr.close();
                    frame.setTitle("Java Text Editor - " + fileName);
                }
            } else if (e.getActionCommand() == "Save") {
                //写入文件
                File file = new File(fileName);
                FileWriter fos = new FileWriter(file, true);
                BufferedWriter bos = new BufferedWriter(fos);
                PrintWriter pos = new PrintWriter(bos);
                pos.print(textArea.getText());

                pos.close();
                bos.close();
                fos.close();
            } else if (e.getActionCommand() == "Save as...") {
                JFileChooser dlg = new JFileChooser();
                int result = dlg.showOpenDialog(frame);
                if (result == JFileChooser.APPROVE_OPTION) {
                    File file = dlg.getSelectedFile();
                    //写入文件
                    FileWriter fos = new FileWriter(file, true);
                    BufferedWriter bos = new BufferedWriter(fos);
                    PrintWriter pos = new PrintWriter(bos);
                    pos.print(textArea.getText());

                    pos.close();
                    bos.close();
                    fos.close();
                }
            } else if (e.getActionCommand() == "Exit") {
                System.exit(0);
            } else if (e.getActionCommand() == "About") {
                final JDialog dialog = new JDialog(frame, "About", true);
                dialog.setSize(267, 117);
                dialog.setLayout(new GridLayout(1, 1));

                dialog.addWindowListener(new WindowAdapter() {
                    @Override
                    public void windowClosing(WindowEvent e) {
                        dialog.dispose();
                    }
                });

                JPanel topPanel = new JPanel();
                JLabel label = new JLabel("Java Text Editor - Author: DingBen");
                topPanel.add(label, BorderLayout.CENTER);
                dialog.add(topPanel);
                dialog.setVisible(true);
            }
        } catch (Exception e1) {
            e1.printStackTrace();
        }
    }
}
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第19课 SWT图形界面开发 P607
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第20课 SWT增强组件库 P643
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第21课 Applet组件编程 P661
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第22课 Java网络编程 P681
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第23课 NIO非阻塞编程 P741
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第24课 RMI分布式网络编程 P801
暂时没看？
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第25课 Corba分布式网络编程 P821
25.2 使用Java编写CORBA程序――HelloWorld实例 P827
使用Java编写CORBA程序主要依赖于IDL接口的编程与编译，共包括如下的5个过程。
（1）定义远程接口
（2）编译远程接口
（3）实现服务器
（4）实现客户机
（5）启动应用程序

25.2.1 创建IDL接口Hello.idl P828
编写IDL接口文件，放在src目录下：
module helloworld
{
    interface Hello
    {
        string sayHello(in string world);
    };
};
指定模块名为helloworld，接口名为Hello，定义了一个接口函数sayHello()，输入参数为string类型，并返回一个string类型的结果。

25.2.2 编译IDL接口产生6个文件
最新的JDK 1.3 以上版本中，提供了新的IDL编辑器idlj，位于JDK的bin\idlj.exe。
进入Hello.idl文件的目录，执行如下编译命令来编译IDL接口：
E:\Program Files\JetBrains\JavaProject\src\Hello.idl
编译后在当前目录下生成helloworld子目录，其中包括一些支持文件，如下：
--Hello.java：标记接口文件。CORBA规范指定这个文件必须扩展IDLEntity，并且与IDL接口同名。这个文件提供类型标记，从而使这个接口能用于其他接口的方法声明。内容如下：
package helloworld;
public interface Hello extends HelloOperations, org.omg.CORBA.Object, org.omg.CORBA.portable.IDLEntity 
{
} // interface Hello

--HelloOperations.java：内含Java公共接口――HelloOperations。规范指出，这个文件应该与具有Operations后缀的IDL接口同名，并且这个文件内含此接口映射的操作标记，上面定义的标记接口（Hello.java）可扩展这个接口。内容如下：
package helloworld;
public interface HelloOperations 
{
  String sayHello (String world);
} // interface HelloOperations

--HelloHelper.java：设计helper类的目的是，让所需要的许多内务处理功能脱离我们的接口，但又随时可用到实现过程。帮助程序文件含有重要的静态narrow方法，这种方法使org.omg.CORBA.Object收缩为一种更具体的类型的对象引用，在这种情况下，将是一个计算程序类型。内容如下：
package helloworld;
abstract public class HelloHelper
{
  private static String  _id = "IDL:helloworld/Hello:1.0";

  public static void insert (org.omg.CORBA.Any a, helloworld.Hello that)
  {
    org.omg.CORBA.portable.OutputStream out = a.create_output_stream ();
    a.type (type ());
    write (out, that);
    a.read_value (out.create_input_stream (), type ());
  }

  public static helloworld.Hello extract (org.omg.CORBA.Any a)
  {
    return read (a.create_input_stream ());
  }

  private static org.omg.CORBA.TypeCode __typeCode = null;
  synchronized public static org.omg.CORBA.TypeCode type ()
  {
    if (__typeCode == null)
    {
      __typeCode = org.omg.CORBA.ORB.init ().create_interface_tc (helloworld.HelloHelper.id (), "Hello");
    }
    return __typeCode;
  }

  public static String id ()
  {
    return _id;
  }

  public static helloworld.Hello read (org.omg.CORBA.portable.InputStream istream)
  {
    return narrow (istream.read_Object (_HelloStub.class));
  }

  public static void write (org.omg.CORBA.portable.OutputStream ostream, helloworld.Hello value)
  {
    ostream.write_Object ((org.omg.CORBA.Object) value);
  }

  public static helloworld.Hello narrow (org.omg.CORBA.Object obj)
  {
    if (obj == null)
      return null;
    else if (obj instanceof helloworld.Hello)
      return (helloworld.Hello)obj;
    else if (!obj._is_a (id ()))
      throw new org.omg.CORBA.BAD_PARAM ();
    else
    {
      org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate ();
      helloworld._HelloStub stub = new helloworld._HelloStub ();
      stub._set_delegate(delegate);
      return stub;
    }
  }

  public static helloworld.Hello unchecked_narrow (org.omg.CORBA.Object obj)
  {
    if (obj == null)
      return null;
    else if (obj instanceof helloworld.Hello)
      return (helloworld.Hello)obj;
    else
    {
      org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl)obj)._get_delegate ();
      helloworld._HelloStub stub = new helloworld._HelloStub ();
      stub._set_delegate(delegate);
      return stub;
    }
  }
  
}

--HelloHolder.java：holder类是一个专门化类，是为了需要通过引用来传递参数的任意数据类型而生成的。这个示例中将不使用holder类，将会在以后的栏目中经常见到它。内容如下：
package helloworld;
public final class HelloHolder implements org.omg.CORBA.portable.Streamable
{
  public helloworld.Hello value = null;

  public HelloHolder ()
  {
  }

  public HelloHolder (helloworld.Hello initialValue)
  {
    value = initialValue;
  }

  public void _read (org.omg.CORBA.portable.InputStream i)
  {
    value = helloworld.HelloHelper.read (i);
  }

  public void _write (org.omg.CORBA.portable.OutputStream o)
  {
    helloworld.HelloHelper.write (o, value);
  }

  public org.omg.CORBA.TypeCode _type ()
  {
    return helloworld.HelloHelper.type ();
  }

}

--HelloPOA.java：skeleton类为CORBA功能提供了请求――响应探测的一大部分。生成HelloPOA.java，是因为默认方式下的实现是基于继承的，如果我们选择基于委托的方式，输出就会不一样。内容如下：
package helloworld;
public abstract class HelloPOA extends org.omg.PortableServer.Servant
 implements helloworld.HelloOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("sayHello", new java.lang.Integer (0));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    org.omg.CORBA.portable.OutputStream out = null;
    java.lang.Integer __method = (java.lang.Integer)_methods.get ($method);
    if (__method == null)
      throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);

    switch (__method.intValue ())
    {
       case 0:  // helloworld/Hello/sayHello
       {
         String world = in.read_string ();
         String $result = null;
         $result = this.sayHello (world);
         out = $rh.createReply();
         out.write_string ($result);
         break;
       }

       default:
         throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
    }

    return out;
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:helloworld/Hello:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public Hello _this() 
  {
    return HelloHelper.narrow(
    super._this_object());
  }

  public Hello _this(org.omg.CORBA.ORB orb) 
  {
    return HelloHelper.narrow(
    super._this_object(orb));
  }


} // class HelloPOA

--_HelloStub.java：这是一个stub类。客户机将需要这个类来进行工作。内容如下：
package helloworld;
public class _HelloStub extends org.omg.CORBA.portable.ObjectImpl implements helloworld.Hello
{

  public String sayHello (String world)
  {
            org.omg.CORBA.portable.InputStream $in = null;
            try {
                org.omg.CORBA.portable.OutputStream $out = _request ("sayHello", true);
                $out.write_string (world);
                $in = _invoke ($out);
                String $result = $in.read_string ();
                return $result;
            } catch (org.omg.CORBA.portable.ApplicationException $ex) {
                $in = $ex.getInputStream ();
                String _id = $ex.getId ();
                throw new org.omg.CORBA.MARSHAL (_id);
            } catch (org.omg.CORBA.portable.RemarshalException $rm) {
                return sayHello (world        );
            } finally {
                _releaseReply ($in);
            }
  } // sayHello

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:helloworld/Hello:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  private void readObject (java.io.ObjectInputStream s) throws java.io.IOException
  {
     String str = s.readUTF ();
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     org.omg.CORBA.Object obj = orb.string_to_object (str);
     org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
     _set_delegate (delegate);
   } finally {
     orb.destroy() ;
   }
  }

  private void writeObject (java.io.ObjectOutputStream s) throws java.io.IOException
  {
     String[] args = null;
     java.util.Properties props = null;
     org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init (args, props);
   try {
     String str = orb.object_to_string (this);
     s.writeUTF (str);
   } finally {
     orb.destroy() ;
   }
  }
} // class _HelloStub

上面生成的6个文件位于src目录下的helloworld中，正好是我们当前的开发目录。

25.2.3 创建IDL接口实现类HelloImpl.java P829
生成的文件在服务器上开始工作，必须编写实现接口的实现类HelloImpl。继承自HelloPOA类，从客户机发来一个请求时，该请求通过 ORB进入HelloPOA，最终调用HelloImpl来完成请求并启动响应。如下：
package corba;

import helloworld.HelloPOA;

/**
 * Created by Ben on 2016/8/18.
 */
public class HelloImpl extends HelloPOA {
    @Override
    public String sayHello(String world) {
        return "Hello " + world + "!";
    }
}

25.2.4 实现服务器 HelloServer.java P829
package corba;

import helloworld.Hello;
import org.omg.CORBA.ORB;
import org.omg.CosNaming.NameComponent;
import org.omg.CosNaming.NamingContext;
import org.omg.CosNaming.NamingContextHelper;

/**
 * Created by Ben on 2016/8/18.
 */
public class HelloServer {
    public static void main(String args[]) {
        try {
            //根据端口创建ORB实例
            String str[] = {"-ORBInitialPort", "1050"};
            ORB orb = ORB.init(str, null);
            org.omg.CORBA.Object objRef = orb.resolve_initial_references("RootPOA");

            //创建服务对象
            org.omg.PortableServer.POA rootPOA = org.omg.PortableServer.POAHelper.narrow(objRef);
            org.omg.PortableServer.POAManager manager = rootPOA.the_POAManager();

            //具体实现类
            HelloImpl helloImpl = new HelloImpl();
            Hello hello = helloImpl._this(orb);

            //创建命名并注册
            NamingContext ncRef = NamingContextHelper.narrow(orb.resolve_initial_references("NameService"));
            NameComponent nc = new NameComponent("Hello", "");
            NameComponent path[] = {nc};
            ncRef.rebind(path, hello);
            manager.activate();
            System.out.println("Service is running...");

            //等待客户端调用
            orb.run();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

25.2.5 实现客户端 HelloClient.java P830
考虑一下正在发生的事件的机制，就会明白客户端和服务器实现上是互为映像的。客户端将所有的参数打包以创建一个请求，然后以它自己的方式来发送这个请求。服务器只是将请求中的参数解包、执行运行，将返回值和输出参数打包，然后向客户端发回响应。客户端则将返回值和输出参数解包，然后继续处理。这样，客户端打包什么，服务器就解包什么，反之亦然。这意味着将会看到客户端和服务器具有相似的结构。客户端还必须创建并初始化一个ORB。
（1）创建一个ORB。
（2）获取一个指向命名上下文的引用。
（3）在命名上下文中查找“Hello”并获得指向该CORBA对象的引用。
（4）调用对象的sayHello()操作并打印结果。
客户端程序如下：
package corba;

import helloworld.Hello;
import helloworld.HelloHelper;
import org.omg.CORBA.ORB;
import org.omg.CosNaming.NameComponent;
import org.omg.CosNaming.NamingContext;
import org.omg.CosNaming.NamingContextHelper;

/**
 * Created by Ben on 2016/8/18.
 */
public class HelloClient {
    public static void main(String args[]) {
        try {
            //根据端口创建ORB实例
            String str[] = {"-ORBInitialPort", "1050"};
            ORB orb = ORB.init(str, null);
            org.omg.CORBA.Object objRef = orb.resolve_initial_references("NameService");

            //获取一个指向命名上下文的引用
            NamingContext ncRef = NamingContextHelper.narrow(objRef);
            NameComponent nc = new NameComponent("Hello", "");
            NameComponent path[] = {nc};

            //查找Hello对象
            Hello hello = HelloHelper.narrow(ncRef.resolve(path));

            //调用函数
            String show = hello.sayHello("World");
            System.out.println(show);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

25.2.6 运行程序 P831
（1）启动一个MS-DOS命令解释器：
tnameserv -ORBInitialPort 1050

运行后会初始化引用端口为1050，输出的窗口如下：
C:\Users\Ben>tnameserv -ORBInitialPort 1050
初始的命名上下文:
IOR:000000000000002b49444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e746578744578743a312e30000000000001000000000000009a000102000000000e3139322e3136382e312e31323100041a00000045afabcb0000000020000f424000000001000000000000000200000008526f6f74504f41000000000d544e616d65536572766963650000000000000008000000010000000114000000000000020000000100000020000000000001000100000002050100010001002000010109000000010001010000000026000000020002
TransientNameServer: 将初始对象引用端口设置为: 1050
准备就绪。

（2）运行HelloServer服务器：
看到Service is running...

（3）启动HelloClient应用程序客户端：
屏幕上会出现“Hello World!”的字样，说明实验成功了。

与传统的客户/服务应用开发完全不同，使用CROBA后，开发人员再不必关心客户和服务之间的通信问题，也不必处理客户和服务之间的协调问题，客户系统和服务系统可以在不同的机器系统中运行，并且可以用不同的语言来实现（如本例中的服务器程序完全可以用C++来编写），这些都由CORBA负责解决，对应用开发者来说都是透明的。

25.2.7 补充：IDL的语法规则 P832
接口描述语言即Interface Description Language或者缩写为IDL，是用来描述软件组件接口的一种计算机语言。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流，如，一个组件用C++写，另一个用Java写成。
1. OMG IDL文件结构
IDL文件以module开始命名模块名，相当于Java程序中的包名。然后在模块中定义数据类型和接口。如下：
module Compute
{
    typedef double radius;
    typedef long times;
    interface PI
    {double getResult(in radius aRadius, in times time);}
}

2. OMG IDL语法规则
采用ASCII字符集构成接口定义的所有标识符。标识符由字母、数字和下画线的任意组合构成，但第一个字符必须是ASCII字母。IDL认为大写字母和小写字母具有相同的含义，如anExample和AnExample是相同的。
程序设计人员不能将关键字用做变量或方法名。需要注意的是关键字的大小写，如：
typedef double context;//错误，变量context是关键字
typedef double CONTEXT;//错误，CONTEXT与关键字context冲突

3. 数据类型
--基本数据类型：OMG IDL基本数据类型包括short、long和相应的无符号（unsigned）类型，表示的字长分别为16、32位。
--浮点数类型：OMG IDL浮点数类型包括float、double和long double类型。
--字符和超大字符类型：OMG IDL定义字符类型char为面向字节的码集中编码的单字节字符；定义类型wchar为从任意字符集中编码的超大字符。
--逻辑类型：用boolean关键字定义的一个变量，聚会只有true和false。
--八进制类型：用octet关键字定义，在网络传输过程中不进行高低位转换的位元序列。
--any数据类型：引入该类型用于表示OMG IDL中任意数据类型。

4. 常量
const double PI = 3.1415926;
在IDL中，可以定义long、unsigned long、string等类型的常量。

5. 构造数据类型 P834
OMG IDL中构造数据类型包括结构、联合、枚举等形式，如下例。
结构类型：
typedef long GoodsNumber;
struct
{
    GoodsNumber number;
    string name;
    float price;
}

联合类型：
union stockIn switch(short)
{
    case 1: stocker: long;
    case 2: goodsName1: string;
    case 3: goodsName2: string;
}

枚举类型：
enum GoodsNumber{GOODS_SAILED, GOODS_INSTOCK};

6. 数组类型 P834
typedef long ADimension[20][100];

7. 模板(template)类型
OMG IDL提供两种类型的模板。
（1）序列（sequence）类型
用该方法可以定义长度可变的任意数值类型的存储序列，通常在定义时可以指定长度，也可以不指定，如：
typedef sequence<80> aSequence;//长度定义为80
typedef sequence anotherSequence;//长度不定

（2）字符串（string）序列
同样对于字符串序列类型，也有两种定义方式：
typedef string<80> aName;
typedef string anotherName;

8. 接口(interface)
接口作为服务对象功能的详细描述，封装了服务对象提供服务方法的全部信息，客户对象利用该接口获取服务对象的属性、访问服务对句中的方法。接口用关键字interface声明，其中包含的属性和方法对所有提出服务请求的客户对象是公开的，如下：
interface JobManager
{
    readonly attribute string FirstName;
    attribute string status;
    string QueryJobStatus(in long Number, out string property);
}
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第26课 Java反射编程与动态代码 P845
Java反射（Reflection）机制是在运行状态中，对于 任意一个类，都能够查找这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息及动态调用对象的方法的功能称为Java语言的反射机制。
Java反射机制主要提供了以下功能。
--在运行时判断任意一个对象所属的类。
--在运行时判断任意一个类所具有的成员变量和方法。
--在运行时构造任意一个类的对象。
--在运行时调用任意一个对象的方法和变量。
--生成动态代理（Dynamic Proxy）。

26.1 Java反射机制 P845
26.1.1 反射的概念 P845
开放性和原因连接是反射系统的两在基本要素。

26.1.2 Java中的反射 P846
Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性。例如，使用它能够获得Java类中各成员的名称并显示出来。

26.1.3 第一个反射的例子 P846

package test;

import java.lang.reflect.Method;//是用来描述某个类中单个方法的一个类

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class c = Class.forName("java.lang.System");//载入指定的类
            Method m[] = c.getDeclaredMethods();//获取这个类中的定义了的方法列表
            for (Method method : m) {
                System.out.println(method.toString());
            }
        } catch (Exception e) {
        }
    }
}
输出：
public static void java.lang.System.exit(int)
public static void java.lang.System.runFinalization()
public static void java.lang.System.runFinalizersOnExit(boolean)
private static void java.lang.System.initializeSystemClass()
public static java.lang.String java.lang.System.setProperty(java.lang.String,java.lang.String)
public static java.lang.String java.lang.System.getProperty(java.lang.String)
public static java.lang.String java.lang.System.getProperty(java.lang.String,java.lang.String)
public static native int java.lang.System.identityHashCode(java.lang.Object)
public static native long java.lang.System.currentTimeMillis()
public static native long java.lang.System.nanoTime()
public static native void java.lang.System.arraycopy(java.lang.Object,int,java.lang.Object,int,int)
private static native void java.lang.System.registerNatives()
public static java.lang.SecurityManager java.lang.System.getSecurityManager()
public static void java.lang.System.load(java.lang.String)
public static void java.lang.System.loadLibrary(java.lang.String)
public static native java.lang.String java.lang.System.mapLibraryName(java.lang.String)
private static void java.lang.System.checkIO()
private static void java.lang.System.checkKey(java.lang.String)
public static java.lang.String java.lang.System.clearProperty(java.lang.String)
public static java.io.Console java.lang.System.console()
public static void java.lang.System.gc()
public static java.util.Properties java.lang.System.getProperties()
public static java.lang.String java.lang.System.getenv(java.lang.String)
public static java.util.Map java.lang.System.getenv()
public static java.nio.channels.Channel java.lang.System.inheritedChannel() throws java.io.IOException
private static native java.util.Properties java.lang.System.initProperties(java.util.Properties)
public static java.lang.String java.lang.System.lineSeparator()
private static java.io.PrintStream java.lang.System.newPrintStream(java.io.FileOutputStream,java.lang.String)
public static void java.lang.System.setErr(java.io.PrintStream)
private static native void java.lang.System.setErr0(java.io.PrintStream)
public static void java.lang.System.setIn(java.io.InputStream)
private static native void java.lang.System.setIn0(java.io.InputStream)
private static void java.lang.System.setJavaLangAccess()
public static void java.lang.System.setOut(java.io.PrintStream)
private static native void java.lang.System.setOut0(java.io.PrintStream)
public static void java.lang.System.setProperties(java.util.Properties)
public static void java.lang.System.setSecurityManager(java.lang.SecurityManager)
private static synchronized void java.lang.System.setSecurityManager0(java.lang.SecurityManager)

26.1.4 Java反射API P847
Class是Java反射中的一个核心类，它代表了内存中的一个Java类。通过它可以取得类的各种操作属性，这些属性是通过java.lang.reflect包中的反射API来描述的。
--Constructor：描述一个类的构造方法
--Field：描述一个类的成员变量
--Method：描述一个类的方法
--Modifer：描述类内各元素的修饰符
--Array：用来对数组进行操作

对于任何一个类来说，都可以通过Class提供的反射调用以不同的方式来获得类的信息。除了可以使用newInstance()创建该类的实例外，可以使用Class取得类的包和类名：
Package getPackage();
String getName();

Class最重要的功能是提供了一组反射调用，用以取得该类的构造函数、变量及方法。
1. 取得构造函数――返回类型 Constructor P848

2. 取得变量――返回类型 Field P848

3. 取得方法――返回类型 Method P849
--使用特定的参数类型获得命名的方法
Method getMethod(String name, Class<?>...parameterTypes);
--获得所有方法列表：
Method[] getMethods();
--获取本地或匿名类的方法：
Method getEnclosingMethod();

4. Array类 P850
提供了动态创建和访问Java数组的方法，这些方法对应了8个Java的基本数据类型，形如：
static boolean getBoolean(Object array, int index);
static void setBoolean(Object array, int index, boolean z);

5. Modifier类 P850
提供了static方法和常量，对类和成员访问修符符进行解码。修饰符集被表示为整数，用不同的位置（bit position）表示不同的修饰符。
static int ABSTRACT;//表示abstract修饰符的int的值

26.2 Java反射应用――检测类 P850
package test.reflection;

public class MyObject {
    public int a;
    public int b;

    public MyObject(int a, int b) {
        this.a = a;
        this.b = b;
    }

    public int sum() {
        return a + b;
    }

    public int minus() {
        return a - b;
    }

    public int multiply() {
        return a * b;
    }

    public int divide() {
        return a / b;
    }

    public String longer(String s1, String s2) {
        return s1.length() > s2.length() ? s1 : s2;
    }
}


26.2.1 获取类 P851
在运行的Java程序中，用java.lang.Class类来描述类和接口等。
下面就是获得一个Class对象的方法之一：
Class cls = Class.forName("test.MyObject");
还有另一种方法，如下：
Class cls = test.MyObject.class;

26.2.2 获取类的方法
package test;

import java.lang.reflect.Method;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            Method m[] = cls.getDeclaredMethods();
            for (Method method : m) { //for (int i = 0; i < methods.length; ++i)
                System.out.println("方法名：" + method.getName());
                System.out.println("修饰符：" + method.getModifiers());
                System.out.println("返回值：" + method.getReturnType());

                Class parameters[] = method.getParameterTypes();
                for (int j = 0; j < parameters.length; ++j) {
                    System.out.println("参数：" + j + "：" + parameters[j]);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
方法名：sum
修饰符：1
返回值：int
方法名：divide
修饰符：1
返回值：int
方法名：minus
修饰符：1
返回值：int
方法名：longer
修饰符：1
返回值：class java.lang.String
参数：0：class java.lang.String
参数：1：class java.lang.String
方法名：multiply
修饰符：1
返回值：int

修饰符public是1，private是2
getDeclaredMethods()来获取一系列的Method对象，分别描述了定义在类中的每一个访求，包括public方法、protected方法和private方法等。如果在程序中使用getMethods()，还可以获得继承来的各个方法的信息。

26.2.3 获取类的构造器 P852
获取类构造器的用法与上述获取方法的用法类似，如下：
package test;

import java.lang.reflect.Constructor;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            Constructor constructors[] = cls.getDeclaredConstructors();
            for (Constructor constructor : constructors) { //for (int i = 0; i < methods.length; ++i)
                System.out.println("方法名：" + constructor.getName());
                System.out.println("修饰符：" + constructor.getModifiers());

                Class parameters[] = constructor.getParameterTypes();
                for (int j = 0; j < parameters.length; ++j) {
                    System.out.println("参数：" + j + "：" + parameters[j]);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
方法名：test.reflection.MyObject
修饰符：1
参数：0：int
参数：1：int

26.2.4 获取类的变量 P852
找出一个类中定义了哪些数据字段也是可能的，如下：
package test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            Field fields[] = cls.getDeclaredFields();
            for (Field field : fields) { //for (int i = 0; i < methods.length; ++i)
                System.out.println("方法名：" + field.getName());
                System.out.println("修饰符：" + field.getModifiers());
                System.out.println("变量类型：" + field.getType());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
方法名：a
修饰符：1
变量类型：int
方法名：b
修饰符：1
变量类型：int

和获取方法的情况一样，获取字段的时候也可以只取得在当前类中申明了的字段信息（使用getDeclaredFields()方法），或者也可以取得父类中定义的字段（使用getFields()方法）。

26.3 Java反射应用――处理对象 P853
可以分所构造器来实例化一个对象。由于类MyObject构造函数有两个int类型的参数，因此需要先创建一个类型数组，再根据类型数组取得构造函数：

package test;

import java.lang.reflect.Constructor;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            //设置参数类型数组
            Class paramTypes[] = new Class[2];
            paramTypes[0] = int.class;
            paramTypes[1] = int.class;

            //根据参数类型取得构造函数
            Constructor constructor = cls.getConstructor(paramTypes);
            Object object =   constructor.newInstance(3, 4);

            //调用默认构造函数，不过此例中MyObject没有默认构造函数，运行报错
//            constructor = cls.getConstructor();
//            object = constructor.newInstance();
            //System.out.println("3 + 4 = " + ((MyObject) object).sum());//应该不是这样调用函数？

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

26.3.2 改变变量的值 P853
package test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            //设置参数类型数组
            Class paramTypes[] = new Class[2];
            paramTypes[0] = int.class;
            paramTypes[1] = int.class;

            Constructor constructor = cls.getConstructor(paramTypes);
            Object object = constructor.newInstance(3, 4);

            //改变字段的值
            Field fieldA = cls.getField("a");
            System.out.println("改变前：" + fieldA.get(object));
            fieldA.setInt(object, 100);
            System.out.println("改变后：" + fieldA.get(object));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
改变前：3
改变后：100

26.3.3 执行类的方法 P854
与构造方法的调用过程相似，需要首先根据需要调用方法的参数类型创建一个参数类型数组，然后再创建一个输入值数组，执行方法的调用。如果函数没有参数，则直接调用即可。
package test;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class cls = Class.forName("test.reflection.MyObject");
            //设置参数类型数组
            Class paramTypes[] = new Class[2];
            paramTypes[0] = int.class;
            paramTypes[1] = int.class;

            Constructor constructor = cls.getConstructor(paramTypes);
            Object object = constructor.newInstance(3, 4);

            //执行无入参方法
            Method sumMethod = cls.getMethod("sum");
            Object sumRet = sumMethod.invoke(object);
            System.out.println("3 + 4 = " + sumRet);

            //执行带入参的方法
            Class paraStringTypes[] = new Class[] {String.class, String.class};//这里的new数组里，如果后面跟了数组对象，则不能带数字new Class[2] {String.class, String.class}将编译错误
            Method longerMethod = cls.getMethod("longer", paraStringTypes);//这里必须将函数名与参数类型都传入
            String stringParam[] = {"Hello", "World"};
            Object longerRet = longerMethod.invoke(object, stringParam);//这里传入要触发的对象和参数值
            System.out.println("Longer of Hello and World is " + longerRet);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

假如一个程序在执行的某处时才知道需要执行的某个方法，这个方法的名称是在程序的运行过程中指定的（如，JavaBean开发环境中就会做这样的事），上面的程序演示了如何做到。

26.3.4 使用数组 P854
package test;

import java.lang.reflect.Array;

public class ReflectionTest {

    public static void main(String[] args) {
        try {
            Class str = Class.forName("java.lang.String");//取得类
            Object arr = Array.newInstance(str, 10);//创建该类的数组
            Array.set(arr, 5, "this is a test");
            String str5 = (String) Array.get(arr, 5);
            System.out.println(str5);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
this is a test

上例创建了10个单位长度的String数组，为第5个位置的字符串赋了值，最后将这个字符串从数组中取出并打印。

//
package test;

import java.lang.reflect.Array;

public class ReflectionTest {
    public static void main(String[] args) {
        try {
            int dims[] = new int[]{5, 10, 15};
            Object arr = Array.newInstance(Integer.TYPE, dims);//创建一个5*10*15的整型数组
            Object arrObj = Array.get(arr, 3);//第一个Array.get()之后，arrObj是一个10*15的数组
            Class cls = arrObj.getClass().getComponentType();
            System.out.println(cls);
            arrObj = Array.get(arrObj, 5);//再次Array.get()，取得其中一个元素，长度为15的数组
            Array.setInt(arrObj, 10, 37);//使用Array.setInt()为第10个元素赋值

            int arrCast[][][] = (int[][][]) arr;
            System.out.println(arrCast[3][5][10]);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

Tips：创建数组时的类型是动态的，在编译时并不知道其类型。

26.4 Java动态代理 P855
26.4.1 动态代理机制 P855
所谓动态代理，即通过代理类Proxy的代理，接口和实现类之间可以不直接发生联系，而可以在运行期（Runtime）实现动态关联。
Java动态代理类Java.lang.reflect包下，一般主要涉及到以下两个类：
（1）接口InvocationHandler：该接口仅定义一个方法。
Object invoke(Object obj, Method method, Object[] args);
第一个参数obj一般是指代理类，method是被代理的方法，args是该方法的参数数组。

（2）Proxy：该类即为动态代理类，作用类实现了InvocationHandler接口的代理类，其中主要包含以下函数：
--protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。
--static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。
--static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当做被代理类使用。
所谓Dynamic Proxy是这样一种类：它是在运行时生成的class，在生成它时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当做这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你做实质性的工作，在生成它的实现时你必须提供一个handler，由它接管实际的工作。

26.4.2 动态代理应用 P856
Java 1.3 引入了名为“动态代理类”（Dynamic Proxy Class）的新特性，利用它可为“已知接口的实现”动态地创建包装器（wrapper）类。
先从非动态代理的实现说起。
1. 定义接口和实现类直接调用
为了实现一系列的不同实现，首先我们定义了一个接口类Hello：
//Hello 接口
public interface Hello {
    void say();
}
分别定义两个实现类HelloWorld和HelloChina，分别执行不同的say()代码：
public class HelloWorld implements Hello {
    public void say() {
        System.out.println("Hello World!");
    }
}

public class HelloChina implements Hello {
    public void say() {
        System.out.println("Hello China!");
    }
}

创建它们的实例，调用其中方法：
Hello world = new HelloWorld();
world.say();
Hello china = new HelloChina();
china.say();

2. 使用包装类进行包装 P857 （即装饰模式）
假定我们现在想拦截对HelloWorld和HelloChina类发出的方法say()的调用，比如在调用前和调用后分别输出字符串"start to say:"和"end say!"，需要定义一个对它们的共有接口类Hello的包装类HelloWrapper：
//包装类HelloWrapper
public class HelloWrapper implements Hello {
    private Hello wrapped;//包装对象
    
    public HelloWrapper(Hello hello) {
        this.wrapped = hello;
    }
    
    //包装函数
    public void say() {
        System.out.println("start to say:");
        wrapped.say()
        System.out.println("end say!");
    }
}
Tips：该包装类也实现了接口Hello，目的是要求该包装类实现对Hello中所有接口函数的包装。

此时可以使用包装类对上面的实现world和china进行包装：
//包装调用
HelloWrapper wrapper1 = new HelloWrapper(world);
wrapper1.say();
HelloWrapper wrapper2 = new HelloWrapper(china);
wrapper2.say();

对于这种包装风格的HelloWrapper来说，一旦想修改Hello接口，缺点就会暴露无遗。为Hello接口添加一个方法，就得为HelloWrapper类添加一个包装器方法。为Hello添加10个方法，就得为HelloWrapper添加10个方法。这显示是效率极差的一种方案。

如果将HelloWrapper继承自HelloWorld，即为实现类HelloWorld实现包装器：
//包装类HelloWrapper，类似WindowAdapter
public class HelloWrapper extends HelloWorld {
    private Hello wrapped;
    
    public HelloWrapper(Hello hello) {
        this.wrapped = hello;
    }

    public void say() {
        System.out.println("start to say:");
        wrapped.say();
        System.out.println("end say!");
    }
}

这种方式在修改接口方法时不必修改包装器，但是又出现了新问题，只有HelloWorld对象才能使用包装器HelloWrapper。而在此之前，实现了Hello接口的任何对象都可以使用HelloWrapper。现在，由Java施加的“线性类出身限制”禁止我们将任意Hello变成一个HelloWrapper。

3. 使用动态代理 P858
动态代理则综合了以上两种方案的优点。使用动态代理，你创建的包装器类不要求为所有方法都使用显式的包装器。

Tips：动态代理仍然有一个限制。当你使用动态代理时，要包装/扩展的对象必须实现一个接口，该接口定义了准备在包装器中使用的所有方法。这一限制的宗旨是鼓励良好的设计，而不是为你带来更多的麻烦。根据经验，每个类都至少应该实现一个接口（nonconstant接口）。良好的接口用法不仅使动态代理成为可能，还有利于程序的模块化。

下面的代码演示了用动态代理来创建一个代理类HelloHandler。创建的这个HelloHandler类不需要实现Hello接口，而是实现了java.lang.reflect.InvocationHandler，只提供了一个invoke()方法，代理对象上的任何方法调用都要通过这一方法进行。观察invoke()的主体，它包含了被调用方法的反射参数Method，可以使用该参数确定当前执行方法的属性。
我们得到的仍然只是一个具有invoke()方法的InvocationHandler，而不是真正想要的Hello对象。动态代理真正的魅力要到创建实现的Hello实例时才能反映出来，通过调用HelloHandler的构造方法初始化了被包装的对象proxyed，代码如下：
//
package test.proxy;

public interface Hello { //接口也不需要加abstract，默认就是abstract
   void say();//接口方法无需加public修饰符，在类实现接口的方法时必须加上public修饰符。
}

//
package test.proxy;

//同一个包中不需要引用
public class HelloWorld implements Hello {
    @Override
    public void say() {
        System.out.println("Hello World!");
    }
}

//
package test.proxy;

public class HelloChina implements Hello {
    @Override
    public void say() {
        System.out.println("Hello China!");
    }
}

//
package test.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class HelloHandler implements InvocationHandler {
    private Object proxyed;

    public HelloHandler(Object proxyed) {
        this.proxyed = proxyed;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result;
        //方法调用之前
        System.out.println("start to say!");

        //调用原始对象的方法
        result = method.invoke(this.proxyed, args);

        //方法调用之后
        System.out.println("end say!");
        return result;
    }

    public static void main(String[] args) {
        //代理调用world
        Hello world = new HelloWorld();
        InvocationHandler handler1 = new HelloHandler(world);
        Hello proxy1 = (Hello) Proxy.newProxyInstance(world.getClass().getClassLoader(), world.getClass().getInterfaces(), handler1);
        proxy1.say();

        //代理调用china
        Hello china = new HelloChina();
        InvocationHandler handler2 = new HelloHandler(china);
        Hello proxy2 = (Hello) Proxy.newProxyInstance(china.getClass().getClassLoader(), china.getClass().getInterfaces(), handler2);
        proxy2.say();
    }
}
输出：
start to say!
Hello World!
end say!
start to say!
Hello China!
end say!

这段代码实现了对目标对象world和china的代理调用。
--首先根据被代理对象创建一个代理类handler1， 此处是HelloHandler对象。
--创建动态代理对象proxy1，它的第一个参数为world类的加载器， 第二个参数为该类的接口，第三个对象为代理对象handler1。
--通过动态代理对象proxy1调用say()方法，此时会在原始对象HelloWorld.say()方法前后输出两句字符串。

上面代码作用简单，就是告诉Proxy类用一个指定的类加载器来动态创建一个对象，该对象要实现指定的接口（本例为Hello），并用提供的InvocationHandler来代替传统的方法主体。结果对象在一个instanceof Hello测试中返回true，并提供了在实现了Hello接口的任何类中都能找到的方法。
在HelloHandler类的invoke()方法中，完全不存在对Hello接口的引用。在本例中，以构造函数参数的形式，为HelloHandler提供了Hello的一个实例。代理Hello实例上的任何方法调用最终都由HelloHandler委托给这个“包装的”Hello。但是，虽然这是最常见的设计，但必须了解，InvocationHandler不一定非要委托给被代理的接口的另一个实例。事实上，InvocationHandler完全能自行提供方法主体，而无须一个委托目标。
最后注意，如果Hello接口中发生改变，那么HelloWorld中的invoke()方法将仍然可移植。如假定say()方法被重命名，那么新的方法名依然会被拦截。

26.4.3 基于动态代理的AOP实现 P860
上面的动态代理对实现类HelloWorld和HelloChina都实现了拦截，这实际上是实现了AOP的功能。AOP（Aspect Oriented Programming）面向切片编程，其中的一种实现方法便是用Proxy来实现的。
AOP的好处是，可以对类的实例统一实现拦截操作，通常应用在日志、权限、缓存、连接池中等。上面的代理拦截器在函数执行前后分别输出字符串，实际上就是一种日志拦截。但它的形式还不太节省，使用代理类进行拦截的代码需要重复编写。为了进行更好的拦截，将该代码抽象出来，通过要拦截的实例对象来创建拦截类实例，即AOP容器类：
//
package test.proxy;

import java.lang.reflect.Proxy;

public class AOPContainer {
    public static Object getBean(Object object) {
        HelloHandler handler = new HelloHandler(object);
        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), handler);
    }
}

//HelloHandler修改如下，main函数的位置不太好
package test.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class HelloHandler implements InvocationHandler {
    private Object proxyed;

    public HelloHandler(Object proxyed) {
        this.proxyed = proxyed;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result;
        //方法调用之前
        System.out.println("start to say!");

        //调用原始对象的方法
        result = method.invoke(this.proxyed, args);

        //方法调用之后
        System.out.println("end say!");
        return result;
    }

    public static void main(String[] args) {
        //代理调用world
        Hello world = new HelloWorld();
        Hello aop1 = (Hello) AOPContainer.getBean(world);
        aop1.say();

        //代理调用china
        Hello china = new HelloChina();
        Hello aop2 = (Hello) AOPContainer.getBean(china);
        aop2.say();
    }
}
这就通过Java Proxy实现了一个简单的AOP容器。也简单展示了AOP的基本实现原理，可以以此为基础实现一个功能完善的AOP容器。
Tips：详细的AOP的应用知识请参见另一本AOP专题图书《开发者突击：精通AOP整合应用开发（AspectWerkz+AspectJ+Spring）》。

26.4.4 基于动态代理的字节码库 P861

26.5.3 课后上机作业 P863
实现一个反射任务工厂类TaskFactory。
//task.properties
login=test.task.impl.LoginTask
register=test.task.impl.RegisterTask
logout=test.task.impl.LogoutTask

//TaskException.java
package test.task;

/**
 * 处理器异常类
 */
public class TaskException extends Exception {
    private static final long serialVersionUID = 1L;
    private static final String COMMAND_NOTFOUND = "无法找到类：";
    private static final String FILE_NOTFOUND = "无法找到文件：";
    private static final String PROFILE_LOADFAIL = "加载property文件失败：";

    public TaskException(String message) {
        super(message);
    }

    public TaskException(String message, Throwable cause) {
        super(message, cause);
    }

    public static TaskException loadPropFileFailed(String fileName) {
        return new TaskException(PROFILE_LOADFAIL + fileName);
    }

    public static TaskException fileNotFound(String fileName) {
        return new TaskException(FILE_NOTFOUND + fileName);
    }

    public static TaskException taskNotFound(String clzName) {
        return new TaskException(COMMAND_NOTFOUND + clzName);
    }
}

//ITask.java
package test.task;

public interface ITask {
    String process(String value) throws TaskException;
}

//TaskFactory.java
package test.task;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.util.Properties;

public class TaskFactory {
    private Properties properties = new Properties();

    /**
     * 单态工厂实例
     */
    private static TaskFactory m_instance = null;

    /**
     * 工厂构造函数，用于加载处理器组件配置文件
     *
     * @throws TaskException
     */
    public TaskFactory() throws TaskException {
        String fileName = "tasks.properties";
        try {
            InputStream in = getClass().getResourceAsStream(fileName);//快速读取文件内容到输入流的方法
            this.properties.load(in);
        } catch (FileNotFoundException e) {
            throw TaskException.fileNotFound(fileName);
        } catch (IOException e) {
            throw TaskException.loadPropFileFailed(fileName);
        }
    }

    /**
     * 创建工厂的唯一实例
     *
     * @return
     * @throws TaskException
     */
    public static TaskFactory getInstance() throws TaskException {
        if (m_instance == null) {
            m_instance = new TaskFactory();
        }
        return m_instance;
    }

    /**
     * 根据用户请求的地址，取得处理器对象
     * @param taskType
     * @return
     * @throws TaskException
     */
    public ITask getTask(String taskType) throws TaskException {
        return createTask(taskType);
    }

    /**
     * 根据用户请求的地址，取得处理器对象
     * @param taskType
     * @return
     * @throws TaskException
     */
    private ITask createTask(String taskType) throws TaskException {
        ITask task = null;

        //取得处理器类名
        String handlerName = this.properties.getProperty(String.valueOf(taskType));

        //未配置实现类
        if (handlerName == null) {
            throw TaskException.taskNotFound(String.valueOf(taskType));
        }

        //未找到实现类
        try {
            //加载类的实例
            Class<?> cls = Class.forName(handlerName);
            Constructor<?> ct = cls.getConstructor();
            task = (ITask) ct.newInstance();
        } catch (Exception e) {
            throw TaskException.taskNotFound(e.getMessage());
        }

        return task;
    }
}

//LoginTask.java
package test.task.impl;

import test.task.ITask;
import test.task.TaskException;

public class LoginTask implements ITask {
    @Override
    public String process(String value) throws TaskException {
        return value + "登录成功";
    }
}

//RegisterTask.java
package test.task.impl;

import test.task.ITask;
import test.task.TaskException;

public class RegisterTask implements ITask {
    @Override
    public String process(String value) throws TaskException {
        return value + "注册成功";
    }
}

//LogoutTask.java
package test.task.impl;

import test.task.ITask;
import test.task.TaskException;

public class LogoutTask implements ITask {
    @Override
    public String process(String value) throws TaskException {
        return value + "已注销";
    }
}

//Test.java
package test.task;

import java.util.Scanner;

public class Test {
    public static void main(String args[]) {
        try {
            while (true) {
                String str = getDataFromConsole();
                String[] arr = str.split(" ");

                String cmd = arr[0];
                String value = arr[1];

                //反射调用
                TaskFactory factory = TaskFactory.getInstance();
                ITask task = factory.getTask(cmd);

                String out = task.process(value);
                System.out.println(out);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static String getDataFromConsole() {
        Scanner scanner = new Scanner(System.in);
        return scanner.nextLine();
    }
}
输出：
register hello
hello注册成功
login admin
admin登录成功
logout admin
admin已注销
abc
java.lang.ArrayIndexOutOfBoundsException: 1
    at test.task.Test.main(Test.java:13)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
    
基于该框架可以实现更多的实现类，这就是面向接口编程的好处，它的核心是使用了Java的反射机制来动态加载类，在加载前的类名是动态的。
Tips：这种模式是一种经典的工厂模式，在类似的任务处理模型中都可以拿过来直接使用。希望可以学会、理解并记住这个案例。
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第27课 Java泛型编程 P871
27.1 了解Java泛型 P871
泛型是为了解决Java中的强制类型转换错误而产生的。
27.1.1 数据类型转换错误 P871
27.1.2 用泛型消除类型转换 P871
简单的定义Hashtable：
Hashtable h = new Hashtable();
h.put(new Integer(1), "admin");
String s = (String) h.get(new Integer(1));
System.out.println(s);

下例中，真正想要做的是创建Hashtable实例，它只将Integer映射为String，可以用新的Hashtable类来完成这件事：
Hashtable<Integer, String> h = new Hashtable<Integer, String>();
h.put(new Integer(1), "admin");
String s = h.get(new Integer(1));
System.out.println(s);
现在不再需要数据类型转换了。
这里使用泛型版本的Hashtable，就不用编写类型转换的代码了，类型转换的过程交给编译器来处理，方便而且安全。


package test.task;

import java.util.ArrayList;
import java.util.List;

public class TestGeneric {
    public static void main(String args[]) {
        List l = new ArrayList();//不声明泛型类型，则可以加入任意类型
        l.add("abc");
        l.add(3);
        for (Object o : l) {
            System.out.println(o);
        }

        List<String> strList = new ArrayList<>(10);//声明了泛型类型，则只能加入特定类型
        strList.add("hello");
        strList.add("world");
//        strList.add(1);
        for (String s : strList) {//编译器提示可以使用foreach流来代替
            System.out.println(s);
        }
    }
}

27.2 泛型类的开发与使用 P872
27.2.1 定义泛型类 P873
public class TestGeneric<K, V> {
}

定义泛型接口的方法类似，可以为接口添加泛型参数：
public interface TestInterface<T> {
    void func(T t);
}

//
package test.task;

import java.util.Hashtable;

public class TestGeneric<K, V> {
    private Hashtable<K, V> hash = new Hashtable<>();//写成这个形式new Hashtable<K, V>();，会提示<K, V>可以被隐式转换的<>代替

    public void put(K k, V v) {
        hash.put(k, v);
    }

    public V get(K k) {
        return hash.get(k);
    }

    public static void main(String args[]) {
        TestGeneric<String, String> testGeneric = new TestGeneric<>();
        testGeneric.put("001", "admin");
        testGeneric.put("002", "ben");
        String str = testGeneric.get("001");
        System.out.println(str);
    }
}
输出：
admin

在主函数中即可定义该类的实例，反省类型参数分别使用String和String，在使用get()方法时就不需要进行类型转换了。
Tips：泛型类使得类的使用更加方便，只需要在使用时来确定泛型参数的类型，大大增加了程序的通用性，就像是C++中的模板。目前Java中集合框架都已经被泛型化了。

27.2.2 无界通配符“?”
上面在使用泛型类型时指定了参数的类型，有时候也许我们并不能提前知道参数的类型，这时候可以使用无界通配符“?”。如下所示，定义的类型泛型使用问号表示，表示test的类型是未知的：
TestGeneric<?, ?> test = new TestGeneric<String, String>();
此进的test中不能加入任何元素，因为这不是类型安全的。这种做法通常用在面向接口编程中，无界通配符通常用做函数的返回参数，用以在不同的函数中实现不同类型的返回结果。

如下的两个实现函数所示，它们返回的都是ArrayList类型，使用的泛型参数分别是String和Integer，此时的接口函数返回值就可以使用无界通配符“?”来表示。
public List<?> getList() {
    return new ArrayList<String>();
}

public List<?> getList() {
    return new ArrayList<Integer>();
}

27.2.3 上限通配符extends P874
有时候想限制可能出现的泛型类的类型。在上面的示例中，类Hashtable的类型参数可以用想用的任何类型参数进行实例化，但时对于其他某些类，想将可能的类型参数集限定为给定类型范围内的子类型。
 
可能想定义泛型类TestGenericExtend，实现的功能与TestGeneric相似，只不过要求键的泛型参数必须是Number的子类。这时就可以使用extends关键字来限制K，用法如下：
public class TestGenericExtend<K extends Number, V> {
}
只需要在类的泛型参数中指定该泛型的父类即可，类中的代码不变。如果有多个接口的上限，可以使用&符号增加接口。如可以为K增加一个Serializable接口限制：
//实现java.io.Serializable 接口的类是可序列化的。没有实现此接口的类将不能使它们的任一状态被序列化或逆序列化。
public class TestGenericExtend<K extends Number & Serializable, V> {
}

//
package test.task;

import java.io.Serializable;
import java.util.Hashtable;

public class TestGenericExtend<K extends Number & Serializable, V> {
    private Hashtable<K, V> hash = new Hashtable<>();

    public void put(K k, V v) {
        hash.put(k, v);
    }

    public V get(K k) {
        return hash.get(k);
    }

    public static void main(String args[]) {
        TestGenericExtend<Integer, String> test = new TestGenericExtend<>();
        test.put(1, "admin");
        test.put(2, "ben");
        String str = test.get(1);
        System.out.println(str);
    }
}
使用该泛型的类时，K的类型必须是Number的子类，如果使用String代替K，将出现类型匹配异常。
当然可以完全不使用显式的范围，只要能确保没有使用不适当的类型来实例化类型参数。使用类型参数设定范围的两个原因：
--范围增加了静态类型检查功能。有了静态类型检查，就能保证泛型类型的每次实例化都符合所设定的范围。
--我们知道类型参数的每次实例化都是这个范围之内的子类，所以可以放心地调用类型参数实例出现在这个范围之内的任何方法。如果没有对参数设定显式的范围，那么默认情况下范围是Object，这意味着我们不能调用实例在Object中未曾出现的任何方法。

27.2.4 下限通配符super P875
通常所谈的主要的是关于上限通配符，还有一个下限通配符super，用来限制泛型最小的范围。
如，对于List<? super Number>是一个“元素类型”未知的列表，但是可能是Number或者Object的超类型，所以它可能是一个List<Number>或一个List<Object>。
//使用下限通配符
List<? super Number> l = new ArrayList<Object>();
l.add(new Integer(5));
由于Integer是Number类型，因此l的下限是Number类。下限通配符远没有上限通配符那样常见，但当需要它们的时候，它们就是必需的。
//
package test.task;

import java.util.ArrayList;
import java.util.List;

public class TestGenericExtend {

    public static void main(String args[]) {
        List<? super Number> l = new ArrayList<Object>();
        l.add(new Integer(10));
        //l.add("abc");

        List<? super Number> l2 = new ArrayList<>();//new ArrayList<Integer>();编译错误，类型下限是Number，即必须是Number的基类或者Number
        l2.add(new Integer(10));
        //l2.add("abc");//编译错误，不是特别懂？？？，表明l是一个下限为Number的类型List，那List<Object>为什么不让加入String
    }
}

27.2.5 定义多态方法 P876 即类不是泛型的，成员函数是泛型的
除了用类型参数对类进行参数化之外，用类型参数对方法进行参数化往往也同样很有用。泛型在Java编译用语中，用类型进行参数化的方法被称为多态方法（Polymorphic method）。
定义的形式为，在函数名前定义泛型参数，该参数可以在函数的返回值类型、参数类型、函数体代码中引用，如下：
public <T> List<T> getList<T obj> {
    return new ArrayList<T>();
}

//
package test;

public class TestGenericMethod {
    public <T> String getString(T obj) {
        return obj.toString();
    }

    public static void main(String args[]) {
        TestGenericMethod test = new TestGenericMethod();
        String s = "Hello";
        Integer i = 100;
        Float f = 95.1f;
        System.out.println(test.getString(s));
        System.out.println(test.getString(i));
        System.out.println(test.getString(f));
    }
}
输出：
Hello
100
95.1

同样，也可以进行类型范围的限制，如，要求T是Number的子类：
public <T extends Number> String getString(T obj) {
    return obj.toString();
}
此时函数只能输入Number的子类型函数，上例中的String类型参数，将会产生类型匹配异常。
Tips：多态方法这所以有用，是因为有时候在一些我们想执行的操作中，参数与返回值之间的类型相关性原本就是泛型的，但是这个泛型性质不依赖于任何类级的类型信息，而且对于各个方法调用都不同相同。

27.2.6 定义泛型异常 P877
在定义接口时，可以像定义类一样指定一个泛型异常，可以使用extends指定异常的类型为Exception，或者更小的范围。然后在接口的方法中可以抛出该异常。如：
//
package test;

public interface TestGenericException<E extends Exception> {
    void execute(int i) throws E;
}

//
package test;

import java.io.IOException;

public class TestGenericExceptionMain implements TestGenericException<IOException> {

    @Override
    public void execute(int i) throws IOException {
        if (i < 10) {
            throw new IOException();
        }
    }

    public static void main(String args[]) {
        try {
            TestGenericExceptionMain test = new TestGenericExceptionMain();
            test.execute(2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
java.io.IOException
    at test.TestGenericExceptionMain.execute(TestGenericExceptionMain.java:10)
    at test.TestGenericExceptionMain.main(TestGenericExceptionMain.java:17)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)

Tips：泛型异常只能在接口中定义，在实现类中指定具体的异常。这种做法的好处是，可以根据不同的异常类型定义不同的实现类。

//------------------------------------------------------------------------------------------------
//Java核心编程技术 第28课 Java注释符编程 P881
28.1 JDK内置注释 P881
28.1.1 注释的格式与分类 P881
可以将注释分为3个基本种类。
--标记注释没有变量。注释显示简单，有名称标识，没有提供其他数据。如，@MarkerAnnotation是标记注释，它不包含数据，仅有注释名称。
@Deprecated

--单一值注释与标记注释类似，但提供一段数据。因为仅提供很少的一点数据，所以可以使用快捷语法（除了@标记外，这应该与普通的Java方法调用很像）：
@SingleValueAnnotation("my data")
如，下面的注释有一个参数：
@SuppressWarnings("deprecation")
public static void selfDestruct() {
    Thread.currentThread().stop();
}

--完整注释有多个数据成员。因此，必须使用更完整的语法（注释不再像普通的Java方法）：
@FullAnnotation(var1="data value 1", var2="data value 2", var3="data value 3")

28.1.2 覆盖注释@Override P882
第一个内置注释类型是@Override。仅用于方法（不用于类、包声明或其他构造），指明注释的方法将覆盖超类中的方法。
使用@Override的作用如下：
（1）它能够强制该函数的代码必须符合超类中该方法的定义格式
函数的参数、抛出异常等必须符合父类的函数，不会让你犯错。
（2）检查该方法必须是父类中的方法
如果使用了@Override，那么该方法必须是其父类中的方法。
在覆盖父类的方法时最好使用@Override，可以为函数形式做正确性检查，也能够标志该方法是被覆盖的方法。

28.1.3 过时注释@Deprecated P883
下一个标准注释类型是@Deprecated。与@Override一样，@Deprecated是标记注释，用来对不应再使用的方法进行注释，这通常用在对新版本代码的修改。如旧版本中提供的方法，在新版本中有了更好的方法，将提示用户可以放弃旧的方法的使用。
//
package test;

public class TestDeprecated {
    //把@Deprecated删掉，调用方法时就没有删除线了
    @Deprecated
    public void oldShow() {
        System.out.println("This is deprecated oldShow()");
    }

    public void newShow() {
        System.out.println("This is newShow()");
    }

    public static void main(String args[]) {
        TestDeprecated testDeprecated = new TestDeprecated();
        testDeprecated.oldShow();//编译器会自动将标注为@Deprecated的方法显示一条删除线
        testDeprecated.newShow();
    }
}
Tips：过时的函数不建议你爱我吗，但不是不可使用，只能说是该函数在新的版本中性能、安全性等方法不是那么完美了，因此才建议使用新的方法。

28.1.4 警告注释@SuppressWarnings P883
最后一个注释类型是@SuppressWarnings，作用是用来消除代码的警告。

@SuppressWarnings("unchecked")

@SuppressWarnings是具有变量的，可以将单一注释类型与该变量一起使用。
也可以以值数组的形式来提供变量，其中每个值指明要阻止的一种特定警告类型。@SuppressWarnings中变量的值采用数组，可以在同一注释中阻止多个警告。例如，@SuppressWarnings(value={"unchecked", "fallthrough"})使用两个值的数组。

28.2 自定义注释 P885
28.2.1 定义注释类型@interface P885
@interface声明：定义新的注释类型与创建接口有很多类似之处，只不过interface关键字之前要有一个@符号，最简单的注释类型示例：
public @interface TestInterface {
}

注释类与普通类文件一样，可以以注释类名作为文件名，如果编译这个注释类型，并将其放在类路径中，那么就可以在源代码方法中使用它，如下：
@TestInterface
public void test() {
}

28.2.2 添加成员变量 P885
注释类型可能有成员变量，用以添加更加复杂的元数据。注释类型中的数据成员被设置成使用有限的信息进行工作，定义数据成员后不需要分别定义访问和修改的方法。只需要定义一个方法，以成员的名称命名它，数据类型应该是该方法返回值的类型。
下面示例，为注释类型@TestInterface添加了3个成员变量，第一个为整型，第二和第三个为字符串型：
//
package test;

public @interface TestInterface {
    int number();
    String value();
    String description();
}

//
package test;

public class TestDeprecated {
    //这里无法省略number=
    @TestInterface(number = 10, value = "v", description = "d")
    public static void main(String args[]) {
        System.out.println("@TestInterface");
    }
}

//只有一个数据成员时
package test;

public @interface TestInterface {
    int number();
}
//
package test;

public class TestDeprecated {
    //这里编译不过，为什么？
    @TestInterface(10)
    public static void main(String args[]) {
        System.out.println("@TestInterface");
    }
}

28.2.3 设置默认值 P886
在成员变量后使用default指定默认值，默认值的类型必须与成员变量声明的类型完全相同。
package test;

public @interface TestInterface {
    int number() default 1;
    String value() default "hello";
    String description() default "world";
}
//
package test;

public class TestDeprecated {
    @TestInterface(value = "abc")
    public static void main(String args[]) {
        System.out.println("@TestInterface");
    }
}

28.2.4 设置目标范围@Target P886
对于自定义的注释类型，可以限定引用它的时机，可以在注释类前使用JDK 5.0 内置的注释@Target来指定注释的目标范围。
ElementType这个枚举定义了注释类型可应用的不同程序元素。

//演示@Target的用法
package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.ANNOTATION_TYPE})//如果把ElementType.METHOD注释掉，则会报编译错误，无法在main方法前使用
public @interface TestInterface {
    int number() default 1;
    String value() default "hello";
    String description() default "world";
}

Java编译器将把@TestInterface应用于类型、方法、构造函数和其他注释类型，这样有助于避免他人误用你的注释类型。

28.2.5 设置保持性@Retention P887
这个注释和Java编译器处理注释的注释类型的方式有关，编译器有以下几种不同的选择。
--将注释保留在编译后的类文件中，并在第一次加载类时读取它。
--将注释保留在编译后的类文件中，但是在运行时忽略它。
--按照规定使用注释，但是并不将它保留到编译后的类文件中。
这3种选项用java.lang.annotation.RetentionPolicy枚举表示。

@Retention注释类型使用枚举中的一个作为唯一的参数，将该元注释用于注释，如下：

package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface TestInterface {
    int number() default 1;
    String value() default "hello";
    String description() default "world";
}
这将使得@TestInterface注释符只能够保持在Java源代码中。

28.2.6 添加公共文档@Documented P888
这是一个标记注释，没有成员变量，表示注释应该出现在类的Javadoc中，在默认情况下，注释不包括在Javadoc中。
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TestInterface {
    int number() default 1;
    String value() default "hello";
    String description() default "world";
}
@Documented的一个实用技巧是保持性策略。上例中规定注释的保持性（retention）是RUNTIME，这是使用@Documented注释类型所必需的。Javadoc使用虚拟机从其类文件（而非源文件）中加载信息。确保JVM从这些类文件中获得生成Javadoc所需信息的唯一方法是将保持性规定为RetentionPolicy.RUNTIME。这样，注释就会保留在编译后的类文件中并且由虚拟机加载，然后Javadoc可以从抽取出来添加到类的HTML文件中。

28.2.7 设置继承@Inherited P888
添加@Inherited后，将看到@TestInterface出现在注释类的子类中。
当然，并不希望所有的注释类型都具有这种行为（因为默认值是不继承的）。如，TODO注释就不会（也不应该）被传播。
//------------------------------------------------------------------------------------------------
//Java核心编程技术 第29课 Java 5.0 语言新特性 P891
JDK 5.0 的11个特征中的两个重要特性――泛型和注释符。

29.1 自动装箱和拆箱（Boxing/Unboxing）P891
实现了基本数据类型与对象数据类型之间的隐式转换。
--基本数据类型至对象数据类型的转换称为自动装箱。
--对象数据类型至基本数据类型的转换称为自动拆箱。
这些类包括：
byte--Byte
short--Short
int--Integer
long--Long
float--Float
double--Double
char--Character
boolean--Boolean

//
package test;

import java.util.ArrayList;
import java.util.List;

public class TestAnnotation {
    public static void main(String args[]) {
        //旧的代码
        Integer intObject = new Integer(20);
        int intPrimitive = 10;
        List<Integer> list = new ArrayList<>();//int将提示primitive(原始)数据不能成为数据类型
        list.add(intObject);
        list.add(new Integer(intPrimitive));

        //如果将Integer类型转换为int，需要使用转换函数
        int intPrimitive2 = intObject.intValue();

        //新的代码
        list.add(intPrimitive);//自动装箱int-->Integer
        int intPrimitive3 = intObject;//自动拆箱Integer-->int
    }
}
该功能让我们在编码时不再需要进行显示转换，代码编写简单，符合编程思维。

29.2 枚举类（Enumeration Class） P892
通常在定义一些常用的键值时，会使用一些public static final int类型的常量来定义。
1. public static final int 的常量
如，要定义一系列颜色值：
public class Constants {
    public static final int RED = 1;
    public static final int YELLOW = 2;
    public static final int BLUE = 3;
    public static final int ORANGE = 4;
}

这种方法有一个隐患，就是这些常量的整型值不能相等。如，像下面这样引用这些变量：
public void paint(int color) {
    switch (color) {
    case Constants.RED:
        ;
    case Contants.YEELOW;
        ;
    case Constants.BLUE;
        ;
    case Constants.ORANGE;
        ;
    default:
        ;
    }
}
对于case分支，如果其中的颜色值有相等，则会出现错乱。为了解决这个问题，出现了枚举类。

2. 定义枚举类 P893
枚举类（enum）非常像public static final int声明，对int所做的最大也是最明显的改进是类型安全，你不能错误地用枚举的一种类型代替另一种类型，这和int不同，所有的int对编译器来说都是一样的。大部分情况下，可以使用enum对代码中所有的public static final int 做插入替换。它们是可比的，并且可以静态导入，所以对它们的引用看起来是等同的，即便是对于内部类（或内部枚举类型）。
可以像下面这样定义颜色列表：
enum Color {
    Red, Yellow, Blue, Orange;
}

像引用变量一样引用枚举变量：
Color color = Color.Red;//引用变量

对于以上paint()函数，枚举类这样使用：
public void paint(Color color) {
    switch (color) {
    case Red:
        ;
    case Yellow:
        ;
    default:
        ;
    }
}

case标签中的值可以引用自switch()中参数的枚举值，并可以使用values()取得枚举列表数组，遍历枚举值：
//
package test;

enum Color {
    Red, Green, Yellow, Orange;
}

public class TestEnum {
    public static void main(String args[]) {
        Color color = Color.Orange;

        switch (color) {
            case Red:
                System.out.println("Red");
                break;//需要加break来跳出switch
            case Green:
                System.out.println("Green");
                break;
            case Yellow:
                System.out.println("Yellow");
                break;
            default:
                System.out.println("Default color: " + color);
        }

        Color[] colors = Color.values();
        for (int i = 0; i < colors.length; ++i) {
            System.out.println(colors[i]);
        }
    }
}

3. 为枚举值添加参数 P894
枚举的变量名可以附带一个参数，用来表示一个附加的属性，如缩写等。参数类型可以是String、int等各种Java类型，形式为：
public enum Name {types(参数值), ...;}
如果附带了参数，必须为该参数添加一个变量名、构造函数和get函数，如下：
//枚举类型可以理解为就是一个类，可以有构造函数等各种函数
package test;

enum Color {
    Red("R"), Green("G"), Yellow("Y"), Orange;//如果这里Orange不提供参数，则需要有无参的构造函数Color()

    private String shortName;
    //这里会提示private是冗余的，可以不带限定符。但是如果使用public则报错public不允许
    private Color(String shortName) {
        this.shortName = shortName;
    }

    Color() {

    }

    public String getShortName() {
        return shortName;
    }
}

public class TestEnum {
    public static void main(String args[]) {
        Color[] colors = Color.values();
        for (int i = 0; i < colors.length; ++i) {
            System.out.println(colors[i]);
            System.out.println(colors[i].getShortName());
        }
    }
}
输出：
Red
R
Green
G
Yellow
Y
Orange
null

也可以用整数值来表示参数
enum Day {
    SUNDAY(0), MONDAY(1), ...;
    
    private int day;
    Day(int day) {
        this.day = day;
    }
    public int getDay() {
        return day;
    }
}

4. 枚举的映射（Map） P894
枚举提供了一些附加的特性，EnumMap和EnumSet这两个实用类是专门为枚举优化的标准集合实现。如果知道集合只包含枚举类型，应该使用这些专门的集合来代替HashMap或HashSet。
//
package test;

import java.util.EnumMap;

enum Color {
    Red, Green, Yellow, Orange;
}

public class TestEnum {
    public static void main(String args[]) {
        EnumMap<Color, String> map = new EnumMap<Color, String>(Color.class);
        map.put(Color.Red, "this is Red");
        map.put(Color.Yellow, "this is Yellow");
        map.put(Color.Green, "this is Green");
        map.put(Color.Orange, "this is Orange");

        Color[] colors = Color.values();
        for (int i = 0; i < colors.length; ++i) {
            System.out.println(map.get(colors[i]));
        }
    }
}
输出：
this is Red
this is Green
this is Yellow
this is Orange
这种做法好处是，可以保证Map列表中的键在枚举值的范围内，而不超出枚举值范围，EnumSet也是如此。
Tips：通常都应用用enum实例替换全部的枚举风格的public static final int结构，因为枚举是安全的。

29.3 可变参数（Variable Arguments） P895
使用3个点号表示一系列的同类型的参数，如下：
void func(Object... args)
3 个点号紧跟在对象类型Object后面，其中的Object可以是任意类型，包括Java基础数据类型和对象数据类型。
在引用该函数时，可以使用逗号分隔传递多个参数，同类型的参数都将作为该参数的一个值传入，如下所示：
func(arg1, arg2,..., argn);
传入的参数args实现上是一个Object类型的数组：
Object[] args;
因此可以像使用数组一样使用args变量。
Tips：由于可变参数的数量不定，因此可变参数只能作为函数的最后一个参数出现，因此函数最多只能有一个可变参数。

//
package test;

public class TestVarargs {
    public static int add(int... args) {
        int total = 0;
        for (int i = 0; i < args.length; ++i) {
            total += args[i];
        }
        return total;
    }

    public static void main(String args[]) {
        System.out.println(TestVarargs.add(1, 2));
        System.out.println(TestVarargs.add(1, 2, 3));
    }
}
输出：
3
6
Tips：正确地使用可变参数确实可以清理一些垃圾代码，它避免了往函数中传递一个长度不固定的数组，可以将待传递的数组中的各个值直接当做参数传递。

//可以参数也可以使用不同类型的参数，此时需要用Object来表示入参，并且需要对参数类型做判断
package test;

public class TestVarargs {
    public static void add(Object... args) {
        int total = 0;
        for (int i = 0; i < args.length; ++i) {
            Object o = args[i];
            if (o instanceof Integer) {
                int argInt = (int) o;
                System.out.println("Int: " + argInt);
            } else if (o instanceof String) {
                String argStr = (String) o;
                System.out.println("String: " + argStr);
            }

        }
    }

    public static void main(String args[]) {
        TestVarargs.add(1, 2);
        TestVarargs.add(3, "hello", "world");
    }
}
输出：
Int: 1
Int: 2
Int: 3
String: hello
String: world

29.4 可变返回类型（Covariant Return Types） P896
JDK5中可以改变被覆盖方法的返回类型。Covariant的意思是，在子类的重载方法中，其方法的返回值的范围比父类的对应类型缩小了，可以是父亲对应类型的子类型。
如下，B类继承自Number，其重载方法whoAreYou()返回的类型不再是Number，而是Number的子类型Integer，这样就缩小了重载方法的范围。
package test;

class Number {
    public Number whoAreYou() {
        return new Number();
    }
}

class Integer extends Number {
    @Override
    public Number whoAreYou() {
        return new Integer();
    }
}

class Float extends Number {
    @Override
    public Number whoAreYou() {
        return new Float();
    }
}

public class TestConvariant {
    public static void main(String args[]) {
        Float f = new Float();
        System.out.println(f.whoAreYou());
    }
}
Tips：这种做法的用意是，允许子类缩小返回类型的范围，使得各实现子类能够更加符合自身的意义。如对于父类Number，它的子类Integer、Float分别用于处理整型和浮点型数据，如果它们返回的值都是Number类型，那么对这两个子类来说，显示是不合适的，子类不应该提及父类，而是只处理自身范围内的数据才是合理的。

29.5 增强循环 Enhanced for Loop P897
通常对于数据列表：
List<String> list = new ArrayList<>();
list.add("how");
list.add("are");
list.add("you");
可以使用for语句来循环该列表：
for (int i = 0; i < list.size(); ++i) {
    String str = list.get(i);
    System.out.println(str);
}
或使用while语句来输出迭代对象：
Iterator<String> iter = list.iterator();
while (iter.hasNext()) {
    String str = iter.next();
    System.out.println(str);
}

JDK 5.0 中提供了增强的for循环功能，可以使用如下形式输出：
for (Object o : c) {
    //
}

此时可以如下输出：
for (String str : list) {
    System.out.println(str);
}
与旧的for循环相比，str对象不需要从list中使用get()取得了，不需要进行指针的累加；与while循环相比，不需要生成迭代对象，也不需要使用next()来循环指针。这样做的好处很显然，只需要理解str是list集合中的对象即可，也完全符合我们的正常思维过程。
将这种特殊的for语句格式称之为“foreach”语句，foreach并不是一个关键字。从英文字面理解foreach也就是“for 每一个”的意思。

foreach语句是for语句的特殊简化版本，但是foreach语句并不能完全取代for语句，然而，任何的foreach语句都可以改写为for语句版本。对于数组、列表、集合类型的数据对象都可以使用这种简化方式。上面的例子可以发现，如果要引用数组或者集合的索引，则foreach语句无法做到，foreach仅仅老老实实的遍历数组或者集合一遍。
Tips：foreach语句是for语句特殊情况下的增强版本，简化了编程，提高了代码的可读性和安全性（不用怕数组越界）。相对老的for语句来说是个很好的补充。提供能用foreach的地方就不要用for了。在用到对集合或者数组索引的情况下，foreach显得力不从心，这个时候是用for语句的时候了。

20.6 静态导入 Static Import P898
Java编程中，通常将固定的函数和变量写成静态的，可以直接通过类名来引用该函数和变量，不需要通过构造类的实现来实现它。如对于Math类的静态方法，可能这样引用：
//旧的方式
package test;

public class TestVarargs {
    public static void main(String args[]) {
        double d = Math.sqrt(Math.pow(3, 2) + Math.pow(4, 2));
        System.out.println(d);
    }
}

对于每一个方法，都需要使用类名来引用，在JDK 5.0 中可以使用静态导入一次性引入，语法格式如下：
import static java.lang.Math.*;
该语句放在类文件的import区域，使用关键字为“import static”，类名后需要添加“.*”，表示引入了所有的静态函数，也可以指定具体的函数名。
package test;

import static java.lang.Math.pow;
import static java.lang.Math.*;

public class TestVarargs {
    public static void main(String args[]) {
        double d = Math.sqrt(Math.pow(3, 2) + Math.pow(4, 2));
        System.out.println(d);

        //新的方式
        double d2 = sqrt(pow(1, 2) + pow(1, 2));
        System.out.println(d2);
    }
}
需要注意的是，默认包无法用静态导入，另外如果导入的类中有重复的方法和属性则需要写出类名，否则编译时无法通过。

29.7 控制台输入 （Console Input） P898
JDK 5.0 中可以通过java.utils.Scanner在控制台进行输入操作。
Scanner是一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。Scanner使用分隔符模式将其输入分解为标记，在默认情况下该分隔符模式与空白匹配。然后可以使用不同的next方法将得到的标记转换为不同类型的值。
1. 读取控制台
以下代码使用户能够从System.in中读取一个数：
package test;

import java.util.Scanner;

public class TestVarargs {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);//输入非数字的字符将抛异常
        int i = sc.nextInt();
        System.out.println(i);
    }
}

2. 读取文件
//test.txt
123
456
abc
789

//
package test;

import java.io.File;
import java.util.Scanner;

public class TestVarargs {
    public static void main(String args[]) {
        try {
            Scanner sc = new Scanner(new File("src/test/test.txt"));//路径一定要从src下开始指定
            while (sc.hasNextLong()) {//读到不是long的对象后就退出
                long l = sc.nextLong();
                System.out.println(l);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
123
456

3. 读取字符串
扫描器还可以使用不同于空白的分隔符，下面是从一个字符串读取若干项的例子：
package test;

import java.util.Scanner;

public class TestVarargs {
    public static void main(String args[]) {
        String input = "1 fish   2 fish   red fish blue fish  ";
        Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*");//\s匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
        System.out.println(s.nextInt());
        System.out.println(s.nextInt());
        System.out.println(s.next());
        System.out.println(s.next());
    }
}
输出
1
2
red
blue

以下代码使用正则表达式同时解析所有的4个标记，并可以产生与上例相同的输出结果：
package test;

import java.util.Scanner;
import java.util.regex.MatchResult;

public class TestVarargs {
    public static void main(String args[]) {
        String input = "1 fish   2 fish   red fish blue fish  ";
        Scanner s = new Scanner(input);
        s.findInLine("(\\d+)\\s*fish\\s*(\\d+)\\s*fish\\s*(\\w+)\\s*fish\\s*(\\w+)");
        MatchResult result = s.match();
        for (int i = 1; i <= result.groupCount(); ++i) {
            System.out.println(result.group(i));
        }
    }
}

Tips：该类为java.utils.Scanner，更多使用可以参数Java API文档。

29.8 StringBuilder类 P900

29.9 格式化I/O （Formatted I/O） P900
//------------------------------------------------------------------------------------------------
//Effective Java 第1章 引言 P1
不严格地讲，一个包的导出的API是由该包中的每个公有（public）类或者接口中所有公有的或者受保护的（protected）成员和构造器组成。
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第1条：考虑用静态工厂方法代替构造器 P4
获取一个实例，类可以提供一个公有的静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。下面是一个Boolean（基本类型boolean的包装类）的简单示例，这个方法将boolean基本类型值转换成了一个Boolean对象引用：
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}

类可以通过静态工厂方法来提供它的客户端，而不是通过构造器。提供静态工厂方法而不是公有的构造器，这样做具有几大优势。
--静态工厂方法与构造器不同的第一大优势在于，它们有名称。如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。
一个类只能有一个带有指定签名的构造器。
由于静态工厂方法有名称，所以它们不受上述的限制。当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重地选择名称以便突出它们之间的区别。

--静态工厂方法与构造器不同的第二大优势在于，不必每次调用它们的时候都创建一个新对象。如果程序经常请求创建相同的对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。
静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作实例受控的类（instance-controlled）。编写实例受控的类有几个原因。可以确认它是一个Singleton（见第3条）或者是不可实例化的（见第4条）。它还使得不可变的类（见第15条）可以确保不会存在两个相等的实例，即当且仅当a==b时才有a.equals(b)为true。如果类保证了这一点，它的客户端就可以使用==操作符来代替equals(Object)方法，这样可以提升性能。枚举（enum）类型（见第30条）保证了这一点。

--静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有了更大的灵活性。

服务提供者框架模式有着无数种变体。如，服务访问API可以利用适配器（Adapter）模式，返回比提供者需要的更丰富的服务接口。下面是一个简单的样例，包含一个服务提供者接口和一个默认提供者：
//
package test;

public interface Service {
    String name();
}

class ServiceA implements Service {
    private String name = "ServiceA";

    @Override
    public String name() {
        return name;
    }
}

class ServiceB implements Service {
    private String name = "ServiceB";

    @Override
    public String name() {
        return name;
    }
}

//
package test;

public interface Provider {
    Service newService();
}

class ProviderA implements Provider {
    @Override
    public Service newService() {
        return new ServiceA();
    }
}

class ProviderB implements Provider {
    @Override
    public Service newService() {
        return new ServiceB();
    }
}

//
package test;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Services {
    private Services() {
    }

    private static final Map<String, Provider> providers = new ConcurrentHashMap<>();
    public static final String DEFAULT_PROVIDER_NAME = "<default>";

    //Provider registration API
    public static void registerDefaultProvider(Provider p) {
        registerDefaultProvider(DEFAULT_PROVIDER_NAME, p);
    }

    public static void registerDefaultProvider(String name, Provider p) {
        providers.put(name, p);
    }

    //Service access API
    public static Service newInstance() {
        return newInstance(DEFAULT_PROVIDER_NAME);
    }

    public static Service newInstance(String name) {
        Provider p = providers.get(name);
        if (p == null) {
            throw new IllegalArgumentException("No provider registered with name: " + name);
        }
        return p.newService();
    }
}

//
package test;

public class TestServices {
    public static void main(String args[]) {
        Services.registerDefaultProvider("A", new ProviderA());
        Services.registerDefaultProvider("B", new ProviderB());

        Service s = Services.newInstance("A");
        System.out.println(s.name());
    }
}
输出：
ServiceA

--静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁。在调用参数化类的构造器时，即便类型参数很明显，也必须指明。这通常要求接续两次提供类型参数：
Map<String, List<String>> m = new HashMap<String, List<String>>();//在1.8中已经可以省略第二个参数了
有了静态工厂方法，编译器就可以替你找到类型参数。这被称作类型推导（type inference）。如，假设HashMap提供了这个静态工厂：
public static <K, V> HashMap<K, V> newInstance() {
    return new HashMap<K, V>();
}
就可以用下面这句简洁的代码代替上面这段繁琐的声明：
Map<String, List<String>> m = HashMap.newInstance();//当前1.8中还未添加此静态方法

--静态方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。对于公有的静态工厂所返回的非公有类，也同样如此。如，想要将Collections Framework中的任何方便的实现类子类化，这是不可能的。这样也因祸得福，因为它鼓励程序员使用复合（composition），而不是继承（见第16条）。

--静态工厂方法的第二个缺点在于，它们与其他的静态方法实际上没有任何区别。在API文档中，它们没有像构造器那样在API文档中明确标识出来，因此，对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类，这是非常困难的。

简而言之，静态工厂方法和公有构造器都各有用处，需要理解它们各自的长处。静态工厂通常更加合适，因此切忌第一反应就是提供公有的构造器，而不先考虑静态工厂。
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第2条：遇到多个构造器参数时要考虑用构建器 P9
静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。考虑用一个类表示包装食品外面显示的营养成份标签。有大量的域。
对于这样的类，应该用哪种构造器或者静态方法来编写？程序员一向习惯采用重叠构造器（telescoping constructor）模式，在这种模式下，提供第一个只有必要参数的构造器，第二个构造器有一个可选参数，第三个有两个可选参数，依此类推，最后一个构造器包含所有可选参数。下面示例，为简单起见，只显示四个可选域：
//
package test;
//Telescoping constructor pattern - does not scale well!
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public NutritionFacts(int servingSize, int servings) {
        this(servingSize, servings, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories) {
        this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat) {
        this(servingSize, servings, calories, fat, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
        this(servingSize, servings, calories, fat, sodium, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
        this.servingSize = servingSize;
        this.servings = servings;
        this.calories = calories;
        this.fat = fat;
        this.sodium = sodium;
        this.carbohydrate = carbohydrate;
    }

    @Override
    public String toString() {
        return "[ServingSize:" + servingSize + "]@[Serving:" + servings + "]@[Calories:" + calories
                + "]@[Fat:" + fat + "]@[Sodium:" + sodium + "]@[Carbohydrate:" + carbohydrate + "]";
    }

    public static void main(String args[]) {
        NutritionFacts cocacola = new NutritionFacts(240, 8, 100, 0, 35, 27);
        System.out.println("Cocacola:" + cocacola);

        NutritionFacts bread = new NutritionFacts(100, 20);
        System.out.println("Bread:" + bread);
    }
}
输出：
Cocacola:[ServingSize:240]@[Serving:8]@[Calories:100]@[Fat:0]@[Sodium:35]@[Carbohydrate:27]
Bread:[ServingSize:100]@[Serving:20]@[Calories:0]@[Fat:0]@[Sodium:0]@[Carbohydrate:0]

这个构造器调用通常需要许多你本不想设置的参数，但还是不得不为它们传递值。这个例子中，我们给fat传递了一个值为0。随着参数数目的增加，它很快就失去了控制。
一句话：重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读。

遇到很多构造器参数的时候，还有第二种代替方法，即JavaBeans模式，在这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个相关的可选参数：
//
package test;
//JavaBeans Pattern - allows inconsistency, mandates mutability
public class NutritionFacts {
    private int servingSize = -1;//如果用setter，则这里不能有final了，final同C++里的const一样，是不能修改的，只能在构造函数初始化
    private int servings = -1;
    private int calories;
    private int fat;
    private int sodium;
    private int carbohydrate;

    public NutritionFacts() {
    }

    //Setters
    public void setServingSize(int servingSize) {
        this.servingSize = servingSize;
    }

    public void setServings(int servings) {
        this.servings = servings;
    }

    public void setCalories(int calories) {
        this.calories = calories;
    }

    public void setFat(int fat) {
        this.fat = fat;
    }

    public void setSodium(int sodium) {
        this.sodium = sodium;
    }

    public void setCarbohydrate(int carbohydrate) {
        this.carbohydrate = carbohydrate;
    }

    @Override
    public String toString() {
        return "[ServingSize:" + servingSize + "]@[Serving:" + servings + "]@[Calories:" + calories
                + "]@[Fat:" + fat + "]@[Sodium:" + sodium + "]@[Carbohydrate:" + carbohydrate + "]";
    }

    public static void main(String args[]) {
        NutritionFacts cocacola = new NutritionFacts();
        cocacola.setCalories(100);
        System.out.println("Cocacola:" + cocacola);

        NutritionFacts bread = new NutritionFacts();
        System.out.println("Bread:" + bread);
    }
}
输出：
Cocacola:[ServingSize:-1]@[Serving:-1]@[Calories:100]@[Fat:0]@[Sodium:0]@[Carbohydrate:0]
Bread:[ServingSize:-1]@[Serving:-1]@[Calories:0]@[Fat:0]@[Sodium:0]@[Carbohydrate:0]

这种模式弥补了重叠构造器模式的不足。创建实例很容易，产生的代码读起来也容易。
但是，JavaBeans模式自身有着很严重的缺点。因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致和状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象，将会导致失败，这种失败与包含错误的代码大相径庭，因此它调试起来十分困难。另一点不足在于，JavaBeans模式阻止了把类做成不可变的可能（见第15条），这就需要程序员付出额外的努力来确保它的线程安全。

幸运的是，还有第三种替代方法，既能保证像重叠构造器模式那样的安全性，也能保证像JavaBeans模式那么好的可读性。这就是Builder模式。不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个builder对象。然后客户端在builder对象上调用类似于setter方法，来设置每个相关的可选参数。最后，客户端调用无参的builder方法来生成不可变的对象。这个builder是它构建的类的静态成员类（见第22条）。下面示例：
package test;

//Builder Pattern
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    //静态内部类，可以不依赖于外部类实例存在 StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
    //非静态内部类，必须依赖外部类实例对象初始化。NoneStaticInnerClass noneStaticInnerClass = outerClass.new NoneStaticInnerClass();
    public static class Builder {
        //Required parameters
        private final int servingSize;
        private final int servings;

        //Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) {
            this.calories = val;
            return this;
        }

        public Builder fat(int val) {
            this.fat = val;
            return this;
        }

        public Builder carbohydrate(int val) {
            this.carbohydrate = val;
            return this;
        }

        public Builder sodium(int val) {
            sodium = val;
            return this;
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }

    @Override
    public String toString() {
        return "[ServingSize:" + servingSize + "]@[Serving:" + servings + "]@[Calories:" + calories
                + "]@[Fat:" + fat + "]@[Sodium:" + sodium + "]@[Carbohydrate:" + carbohydrate + "]";
    }

    public static void main(String args[]) {
        NutritionFacts cocacola = new NutritionFacts.Builder(240, 0).calories(100).sodium(35).carbohydrate(27).build();
        System.out.println("Cocacola:" + cocacola);

        NutritionFacts bread = new Builder(100, 30).build();//这里可以直接new Builder()
        System.out.println("Bread:" + bread);
    }
}
输出：
Cocacola:[ServingSize:240]@[Serving:0]@[Calories:100]@[Fat:0]@[Sodium:35]@[Carbohydrate:27]
Bread:[ServingSize:100]@[Serving:30]@[Calories:0]@[Fat:0]@[Sodium:0]@[Carbohydrate:0]

注意NutritionFacts是不可变的，所有的默认参数值都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用连接起来。
这样的客户端代码很容易编写，更为重要的是，易于阅读。builder模式模拟了具名的可选参数。

builder像个构造器一样，可以对其参数强加约束条件。build()方法可以检验这些约束条件。将参数从builder拷贝到对象中后，并在对象域而不是builder域（见第39条）中对它们进行校验，这一点很重要。如果违反了任何约束条件，build()方法就应该抛出IllegalStateException（见第60条）。异常的详细信息应该显示出违反了哪个约束条件（见第63条）。
对多个参数强加约束条件的另一种方法是，用多个setter方法对某个约束条件必须持有的所有参数进行检查。如果该约束条件没有得到满足，setter方法就会抛出IllegalArgumentException。这有个好处，就是一旦传递了无效的参数，立即就会发现约束条件失败，而不是等着调用build()方法。
与构造器相比，builder的微略优势在于，builder可以有多个可变（varargs）参数。构造器就像方法一样，只能有一个可变参数。因为builder利用单独的方法来设置每个参数，想要多少个可变参数，就可以有多少个，直到每个setter方法都有一个可变参数。
Builder模式十分灵活，可以利用单个builder构造多个对象。builder的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder可以自动填充某些域，例如每次创建对象时自动增加序列号。

设置了参数的builder生成了一个很好的抽象工厂（Abstract Factory）。客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。要使用这种用法，需要有个类型来表示builder。1.5 及之后版本，只要一个泛型（见第26条）就能满足所有builder，无论它们在构造哪种类型的对象：
//A builder for objects of type T
public interface Builder<T> {
    public T build();
}
可以声明NutritionFacts.Builder类来实现Builder<NutritionFacts>。

Class.newInstance破坏了编译时的异常检查。上面讲过的Builder接口弥补了这些不足。

Builder模式的确也有不足。为了创建对象，必须先创建它的构造器。虽然创建构建器的开销在实践中可能不那么明显，但是在某些十分注意性能的情况下，可能就成问题了。Builder模式还比重叠构造器模式更加冗长，因此它只在有很多参数的时候才使用，比如4个或者更多个参数。但是记住，将来你可能需要添加参数。如果一开始就使用构造器或者静态工厂，等到类需要多个参数时才添加构建器，就会无法控制，那些过时的构造器或者静态工厂显得十分不协调。因此，通常最好一开始就使用构建器。

简而言之，如果类的构造器或者静态工厂中具有多个参数，设计这种类时Builder模式就是种不错的选择，特别是当大多数参数都是可选的时候。与使用传统的重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBeans更加安全。

//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第3条：用私有构造器或者枚举类型强化Singleton属性 P14
Singleton指仅仅被实例化一次的类。Singleton通常被用来代表那些本质上唯一的系统组件，比如窗口管理器或者文件系统。使类成为Singleton会使它的客户端测试变得十分困难，因为无法给Singleton替换模拟实现，除非它实现一个充当其类型的接口。
//Singleton with public final field
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {}

    public void leaveTheBuilding() {}
}

私有构造器仅被调用一次，用来实例化公有的静态final域Elvis.INSTANCE。要提醒一点：享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制（见第53条）调用私有构造器。如果需要抵御这种苏南，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。

在实现Singleton的第二种方法中，公有的成员是个静态工厂方法：
//Singleton with static factory
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {}
    public static Elvis getInstance() { return INSTANCE;}

    public void leaveTheBuilding() {}
}
对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以，永远不会创建其他的Elvis实例（上述提醒依然适用）。

公有域方法的主要好处在于，组成类的成员的声明很清楚地表明了这个类是一个Singleton：公有的静态域是final的，所以该域将总是包含相同的对象引用。公有域方法在性能不上再有任何优势：现代的JVM实现几乎都能够将静态工厂方法的调用内联化。
工厂方法的优势之一在于，它提供了灵活性：在不改变其API的前提下，可以改变该类是否应该为Singleton的想法。工厂方法返回该类的唯一实例，但是，它可以很容易被修改，如改成每个调用该方法的线程返回一个唯一的实例。第二个优势与泛型（见第27条）有关。这些执行之间通常都不相关，public域（public-field）的方法比较简单。

为了使用利用这其中一种方法实现的Singleton类变成可序列化的，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法（见第77条）。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例，在我们的例子中，会导致“假冒的Elvis”。为防止这种情况，要在Elvis类中加入下面这个readResolve方法：
private Object readResolve() {
    return INSTANCE;
}

从Java 1.5 发行版本起，实现Singleton还有第三种方法。只需编写一个包含单个元素的枚举类型： //https://www.cnblogs.com/yangzhilong/p/6148639.html
//
package test;

public enum Elvis {
    INSTANCE;

    private int i = 3;

    public void set(int i) {
        this.i = i;
    }

    public int get() {
        return i;
    }
}

//
package test;

public class TestSingleton {
    public static void main(String args[]) {
        Elvis elvis = Elvis.INSTANCE;
        System.out.println(elvis.get());

        Elvis elvis1 = Elvis.INSTANCE;
        elvis1.set(5);

        System.out.println(elvis.get());
    }
}
输出：
3
5

这种方法在功能上与公有域方法相近，但是它更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即便是在面对复杂的序列化或者反射攻击的时候。虽然还没有广泛采用，但是元素的枚举类型已经成为实现Singleton的最佳方法。
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第4条：通过私有构造器强化不可实现化的能力 P16

企图通过将类做成抽象类来强制该类不可被实例化，这是行不通的。该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了继承而设计的（见第17条）。由于只有当类不包含显式的构造器时，编译器才会生成缺省的构造器，因此只要让这个类包含私有构造器，它就不能被实例化了：
//Noninstantiable utility class
public class UtilityClass {
    //Suppress default constructor for noninstantiability
    private UtilityClass() {
        throw new AssertionError();
    }
}

显式构造器是私有的，所以不可以在该类的外部访问它。AssertionError不是必需的，但是它可以避免不小心在类的内部调用构造器。它保证该类在任何情况下都不会被实例化。这种习惯用法有点违背直觉，好像构造器专门设计成不能被调用一样。因此，明智的做法就是在代码中增加一条注释，如上。
这种习惯用法也有副作用，它使得一个类不能被子类化。所有的构造器都必须显式或隐式地调用超类（superclass）构造器，在这种情况下，子类就没有可访问的超类构造器可调用了。
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第5条：避免创建不必要的对象 P17
String s = new String("stringette");//不要这样写！
该语句每次执行的时候都创建一个新的String实例，但是这些创建对象的动作都是不必要的。传递给String构造器的参数（“stringette”）本身就是一个String实例，功能方面等同于构造器创建的所有对象。如果这种用法是在一个循环中，或者是在一个被频繁调用的方法中，就会创建出成千上万不必要的String实例。

改进后的版本如下：
String s = "stringette";
该版本只用了一个String实例，而不是每次执行的时候都创建一个新的实例。而且，它可以保证，对于所有同一台虚拟机中运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。

对于同时提供了静态工厂方法（见第1条）和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。如，静态工厂方法Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。构造器在每次调用的时候都会创建一个新的对象，而静态工厂方法则从来不要求这样做，实际上也不会这样做。

//
package test;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

public class Person {
    private final Date birthDate;

    public Person(Date birthDate) {
        this.birthDate = birthDate;
    }

    //判断是否是出生峰年，不好的写法
    public boolean isBabyBoomer() {
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));

        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomStart = gmtCal.getTime();

        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomEnd = gmtCal.getTime();

        return birthDate.compareTo(boomStart) >= 0 && birthDate.compareTo(boomEnd) < 0;
    }

    public static void main(String args[]) {
        try {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");

            Date date = simpleDateFormat.parse("1943-01-01");
            Person xiaoMing = new Person(date);
            System.out.println("XiaoMing is in boom birth year: " + xiaoMing.isBabyBoomer());

            Date date1 = simpleDateFormat.parse("1947-01-01");
            Person xiaoLi = new Person(date1);
            System.out.println("XiaoLi is in boom birth year: " + xiaoLi.isBabyBoomer());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
输出：
XiaoMing is in boom birth year: false
XiaoLi is in boom birth year: true

isBabyBoomer每次被调用的时候，都会创建一个Calendar，一个TimeZone和两个Date实例，这是不必要的。下面的版本用一个静态的初始化器（initializer），避免了这种效率低下的情况：
//
package test;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

public class Person {
    private final Date birthDate;
    private static final Date BOOM_START;
    private static final Date BOOM_END;

    public Person(Date birthDate) {
        this.birthDate = birthDate;
    }

    static {
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));

        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_START = gmtCal.getTime();

        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_END = gmtCal.getTime();
    }

    //判断是否是出生峰年，好的写法
    public boolean isBabyBoomer() {
        return birthDate.compareTo(BOOM_START) >= 0 && birthDate.compareTo(BOOM_END) < 0;
    }

    public static void main(String args[]) {
        try {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");

            Date date = simpleDateFormat.parse("1943-01-01");
            Person xiaoMing = new Person(date);
            System.out.println("XiaoMing is in boom birth year: " + xiaoMing.isBabyBoomer());

            Date date1 = simpleDateFormat.parse("1947-01-01");
            Person xiaoLi = new Person(date1);
            System.out.println("XiaoLi is in boom birth year: " + xiaoLi.isBabyBoomer());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

改进后的Person类只在初始化的时候创建Calendar、TimeZone和Date实例一次，而不是在每次调用isBabyBoomer的时候都创建这些实例。如果isBabyBoomer方法被频繁地调用，这种方法将会显著地提高性能。代码的含义也更加清晰了。

如果改进后的Person类被初始化了，它的isBabyBoomer方法却永远不会被调用，那就没有必要初始化BOOM_START和BOOM_END域。通过延迟初始化（lazily initializing）（见第71条），即把对这些域的初始化延迟到isBabyBoomer方法第一次被调用的时候进行，则有可能消除这些不必要的初始化工作，但是不建议这样做。正如延迟初始化中常见的情况一样，这样做会使方法的实例更加复杂，从而无法将性能显著提高到超过已经达到的水平（见第55条）。

Java 1.5 发行版本中，有一种创建多余对象的新方法，称作自动装箱（autoboxing），允许程序员将基本类型和装箱基本类型（Boxed Primitive Type）混用。按需要自动装箱和拆箱。自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消除。在语义上还有着微妙和差别，在性能上也有着比较明显的差别（见第49条）。下面程序，计算所有int正值的总和，程序必须使用long。
//
package test;

public class TestLong {
    public static void main(String args[]) {
        Long sum = 0L;

        long startMillisTime = System.currentTimeMillis();
        System.out.println("startMillisTime=" + startMillisTime);

        for (int i = 0; i < Integer.MAX_VALUE; ++i) {
            sum += i;
        }
        System.out.println("Sum of all integers is:" + sum);

        long endMillisTime = System.currentTimeMillis();
        System.out.println("endMillisTime=" + endMillisTime);
        System.out.println("MillisTime(ms): " + (endMillisTime - startMillisTime));
    }
}
输出：
startMillisTime=1476720305497
Sum of all integers is:2305843005992468481
endMillisTime=1476720315801
MillisTime(ms): 10304

程序算出的答案是正确的，但是慢一些，只因为打错了一个字符。变量sum被声明成Long而不是long，意味着程序构造了大约2^31 个多余的Long实例。将sum的声明从Long改成long，运行时间从10秒减少到1秒。

将Long sum = 0L;修改为long sum = 0L;
输出：
startMillisTime=1476720390027
Sum of all integers is:2305843005992468481
endMillisTime=1476720391503
MillisTime(ms): 1476

结论很明显：要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

不要错误地认为本条目所介绍的内容暗示着“创建对象的代价非常昂贵，我们应该要尽可能地避免创建对象”。相反，由于小对象的构造器只做很少量的显式工作，所以，小对象的创建和回收动作是非常廉价的，特别是在现代的JVM实现上更是如此。通过创建附加的对象，提升程序的清晰性、简洁性和功能性，这通常是件好事。

反之，通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的。真正正确使用对象池的典型对象示例就是数据库连接池。但是，一般而言，维护自己的对象池改写会把代码弄得很乱，同时增加内存占用（footprint），并且还会损害性能。现代的JVM实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能。

与本条目对应的是第39条中有关“保护性拷贝（defensive copying）”的内容。本条目提及“当你应该重用现有对象的时候，请不要创建新的对象”，而第39条则说“当你应该创建新对象的时候，请不要重用现有的对象”。注意，在提倡使用保护性拷贝的时候，因重用对象而付出的代价要远远大于因创建重复对象而付出的代价。必要时如果没能实施保护性拷贝，将会导致潜在的错误和安全漏洞，而不必要地创建对象则只会影响程序的风格和性能。
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第6条：消除过期的对象引用 P21
转到具有垃圾回收功能的语言，认为自己不再需要考虑内存管理的事情了，其实不然。
考虑下面简单的栈实现例子：
//
package test;

import java.util.Arrays;
import java.util.EmptyStackException;

public class Stack {
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private Object[] elements;//private Object[] elements = new Object[DEFAULT_INITIAL_CAPACITY];//由于DEFAULT_INITIAL_CAPACITY是static，所以优先于elements初始化好，如果将static去掉，则DEFAULT_INITIAL_CAPACITY必须先于elements定义

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];//这里的new初始化可以在上面elements定义的地方直接初始化好
    }

    public void push(Object o) {
        ensureCapacity();
        elements[size++] = o;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }

    public int size() {
        return size;
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}

测试用例：
package test;

import org.junit.Test;

import static org.junit.Assert.*;

public class StackTest {
    @Test
    public void testPush_should_returnSize_when_pushElement() {
        Stack stack = new Stack();
        stack.push("hello");
        assertEquals(1, stack.size());
    }

    @Test
    public void testPop_should_returnElement_when_pop() {
        Stack stack = new Stack();

        String hello = "hello";
        String world = "world";

        stack.push(hello);
        stack.push(world);

        assertEquals(2, stack.size());
        assertEquals(world, stack.pop());
        assertEquals(1, stack.size());
    }
}

这段程序（它的泛型版本见第26条）中并没有很明显的错误。但这个程序中隐藏着一个问题，不严格地讲，这段程序有一个“内存泄漏”，随着垃圾回收器活动的增加，或者由于内存占用的不断增加，程序性能的降低会逐渐表现出来。极端的情况下，这种内存泄漏会导致磁盘交换（Disk Paging），甚至导致程序失败（OutOfMemoryError错误），但这种失败情形相对比较少见。

发生内存泄漏的地方是：如果一个栈先增长，然后再收缩，那么从栈中弹出来的对象将不会被当作垃圾回收，即便使用栈的程序不再引用这些对象，它们也不会被回收。这是因为，栈内部维护着对这些对象的过期引用（obsolete reference）。所谓的过期引用，是指永远也不会再被解除的引用。在本例中，凡是在elements数组的“活动部分（active portion）”之外的任何引用都是过期的。活动部分是指elements中下标小于ize的那些元素。

在支持垃圾回收的语言中，内存泄漏是很隐蔽的（称这类内存泄漏为“无意识的对象保持（unintentional object retention）”更为恰当）。如果一个对象引用被无意识地保留起来了，那么，垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象。

修复的方法很简单：一旦对象引用已经过期，只需清空这些引用即可。对于上述例子中的Stack类，只要一个单元被弹出栈，指向它的引用就过期了，pop方法修改如下：
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result;
}

清空过期引用的另一个好处是，如果它们以后又被错误地解除引用（这里是不是应该是引用），程序就会立即抛出NullPointerException异常，而不是悄悄地错误运行下去。尽快地检测出程序中的错误总是有益的。

清空对象引用应该是一种例外，而不是一种规范行为。消除过期引用最好的方法是让包含该引用的变量结束其生命周期。如果你是在最紧凑的作用域范围内定义每一个变量（见第45条），这种情形就会自然而然地发生。

一般而言，只是类是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。

内存泄漏的另一个常见来源是缓存。如果正好要实现这样的缓存：只要在缓存之外存在对某个项的键的引用，该项就有意义，那么就可以用WeakHashMap代表缓存；当缓存中的项过期之后，它们就会自动被删除。记住只有当所要的缓存项的生命周期是由该键的外部引用而不是由值决定时，WeakHashMap才有用处。（是说键被其余地方引用时，WeakHashMap才会保留该项，如果键只是被WeakHashMap引用时，过段时间仍会删除该项？）

缓存应该时不时地清除掉没用的项。这项清除工作可以由一个后台线程（可能是Timer或者ScheduledThreadPoolExcutor）来完成，或者也可以在给缓存添加新条目的时候顺便进行清理。LinkedHashMap类利用它的removeEldestEntry方法可以很容易地实现后一种方案。对于更加复杂的缓存，必须直接使用java.lang.ref。

在内泄漏的第三个常见的来源是监听器和其他回调。如果实现了一个API，客户端在这个API中注册回调，却没有显式地取消注册，那么除非你采取某些动作，否则它们就会积聚。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用（weak reference），如，只将它们保存成WeakHashMap中的键。（学习一下WeakHashMap的功能？）
//------------------------------------------------------------------------------------------------
//Effective Java 第2章 创建和销毁对象 P4
//第7条：避免使用终结方法 P24
终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。终结方法也有其可用之处，但是根据经验，应该避免使用终结方法。

C++程序员被告知“不要把终结方法当作是C++中析构器（destructors）的对应物”。在C++中，析构器是回收一个对象所占用资源的常规方法，是构造器所必需的对应物。在Java中，当一个对象变得不可到达的时候，垃圾回收器会回收与该对象相关联的存储空间，并不需要程序员做专门的工作。C++的析构器也可以被用来回收其他的非内存资源。而在Java中，一般用try-finally块来成类似的工作。

终结方法的缺点在于不能保证会被及时地执行。从一个对象变得不可到达开始，到它的终结方法被执行，所花费的这段时间是任意长的。这意味着，注重时间(time-critical)的任务不应该由终结方法来完成。如，用终结方法来关闭已经打开的文件，这是严重错误，因为打开文件的描述符是一种很有限的资源，由于JVM会延迟执行终结方法，所以大量的文件会保留在打开状态，当一个程序再不能打开文件的时候，它可能会运行失败。

及时地执行终结方法正是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中会大相径庭。如果程序依赖于终结方法被执行的时间点，那么这个程序的行为在不同的JVM中运行的表现可能就会截然不同。

Java语言规范不仅不保证终结方法会被及时地执行，而且根本就不保证它们会被执行。当一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有被执行，这是完全有可能的。结论是：不应该依赖终结方法来更新重要的持久状态。如，依赖终结方法来解放共享资源（比如数据库）上的永久锁，很容易让整个分布式系统垮掉。

不要被System.gc和System.runFinalization两个方法所诱惑，它们确实增加了终结方法被执行的机会，但是它们并不保证终结方法一定会被执行。唯一声称保证终结方法被执行的方法是System.runFinalizersOnExit，以及Runtime.runFinalizersOnExit。这两个方法都有致命的缺陷，已经被废弃了。

如果未被捕获的异常在终结过程中被抛出来，那么这种异常可以被忽略，并且该对象的终结过程也会终止。未被捕获的异常会使对象处于破坏的状态（a corrupt state），如果另一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为。正常情况下，未被捕获的异常将会使线程终止，并打印出栈轨迹（Stack Trace），但是如果异常发生在终结方法之中，则不会如此，甚至连警告都不会打印出来。

还有一点：使用终结方法有一个非常严重的（Severe）性能损失。在作者的机器上，创建和销毁一个简单对象的时间大约为5.6 ns。增加一个终结方法使时间增加到了2400 ns。换句话说，用终结方法创建和销毁对象慢了大约430倍。

如果类的对象中封装的资源（例如文件或者线程）确实需要终止，只需提供一个显式的终止方法，并要求该类的客户端在每个实例不再有用的时候调用这个方法。值得提及的一个细节是，该实例必须记录下自己是否已经被终止了：显式的终止方法必须在一个私有域中记录下“该对象已经不再有效”。如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并抛出IllegalStateException异常。（在调用终止方法之后，直接设置对象为null不就可以了吗？）

显式终止方法的典型例子是InputStream、OutputStream和java.sql.Connection上的close()方法。另一个例子是java.util.Timer上的cancel方法，它执行必要的状态改变，使得与Timer实例相关联的该线程温和地终止自己。java.awt中的例子还包括Graphics.dispose和Window.dispose。这些方法通常由于性能不好而不被关注。一个相关的方法是Image.flush，它会释放所有与Image实例相关联的资源，但是该实例仍然处于可用的状态，如果有必要的话，会重新分配资源。

显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止。在finally子句内部调用显式的终止方法，可以保证即使使用对象的时候有异常抛出，该终止方法也会执行：
//try-finally block guarantees execution of termination method
Foo foo = new Foo();
try {
    //Do what must be done with foo
    ...
} finally {
    foo.terminate();//Explicit termination method
}

终结方法（即默认的finalizer方法）的好处，有两种合法用途。第一种用途是，当对象的所有者忘记调用前面段落中建议的显式终止方法时，终结方法可以充当“安全网”（safety net）。虽然这样做并不能保证终结方法会被及时地调用，但是在客户端无法通过调用显式的终止方法来正常结束操作情况下（希望这种情形尽可能地少发生），迟一点释放关键资源总比永远不释放要好。（即手工写终结方法，并在该方法是释放关键资源）。但是如果终结方法发现资源还未被终止，则应该在日志中记录一条警告，因为这表示客户端代码中的一个Bug，应该得到修复。如果你正考虑编写这样的安全网终结方法，就要认真考虑清楚，这种额外的保护是否值得你付出这份额外的代价。

显式终止方法模式的示例中所示的四个类（FileInputStream，FileOutputStream、Timer和Connection），都具有终结方法，当它们的终止方法未能被调用的情况下，这些终结方法充当了安全网。
//查看了FileInputStream类的finalize()方法，确实有调用close()方法
/**
 * Ensures that the <code>close</code> method of this file input stream is
 * called when there are no more references to it.
 *
 * @exception  IOException  if an I/O error occurs.
 * @see        java.io.FileInputStream#close()
 */
protected void finalize() throws IOException {
    if ((fd != null) &&  (fd != FileDescriptor.in)) {
        /* if fd is shared, the references in FileDescriptor
         * will ensure that finalizer is only called when
         * safe to do so. All references using the fd have
         * become unreachable. We can call close()
         */
        close();
    }
}

终结方法的第二种合理用途与对象的本地对等体（native peer）有关。本地对等体是一个本地对象（native object），普通对象通过本地方法（native method）委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的Java对等体被回收的时候，它不会被回收。在本地对等体并不拥有关键资源的前提下，终结方法正是执行这项任务最合适的工具。如果本地对等体拥有必须被及时终止的资源，那么该类就应该具有一个显式的终止方法，如前所述。终止方法应该完成所有必要的工作以便释放关键的资源。终止方法可以是本地方法，或者它也可以调用本地方法。

注意，“终结方法链（finalizer chaining）”并不会被自动执行。如果类（不是Object）有终结方法，并且子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法。应该在一个try块中终结子类，并在相应的finally块中调用超类的终结方法。这样做可以保证：即便子类的终结过程抛出异常，超类的终结方法也会得到执行。

//Manual finalizer chaining
@Override
protected void finalize() throws Throwable {
    try {
        ...//Finalize subclass state
    } finally {
        super.finalize();
    }
}

如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法（或者有意选择不调用超类的终结方法），那么超类的终结方法将永远也不会被调用。要防范这样粗心大意或者恶意的子类是有可能的，代价就是为每个将被终结的对象创建一个附加的对象。不是把终结方法放在要求终结处理的类中，而是把终结方法放在一个匿名的类（见第22条）中，该匿名类的唯一用途就是终结它的外围实例（enclosing instance）。该匿名类的单个实例被称为终结方法守卫者（finalizer guardian），外围类的每个实例都会创建这样一个守卫者。外围实例在它的私有实例域中保存着一个对其终结方法守卫者的唯一引用，因此终结方法守卫者与外围实例可以同时启动终结过程。当守卫者被终结的时候，它执行外围实例所期望的终结行为，就好像它的终结方法是外围对象上的一个方法一样：
//测试如下
package test;

public class TestFinalizerGuardian {
    private final Object finalizerGuardian = new Object() {
        @Override
        protected void finalize() throws Throwable {
            System.out.println("finalizerGuardian releases resource for outer class.");
        }
    };

    // @Override
    // protected void finalize() throws Throwable {
        // super.finalize();
        // System.out.println("Outer class releases resource.");
    // }

    public void sayHello() {
        System.out.println("hello");
    }

    public static void main(String args[]) {
        TestFinalizerGuardian testFinalizerGuardian = new TestFinalizerGuardian();
        testFinalizerGuardian.sayHello();
    }
}
输出：
hello
（并没有调用finalize()终结函数）

注意，外部公有类并没有终结方法（除了它从Object中继承了一个无关紧急的之外），所以子类的终结方法是否调用super.finalize()并不重要，对于每一个带有终结方法的非final公有类，都应该考虑使用这种方法。

总之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用终结方法。在这些很少见的情况下，既然使用了终结方法，就要记住调用super.finalize。如果用终结方法作为安全网，要记得记录终结方法的非法用法。最后，如果需要把终结方法与公有的非final类关联起来，请考虑使用终结方法守卫者，以确保即使子类的终结方法未能调用super.finalize，该终结方法也会被执行。
//------------------------------------------------------------------------------------------------
//Effective Java 第3章 对于所有对象都通用的方法P28
//第8条：覆盖equals时请遵守通用约定 P28
最容易避免覆盖equals方法的问题就是不覆盖equals方法，这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，就是所期望的结果：
--类的每个实例本质上都是唯一的。对于代表活动实例而不是值（value）的类来说确实如此，例如Thread。Object提供的equals实现对于这些类来说正是正确的行为。
//
package test;

public class MyObject {
}
//
package test;

import org.junit.Test;

import static org.junit.Assert.*;

public class MyObjectTest {
    @Test
    public void testCatOrderByAge() {
        Integer i = new Integer(1);
        Integer i2 = new Integer(1);
        assertTrue(i.equals(i2));
    }

    @Test
    public void testEquals_should_equal_when_objectSame() {
        MyObject myObject = new MyObject();
        assertTrue(myObject.equals(myObject));

        MyObject myObject1 = new MyObject();
        assertFalse(myObject.equals(myObject1));
    }
}

--不关心类是否提供了“逻辑相等（logical equality）”的测试功能。
--超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。
--类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。在这种情况下，应该覆盖equals方法，以防它被意外调用：
@Override
public boolean equals(Object c) {
    throw new AssertionError();//Method is never called
}

如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖equals以实现期望的行为，这时就需要覆盖equals方法。这通常属于“值类（value class）”的情形。值类仅仅是一个表示值的类，例如Integer或者Date。程序员在利用equals方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足这种要求，不仅必需覆盖equals方法，而且这样做也使得这个类的实例可以被用做映射表（map）的键（key），或者集合（set）的元素，使映射或者集合表现出预期的行为。

有一种“值类”不需要覆盖equals方法，即用实例受控（见第1条）确保“每个值至多只存在一个对象”的类。枚举值（见第30条）就属于这种类。对于这样的类而言，逻辑相同与对象等同是一回事，因此Object的equals方法赞同于逻辑意义上的equals方法。

在覆盖equals方法的时候，必须要遵守它的通用约定。下面是约定的内容，来自Object的规范：
equals方法实现了等价关系（equivalence relation）：
--自反性（reflexive）。对于任何非null的引用值，x.equals(x)必须返回true。
--对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。
--传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。
--一致性（consistent）。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false。
--对于任何非null的引用值x，x.equals(null)必须返回false。

如果违反了它们，就会发现程序将会表现不正常，甚至崩溃，而且很难找到失败的根源。没有哪个类是孤立的。一个类的实例通常会被频繁地传递给另一个类的实例。有许多类，包括所有的集合类（collection class）在内，都依赖于传递给它们的对象是否遵守了equals约定。

下面按照顺序逐一查看以下5个要求：
1. 自反性（reflexivity）――――第一个要求仅仅说明对象必须等于其自身。如果违背了这一条，然后把该类的实例添加到集合（collection）中，该集合的contains方法将果断地告诉你，该集合不包含你刚刚添加的实例。
2. 对称性（symmetry）――――第二个要求是说，任何两个对象对于“它们是否相等”的问题都必须保持一致。如下面的类，它实现了一个区分大小写的字符串。字符串由toString保存，但在比较操作中被忽略。
//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class CaseInsensitiveStringTest {
    @Test
    public void testEquals_should_equal_when_equalsString() {
        CaseInsensitiveString caseInsensitiveString = new CaseInsensitiveString("Hello");
        assertEquals(caseInsensitiveString, "Hello");
        assertEquals(caseInsensitiveString, "hello");

        assertNotEquals("Hello", caseInsensitiveString);//违反了对称性
        assertNotEquals("hello", caseInsensitiveString);//违反了对称性
    }
}

//
package test;

public class CaseInsensitiveString {

    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = s;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(((CaseInsensitiveString) obj).s);
        }

        if (obj instanceof String) { //One-way interoperability
            return s.equalsIgnoreCase((String) obj);
        }

        return false;
    }
}

问题在于，虽然CaseInsensitiveString类中的equals方法知道普通字符串（String）对象，但是，String类中的equals方法却不知道不区分大小写的字符串。因此,s.equals(cis)返回false，显然违反了对称性。假设把不区分大小写的字符串对象放到一个集合中：
List<CaseInsensitiveString> list = new ArrayList<>();
list.add(cis);
此时list.contains(s)会返回的结果是什么没人知道。可能返回false，可能返回true，或者抛出一个运行时（runtime）异常。一旦违反了equals约定，当其他对象面对你的对象时，你完全不知道这些对象的行为会怎么样。

为了解决这个问题，只需把企图与String互操作的这段代码从equals方法中去掉就可以了，这样做之后，就可以重构该方法，使它变成一条单独的返回语句：
//测试用例
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class CaseInsensitiveStringTest {
    @Test
    public void testEquals_should_equal_when_equalsString() {
        CaseInsensitiveString caseInsensitiveString = new CaseInsensitiveString("Hello");
        assertNotEquals(caseInsensitiveString, "Hello");
        assertNotEquals(caseInsensitiveString, "hello");

        assertNotEquals("Hello", caseInsensitiveString);
        assertNotEquals("hello", caseInsensitiveString);

        CaseInsensitiveString caseInsensitiveString1 = new CaseInsensitiveString("hello");
        assertEquals(caseInsensitiveString, caseInsensitiveString1);
        assertEquals(caseInsensitiveString1, caseInsensitiveString);
    }
}

//
package test;

public class CaseInsensitiveString {

    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = s;
    }

    @Override
    public boolean equals(Object obj) {
        return obj instanceof CaseInsensitiveString &&
                s.equalsIgnoreCase(((CaseInsensitiveString) obj).s);
    }
}

3. 传递性（transitivity）――――equals约定的第三个要求是，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。无意识地违反这条规则的情形也不难想像。考虑子类的情形，它将一个新的值组件（value component）添加到了超类中。子类增加的信息会影响到equals的比较结果。首先以一个简单的不可变的二维整数型Point类开始：

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class PointTest {
    @Test
    public void testEquals_should_equal_when_equalsPoint() {
        Point p = new Point(1, 2);
        Point p1 = new Point(1, 2);
        assertEquals(p, p1);

        Point p2 = new Point(2, 2);
        assertNotEquals(p, p2);
    }
}

//
package test;

public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Point)) {
            return false;
        }
        Point point = (Point) obj;
        return point.x == x && point.y == y;
    }
}

扩展这个类，为一个点添加颜色信息：

//package test;

import org.junit.Test;

import java.awt.Color;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class ColorPointTest {
    @Test
    public void testEquals_should_notEqual_when_pointEqualColorPoint() {
        Point p = new Point(1, 2);
        ColorPoint cp = new ColorPoint(1, 2, Color.RED);
        assertEquals(p, cp);
        assertNotEquals(cp, p);
    }
}

//
package test;

import java.awt.Color;

public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    //Broken - violates symmetry!
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof ColorPoint)) {
            return false;
        }
        return super.equals(obj) && ((ColorPoint) obj).color == color;
    }
}

如果完全不提供equals方法，直接从Point继承，在equals做比较时颜色信息就被忽略掉了。虽然不违反equals约定，但是无法接受。假设编写了一个equals方法，只有当它的参数是另一个有色点时，并且具有同样的位置和颜色时，才返回true。见上。
这个方法问题在于，违反了对称性。p.equals(cp)返回true，cp.equals(p)则返回false。尝试修正这个问题，让ColorPoint.equals在进行“混合比较”时忽略颜色信息：
//package test;

import java.awt.Color;

public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    //Broken - violates transitivity!
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Point)) {
            return false;
        }

        // If obj is a normal Point, do a color-blind comparison
        if (!(obj instanceof ColorPoint)) {
            return obj.equals(this);
        }
        return super.equals(obj) && ((ColorPoint) obj).color == color;
    }
}

这种方法确实提供了对称性，但是却牺牲了传递性：
//
package test;

import org.junit.Test;

import java.awt.Color;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class ColorPointTest {
    @Test
    public void testEquals_should_notEqual_when_pointEqualColorPoint() {
        ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
        Point p2 = new Point(1, 2);
        ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
        assertEquals(p1, p2);
        assertEquals(p2, p3);
        assertNotEquals(p1, p3);
    }
}

此时，前两种比较不考虑颜色信息（“色盲”），而第三种比较则考虑了颜色信息。
怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定，除非愿意放弃面向对象的抽象所带来的优势。

可能听说，在equals方法中用getClass测试代替instanceof测试，可以扩展可实例化的类和增加新的值组件，同时保留equals约定：
//Broken - violates Liskov substitution principle(page 40)
@Override
public boolean equals(Object obj) {
    if (obj == null || obj.getClass() != getClass()) {
        return false;
    }
    Point point = (Point) obj;
    return point.x == x && point.y == y;
}
这段程序只有当对象具有相同的实现时，才能使对象等同。虽然这样也不算太糟糕，但是结果却是无法接受的。
假设要编写一个方法，以检验某个整值点是否处在单位圆中，下面是可以采用的其中一个方法：
//
package test;

import java.util.HashSet;
import java.util.Set;

public class UnitCircle {
    private static final Set<Point> unitCircle;

    static {
        unitCircle = new HashSet<Point>();
        unitCircle.add(new Point(1, 0));
        unitCircle.add(new Point(0, 1));
        unitCircle.add(new Point(-1, 0));
        unitCircle.add(new Point(0, -1));
    }

    public static boolean onUnitCircle(Point p) {
        return unitCircle.contains(p);
    }
}

//Point
package test;

public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || obj.getClass() != getClass()) {
            return false;
        }
        Point point = (Point) obj;
        return point.x == x && point.y == y;
    }

    @Override
    public int hashCode() {
        return x + y;
    }
}

//
package test;

import org.junit.Test;

import java.nio.channels.Pipe;
import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

public class PointTest {
    @Test
    public void testEquals_should_equal_when_equalsPoint() {
        Point p = new Point(1, 2);
        Point p1 = new Point(1, 2);
        assertEquals(p, p1);

        Point p2 = new Point(2, 2);
        assertNotEquals(p, p2);
    }

    @Test
    public void testHashSet_should_contain_when_contain() {
        Set<Point> points = new HashSet<Point>();
        points.add(new Point(1, 1));
        points.add(new Point(1, 3));

        assertTrue(points.contains(new Point(1, 1)));
        assertTrue(points.contains(new Point(1, 3)));
        assertFalse(points.contains(new Point(2, 2)));
    }
}

//Test
package test;

import org.junit.Test;

import static org.junit.Assert.assertTrue;

public class UnitCircleTest {
    @Test
    public void testOnUnitCircle_should_contain_when_PointOnUnitCircle() {
        Point p = new Point(0, 1);
        assertTrue(UnitCircle.onUnitCircle(p));
    }
}

HashSet中contains的判断条件：contains()是根据equals()和hashCode()判断2个对象是否是同一个，没重写hashCode()，系统默认按照地址计算hashCode，2个地址不同，hashCode也不同，返回当然是false。
equals和hashcode方法要同时重写，并且要在equals为true的时候，hashCode必须要相同。这个已经是一种不成文的规定了，这两个方法要重写就要一起重写，而且IDE里也会只重写一个会视为警告。所以这两个方法要同时重写。
详细的可以去看HashMap的contains实现，哪里是equals和hashCode两个同时使用了，所以在有Map的时候，必须两个都要验证，但是在ArrayList里不验证hashCode，所以ArrayList里不重新这个hashCode也无所谓。

上述UnitCircle可能不是实现这种功能的最快方式，不过效果很好。但是假设通过某种不添加值组件的方式扩展了Point，例如让它的构造器记录创建了多少个实例：
//
package test;

import java.util.concurrent.atomic.AtomicInteger;

public class CounterPoint extends Point {

    private static final AtomicInteger counter = new AtomicInteger();

    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }

    public int numberCreated() {
        return counter.get();
    }
}

//测试
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CounterPointTest {
    @Test
    public void testCounter_should_equals_when_createCounterPoint() {
        CounterPoint counterPoint = new CounterPoint(1, 1);
        assertEquals(1, counterPoint.numberCreated());

        CounterPoint counterPoint1 = new CounterPoint(0, 1);
        assertEquals(2, counterPoint.numberCreated());
    }
    
    @Test
    public void testOnUnitCircle_should_contains_when_counterPointIn() {
        Point cp = new CounterPoint(0, 1);
        assertFalse(UnitCircle.onUnitCircle(cp)); //把CounterPoint传入contains函数，则无法返回true

        Point p = new Point(0, 1);
        assertTrue(UnitCircle.onUnitCircle(p));
    }
}

里氏替换原则（Liskov substitution principle）认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类类型编写的任何方法，在它的子类型上也应该同样运行得很好。但是将CounterPoint实例传给了onUnitCircle方法，如果Point类使用了基于getClass的equals方法，无论CounterPoint的x和y值是什么，onUnitCircle方法都会返回false。之所以如此，是因为像onUnitCircle方法所用的HashSet这样的集合，利用equals方法检验包含条件，没有任何CounterPoint实例与任何Point对应。但是，如果在Point上使用适当的基于instanceof的equals方法，当遇到CounterPoint时，相同的onUnitCircle方法就会工作得很好。

虽然没有一种满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（workaround）。根据第16条的建议：复合优先于继承。我们不再让ColorPoint扩展Point，而是在ColorPoint中加入一个私有的Point域，以及一个公有的视图（view）方法（见么5条），此就去返回一个与该有色点处在相同位置的普通Point对象：
//
package test;

import java.awt.Color;

// Adds a value component without violating the equals contract
public class ColorPoint {
    private final Point point;
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        if (color == null) {
            throw new NullPointerException();
        }
        point = new Point(x, y);
        this.color = color;
    }

    /**
     * Returns the point-view of this color point
     */
    public Point asPoint() {
        return point;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof ColorPoint)) {
            return false;
        }
        ColorPoint cp = (ColorPoint) obj;
        return cp.point.equals(point) && cp.color.equals(color);
    }
}

//
package test;

public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof Point)) {
            return false;
        }
        Point point = (Point) obj;
        return point.x == x && point.y == y;
    }

    @Override
    public int hashCode() {
        return x + y;
    }
}


//Test
package test;

import org.junit.Test;

import java.awt.Color;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

public class ColorPointTest {
    @Test
    public void testColorPointEquals_should_equals_when_colorPointEqual() {
        ColorPoint cp = new ColorPoint(1, 1, Color.BLACK);
        ColorPoint cp1 = new ColorPoint(1, 1, Color.BLACK);
        ColorPoint cp2 = new ColorPoint(1, 1, Color.RED);

        Point p = new Point(1, 1);
        assertNotEquals(cp, p);
        assertEquals(cp, cp1);
        assertNotEquals(cp, cp2);
    }
}

注意，可以一个抽象（abstract）类的子类中增加新的值组件，而不会违反equals约定。对于根据第20条的建议“用类层次（class hierarchies）代替标签类（tagged class）”而得到的那种类层次结构来说，这一点非常重要。如，可能有一个抽象的Shape类，没有任何值组件，Circle子类添加了一个radius域，Rectangle子类添加了length和width域。只要不可能直接创建超类的实例，前面所述的种种问题就不会发生。

4. 一致性（consistency）――――equals约定的第四个要求是：如果两个对象相等，它们就必须始终保持相等。当在写一个类的时候，应该仔细考虑它是否应该是不可变的（见第15条）。如果认为它应该是不可变的，就必须保证equals方法满足这样的限制条件：相等的对象永远相等，不相等的对象永远不相等。
无论类是否是不可变的，都不要使equals方法依赖于不可靠的资源。例如，java.net.URL的equals方法依赖于对URL中主机IP地址的比较。将一个主机名转变成IP地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果。这样会导致URL的equals方法违反equals约定。除了极少娄的例外情况，equals方法都应该对驻留在内存中的对象执行确定性的计算。

//final测试 http://www.importnew.com/7553.html
final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。

//
package test;

public class FinalKeywords {
    private int i; //如果这里声明为private final int i，则无法修改该值，setI编译错误

    public void setI(int i) {
        this.i = i;
    }

    public FinalKeywords(int i) {
        this.i = i;
    }
}

//Test
package test;

import org.junit.Test;

public class FinalKeywordsTest {
    @Test
    public void testFinalClass_should_notAllowedChangeRef_when_declaredFinal() {
        final FinalKeywords finalKeywords = new FinalKeywords(3);
        //finalKeywords = new FinalKeywords(4); //声明为final将不能改变引用，所以不能重新new
        finalKeywords.setI(4); //可以修改值，引用地址没有改变，内存空间上的数据有变化，所以没问题
    }
}

5. 非空性（Non-nullity）――――最后一个要求没有名称，姑且称它为“非空性（Non-nullity）”，意思是指所有的对象都必须不等于null。
不需要显示地判断 if (o == null) return false;
在equals方法中，进行类型转换前，equals方法必须使用instanceof操作符，检查其参数是否为正确的类型：
@Override public boolean equals(Object o) {
    if (!(o instanceof MyType)) {
        return false;
    }
    MyType mt = (MyType) o;
    //...
}
如果漏掉了这一步的类型检查，并且传递给equals方法的参数又是错误的类型，那么equals方法将会抛出ClassCastException异常，这就违反了equals约定。但是如果instanceof的第一个操作数为null，那么，不管第二个操作数是哪种类型，instanceof操作符都指定应该返回false。因此，如果把null传给equals方法，类型检查就会返回false，所以不需要单独的null检查。

结果这些要求，得出了实现高质量equals方法的诀窍：
1. 使用==操作符检查“参数是否为这个对象的引用”。如果是，则返回true。这是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
2. 使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现 的接口改进了equals约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口（collection interface）如Set、List、Map和Map.Entry具有这样的特性。
3. 把参数转换成正确的类型。转换之前进行过instanceof测试，所以确保会成功。
4. 对于该类中的每个“关键（significant）”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true，否则返回false。如果第2步中的类型是个接口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问参数中的域，这要取决于它们的可访问性。

对于既不是float也不是double类型的基本类型域，可以使用==操作符进行比较；
对于对象引用域，可以递归地调用equals方法；
对于float域，可以使用Float.compare方法；
对于double域，则使用Double.compare方法。
对于float和double域进行特殊的处理是有必要的，因为存在着Float.NaN、-0.0f 以及类似的double常量。
对于数组域，则要把以上这些指导原则应用到每个元素上。如果数组域中的每个元素都很重要，就可以使用发行版本1.5 中新增的其中一个Array.equals方法。

对于对象引用域包含null可能是合法的，所以，为了避免可能导致NullPointerException异常，则使用下面的习惯用法来比较这样的域：
(field == null ? o.field == null : field.equals(o.field))
如果field和o.field通常是相同的对象引用，那么下面的做法就会更快一些：
(field == o.field || (field != null && field.equals(o.field)))

对于有些类，如前面提到的CaseInsensitiveString类，域的比较要比简单的等同性测试复杂得多。如果是这种情况，可能会希望保存该域的一个“范式（canonical form）”，这样equals方法就可以根据这些范式进行低开销的精确比较，而不是高开销的非精确比较。这种方法对于不可变类（见第15条）是最为合适的；如果对象可能发生变化，就必须使用其范式保持最新。

域的比较顺序可能会影响到equals方法的性能。为了获得最佳的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条件同时满足的域。不应该去比较那些不属于对象逻辑状态的域，如用于同步操作的Lock域。也不需要比较冗余域（redundant field），因为这些冗余域可以由“关键域”计算获得，但是这样做有可能提高equals方法的性能。如果冗余域代表了整个对象的综合描述，比较这相域可以节省当比较失败时去比较实际数据所需要的开销。如，假设有一个Polygon类，并缓存了该区域。如果两个多边形有着不同的区域，就没有必要去比较它们的边和至高点。

5. 当你编写完成了equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的。当然，equals方法也必须满足其他两个特性（自反性和非空性），但是这两种特性通常会自动满足。

根据上面的诀窍构建的equals方法的具体例子，请参看第9条的PhoneNumber.equals。下面是最后一些告诫：
--覆盖equals时总要覆盖hashCode（见第9条）。
--不要企图让equals方法过于智能。如果只是简单地测试域中的值是否相等，则不难做到遵守equals约定。如果想过度地寻求各种等价关系，则很容易陷入麻烦之中。把任何一种别名形式考虑到等价的范围内，往往不会是好主意。
--不要将equals声明中的Object对象替换为其他的类型。如下：
public boolean equals(MyClass o) {
    //...
}
问题在于，这个方法并没有覆盖Object.equals，因为它的参数应该是Object类型，相反，它重载（overload）了Object.equals（见第41条）。在原有equals方法的基础上，再提供一个“强类型（strongly typed）”的equals方法，只要这两个方法返回同样的结果（没有强制的理由必须这样做），那么这就是可以接受的。在某些特定的情况下，这也许能够稍微改善性能，但是与增加的复杂性相比，这种做法是不值得的（见第55条）。
@Override注解的用法一致，可以防止这种错误（见第36条）。这个equals方法不能编译，错误消息会告诉你哪里出了问题：
@Overrid public boolean equals(MyClass o) {
    //...
}
//------------------------------------------------------------------------------------------------
//Effective Java 第3章 对于所有对象都通用的方法P28
//第9条：覆盖equals时总要覆盖hashCode P39
在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常动作，这样的集合包括HashMap、HashSet和Hashtable。

约定内容，如下：
--在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次所返回的整数可以不一致。
--如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
--如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。

因没有覆盖hashCode而违反的关键约定是第二条：相等的对象必须具有相等的散列码（hash code）。根据类的equals方法，两个截然不同的实例在逻辑上有可能是相等的，但是根据Object类的hashCode方法，它们仅仅是两个没有任何共同之外的对象。因此，对象的hashCode方法返回两个看起来是随机的整数，而不是要追第二个约定所要求的那样，返回两个相等的整数。
//
package test;

public final class PhoneNumber {

    private final int areaCode;
    private final int prefix;
    private final int lineNumber;

    public PhoneNumber(int areaCode, int prefix, int lineNumber) {
        rangeCheck(areaCode, 999, "area code");
        this.areaCode = areaCode;
        this.prefix = prefix;
        this.lineNumber = lineNumber;
    }

    private static void rangeCheck(int arg, int max, String name) {
        if (arg < 0 || arg > max) {
            throw new IllegalArgumentException(name + ": " + arg);
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof PhoneNumber)) {
            return false;
        }
        PhoneNumber pn = (PhoneNumber) obj;
        return pn.lineNumber == lineNumber
            && pn.prefix == prefix
            && pn.areaCode == areaCode;
    }

    //Broken - no hashCode method!
}

//Test
package test;

import org.junit.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.Assert.assertNotEquals;

public class PhoneNumberTest {
    @Test
    public void testPhoneNumberMap_should_getPhoneNubmerObj_when_get() {
        Map<PhoneNumber, String> m = new HashMap<>();
        m.put(new PhoneNumber(707, 867, 5309), "Jenny");
        assertNotEquals(m.get(new PhoneNumber(707, 867, 5309)), null); //用例执行失败
    }
}

map.put和map.get里涉及两个PhoneNumber实例：第一个被用于插入到HashMap中，第二个实例与第一个相等，被用于（试图用于）获取。由于PhoneNumber类没有覆盖hashCode方法，从而导致两个相等的实例具有不相等的散列码，违反了hashCode的约定。因此，put方法把电话号码对象存放在一个散列桶（hash bucket）中，get方法却在另一个散列桶中查找这个电话号码。即便这两个实例下她被放到同一个散列桶中，get方法也必定会返回null，因为HashMap有一项优化，可以将与每个项相关联的散列码缓存起来，如果散列码不匹配，也不必检验对象的等同性。
修改这个问题非常简单，保需为PhoneNumber类提供一个适当的hashCode方法即可，那么，hashCode方法应该是什么样？编写一个合法但并不好用的hashCode方法没有任何价值。如，下面这个方法总是合法的，但永远都不应该被正式使用：
//The worst possible legal hash function - never use!
@Override public int hashCode() {
    return 42;
}
上面这个hashCode方法是合法的，因为它确保了相等的对象总是具有同样的散列码。但它也极为恶劣，因为它使得每个对象都具有同样的散列码。因此，每个对象都被映射到同一个散列桶中，使散列表退化为链表（linked list）。它使得本该线性时间运行的程序变成了以平方级时间在运行。对于规格很大的散列表而言，这会关系到散列表能否正常工作。

一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”。这正是hashCode约定中第三条的含义。理想情况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的散列值上。要想完全达到这种理想的情况是非常困难的。相对接近这种理想情形则并不太困难。下面给出一种简单的解决方法：
1. 把某个非零的常数值，比如说17，保存在一个名为result的int类型的变量中。
2. 对于 对象中每个关键域f（指equals方法中涉及的每个域），完成以下步骤：
    a. 为该域计算int类型的散列码c：
        i. 如果该域是boolean类型，则计算（f ? 1 : 0） 。
        ii. 如果该域是byte、char、short或者int类型，则计算(int) f。
        iii. 如果该域是long类型，则计算(int)(f ^ (f >>> 32))。
        iv. 如果该域是float类型，则计算Float.floatToIntBits(f)。
        v. 如果该域是double类型，则计算Double.doubleToLongBits(f)，然后按照步骤2.a.iii，为得到的long类型值计算散列值。
        vi. 如果该域是一个对象引用，并且该类的equals方法通过递归地调用equals的方式来比较这个域，则同样为这个域递归的调用hashCode。如果需要更复杂的比较，则为这个域计算一个“范式（canonical respresentation）”，然后针对这个范式调用hashCode。如果这个域的值为null，则返回0（或者其他某个常数，但通常是0）。
        vii. 如果该域是一个数组，则要把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的做法把这些散列值组合起来。如果数组域中的每个元素都很重要，可以利用发行版本1.5 中增加的其中一个Arrays.hashCode方法。
    b. 按照下面的公式，把步骤2.a中计算得到的散列码c合并到result中：
    result = 31 * result + c;
3. 返回result。
4. 写完了hashCode方法之后，问问自己“相等的实例是否都具有相等的散列码”。要编写单元测试来验证你的推断。如果相等的实例有着不相等的散列码，则要找出原因，并修正错误。

在散列码的计算过程中，可以把冗余域（redundant field）排队在外。如果一个域的值可以根据参与计算的其他域值计算出来，则可以把这样的域排队在外。必须排队equals比较计算中没有用到的任何域，否则很有可能违反hashCode约定的第二条。

上述步骤1中用到了一个非零的初始值，因此步骤2.a中计算的散列值为0的那些初始域，会影响到散列值。如果步骤1中的初始值为0，则整个散列值将不受这些初始域的影响，因为这些初始域会增加冲突的可能性。值17则是任选的。
步骤2.b中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似的域，这样的乘法运算就会产生一个更好的散列函数。例如，如果String散列函数省略了这个乘法部分，那么只是字母顺序不同的所有字符串都会有相同的散列码。之所以选择31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息会丢失，因为与2相乘等价于移位运算。使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：31 * i == (i << 5) - i。现代的VM可以自动完成这种优化。

把上述解决办法用到PhoneNumber类中。它有三个关键域，都是short类型：
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + areaCode;
    result = 31 * result + prefix;
    result = 31 * result + lineNumber;
    return result;
}

用例执行成功。
因为这个方法返回的结果是一个简单的，确定的计算结果，它的输入只是PhoneNumber实例中的三个关键域，因此相等的PhoneNumber显然都会有相等的散列码。实际上，对于PhoneNumber的hashCode实现而言，上面这个方法是非常合理的，相当于Java平台类库中的实现。它的做法非常简单，也相当快捷，恰当地把不相等的电话号码分散到不同的散列桶中。

如果一个类是不可变的，并且计算散列码的开销也比较大，就应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。如果你觉得这种类型的大多数对象都会被用做散列键（hash keys），就应该在创建实例的时候计算散列码。否则，可以选择“延迟初始化（lazily initialize）”散列码，一直到hashCode被第一次调用的时候才初始化（见第71条）。现在尚不清楚我们的PhoneNumber类是否值得这样处理，但可以通过它来说明这种方法该如何实现：
//Lazily initialized, cached hashCode
private volatile int hashCode; // (See Item 71) volatile可以保证多个线程访问hashCode时，每个线程都会获取该域的最新数据，一定程度上降低重复计算。但是该字段并不能保证原子操作，有可能出现hashCode在一个线程为0时，另一个线程已经计算完成hashCode值，并同步到主内存中，此时在当前线程中，result计算完成后，会再次将结果赋给hashCode。只是重复计算，结果是一样的。
@Override public int hashCode() {
    int result = hashCode;
    if (result == 0) {
        result = 17;
        result = 31 * result + areaCode;
        result = 31 * result + prefix;
        result = 31 * result + lineNumber;
        hashCode = result;
    }
    return result;
}

本条目中介绍的方法对于绝大多数应用程序而言已经足够了。

不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。虽然这样得到的散列函数运行起来可能更快，但它的效果不见得会好，可能会导致散列表慢到根本无法使用。
//------------------------------------------------------------------------------------------------
//Effective Java 第3章 对于所有对象都通用的方法P28
//第10条：始终要覆盖toString P44
java.lang.Object提供了toString方法的一个实现，但它返回的字符串通常并不是类的用户所期望看到的。它包含类的名称，以及一个“@”符号，接着是散列码的无符号十六进制表示法。如“PhoneNumber@163b91”。toString的通用约定指出，被返回的字符串应该是一个“简洁的，但信息丰富，并且易于阅读的表达形式”。toString的约定进一步指出，“建议所有的子类都覆盖个方法。”这是一个很好的建议！

//以第9条中的PhoneNumber为例：
public class PhoneNumberTest {
    @Test
    public void testPhoneNumberMap_should_getPhoneNubmerObj_when_get() {
        PhoneNumber phoneNumber = new PhoneNumber(707, 867, 5309);

        System.out.println(phoneNumber.hashCode());
        System.out.println(phoneNumber);

        int i = 0x12960c;
        System.out.println(i);
    }
}
输出：
1218060
test.PhoneNumber@12960c
1218060

虽然遵守toString的约定并不像遵守equals和hashCode的约定（见第8、9条）那么重要，但是提供好的toString实现可以使类用起来更加舒适。当对象被传递给println、printf、字符串联操作符（+）以及assert或者被调试器打印出来时，toString方法会被自动调用。（Java 1.5 发行版本在平台中增加了printf方法，还提供了包括String.format的相关方法，与C语言中的sprintf相似。）

如果为PhoneNumber提供了好的toString方法，那么，要产生有用的诊断消息会非常容易：
System.out.println("Failed to connect: " + phoneNumber);

在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息，譬如上述电话号码例子那样。如果对象太大，或者对象中包含的状态信息难以用字符串表达，这样做就有点不切实际。这种情况下，toString应该返回一个摘要信息，如“Manhattan white pages(1487536 listings)”或者"Thread[main, 5, main]"。理想情况下，字符串应该是自描述的（self-explanatory），（Thread例子不满足这样的要求。）

无论是否决定指定格式，都应该在文档中明确地表明你的意图。如果要指定格式，则应该严格地这样去做。如，下面是第9条中PhoneNumber类的toString方法：
/**
 * Returns the string representation of this phone number.
 * The string consists of fourteen characters whose format
 * is "(XXX) YYY-ZZZZ", where XXX is the area code, YYY is
 * the prefix, and ZZZZ is the line number. (Each of the
 * capital letters represents a single decimal digit.)
 *
 * If any of the three parts of this phone number is too small
 * to fill up its field, the field is padded with leading zeros.
 * For example, if the value of the line number is 123, the last
 * four characters of the string representation will be "0123".
 *
 * Note that there is a single space separating the closing
 * parenthesis after the area code from the first digit of the
 * prefix.
 */
@Override
public String toString() {
    return String.format("(%03d) %03d-%04d", areaCode, prefix, lineNumber);
}

如果决定不指定格式，那么文档注释部分也应该有如下所示的指示信息：
/**
 * Returns a brief description of this potion. The exact details
 * of the representation are unspecified and subject to change, 
 * but the following may be regarded as typical:
 * "[Potion #9: type=love, smell=turpentine, look=india ink]"
 */
@Override
public String toString() {
    //...
}

对于那些依赖于格式的细节进行编程或者产生永久数据的程序员，在读到这段注释之后，一旦格式被改变，则只能自己承担后果。

无论是否指定格式，都为toString返回值中包含的所有信息，提供一种编程式的访问途径。如，PhoneNumber类应该包含针对area code、prefix和line number的访问方法。如果不这么做，就会强迫那些需要这些信息的程序员不得不自己去解析这些字符串。除了降低了程序的性能，使得程序员们去做这些不的工作之外，这个解析过程也很容易出错，会导致系统不稳定，如果格式发生变化，还会导致系统崩溃。如果没有提供这些访问方法，即便你已经指明了字符串的格式是可以变化的，这个字符串格式也成了事实上的API。
//------------------------------------------------------------------------------------------------
//Effective Java 第3章 对于所有对象都通用的方法P28
//第11条：谨慎地覆盖clone P46
clone方法不应该在构造的过程中，调用新对象中任何非final的方法（见第17条）。如果clone调用了一个被覆盖的方法，那么在该方法所在的子类有机会修正它在克隆对象中的状态之前，该方法就会先被执行，这样很有可能会导致克隆对象和原始对象之间的不一致。因此，上一段落中讨论到的put(key, value)方法应该要么是final的，要么是私有的（如果是私有的，它应该算是非final公有方法的“辅助方法”）。
Object的clone方法被声明为可抛出CloneNotSupportedException异常，但是，覆盖版本的clone方法可能会忽略这个声明。公有的clone方法应该省略这个声明，因为不会抛出受检异常（checked exception）的方法与会抛出异常的方法相比，使用起来更加轻松（见第59条）。如果专门为了继承而设计的类（见第17条）覆盖了clone方法，覆盖版本的clone方法就应该模拟Object.clone的行为：它应该被声明为protected、抛出CloneNotSupportedException异常，并且该类不应该实现Cloneable接口。这样做可以使子类具有实现或不实现Cloneable接口的自由，就仿佛它们直接扩展了Object一样。
还有一点，如果决定 用线程安全的类实现Cloneable接口，要记得它的clone方法必须得到很好的同步，就像任何其他方法一样（见第66条）。Object的clone方法没有同步，因此即便很满意，可能也必须编写同步的clone方法来调用super.clone()。

简而言之，所有实现了Cloneable接口的类都应该用一个公有的方法覆盖clone。此公有方法首先调用super.clone，然后修正任何需要修正的域。一般情况下，这意味着要拷贝任何包含内部“深层结构”的可变对象，并用指向新对象的引用 代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用clone来完成，但这通常并不是最佳方法。如果该类只包含基本类型的域，或者指向不可变对象的引用，那么多半的情况是没有域需要修正。这条规则也有例外，如代表序列号或其他唯一ID值的域，或者代表对象的创建时间地域，不管这些域是基本类型还是不可变的，它们也都需要被修正。

如果扩展一个实现了Cloneable接口的类，那么除了实现一个行为良好的clone方法外，没有别的选择。否则，最好提供某些其他的途径来代替对象拷贝，或者不提供这样的功能。例如，对于不可变类，支持对象拷贝并没有太大的意义，因为被拷贝的对象与原始对象并没有实质的不同。

另一个实现对象拷贝的好办法是提供一个拷贝构造器（copy constructor）或拷贝工厂（copy factory）。拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类，例如：
public Yum(Yum yum);

拷贝工厂是类似于拷贝构造器静态工厂：
public static Yum newInstance(Yum yum);

拷贝构造器的做法，及其静态工厂方法的变形，都比Cloneable/clone方法具有更多的优势：它们不依赖于某一种很有风险的、语言之外的对象创建机制；它们不要求遵守尚未制定好文档的规范；它们不会与final域的正常使用发生冲突；它们不会抛出不必要的受检异常（checked exception）；它们不需要进行类型转换。虽然不可能把拷贝构造器或者静态工厂放到接口中，但是由于Cloneable的接口缺少一个公有的clone方法，所以它也没有提供一个接口该有的功能。因此，使用拷贝构造器或者拷贝工厂来代替clone方法时，并没有放弃接口的功能特性。

更进一步，拷贝构造器或者拷贝工厂可以带一个参数，参数类型是通过该类实现的接口。例如，所有通用集合实现都提供了一个拷贝构造器，它的参数类型为Collection或者Map。基于接口的拷贝构造器和拷贝工厂（更准确的叫法应该是“转换构造器（conversion constructor）”和转换工厂（conversion factory）），允许客户选择拷贝的实现类型，而不是强迫客户接受原始的实现类型。例如，假设有一个HashSet，并且希望把它拷贝成一个TreeSet。clone方法无法提供这样的功能，但是用转换构造器很容易实现：new TreeSet(s)。

既然Cloneable具有上述那么多问题，可以肯定地说，其他的接口都不应该扩展（extend）这个接口，为了继承而设计的类（见第17条）也不应该实现（implement）这个接口。由于它具有这么多缺点，有些专家级的程序员干脆从来不去覆盖clone方法，也从来不去调用它，除非拷贝数组。必须清楚一点，对于一个专门为了继承而设计的类，如果未能提供行为良好的受保护的（protected）clone方法，它的子类就不可能实现Cloneable接口。
//------------------------------------------------------------------------------------------------
//Effective Java 第3章 对于所有对象都通用的方法P28
//第12条：考虑实现Comparable接口 P53
与本章中讨论的其他方法不同，compareTo方法并没有在Object中声明。它是Comparable接口中唯一的方法。compareTo方法不但允许进行简单的赞同性比较，而且允许执行顺序比较，它与Object的equals方法具有相似的特征，它还是个泛型。类实现了Comparable接口，就表明它的实例具有内存的排序关系（natural ordering）。为实现Comparable接口的对象数组进行排序就这么简单：
Arrays.sort(a);

Comparator<T>是让一个比较类实现的，要实现compara(T t1, T t2)接口，就成为了一个比较器，可用于作为入参传递给Set、Map等对象（在本文档中搜索Comparator<Student>），类似于C++中的函数对象。
Comparable<T>是让一个普通的对象类继承的，要实现compareTo(T anotherT)，该类就自动具有了比较功能。

//如Cat类
package test;

import java.util.Comparator;

public class Cat implements Comparable<Cat>{
    private final int age;
    private final String name;
    private final int weight;

    public Cat(int age, String name, int weight) {
        this.age = age;
        this.name = name;
        this.weight = weight;
    }

    public int age() {
        return age;
    }

    public String name() {
        return name;
    }

    public int weight() {
        return weight;
    }

    @Override
    public int compareTo(Cat anotherCat) {
        if (age > anotherCat.age) {
            return 1;
        } else if (age < anotherCat.age) {
            return -1;
        }

        if (name.compareTo(anotherCat.name) > 0) {
            return 1;
        } else if (name.compareTo(anotherCat.name) < 0) {
            return -1;
        }

        //return new Integer(weight).compareTo(new Integer(anotherCat.weight));
        return Integer.compare(weight, anotherCat.weight);
    }
}

//
package test;

import org.junit.Test;

import java.util.Arrays;

import static org.junit.Assert.assertEquals;

public class CatSortAlgTest {
    @Test
    public void testCatOrderByAge() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(2, "XiaoHei", 3)};
        Arrays.sort(cats);
        assertEquals(cats[0].age(), 1);
        assertEquals(cats[1].age(), 2);
        assertEquals(cats[2].age(), 3);
    }

    @Test
    public void testCatOrderByName() {
        Cat[] cats = new Cat[]{new Cat(1, "MiMi", 5), new Cat(1, "DaHuang", 4), new Cat(1, "XiaoHei", 3)};
        Arrays.sort(cats);
        assertEquals(cats[0].name(), "DaHuang");
        assertEquals(cats[1].name(), "MiMi");
        assertEquals(cats[2].name(), "XiaoHei");
    }

    @Test
    public void testCatOrderByWeight() {
        Cat[] cats = new Cat[]{new Cat(1, "MiMi", 5), new Cat(1, "MiMi", 4), new Cat(1, "MiMi", 3)};
        Arrays.sort(cats);
        assertEquals(cats[0].weight(), 3);
        assertEquals(cats[1].weight(), 4);
        assertEquals(cats[2].weight(), 5);
    }

    @Test
    public void testCatOrderBySameAgeWithSome() {
        Cat[] cats = new Cat[]{new Cat(3, "MiMi", 5), new Cat(5, "DaHuang", 4), new Cat(3, "XiaoHei", 3)};
        Arrays.sort(cats);
        assertEquals(cats[0].name(), "MiMi");
        assertEquals(cats[1].name(), "XiaoHei");
        assertEquals(cats[2].name(), "DaHuang");
    }
}

对存储在集合中的Comparable对象进行搜索、计算极限值以及自动维护也同样简单。如，下面程序依赖于String实现了Comparable接口，去掉了命令行参数列表中的重复参数，并按字母顺序打印出来：
package test;

import org.junit.Test;

import java.util.Collections;
import java.util.Set;
import java.util.TreeSet;

public class CatSortAlgTest {
    @Test
    public void testCollectionAddAll() {
        String[] strings = {"world", "hello", "world"};
        Set<String> stringSet = new TreeSet<>();
        Collections.addAll(stringSet, strings);
        System.out.println(stringSet);
    }
}
输出：
[hello, world]

一旦类实现了Comparable接口，它就可以跟许多泛型算法（generic algorithm）以及依赖于该接口的集合实现（collection implementation）进行协作。付出很小的努力就可以获得非常强大的功能。Java平台类库中的所有值类（value classes）都实现了Comparable接口。如果正在编写一个值类，它具有非常明显的内存排序关系，比如按字母排序、按数值顺序或者按年代顺序，你就应该坚决考虑实现这个接口：
public interface Comparable<T> {
    int compareTo(T t);
}

compareTo方法的通用约定与equals方法的相似：
将这个对象与指定的对象进行比较。当该对象小于、等于或者大于指定对象的时候，分别返回一个负整数、零或者正整数。如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。

在下面的说明中，符号sgn（表达式）表示数学中的signum函数，它根据表达式（expression）的值为负值、零和正值，分别返回-1 、0或者1。
--实现者必须确保所有的x和y都满足sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。（这也暗示着，当且仅当y.compareTo(x)抛出异常时，x.compareTo(y)才必须抛出异常。）
--实现者还必须确保这个比较关系是传递的：(x.compareTo(y) > 0 && y.compareTo(z) > 0)暗示着x.compareTo(z) > 0 。
--实现者必须确保x.compareTo(y) == 0 暗示着所有的z都满足sgn(x.compareTo(z)) == sgn(y.compareTo(z))。
--强烈建议(x.compareTo(y) == 0) == (x.equals(y))，但这并非绝对必要。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：该类具有内存的排序功能，但是与equals不一致。”

与equals不同，在跨越不同类的时候，compareTo可以不做比较：如果两个被比较的对象引用不同类的对象，compareTo可以抛出ClassCastException异常。

就好像违反了hashCode约定的类会破坏其他依赖于散列做法的类一样，违反compareTo约定的类也会破坏其他依赖于比较关系的类。依赖于比较关系的类包括有序集合类TreeSet和TreeMap，以及工具类Collections和Arrays，它们内部包含有搜索和排序算法。

回顾一下compareTo约定中的条款。第一条指出，如果颠倒了两个对象引用 之间的比较方法，就会发生下面的情况：如果第一个对象小于第二个对象，则第二个对象一定大于第一个对象；如果第一个对象等于第二个对象，则第二个对象一定等于第一个对象；如果第一个对象大于第二个对象，则第二个对象一定小于第一个对象。第二条指出，如果一个对象大于第二个对象，并且第二个对象又大于第三个对象，那么第一个对象一定大于第三个对象。最后一条指出，在比较时被认为相等的所有对象，它们跟别的对象做比较时一定会产生同样的结果。

这三个条款的一个直接结果是，由compareTo方法施加的等同性测试（equality test），也一定遵守相同于equals约定所施加的限制条件：自反性、对称性和传递性。因此，下面的告诫也同样适用：无法在用新的值组件扩展可实例化的类时，同时保持compareTo约定，除非愿意放弃面向对象的抽象优势（见第8条）。针对equals的权宜之计也同样适用于compareTo方法。如果想为一个实现了Comparable接口的类增加值组件，请不要扩展这个类；而是要编写一个不相关的类，其中包含第一个类的一个实例。然后提供一个“视图（view）”方法返回这个实例。这样既可以让你自由地在第二个类上实现compareTo方法，同时也允许你的客户端在必要的时候，把第二个类的实例视同第一个类的实例。

compareTo约定的最后一段是一个强烈的建议，而不是真正的规则，只是说明了compareTo方法施加的等同性测试，在通常情况下应该返回与equals方法同样的结果。如果遵守了这一条，那么由compareTo方法所施加的顺序关系就认为“与equals一致（consistent with equals）”。如果违反了这条规则，顺序关系就被认为“与equals不一致（inconsistent with equals）”。如果一个类的compareTo方法施加了一个与equals方法不致的顺序关系，它仍然能够正常工作，但是，如果一个有序集合（sorted collection）包含了该类的元素，这个集合就可能无法遵守相应集合接口（Collection、Set或Map）的通用约定。这是因为，对于这些接口的通用约定是按照equals方法来定义的，但是有序集合使用了由compareTo方法而不是equals方法所施加的等同性测试。尽管出现这种情况下不会等成灾难性的后果，但是应该有所了解。

如，考虑BigDecimal类，它的compareTo方法与equals不一致。如果创建了一个HashSet实例，并且添加new BigDecimal("1.0")和new BigDecimal("1.00")，这个集合就将包含两个元素，因为新增到集合中的两个BigDecimal实例，通过equals方法来比较时是不相等的。然而，如果使用TreeSet而不是HashSet来执行同样的过程，集合中将只包含一个元素，因为这两个BigDecimal实例在通过compareTo方法进行比较时是相等的。
//
package test;

import org.junit.Test;

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.TreeSet;

public class BigDecimalTest {
    @Test
    public void testCollectionAddAll() {
        HashSet<BigDecimal> bigDecimalHashSet = new HashSet<>();
        bigDecimalHashSet.add(new BigDecimal("1.0"));
        bigDecimalHashSet.add(new BigDecimal("1.00"));
        System.out.println(bigDecimalHashSet);

        TreeSet<BigDecimal> bigDecimalTreeSet = new TreeSet<>();
        bigDecimalTreeSet.add(new BigDecimal("1.0"));
        bigDecimalTreeSet.add(new BigDecimal("1.00"));
        System.out.println(bigDecimalTreeSet);
    }
}
输出：
[1.0, 1.00]
[1.0]

编写compareTo方法与编写equals方法非常相似，也有几处重大差别。因为Comparable接口是参数化的，而且comparable（这里错了吧，感觉应该是compareTo）方法是静态的类型，因此不必进行类型检查，也不必对它的参数进行类型转换。如果参数的类型不合适，这个调用甚至无法编译。如果参数为null，这个调用应该抛出NullPointerException异常，并且一旦该方法试图访问它的成员时就应该抛出。

compareTo方法中域的比较是顺序的比较，而不是等同性的比较。比较对象引用域可以是通过递归地调用compareTo方法来实现。如果一个域并没有实现Comparable接口，或者你需要使用一个非标准的排序关系，就可以使用一个显式的Comparator来代替。或者编写自己的Comparator，或者使用已有的Comparator，譬如针对第8条中CaseInsensitiveString类的这个compareTo方法使用一个已有的Comparator：
public final class CaseInsensitiveString implements Comparable<CaseInsensitiveString> {
    public int compareTo(CaseInsensitiveString cis) {
        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);
    }
    
    // Remainder omitted
}

System.out.println(String.CASE_INSENSITIVE_ORDER.compare("hello", "HELLO"));//0
System.out.println(String.CASE_INSENSITIVE_ORDER.compare("hello", "IELLO"));//-1
System.out.println(String.CASE_INSENSITIVE_ORDER.compare("hello", "GELLO"));//1

注意CaseInsensitiveString类实现了Comparable<CaseInsensitiveString>接口。CaseInsensitiveString引用只能与其他的Comparable<CaseInsensitiveString>引用进行比较。在声明类去实现Comparable接口时，这是常见的模式。还要注意compareTo方法的参数是CaseInsensitiveString，而不是Object。这是上述的类声音所要求的。

比较整数型基本类型的域，可以使用关系操作符<和>。如，浮点域用Double.compare和Float.compare，而不用关系操作符，当应用到浮点值时，它们没有遵守compareTo的通用约定。对于数组域，则要把这些指导原则应用到每个元素上。

如果一个类有多个关键域，则按什么样的顺序来比较这些域是非常关键的。必须从最关键的域开始，逐步进行到所有的重要域。如果某个域的比较产生了非零的结果（零代表相等），则整个比较操作结束，并返回该结果。如果最关键的域是相等的，则进一步比较次最关键的域，以此类推。如果所有的域都是相等的，则对象就是相等的，并返回零。通过第9条中的PhoneNumber类的compareTo方法来说明这种方法：
public int compareTo(PhoneNumber pn) {
    //compare area codes
    if (areaCode < pn.areaCode)
        return -1;
    if (areaCode > pn.areaCode)
        return 1;
    
    //area codes are equal, compare prefixes
    if (prefix < pn.prefix)
        return -1;
    if (prefix > pn.prefix)
        return 1;
    
    //area codes and prefixes are equal, compare line numbers
    if (lineNumber < pn.lineNumber)
        return -1;
    if (lineNumber > pn.lineNumber)
        return 1;
    
    return 0; //All fields are equal
}

虽然这个方法可选，但它还可以改进。compareTo方法的约定并没有指定返回值的大小（magnitude），而只是指定了返回值的符号。可以利用这一点来简化代码，或者还能提高运行速度：
public int compareTo(PhoneNumber pn) {
    //Compare area codes
    int areaCodeDiff = areaCode - pn.areaCode;
    if (areaCodeDiff != 0)
        return areaCodeDiff;
    
    //Area codes are equal, compare prefixes
    int prefixDiff = prefix - pn.prefix;
    if (prefixDiff != 0)
        return prefixDiff;
    
    //Area codes and prefixes are equal, compare line numbers
    return lineNumber - pn.lineNumber;
}

这项技巧在这里能够工作得很好，但是用起来要非常小心。除非你确信相关的域不会为负值，或者更一般的情况：最小和最大的可能域值之差小于或等于INTEGER.MAX_VALUE(2^32 -1)，否则就不要使用这种方法。这项技巧有时候不能正常工作的原因在于，一个有符号的32位整数还没有大到足以表达任意两个32位整数的差。如果i是一个很大的正整数（int类型），而j是一个很大的负整数（int类型），那么（i - j）将会溢出，并返回一个负值。这样就使得compareTo方法将对某些参数返回错误的结果，违反了compareTo约定的第一条和第二条。这不是一个纯粹的理论问题：它已经在实际的系统中导致了失败。这些失败可能非常难以调试，因为这样的compareTo方法对于大多数的输入值都能正常工作。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第13条：使类和成员的可访问性最小化 P58
设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。模块之前只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏（information hiding）或封装（encapsulation），是软件设计的基本原则之一。

信息隐藏的几个重要原因：
它可以有效地解除组成系统的各模块之间的耦合关系，使得这些模块可以独立地开发、测试、优化、使用、理解和修改。这样可以加快系统开发的速度，因为这些模块可以并行开发。
它也减轻了维护的负担，程序员可以更快地理解这些模块，并且在调试它们的时候可以不影响其他模块。
信息隐藏本身无论是对内还是对外，都不会带来更好的性能，但是它可以有效地调节性能：一旦完成一个系统，并通过剖析确定了哪些模块影响了系统的性能（见第55条），那些模块就可以被进一步优化，而不是影响到其他模块的正确性。
信息隐藏提高了软件的可重用性，因为模块之间并不紧密相连，除了开发这些模块所使用的环境之外，它们在其他的环境中往往也很有用。
信息隐藏也降低了构建大型系统的风险，因为即便整个系统不可用，但是这些独立的模块却有可能是可用的。

Java程序设计语言提供了许多机制（facility）来协助信息隐藏。访问控制（access control）机制决定了类、接口和成员的可访问性（accessibility）。实体的可访问性是由该实体声音所在的位置，以及该实体声明中所出现的访问修饰符（private、protected和public）共同决定的。正确地使用这些修饰符对于实现信息隐藏是非常关键的。

第一规则很简单：尽可能地使每个类或者成员不被外界访问。换句话说，应该使用与你正在编写的软件的对应功能相一致的、尽可能最小的访问级别。

对于顶层的（非嵌套的）类和接口，只有两种可能的访问级别：包级私有的（package-private）和公有的（public）。如果你用public修饰符声明了顶层类或者接口，那它就是公有的；否则，它将是包级私有的。如果类或者接口能够被做成包级私有的，它就应该被做成包级私有。通过把类或者接口做成包级私有，它实际上成了这个包的实现的一部分，而不是该包导出的API的一部分，在以后的发行版本中，可以对它进行修改、替换，或者删除，而无需担心会影响到现有的客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的兼容性。

如果一个包级私有的顶层类（或者接口）只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类（见第22条）。这样可以将它的可访问范围从包中的所有类缩小到了使用它的那个类。然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的更重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。

对于成员（域、方法、嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：
--私有的（private）――只有在声明该成员的顶层类内部才可以访问这个成员。
--包级私有的（package-private）――声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省（default）访问级别”，如果没有为成员指定访问修饰符，就采用这个访问级别。
--受保护的（protected）――声明该成员的类的子类可以访问这个成员（但有一些限制），并且，声明该成员的包内部的任何类也可以访问这个成员。
--公有的（public）――在任何地方都可以访问该成员。

当你设计了类的公有API之后，可能觉得应该把所有其他的成员都变成私有的。其实，只有当同一个包内的另一个类真正需要访问一个成员的时候，才应该删除private修饰符，使该成员变成包级私有的。如果你发现自己经常要做这样的事情，就应该重要检查你的系统设计，看看是否另一种分解方案所得到的类，与其他类之间的耦合度会更小。也就是说，私有成员和包级私有成员都是一个类的实现中的一部分，一般不会影响它的导出的API。然而，如果这个类实现了Serializable接口（见第74条和第75条），这些域就可能被“泄露（leak）”到导出的API中。

对于公有类的成员当访问级别从包级私有变成保护级别时，会大大增强可访问性。受保护的成员是类的导出的API的一部分，必须永远得到支持。导出的类的受保护成员也代表了该类对于某个实现细节的公开承诺（见第17条）。受保护的成员应该尽量少用。

有一条规则限制了降低方法的可访问性的能力。如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超类中的访问级别。这样可以确保任何可使用超类的实例的地方也都可以使用子类的实例。如果违反了这条规则，那试图编译该子类的时候，编译器就会产生一条错误消息。这条规则有种特殊的情形：如果一个类实现了一个接口，那么接口中所有的类方法在这个类中也都必须被声明为公有的。之所以如此，是因为接口中的所有方法都隐含着公有访问级别。

为了便于测试，可以试着使类、接口或者成员变得更容易访问。这么做在一定程度上来说是好的。为了测试而将一个公有类的私有成员变成包级私有的，这还可以接受，但是要将访问级别提高到超过它，这就无法接受了。换句话说，不能为了测试，而将类、接口或者成员变成包的导出的API的一部分。幸运的是，也没有必要这么做，因为可以让测试作为被测试的包的一部分来运行，从而能够访问它的包级私有的元素。

实例域决不能是公有的（见第14条）。如果域是非final的，或者是一个指向可变对象的final引用，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采取任何行动的能力。因此，包含公有可变域的类并不是线程安全的。即便域是final的，并且引用不可变的对象，当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。

同样的建议也适用于静态域，只是有一种例外情况。假设常量构成了类提供的整个抽象中的一部分，可以通过公有的静态final域来暴露这些常量。按惯例，这种域的名称由大写字母组成，单词之间用下划线隔开（见第56条）。很重要的一点是，这些域要么包含基本类型的值，要么包含指向不可变对象的引用（见第15条）。如果final域包含可变对象的引用 ，它便具有非final域的所有缺点。虽然引用本身不能被修改，但是它所引用的对象却可以被修改――这会导致灾难性的后果。

长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的。如果类具有这样的域或者访问方法，客户端将能够修改数组中的内容。这是安全漏洞的一个常见根源：
// Potential security hole!
public static final Thing[] VALUES = {...};

要注意，许多IDE会产生返回指向私有数组域的引用的访问方法，这样就会产生这个问题。修改这个问题有两种方法。可以使用公有数组变成私有的，并增加一个公有的不可变列表：
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thins> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

另一种方法是，可以使数组变成私有的，并添加一个公有方法，它返回私有数组的一个备份：
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}

要在这两种方法之间做出选择，得考虑客户端可能怎么处理这个结果。哪种返回类型更加方法，哪种会得到更好的性能。

总而言之，应该始终尽可能地降低可访问性。在仔细地设计了一个最小的公有API之后，应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域特殊情形之外，公有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都是不可变的。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第14条：在公有类中使用访问方法而非公有域 P62
对于公有类，坚持面向对象程序设计思想的看法是正确的：如果类可以在它所在的包的外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端代码已经遍布各处了。

然而，如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误――假设这些数据域确实描述了该类所提供的抽象。这种方法比访问方法的做法更不会产生视觉混乱，无论是在类定义中，还是在使用该类的客户端代码中。虽然客户端代码与该类的内部表示法紧密相连，但是这些代码被限定在包含该类的包中。如有必要，不改变包之外的任何代码而只改变内部数据表示法也是可以的。在私有嵌套类的情况下，改变的作用范围被进一步限制在外围类中。

Java平台类库中有几个类违反了“公有类不应该直接暴露数据域”的告诫。显著的例子包括java.awt包中的Point和Dimension类。它们是反面的示例。如第55条中所述，决定暴露Dimension类的内部数据等成了严重的性能问题，而且，这个问题至今依然存在。

让公有类直接暴露域从来都不是种好办法，但是如果域是不可变的，这种做法的危害就比较小一些。如果不改变类的API，就无法改变这种类的表示法，当域被读取的时候，也无法采取辅助的行动，但是可以强加约束条件。如，这个类确保了每个实例都表示一个有效的时间：
// Public class with exposed immutable fields - questionable
public final class Time {
    private static final int HOURS_PER_DAY = 24;
    private static final int MINUTES_PER_HOUR = 60;
    
    public final int hour;
    public final int minute;
    
    public Time(int hour, int minute) {
        if (hour < 0 || hour >= HOURS_PER_DAY) {
            throw new IllegalArgumentException("Hour: " + hour);
        }
        if (minute < 0 || minute >= MINUTES_PER_HOUR) {
            throw new IlleagalArgumentException("Min: " + minute);
        }
        this.hour = hour;
        this.minute = minute;
    }
    
    // Remainder omitted
}

总之，公有类永远都不应该暴露可变的域。虽然还是有问题，但是让公有类暴露不可变的域其危害比较小。但是有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变还是不可变的。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第15条：使可变性最小化 P58
不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期（lifetime）内固定不变。Java平台类库中包含许多不可变的类，其中有String、基本类型的包装类、BigInteger和BigDecimal。存在不可变的类有许多理由：不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变，要遵循下面五条规则：
1. 不要提供任何会修改对象状态的方法（也称为mutator）。
2. 保证类不会被扩展。这样可以防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法是使这个类成为final的，后面讨论其他的做法。
3. 使所有的域都是final的。通过系统的强制方式，这可以清楚地表明意图。而且，如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为，正如内存模型中所述。
4. 使所有的域都成为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。虽然从技术上讲，允许不可变的类具有公有的final域，只要这些域包含基本类型的值或者指向不可变对象的引用，但是不建议这样做，因为这样会使得在以后的版本中无法再改变内部的表示法（见第13条）。
5. 确认对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法（accessor）中返回该对象引用。在构造器、访问方法和readObject方法（见第76条）中请使用保护性拷贝（defensive copy）技术（见第39条）。

前面条目中许多例子都是不可变的，其中一个例子是第9条中的PhoneNumber，它针对每个属性都有访问方法（accessor），但是没有对应的设值方法（mutator）。下面是个稍微复杂的例子：
//
package test;

public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double realPart() {
        return re;
    }

    public double imaginaryPart() {
        return im;
    }

    public Complex add(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex substract(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex multiply(Complex c) {
        return new Complex(re * c.re - im * c.im,
            re * c.im + im * c.re);
    }

    public Complex divide(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
            (im * c.re - re * c.im) / tmp);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof Complex)) {
            return false;
        }

        Complex c = (Complex) o;

        // See page 43 to find out why we use compare instead of ==. See the 12th Instruction.
        return Double.compare(re, c.re) == 0 &&
            Double.compare(im, c.im) == 0;

    }

    @Override
    public int hashCode() {
        int result = 17 + hashDouble(re);
        result = 31 * result + hashDouble(im);
        return result;
    }

    @Override
    public String toString() {
        return "(" + re + " + " + im + "i)";
    }

    private int hashDouble(double val) {
        long longBits = Double.doubleToLongBits(val);
        return (int) (longBits ^ (longBits >>> 32));
    }
}

这个类表示一个复数（complex number，具有实部和虚部）。除了标准的Object方法，还提供了针对实部和虚部的访问方法，以及4种基本的算术运算：加法、减法、乘法和除法。
注意这些算法运算是如何创建并返回新的Complex实例，而不是修改这个实例。大多数重要的不可变类都使用了这种模式。它被称为函数的（functional）做法，因为这引起方法返回了一个函数的结果，这些函数对操作数进行运行但不修改它。与之相对应的更常见的是过程的（procedural）或者命令式的（imperative）做法，使用这些方式时，将一个过程作用在它们的操作数上，会导致它的状态发生改变。

函数方式做法带来了不可变性，具有许多优点。不可变对象比较简单。不可变对象可以只有一种状态，即被创建时的状态。如果能够确保所有的构造器都建立了这个类的约束方法，就可以确保这些约束关系在整个生命周期内永远不再发生变化，你和使用这个类的程序员都无需再做额外的工作来维护这些约束关系。另一方法，可变的对象可以有任意复杂的状态空间。如果文档中没有对mutator方法所执行的状态转换提供精确的描述，要可靠地使用一个可变类是非常困难的，甚至是不可能的。

不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这样的对象时，它们不会遭到破坏。这是获得线程安全最容易的方法。实际上，没有任何线程会注意到其他线程对于不可变对象的影响。所以，不可变对象可以被自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例。要做到这一点，一个很简便的办法就是，对于频繁用到的值，为它们提供公有的静态final常量。如，Complex类可能会提供下面的常量：
public static final Complex ZERO = new Complex(0, 0);
public static final Complex ONE = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);

这种方法可以被进一步扩展。不可变的类可以提供一些静态工厂（见第1条），它们把频繁被请求的实例缓存起来，从而当现在实例可以符合请求的时候，就不必创建新的实例。所有基本类型的包装类和BigInteger都有这样的静态工厂。使用这样的静态工厂也复合客户端之间可以共享现在的实例，而不用创建新的实例，从而降低内存占用和垃圾回收的成本。在设计新的类时，选择用静态工厂代替公有的构造器可以让你以后有添加缓存的灵活性，而不必影响客户端。

“不可变对象可以被自由地共享”导致的结果是，永远也不需要进行保护性拷贝（见第39条）。实际上，根本无需做任何拷贝，这些拷贝始终等于原始的对象。因为，不需要，也不应该为不可变的类提供clone方法或者拷贝构造器（copy constructor，见第11条）。这一点在Java平台的早期并不好理解，所以String类仍然具有拷贝构造器，但是应该尽量少用它（见第5条）。

不仅可以共享不可变对象，甚至也可以共享它们的内部信息。例如，BigInteger类内部使用了符号数值表示法。符号用一个int类型的值来表示，数值则用一个int数组表示。negate方法产生一个新的BigInteger，其中数值是一样的，符号则是相反的。它并不需要拷贝数组；新建的BigInteger也指向原始实例中的同一个内部数组。

不可变对象为其他对象提供了大量的构造（building blocks），无论是可变的还是不可变的对象。如果知道一个复杂对象内部的组件对象不会改变，要维护它的不变性约束是比较容易的。这条原则的一种特例在于，不可变对象构成了大量的映射键（map key）和集合元素（set element）；一旦不可变对象进入到映射（map）或者集合（set）中，尽管这破坏了映射或者集合的不变性约束，但是也不用担心它们的值会发生变化。（没看懂？？）

不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。创建这种对象的代价可能很高，特别是对于大型对象的情形。如，假设你有一个上百万位的BigInteger，想要改变它的低位：
BigInteger moby = ...;
moby = moby.flipBit(0);

flipBit方法创建了一个新的BigInteger实例，也有上百万位长，它与原来的对象只差一位不同。这项操作所消耗的时间和空间与BigInteger的长度成正比。拿它与java.util.BitSet进行比较。与BigInteger类似，BigSet代表一个任意长度的位序列，但是与BigInteger不同的是，BitSet是可变的。BitSet类提供了一个方法，允许在固定时间（constant time）内改变此“百万位”实例中单个位的状态。

BigInteger有一个包级私有的可变“配套类（companing class）”，它的用途是加速诸如“模指数（modular exponentiation）”这样的多步骤操作。由于前面提到的诸多原因，使用可变的配套类比使用BigInteger要困难得多，但幸运的是，并不需要这样做。因为BigInteger的实现者已经替你完成了所有的困难工作。

如果能够精确地预测出客户端将要在不可变的类上执行哪些复杂的多阶段操作，这种包级私有的可变配套类的方法可以工作得很好。如果无法预测，最好的办法就是提供一个公有的可变配套类。在Java平台类库中，这种方法的主要例子是String类，它的可变配套类是StringBuilder（不是线程安全的，单线程使用速度快）（和基本上已经废弃的StringBuffer，线程安全的）。可以这样认为，在特定的环境下，相对于BigInteger而言，BitSet同样扮演了可变配套类的角色。

为了确保不可变性，类绝对不允许自身被子类化。除了“使类成为final的”这种方法之外，还有另外一种更加灵活的办法可以做到这一点。让不可变的类变成final的另一种办法就是，让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂（static factory）来代替公有的构造器（见第1条）。

以Complex为例：
// Immutable class with static factories instead of constructors
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }
    
    // Remainder unchanged
}

虽然这种方法并不常用，但它经常是最好的替代方法。它最灵活，因为它允许使用多个包级私有的实现类。对于处在它的包外部的客户端而言，不可变的类实际上是final的，因为不可能把来自另一个包的类、缺省公有的或受保护的构造器的类进行扩展。除了允许多个实现类的灵活性之外，这种方法还使得有可能通过改善静态工厂的对象的缓存能力，在后续的发行版本中改进该类的性能。

静态工厂与构造器相比具有许多其他的优势，如第1条中所讨论的。如，假设希望提供一种“基于极坐标创建复数”的方式。如果使用构造器来实现这样的功能，可能会使得这个类很零乱，因为这样的构造器与已用的构造器Complex(double, double)具有相同的签名。通过静态工厂，这很容易做到。只需添加第二个静态工厂，并且工厂的名字清楚地表明了它的功能即可：
public static Complex valueOfPolar(double r, double theta) {
    return new Complex(r * Math.cos(theta), r * Math.sin(theta));
}

当BigInteger和BIgDecimal刚被编写出来的时候，对于“不可变的类必须为final的”还没有得到广泛地理解，所以它们的所有方法都有可能会被覆盖。遗憾的是，为了保持向后兼容，这个问题地直无法得以修正。如果在编写一个类，它的安全性依赖于（来自不可信客户端的）BigInteger或者BigDecimal参数的不可变性，就必须进行检查，以确定这个参数是否为“真正的”BigInteger或者BigDecimal，而不是不可信任子类的实例。如果是后者的话，就必须在假设它可能是可变的前提下对它进行保护性拷贝（见第39条）：
public static BigInteger safeInstance(BigInteger val) {
    if (val.getClass() != BigInteger.class) {
        return new BigInteger(val.toByteArray());
    }
    return val;
}

本条目形状处关于不可变类的诸多规则指出：没有方法会修改对象，并且它的所有域都必须是final的。实际上，这些规则比真正的要求更强硬了一点，为了提供性能可以有所放松。事实上应该：没有一个方法能够对对象的状态产生外部可见（externally visible）的改变。然而，许多不可变的类拥有一个或者多个非final的域，它们在第一次被请求执行这些计算的时候，把一些开销昂贵的计算结果缓存在这些域中。如果将来再次请求同样的计算，就直接返回这些缓存的值，从而节约了重新计算所需要的开销。这种技巧可以很好的工作，因为对象是不可变的，它的不可变性保持了这些计算如果被再次执行，就会产生同样的结果。
如，PhoneNumber类的hashCode方法（见第9条）在第一次被调用的时候，计算出散列码，然后把它缓存起来，以备将来被再次调用时使用。这种方法是延迟初始化（lazy initialization）（见第71条）的一个例子，String类也用到了。

有关序列化功能的一条告诫有必要在这里提出来。如果选择让自己的不可变类实现Serializable接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法，即便默认的序列化形式是可以接受的，也是如此。否则攻击者可能从不可变的类创建可变的实例。这个话题的详细内容请参见第76条。

总之，坚决不要为每个get方法编写一个相应的set方法。除非有很好的理由要让类成为可变的类，否则就应该是不可变的。不可变的类有许多优点，唯一缺点是在特定的情况下存在潜在的性能问题。应该问题使一些小的值对象，比如PhoneNumber和Complex，成为不可变的（在Java平台类库中，有几个类如java.util.Date和java.awt.Point，它们本应该是不可变的，但实际上却不是）。也应该认真考虑把一些较大的值对象做成不可变的，如String和BigInteger。只能当确认有必要实现令人满意的性能时（见第55条），才应该为不可变的类提供公有的可变配套类。

对于有些类而言，其不可变性是不切实际的。如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。降低对象可以存在的状态数，可以更容易地分析该对象的行为，同时降低出错的可能性。因此，除非有令人信服的理由要使域变成是非final的，否则要使每个域都是final。

构造器应该创建完全初始化的对象，并建立起所有的约束关系。不要在构造器或者静态工厂之外再提供公有的初始化方法，除非有令人信服的理由必须这么做。同样的，也不应该提供“重新初始化”方法（它使得对象可以被重用，就好像这个对象是由另一不同的初始状态构造出来一样）。与所增加的复杂性相比，“重新初始化”方法通常并没有带来太多的性能优势。

可以通过TimerTask类来说明这些原则。它是可变的，但是它的状态空间被有意地设计得非常小。你可以创建一个实例，对它进行调度使它执行起来，也可以随意地取消它。一旦一个定时器任务（timer task）已经完成，或者已经被取消，就不可能再对它重新调度。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第16条：复合优先于继承 P71
继承（inheritance）是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里，子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计、并且具有很好的文档说明的类来说（见第17条），使用继承也是非常安全的。然而，对普通的具体类（concrete class）进行跨越包边界的继承，则是非常危险的。本书使用“继承”一词，含义是实现继承（implementation inheritance，当一个类扩展另一个类的时候）。本条目中讨论的问题并不适用于接口继承（interface inheritance，当一个类实现一个接口的时候，或者当一个接口扩展另一个接口的时候）。

与方法调用不同的是，继承打破了封装性。子类依赖于其超类的特定功能的实现细节。超类的实现有可能会随着发行版本的同不而有所变化，如果真的发生了变化，子类可能会遭到破坏，即便它的代码完全没有改变。因而，子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。

为了明说具体，假设有一个程序使用了HashSet。为了调优该程序的性能，需要查询HashSet，看一看自从它被创建以来曾经添加了多少个元素（不要与它当前的元素混淆起来，元素数目会随着元素的删除而递减）。为了提供这种功能，我们得编写一个HashSet变量，它记录下试图插入的元素数量，并针对该计数值导出一个访问方法。HashSet类包含两个可以增加元素的方法：add和addAll，因此两个方法都要覆盖：
//
package test;

import java.util.Collection;
import java.util.HashSet;

// Broken - Inappropriate use of inheritance!
public class InstrumentedHashSet<E> extends HashSet<E> {
    // The number of attempted element insertions
    private int addCount = 0;

    public InstrumentedHashSet() {

    }

    public InstrumentedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor);
    }

    @Override
    public boolean add(E e) {
        ++addCount;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

//
package test;

import org.junit.Test;

import java.util.Arrays;

import static org.junit.Assert.*;

public class InstrumentedHashSetTest {
    @Test
    public void testAddAll() {
        InstrumentedHashSet<String> s = new InstrumentedHashSet<>();
        s.addAll(Arrays.asList("hello", "world", "good"));
        assertEquals(3, s.getAddCount());
    }
}
结果：
java.lang.AssertionError: 
Expected :3
Actual   :6

这个类看起来非常合理，但它并不能正常工作。
我们期望getAddCount方法将会返回3，实际上返回6。HashSet内部，addAll方法是基于它的add方法来实现的，即便HashSet方法中并没有说明这样的实现细节，这也是合理的。

只要去掉被覆盖的addAll方法，就可以“修正”这个子类。虽然这样得到的类可以正常工作，但是它的功能正确性则需要依赖于这样的事实：HashSet的addAll方法是在它的add方法上实现的。这种“自用性（self-use）”是实现细节，不是承诺，不能保证在Java平台的所有实现中都保持不变，不能保证随着发行版本的不同而不发生变化。因此，这样得到的InstrumentedHashSet类将是非常脆弱的。

稍微好一点的做法是，覆盖addAll方法来遍历指定的集合，为每个元素调用一次add方法。这样做可以保证得到正确的结果，不管HashSet的addAll方法是否是在add方法的基础上实现，因为HashSet的addAll实现将不会再被调用到。然而，这项技术并没有解决所有的问题，它相当于重新实现了超类的方法，这些超类的方法可能是自用的（self-use），也可能不是自用的，这种方法很困难，也非常耗时，并且容易出错。

导致子类脆弱的一个相关的原因是，它们的超类在后续的发行版本中可以获得新的方法。假设一个程序的安全性依赖于这样的事实：所有被插入到某个集合中的元素都满足某个先决条件。下面的做法就可以确保这一点：对集合进行子类化，并覆盖所有能够添加元素的方法，以便 确保在加入每个元素之前它是满足这个先决条件的。如果在后续的发行版本中，超类中没有增加能够插入元素的新方法，这种做法就可以正常工作。然而，一旦超类增加了这样的新方法，则很可能仅仅由于调用了这个未被子类覆盖的新方法，而将“非法的”元素添加到子类的实例。

上面两个问题都来源于覆盖（overriding）动作。如果在扩展一个类的时候，仅仅是增加新的方法，而不覆盖现有的方法。虽然这种扩展方式比较安全一些，但是也并非完全没有风险。如果超类在后续的发行版本中获得了一个新的方法，并且不幸的是，你给子类提供了一个签名相同但返回类型不同的方法，那么这样的子类将无法通过编译。如果给子类提供的方法带有与新的超类方法完全相同的签名和返回类型，实际上就覆盖了超类中的方法，因此又回到上述的两个问题上去了。此外，你的方法是否能够遵守新的超类方法的约定，也是很值得怀疑的，因为当你在编写子类方法的时候，这个约定根本8没有面世。

有一种方法可以避免前面提到的所有问题。不用扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。这种设计被称做“复合（composition）”，因为现有的类变成了新类的一个组件。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为转发（forwarding），新类中的方法被称为转发方法（forwarding method）。这样得到的类将会非常稳固，它不依赖于现有类的实现细节。即便现有的类添加了新的方法，也不会影响新的类。请看下面例子，它用复合/转发的方法来代替InstrumentedHashSet类。这个实现分为两部分：类本身和可重用的转发类（forwarding class），包含了所有的转发方法，没有其他方法：
//ForwardingSet
package test;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;
//装饰模式
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;

    public ForwardingSet(Set<E> s) {
        this.s = s;
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        return s.equals(obj);
    }

    @Override
    public String toString() {
        return s.toString();
    }

    @Override
    public int size() {
        return s.size();
    }

    @Override
    public boolean isEmpty() {
        return s.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        return s.contains(o);
    }

    @Override
    public Iterator<E> iterator() {
        return s.iterator();
    }

    @Override
    public Object[] toArray() {
        return s.toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean add(E e) {
        return s.add(e);
    }

    @Override
    public boolean remove(Object o) {
        return s.remove(o);
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        return s.containsAll(c);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        return s.addAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return s.retainAll(c);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return s.removeAll(c);
    }

    @Override
    public void clear() {
        s.clear();
    }
}

//InstrumentedSet
package test;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

// Wrapper class - uses composition in place of inheritance
public class InstrumentedSet<E> extends ForwardingSet<E> {
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        ++addCount;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

//测试类
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.HashSet;

import static org.junit.Assert.*;

public class InstrumentedSetTest {
    @Test
    public void testAddAll() {
        InstrumentedSet<String> s = new InstrumentedSet<>(new HashSet<String>());//InstrumentedSet<String> s = new InstrumentedSet<>(new HashSet<>());，这里HashSet<>如果不写明String类型，报错Error:(13, 37) java: 不兼容的类型: test.InstrumentedSet<java.lang.Object>无法转换为test.InstrumentedSet<java.lang.String>，为什么不能自动识别？我理解的类型自动识别是只对当前new类型的，而不能对构造函数中的未知入参类型识别
        s.addAll(Arrays.asList("hello", "world", "good"));
        assertEquals(3, s.getAddCount());
    }
}
测试通过

Set接口的存在使得InstrumentedSet类的设计成为可能，因为Set接口保存了HashSet类的功能特性。除了获得健壮性之外，这种设计也带来了格外的灵活性。InstrumentedSet类实现了Set接口，并且拥有单个构造器，它的参数也是Set类型。从本质上讲，这个类把一个Set转变成了另一个Set，同时增加了计数的功能。这里的包装类（wrapper class）可以被用来包装任何Set实现，并且可以结合任何先前存在的构造器一起工作。如：
Set<Date> s = new InstrumentedSet<Date>(new TreeSet<Date>(cmp));
Set<E> s2 = new InstrumentedSet<E>(new HashSet<E>(capacity));

InstrumentedSet类甚至也可以用来临时替换一个原来没有计数特性的Set实例：
static void walk(Set<Dog> dogs) {
    InstrumentedSet<Dog> iDogs = new InstrumentedSet<Dog>(dogs);
    ... // Within this method use iDogs instead of dogs
}

因为每一个InstrumentedSet实例都把另一个Set实例包装起来了，所以InstrumentedSet类被称为包装类（wrapper class）。这也正是Decorator模式，因为InstrumentedSet类对一个集合进行了修饰，为它增加了计数特性。有时候，复合和转发的结合也被错误地称为“委托（delegation）”。从技术的角度而言，这不是委托，除非包装对象把自身传递给被包装的对象。

包装类几乎没有什么缺点。需要注意的一点是，包装类不适合用在回调框架（callback framework）中，在回调框架中，对象把自身的引用 传递给其他的对象，用于后续的调用（“回调”）。因为被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为SELF问题。

只有当子类真正是超类的子类型（subtype）时，才适合用继承。换句话说，对于 两个类A和B，只有当两者之间确实存在“is-a”关系的时候，类B才应该扩展类A。如果打算让类B扩展类A，就应该问问自己：每个B确实也是A吗。如果不能确定这个问题的答案是肯定的，那么B就不应该扩展A。如果答案是否定的，通常情况下，B应该包含A的一个私有实例，并且暴露一个较小的、较简单的API：A本质上不是B的一部分，只是它的实现细节布局。

如果在适合于使用复合的地方使用了继承，则会不必要地暴露实现细节。这样得到的API会把你限制在原始的实现上，永远限定了类的性能。更为严重的是，由于暴露了内部的细节，客户端就有可能直接访问这些内部细节。这样至少会导致语义上的混淆。例如，如果p指向Properties实例，那么p.getProperty(key)就有可能产生与p.get(key)不同的结果：前者考虑了默认的属性表，而后者是继承自Hashtable的，它则没有考虑默认属性列表。最严重的是，客户有可能直接修改超类，从而破坏子类的约束条件。在Properties的情形中，设计者的目标是，只允许字符串作为键（key）和值（value），但是直接访问底层的Hashtable就可以违反这种约束条件。一旦违反了约束条件，就不可能再使用Properties API的其他部分（load和store）了。等到发现这个问题时，要改正它已经太晚了，因为客户端依赖于使用非字符串的键和值了。

在决定使用继承而不是复合之前，还应该问自己最后一组问题。对于正试图扩展的类，它的API中有没有缺陷呢，如果有，是否愿意把那些缺陷传播到类的API中。继承机制会把超类API中的所有缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。

简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性（fragility）。为了避免这咱脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类时。包装类不仅比子类更加健壮，而且也更加强大。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第17条：要么为继承而设计，并提供文档，要么就禁止继承 P17
关于程序文档有句格言：好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。
对于为了继承而设计的类，唯一的测试方法就是编写子类。如果遗漏了关键的受保护成员，尝试编写子类就会遗漏所带来的痛苦变得更加明显。如果编写了多个子类，并且无一使用受保护的成员，或许就应该把它做成私有的。经验表明，3个子类通常就足以测试一个可扩展的类。除了超类的创建者之外，都要编写一个或者多个这种子类。

为了允许继承，类还必须遵守其他一些约束。构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。如果违反了这条规则，很有可能导致程序失败。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器之前就先被调用。如果该覆盖版本的方法依赖于子类构造器所执行的任何初始化工作，该方法将不会如预期般的执行。举个例子，有个类违反了这条规则：
public class Super {
    // Broken - constructor invokes an overridable method
    public Super() {
        overrideMe();
    }
    
    public void overrideMe() {
    }
}

下面的子类覆盖了方法overrideMe，Super唯一的构造器就错误地调用了这个方法：
public final class Sub extends Super {
    private final Date date;
    
    Sub() {
        date = new Date();
    }
    
    // Overriding method invoked by superclass constructor
    @Override public void overrideMe() {
        System.out.println(date);
    }
    
    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
输出：
null
Sun Jan 15 21:50:37 CST 2017

你可能会期待程序打印出日期两次，但是它第一次打印出的是null，因为overrideMe方法被Super构造器调用的时候，构造器Sub还没有机会初始化date域。注意，这个程序观察到的final域处于两种不同的状态，还要注意，如果overrideMe已经调用了date中的任何方法，当Super构造器调用overrideMe的时候，调用就会抛出NullPointerException异常。如果该程序没有抛出NullPointerException异常，唯一的原因就在于println方法对于处理null参数有着特殊的规定。

如果你决定在一个为了继承而设计的类中实现Cloneable或者Serialiable接口，就应该该意识到，因为clone和readObject方法在行为上非常类似于构造器，所以类似的限制规则也是适用的：无论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。对于readObject方法，覆盖版本的方法将在子类的状态被反序列化（deserialized）之前先被运行；而对于clone方法，覆盖版本的方法则是在子类的clone方法有机会修正被克隆对象的状态之前先被运行。无论哪种情形，都不可避免地将导致程序失败。在clone方法的情形中，这种失败可能会同时损害到原始的对象以及被克隆的对象本身。如，如果覆盖版本的方法假设它正在修改对象深层结构的克隆对象的备份，就会发生这种情况，但是该备份还没有完成。

最后，如果你决定在一个为了继承而设计的类中实现Serializable，并且该类有一个readResolve或者writeReplace方法，就必须使readResolve或者writeReplace成为受保护的方法，而不是私有的方法。如果这些方法是私有的，那么子类将会不声不响地忽略掉这两个方法。这正是“为了允许继承，而把实现细节变成一个类的API的一部分”的另一种情形。

为了继承而设计的类，对这个类会有一些实质性的限制。这并不是很轻松就可以承诺的决定。在某些情况下，这样的决定很明显是正确的，比如抽象类，包括接口的骨架实现（skeletal implementation）（见第18条）。但是，在另外一些情况下，这样的决定却很显示是错误的，如不可变的类（见第15条）。

对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种办法可以禁止子类化。比较容易的办法是把这个类声明为final的。另一种办法是把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器。后一种方法在第15条中讨论过，它为内部使用子类提供了灵活性。这两种办法都是可以接受的。

如果具体的类没有实现标准的接口，那么禁止继承可能会给有些程序员带来为便。如果你认为必须从这样的类继承，一种合理的办法是确保这个类永远不会调用它的任何可覆盖的方法，并在文档中说明这一点。换句话说，完全消除这个类中可覆盖方法的自用特性。这样做之后，就可以创建“能够安全地进行子类化”的类。覆盖方法将永远也不会影响其他任何方法的行为。

你可以机械地消除类中可覆盖方法的自用特性，而不改变它的行为。将每个可覆盖方法的代码体移到一个私有的“辅助方法（helper method）”中，并且让每个可覆盖的方法调用它的私有辅助方法。然后，用“直接调用可覆盖方法的私有辅助方法”来代替“可覆盖方法的每个自用调用”。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第18条：接口优于抽象类 P82
现有的类可以很容易被更新，以实现新的接口。

接口是定义mixin（混合类型）的理想选择。不严格地讲，mixin是指这样的类型：类除了实现它的“基本类型（primary type）”之外，还可以实现这个mixin类型，以表明它提供了某些可供选择的行为。如Comparable是一个mixin接口，它允许类表明它的实例可以与其他的可相互比较的对象进行排序。这样的接口之所以被称为mixin，是因为它允许任选的功能可被混合到类型的主要功能中。抽象类不能被用于定义mixin，同样也是因为它们不能被更新到现有的类中：类不可能有一个以上的父类，类层次结构中也没有适当的地方来插入mixin。

接口允许我们构造非层次结构的类型框架。类型层次对于组织某些事物是非常合适的，但是其他有些事物并不能被整齐地组织成一个严格的层次结构。如，假设有一个接口代表一个singer（歌唱家），另一个接口代表一个songwriter（作曲家）：
public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(boolean hit);
}
现实生活中，有些歌唱家本身也是作曲家。因为我们使用了接口而不是抽象类来定义这些类型，所以对于单个类而言，它同时实现Singer和Songwriter是完全允许的。实际上，我们可以定义第三个接口，同时扩展了Singer和Songwriter，并添加了一些适合于这种组合的新方法：
public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip strum();
    void actSensitive();
}
并不总是需要这种灵活性，但是一旦你这样做了，接口可就成了救世主，能帮助你解决大问题。
通过第16条中介绍的包装类（wrapper class）模式，接口使得安全地增强类的功能成为可能。如果使用抽象类来定义类型，那么程序员除了使用继承的手段来增加功能，没有其他的选择。这样得到的类与包装类相比，功能更差，也更加脆弱。

虽然接口不允许包含方法的实现，但是，使用接口来定义类型并不妨碍你为程序员提供实现上的帮助。通过对你导出的每个重要接口都提供一个抽象的骨架实现（skeletal implementation）类，把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。
按照惯例，骨架实现被称为AbstractInterface，这里的Interface是指所实现的接口的名字。
如，Collections Framework为每个重要的集合接口都提供了一个骨架实现，包括AbstractCollection、AbstractSet、AbstractList和AbstractMap。将它们称为SkeletalCollection、SkeletalSet、SkeletalList和SkeletalMap也是有道理的，但是现在Abstract的用法已经根深蒂固。

如果设计得当，骨架实现可以使程序员很容易提供他们自己的接口实现。如，下面是一个静态工厂方法，它包含一个完整的、功能全面的List实现：
//
package test;

import java.util.AbstractList;
import java.util.List;

public class ListGenerator {
    static List<Integer> intArrayAsList(final int[] a) {
        if (a == null) {
            throw new NullPointerException();
        }

        return new AbstractList<Integer>() {
            @Override
            public Integer get(int index) {
                return a[index];
            }

            @Override
            public Integer set(int index, Integer element) {
                int oldVal = a[index];
                a[index] = element;
                return oldVal;
            }

            @Override
            public int size() {
                return a.length;
            }
        };
    }
}

//
package test;

import org.junit.Test;

import java.util.List;

import static org.junit.Assert.assertEquals;

public class ListGeneratorTest {
    @Test
    public void intArrayAsList() throws Exception {
        List<Integer> integers = ListGenerator.intArrayAsList(new int[]{4, 2, 3});
        assertEquals(3, integers.size());
        assertEquals((long) 4, (long) integers.get(0));
        assertEquals((long) 2, (long) integers.get(1));
        assertEquals((long) 3, (long) integers.get(2));
    }
}

当你考虑一个List实现应该为你完成哪些工作的时候，可以看出，这个例子充分演示了骨架实现的强大功能。这个例子是个Adapter，它允许将int数组看作Integer实现的列表。由于在int值和Integer实例之间来回转换需要开销，它的性能不会很好。注意，这个例子中只提供一个静态工厂，并且这个类还是个不可被访问的匿名类（anonymous class）（见第22条），它被隐藏在静态工厂的内部。

设计公有的接口要非常谨慎。接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。你必须在初次设计的时候就保证接口是正确的。如果接口包含微小的瑕疵，它将会一直影响你以及接口的用户。如果接口具有严重的缺陷，它可以导致API彻底失败。在发行新接口的时候，最好的做法是，在接口被“冻结”之前，尽可能让更多的程序员用尽可能多的方式来实现这个新接口。这样有助于在依然可以改正缺陷的时候就发现它们。

简而言之，接口通常是定义允许多个实现的类型的最佳途径。这条规则有个例外，即当演变的容易性比灵活性和功能更为重要的时候，在这种情况下，应该使用抽象类来定义类型，但前提是必须理解并且可以接受这些局限性。如果你导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类。最后，应该尽可能谨慎地设计所有的公有接口，并通过编写多个实现来对它们进行全面的测试。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第19条：接口只用于定义类型 P86
当类实现接口时，接口就充当可以引用这个类的实例的类型（type）。因此，类实现了接口，就表明客户端可以对这个类的实例实话某些动作。为了任何其他目的而定义的接口是不恰当的。
有一种接口被称为常量接口（constant interface），它不满足上面的条件。这种接口没有包含任何方法，它只包含静态的final域，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名。下面是一个例子：
// Constant interface antipattern - do not use!
package test;

public interface PhysicalConstants {
    // Avogadro's number (1/mol)
    static final double AVOGADROS_NUMBER = 6.02214199e23; //static final is redundant for interface

    // Boltzmann constant (J/K)
    static final double BOLTZMANN_CONSTANT = 1.3806503e-23;

    // Mass of the electron (kg)
    static final double ELECTRON_MASS = 9.10938188e-31;
}

//
package test;

public class ConcretePhysicalConstants implements PhysicalConstants {
    public void show() {
        System.out.println(AVOGADROS_NUMBER); //可以不用加类名，直接使用常量名
        System.out.println(BOLTZMANN_CONSTANT);
        System.out.println(ELECTRON_MASS);
    }
}

//
package test;

import org.junit.Test;

public class PhysicalConstantsTest {

    @Test
    public void testConstants() {
        System.out.println(PhysicalConstants.AVOGADROS_NUMBER);
        System.out.println(PhysicalConstants.BOLTZMANN_CONSTANT);
        System.out.println(PhysicalConstants.ELECTRON_MASS);
    }

    @Test
    public void testConcretePhysicalConstants() {
        System.out.println(ConcretePhysicalConstants.AVOGADROS_NUMBER);
        System.out.println(ConcretePhysicalConstants.BOLTZMANN_CONSTANT);
        System.out.println(ConcretePhysicalConstants.ELECTRON_MASS);
    }

    @Test
    public void testConcreteConstants() {
        ConcretePhysicalConstants concretePhysicalConstants = new ConcretePhysicalConstants();
        concretePhysicalConstants.show();
    }
}
输出：
6.02214199E23
1.3806503E-23
9.10938188E-31
6.02214199E23
1.3806503E-23
9.10938188E-31
6.02214199E23
1.3806503E-23
9.10938188E-31

常量接口模式是对接口的不良使用。类在内部使用某些常量，这纯粹是实现细节。实现常量接口，会导致把这样的实现细节泄露到该类的导出API中。类实现常量接口，这对于这个类的用户来讲并没有什么价值。实际上，这样做反而会使他们更加糊涂。更糟糕的提，它代表了一种承诺：如果在将来的发行版本中，这个类被修改了，它不再需要使用这些常量了，它依然必须实现这个接口，以确保二进制兼容性（什么意思？）。如果非final类实现了常量接口，它的所有子类的命名空间也会被接口中的常量所“污染”。

Java平台类库中有几个常量接口，如java.io.ObjectStreamConstants。这些接口应该被认为是反而的典型，不值得效仿。

如果要导出常量，可以有几种合理的选择方案。如果这些常量与某个现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中。如，在Java平台类库中所有的数值包装类，如Integer和Double，都导出了MIN_VALUE和MAX_VALUE常量。如果这些常量最好被看作枚举类型的成员，就应该用枚举类型（enum type）（见第30条）来导出这些常量。否则，应该使用不可实例化的工具类（utility class）（见第4条）来导出这些常量。下面的例子是前面的PhysicalConstants例子的工具类翻版：
//Constant utility class
package com.effectivejava.science;

public class PhysicalConstants {
    private PhysicalConstants() { } //Prevents instantiation
    public static final double AVOGADROS_NUMBER = 6.02214199e23;
    public static final double BOLTZMANN_CONSTANT = 1.3806503e-23;
    public static final double ELECTRON_MASS = 9.10938188e-31;
}

工具类通常要求客户端要用类名来修饰这些常量名，例如PhysicalConstants.AVOGADROS_NUMBER。如果大量利用工具类导出的常量，可以通过利用静态导入（static import）机制，避免用类名来修饰常量名，不过，静态导入机制是在Java 1.5 才引入的：
// Use of static import to avoid qualifying contants
import static com.effectivejava.science.PhysicalConstants.*;
public class Test {
    double atoms(double mols) {
        return AVOGADROS_NUMBER * mols;
    }
    // Many more uses of PhysicalConstants justify static import
}

简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第20条：类层次优于标签类 P88
有时候，可能会遇到带有两种甚至更多种风格的实例的类，并包含表示实例风格的标签（tag）域。如，考虑下面的类，能够表示圆形或者矩形。
//
package test;

// Tagged class - vastly inferior to a class hierarchy
public class Figure {
    enum Shape {
        RECTANGLE, CIRCLE
    }

    // Tag field - the shape of this figure
    final Shape shape;

    // These fields are used only if shape is RECTANGLE
    double length;
    double width;

    // This field is used only if shape is CIRCLE
    double radius;

    // Constructor for circle

    public Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // Constructor for rectangle

    public Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch (shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError();
        }
    }
}

这种标签类（tagged class）有着许多缺点。它们中充斥着样板代码，包括枚举声明、标签域以及条件语句。由于多个实现乱七八糟地挤在了单个类中，破坏了可读性。内存占用也增加了，因为实例承担着属于其他风格的不相关的域。域不能做成是final的，除非构造器初始化了不相关的域，产生更多的样板代码。构造器必须不借助编译器，来设置标签域，并初始化正确的数据域：如果初始化了错误的域，程序就会在运行时失败。无法给标签类添加风格，除非可以修改它的源文件。如果一定要添加风格，就必须记得给每个条件语句都添加一个条件，否则类就会在运行时失败。最后，实例的数据类型没有提供任何关于其风格的线索。一句话，标签类过于冗长、容易出错，并且效率低下。

面向对象的语言例如Java，就提供了其他更好的方法来定义能表示多种风格对象的单个数据类型：子类型化（subtyping）。标签类正是类层次的一种简单的效仿。
为了将标签类转变成类层次，首先要为标签类中的每个方法都定义一个包含抽象方法的抽象类，这每个方法的行为都依赖于标签值。在Figure类中，只有一个这样的方法：area。这个抽象类是类层次的根（root）。如果还有其他的方法其行为不依赖于标签的值，就把这个方法放在这个类中。同样地，如果所有的方法都用到了某些数据域，就应该把它们放在这个类中。在Figure类中，不存在这种类型独立的方法或者数据域。

接下来，为每种原始标签类都定义根类的具体子类。在前面的例子中，这样的类型有两个：圆形（circle）和矩形（rectangle）。在每个子类中都包含特定于该类型的数据域。以下是与原始的Figure类相对应的类层次：
package test;

abstract class Figure {
    abstract double area(); //抽象方法缺省情况下默认为public
}

class Circle extends Figure {
    final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}

这个类层次纠正了前面提到过的标签类的所有缺点。这段代码简单且清楚，没有包含在原来的版本中所见到的所有样板代码。每个类型的实现都配有自己的类，这些类都没有受到不相关的数据域的拖累。所有的域都是final的。编译器确保每个类的构造器都初始化它的数据域，对于根类中声明的每个抽象方法，都确保有一个实现。这样就杜绝了由于遗漏switch case而导致运行时失败的可能性。多个程序员可以独立地扩展层次结构，并且不用访问根类的源代码就能相互操作。每种类型都有一个相关的独立的数据类型，允许程序员指明变量的类型，限制变量，并将参数输入到特殊的类型。

类层次的另一种好处在于，它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检查。假设上述例子中的标签类也允许表达正方形。类层次可以反映出正方形是一种特殊的矩形这一事实（假设两者都是不可变的）：
class Square extends Rectangle {
    Square(double side) {
        super(side, side);
    }
}
注意，上述层次中的域是被直接访问的，而不是通过访问方法。为了简洁起见才这么做，如果层次结构是公有的（见第14条），则不允许这样做。

简而言之，标签类很少有适用的时候，当你想要编写一个包含显式标签域的类时，应该考虑一下，这个标签是否可以被取消，这个类是否可以用类层次来代替。当你遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第21条：用函数对象表示策略 P91
Java没有提供函数指针，但可以用对象引用实现同样的功能。调用对象上的方法通常是执行该对象（that object）上的某项操作。然而，也可能定义这样一种对象，它的方法执行其他对象（other object）（这些对象被显式传递给这些方法）上的操作。如果一个类仅仅导出这样的一个方法，它的实例实际上就等同于一个指向该方法的指针。这样的实例被称为函数（function object）。如，考虑下面的类：
class StringLengthComparator {
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
}
这个方法是一个比较器，它根据长度来给字符串排序，而不是根据更常用的字典顺序。指向StringLengthComparator对象的引用可以被当作是一个指向该比较器的“函数指针（function pointer）”，可以在任意一对字符串上被调用。换句话说，StringLengthComparator实例是用于字符串比较操作的具体策略（concrete strategy）。
作为典型的具体策略类，StringLengthComparator类是无状态的（stateless）：它没有域，所以这个类的所有实例在功能上都是相互等价的。因此，它作为一个Singleton是非常合适的，可以节省不必要的对象创建开销（见第3条和第5条）：
class StringLengthComparator {
    private StringLengthComparator() {}
    public static final StringLengthComparator INSTANCE = new StringLengthComparator();
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
}

使用StringLengthComparator来传递实例并不好，因为客户端将无法传递任何其他的比较策略。我们需要定义一个Comparator接口，并修改StringLengthComparator来实现这个接口。定义一个策略接口（strategy interface），如下：
// Stragety interface
public interface Comparator<T> {
    public int compare(T t1, T t2);
}
Comparator接口的这个定义也出现在java.util包中，这并不神奇，你自己也完全可以定义它。Comparator接口是泛型（见第26条）的，它适合作为任何其他对象的比较器。它的compare方法的两个参数类型为T（它正常的类型参数），而不是String。
class StringLengthComparator implements Comparator<String> {
    //... 实现同之前一样
}

具体的策略类往往使用匿名类声明（见第22条）。下面的语句对一个字符串数组排序：
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.Comparator;
import java.util.stream.Stream;

public class ComparatorTest {
    @Test
    public void testDefaultStringCompare() {
        String[] strings = new String[]{"is", "a", "good", "today", "day"};
        Arrays.sort(strings);
        Stream.of(strings).forEach(System.out::println);
    }

    @Test
    public void testCustomizedStringCompare() {
        String[] strings = new String[]{"is", "a", "good", "today", "day"};
        Arrays.sort(strings, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.length() - s2.length();
            }
        });

        //可以用如下方法替换
        //Arrays.sort(strings, (s1, s2) -> s1.length() - s2.length());
        //Arrays.sort(strings, Comparator.comparingInt(String::length));
        Stream.of(strings).forEach(System.out::println);
    }
}
输出：
a
day
good
is
today
a
is
day
good
today

但是注意，以这种方法使用匿名类，将会在每次执行调用的时候创建一个新的实例。如果它被重复执行，考虑将函数对象存储到一个私有的静态final域里，并重用它。这样做的另一种好处是，可以为这个函数对象取一个有意义的域名称。

因为策略接口被用做所有具体策略实例的类型，所以我们并不需要为了导出具体策略，而把具体策略类做成公有的。相反，“宿主类（host class）”还可以导出公有的静态域（或者静态工厂方法），其类型为策略接口，具体的策略类可以是宿主类的私有嵌套类。下面的例子使用静态成员类，而不是匿名类，以便允许具体的策略类实现第二个接口Serializable：
package test;

import java.io.Serializable;
import java.util.Comparator;

public class Host {
    private static class StrLenCmp implements Comparator<String>, Serializable {
        @Override
        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }

    public static final Comparator<String> STRING_LENGTH_COMPARATOR = new StrLenCmp(); //如果private static class中无static，则这里不能为静态变量

    // Bulk of class omitted
}
//Arrays.sort(strings, Host.STRING_LENGTH_COMPARATOR);

String类利用这种模式，通过它的CASE_INSENSITIVE_ORDER域，导出一个不区分大小写的字符串比较器。如下：
package test;

import org.junit.Test;

import java.util.Arrays;
import java.util.stream.Stream;

public class ComparatorTest {
    @Test
    public void testDefaultStringCompare() {
        String[] strings = new String[]{"IS", "a", "good", "today", "day"};
        Arrays.sort(strings);
        Stream.of(strings).forEach(System.out::println);
    }

    @Test
    public void testCustomizedStringCompare() {
        String[] strings = new String[]{"IS", "a", "good", "today", "day"};
        Arrays.sort(strings, String.CASE_INSENSITIVE_ORDER);
        Stream.of(strings).forEach(System.out::println);
    }
}
输出：
IS
a
day
good
today
a
day
good
IS
today

简而言之，函数指针的主要用途就是实现策略（Strategy）模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域被导出，其类型为该策略接口。
//------------------------------------------------------------------------------------------------
//Effective Java 第4章 类和接口 P58
//第22条：优先考虑静态成员类 P94
嵌套类（nested class）是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类（enclosing class）提供服务。如果嵌套类将来可能用于其他的某个环境中，它就应该是顶层类（top-level class）。嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。

静态成员类是最简单的一种嵌套类。最好把它看作是普通的类，只是碰巧被声明在另一个类的内部而已，它可以访问外围类的所有成员，包括那些声明为私有的成员。静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才可以被访问等。

静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。例如，考虑一个枚举，它描述了计算器支持的种操作（见第30条）。Operation枚举应该是Calcutor类的公有静态成员类，然后，Calculator类的客户端就可以用诸如Calculator.Operation.PLUS和Calculator.Operator.MINUS这样的名称来引用这些操作。

从语法上讲，静态成员类和非静态成员类之间唯一的区别是，静态成员类的声明中包含修饰符static。尽管它们的语法非常相似，但是这两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个外围实例（enclosing instance）相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。

当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之被建立起来；而且，这种关联关系以后不能被修改。通常情况下，当在外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关联关系被自动建立起来。使用表达式enclosingInstance.new MemberClass(args)来手工建立这种关联关系也是有可能的，但是很少使用。这种关联关系需要消耗非静态成员类实例的空间，并且增加了构造的时间开销。

非静态成员类的一种常见用法是定义一个Adapter，它允许外部类的实例被看作是另一个不相关的类的实例。如，Map接口的实例往往使用非静态成员类来实例它们的集合视图（collection view），这些集合视图是由Map的keySet、entrySet和Values方法返回的。同样，如Set和List这种集合接口的实例往往也使用非静态成员类来实现它们的迭代器（iterator）：
// Typical use of a nonstatic member class
public class MySet<E> extends Abstract<E> {
    //... Bulk of the calss ommited
    
    public Iterator<E> iterator() {
        return new MyIterator();
    }
    
    private class MyIterator implements Iterator<E> {
        //...
    }
}

如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成员静态成员类，而不是非静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保丰这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收（见第6条）时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就不能使用非静态成员类，因为非静态成员类的实例必须要有一个外围实例。

私有静态成员类的一种常见用法是用来代表外围类的对象的组件。如，考虑一个Map实例，它把键（key）和值（value）关联起来。许多Map实例的内部都有一个Entry对象，对应于Map中的每个键-值对。虽然每个entry都与一个Map关系，但是entry上的方法（getKey、getValue和SetValue）并不需要访问该Map。因此，使用非静态成员来表示entry是很浪费的：私有的静态成员类是最佳的选择。如果不小心漏掉了entry声明中的static修饰符，该Map仍然可以工作，但是每个entry中将会包含一个指向该Map的引用，这样就浪费了空间和时间。

如果相关的类是导出类的公有的或者受保护的成员，则在静态和非静态成员类之间做出正确的选择是非常重要的。在这种情况下，该成员类就是导出的API元素，在后续发行版本中，如果不违反二进制兼容性，就不能从非静态成员类变为静态成员类。

匿名类不同于Java程序设计语言中的其他任何语法单元，没有名字。它不是外围类的一个成员。它并不与其他成员一起被声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它才有外围实例。但是即便它们出现在静态的环境中，也不可能拥有任何静态成员。（无法引用，所以静态成员用不到？）

匿名类的适用性受到诸多的限制。除了在它们被声明的时间之外，是无法将它们实例化的。不能执行instanceof测试，或者做任何需要命名类的其他事情。无法声明一个匿名类实现多个接口，或者扩展一个类，并同时扩展类和实现接口。匿名类的客户端无法调用任何成员，除了从它的超类型中继承得到之外。由于匿名类出现在表达式当中，它们必须保持简短――大约10行或者更少些――否则会影响程序的可读性。

匿名类的一种常见用法是动态的创建函数对象（function object，见第21条）。如，第92页中的sort方法调用，利用匿名的Comparator实例，根据一组字符串的长度对它们进行排序。匿名类的另一种常见用法是创建过程对象（process object），比如Runnable、Thread或者TimerTask实例。第三种常见的用法是在静态工厂方法的内部（参见第18条中的intArrayAsList方法）。

局部类是四种嵌套类中用得最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。局部类与其他三种嵌套类中的每一种都有一些共同的属性。与成员类一样，局部类有名字，可以被重复地使用。与匿名类一样，只有当局部类是在非静态环境中定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样，它们必须非常简短，以便不影响到可读性。

简而言之，四种嵌套类，第一种都有自己的用途。如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类特征，就要把它做成匿名类；否则，就做成局部类。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
Java 1.5 发行版本中增加了泛型（Generic）。

//第23条：不要在新代码中使用原生态类型 P97
声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。

每种泛型定义一组参数化的类型（parameterized type），构成格式为：先是类或者接口的名称，接着用尖括号（<>）把对应于泛型形式类型参数的实际参数列表括起来。

最后，每个泛型都定义一个原生态类型（raw type），即不带任何实际类型参数的泛型名称。如，与List<E>相对应的原生态类型是List。原生态类型就像从类型声明中删除了所有泛型信息一样。实际上，原生态类型List与Java平台没有泛型之前的接口类型List完全一样。

有了泛型，就可以利用改进后的类型声明来代替集合中的注释，告诉编译器之前的注释中所隐含的信息：
// Parameterized collection type - typesafe
private final Collection<Stamp> stamps = ...;
通过这条声明，编译器知道stamps应该只包含Stamp实例，并给予保证。

虽然假设不小心将coin插入到stamp集合中可能显得有点牵强，但这类问题却是真实的。如，很容易想像有人会不小心将一个java.util.Date实例放进一个原本只包含java.sql.Date实例的集合中。

如上所述，如果不提供类型参数，使用集合类型和其他泛型也仍然是合法的，但是不应该这么做。如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。允许使用原生态类型，是为了提供兼容性。泛型出现的时候，已经存在大量没有使用泛型的Java代码。人们认为让所有这些代码保持合法，并且能够与使用泛型的新代码互用。它必须合法，才能将参数化类型的实例传递给那些被设计成使用普通类型的方法，反之亦然。这种需求被称作移植兼容性（Migration Compatibility），促成了支持原生态类型的决定。

虽然不应该在新代码中使用像List这样的原生态类型，使用参数化的类型以允许插入任意对象，如List<Object>，这还是可以的。原生态类型List和参数化的类型List<Object>之间区别，不严格地说，前者逃避了泛型检查，后者则明确告知编译器，它能够持有任意类型的对象。虽然可以将List<String>传递给类型List的参数，但是不能将它传给类型List<Object>的参数。泛型有子类型化（subtyping）的规则，List<String>是原生态类型List的一个子类型，而不是参数化类型List<Object>的子类型（见第25条）。因此，如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会。
//
package test;

import java.util.ArrayList;
import java.util.List;

public class GenericTest {
    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        unsafeAdd(strings, new Integer(42));
        String s = strings.get(0);
    }

    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }
}

程序可以进行编译，但是因为它使用了原生态类型List，会收到一条警告：
E:\Program Files\JetBrains\JavaProject\JUnitProject\src\main\java\test\GenericTest.java
Information:java: E:\Program Files\JetBrains\JavaProject\JUnitProject\src\main\java\test\GenericTest.java使用了未经检查或不安全的操作。
Information:java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。

实际上，如果运行这段程序，在程序试图将strings.get(0)的调用结果转换成一个String时，会收到一个ClassCastException异常。这是一个编译器生成的转换，因此一般保证会成功，但我们在例子中忽略了一条编译器警告，就会为此而付出代价。

如果在unsafeAdd声明中用参数化类型List<Object>代替原生态类型List，并试着重新编译这段程序，会发现它无法再进行编译了。
    private static void unsafeAdd(List<Object> list, Object o) {
        list.add(o);
    }
Error:(9, 19) java: 不兼容的类型: java.util.List<java.lang.String>无法转换为java.util.List<java.lang.Object>

在不确定或者不在乎集合中的元素类型的情况下，也许会使用原生态类型。如，假设想要编写一个方法，它有两个集合（set），并从中返回它们共有的元素的数量。如果对泛型还不熟悉的话，可以参考以下方式来编写这种方法：
package test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GenericTest {
    public static void main(String[] args) {
        Set<String> strings1 = new HashSet<>();
        strings1.addAll(Arrays.asList("d", "e", "f"));

        Set<String> strings2 = new HashSet<>();
        strings2.addAll(Arrays.asList("c", "d", "f", "a"));

        int sameStringCount = numElementsInCommon(strings1, strings2);
        System.out.println(sameStringCount);


        Set<Integer> integers1 = new HashSet<>();
        integers1.addAll(Arrays.asList(1, 2, 3));

        Set<Integer> integers2 = new HashSet<>();
        integers2.addAll(Arrays.asList(4, 1, 5));

        int sameIntCount = numElementsInCommon(integers1, integers2);
        System.out.println(sameIntCount);
    }

    // Use of raw type for unknown element type - don't do this!
    private static int numElementsInCommon(Set s1, Set s2) {
        int result = 0;
        for (Object o1 : s1) {
            if (s2.contains(o1)) {
                ++result;
            }
        }
        return result;
    }
}
输出：
2
1

这个方法倒是可以，但它使用了原生态类型，这是很危险的。从Java 1.5 发行版本开始，Java就提供了一种安全的替代方法，称作无限制的通配符类型（unbounded wildcard type）。如果要使用泛型，但不确定或者不关心实际的类型参数，就可以使用一个问号代替。如，泛型Set<E>的无限制通配符类型为Set<?>（读作“某个类型的集合”）。这是最普通的参数化Set类型，可以持有任何集合。下面是numElementsInCommon方便使用无限制通配符类型时的情形：
    // Unbounded wildcard type - typesafe and flexible
    private static int numElementsInCommon(Set<?> s1, Set<?> s2) {
        int result = 0;
        for (Object o1 : s1) {
            if (s2.contains(o1)) {
                ++result;
            }
        }
        return result;
    }
    
无限制通配符类型Set<?>和原生态类型Set之间区别，通配符类型是安全的，原生态类型则不安全。由于可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件；但不能将任何元素（除了null之外）放到Collection<?>中。如果尝试这么做的话，会产生一条像这样的编译错误消息：
WildCard.java:13: cannot find symbol
symbol: method add(String)
location: interface Collection<capture#825 of ?>
    c.add("verboten");
      ^

（但是这样写将编译不过：
Set<?> strings1 = new HashSet<>(); //不能声明为?类型，并且加入对象
strings1.addAll(Arrays.asList("d", "e", "f"));）

这样的错误消息，编译器已经尽到了它的职责，防止你破坏集合的类型约束条件。不仅无法将任何元素（除了null之外）放进Collection<?>中，而且根本无法猜测你会得到哪种类型的对象。要是无法接受这些限制，就可以使用泛型方法（generic method，见第27条）或者有限制的通配符类型（bounded wildcard type，见第28条）。

不要在新代码中使用原生态类型，这条规则有两个小小的例外，两者源于“泛型信息可以在运行时被擦除”（见第25条）这一事实。在类文字（class literal）中必须使用原生态类型。规范不允许使用参数化类型（虽然允许数组类型和基本类型）。换句话说，List.class， String[].class和int.class都合法，但是List<String>.class和List<?>.class则不合法。

这条规则的第二个例外与instanceof操作符有关。由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用instanceof操作符是非法的。用无限制通配符类型代替原生态类型，对instanceof操作符的行为不会产生任何影响。在这种情况下，尖括号(<>)和问题(?)就显得多余了，下面是利用泛型来使用instanceof操作符的首先方法：
// Legitimate use of raw type - instanceof operator
if (o instanceof Set) {     // Raw type
    Set<?> m = (Set<?>) o;  // Wildcard type
    //...
}
注意，一旦确定这个o是个Set，就必须将它转换成通配符类型Set<?>，而不是转换成原生态类型Set。这是个受检的（checked）转换，因此不会导致编译时警告。

总之，使用原生态类型会在运行时导致异常，因此不要在新代码中使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。做个快速的回顾：Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；Set则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第24条：消除非受检警告 P103
有些警告比较难以消除。要尽可能地消除每一个非受检警告。如果消除了所有警告，就可以确保代码是类型安全的。这意味着不会在运行时出现ClassCastException异常，你会更加自信自己的程序可以实现预期的功能。

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下才）可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。如果在禁止警告之前没有先证实代码是类型安全的，那就只是给你自己一种错误的安全感而已。代码在编译的时候可能没有出现任何警告，但它在运行时仍然会抛出ClassCastException异常。但是如果忽略（而不是禁止）明知道是安全的非受检警告，那么当新出现一条真正有问题的警告时，你也不会注意到。新出现的警告就会淹没在所有的错误警告中。

SuppressWarnings注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围中使用SuppressWarnings注解。它通常是个变量声明，或是非常简短的方法或者构造器。永远不要在整个类上使用SuppressWarnings，这可能会掩盖了重要的警告。

如果发现在长度不止一行的方法或者构造器中使用了SuppressWarnings注解，可以将它移到一个局部变量的声明中。虽然必须声明一个新的局部变量，不过这么做还是值得的。如，考虑ArrayList类当中的toArray方法：
public <T> T[] toArray(T[] a) {
    if (a.length < size)
        return (T[]) Arrays.copyOf(elements, size, a.getClass());
    System.arraycopy(elements, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}

如果编译ArrayList，该方法会产生成这条警告：
ArrayList.java:305: warning: [unchecked] unchecked cast found : Object[], required: T[]
    return (T[]) Arrays.copyOf(elements, size, a.getClass());
                              ^
将SuppressWarnings注解放在return语句中是非法的，因为它不是一个声明。可以试着将注解放在整个方法上，但是在实践中千万不要这么做，而是应该声明一个局部变量来保存返回值，并注解其声明，像这样：
public <T> T[] toArray(T[] a) {
    if (a.length < size) {
        // This cast is correct because the array we're creating is of the same type as the one passed in, which is T[].
        @SuppressWarnings("unchecked") T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());
        return result;
    }
    System.arraycopy(elements, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
这个方法可以正确地编译，禁止非受检警告的范围也减到了最小。

每当使用SuppressWarnings("unchecked")注解时，都要添加一条注释，说明为什么这么做是安全的。这样可以帮助其他人理解代码，更重要的是，可以尽量减少其他人修改代码后导致计算不安全的概率。如果觉得这种注释很难编写，就要多加思考，最终会发现非受检操作是非常不安全的。

总之，非受检警告很重要，不要忽略它们。每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力消除这些警告。如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的，就可以在尽可能小的范围中，用@SuppressWarnings("unchecked")注释禁止该警告。要用注释把禁止该警告的原因记录下来。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第25条：列表优先于数组 P105
数组与泛型相比，有两个重要不同点。首先，数组是协变的（convariant）。表示如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型，相反，泛型则是不可变的（invariant）：对于任意两个不同的类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是List<Type2>的超类型。你可能认为，这意味着泛型是有缺陷的，实际上可以说数组才是有缺陷的。
下面的代码片段是合法的：
// Fails at runtime!
Object[] objectArray = new Long[1];
objectArray[0] = "I don't fit in"; // Throws ArrayStoreException

但下面这段代码则不合法：
// Won't compile!
List<Object> o1 = new ArrayList<Long>(); // 编译报错，Incompatible types
o1.add("I don't fit in");
这其中无论哪种方法，都不能将String放进Long容器中，但是利用数组，会在运行时发现所犯的错误；利用列表，则可以在编译时发现错误。当然希望在编译时发现错误了。

数组与泛型的第二大区别在于，数组是具体化的（reified）。因此数组会在运行时才知道并检查它们的元素类型约束。如上所述，如果企图将String保存到Long数组中，就会得到一个ArrayStoreException异常。相比之下，泛型则是通过擦除（erasure）来实现的。因此泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用（见第23条）。

由于上述这些根本的区别，因此数组和泛型不能很好的混合使用。如，创建泛型、参数化类型或者类型参数的是非法的。这些数组创建表达式没有一个是合法的：new List<E>[]、new List<String>[]和new E[]。这些在编译时都会导致一个generic array creation（泛型数组创建）错误。

创建泛型数组是非法的，因为它不是类型安全的。要是它合法，编译器在其他正确的程序中民生的转换就会在运行时失败，并出现一个ClassCastException异常。这就违背了泛型系统提供的基本保证。

从技术上角度来说，像E、List<E>和List<String>这样的类型应称作不可具体化的（non-reifiable）类型。不可具体化的（non-reifiable）类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具体化的（reifiable）参数化类型是无限制的通配符类型，如List<?>和Map<?, ?>（见第23条）。虽然不常用，但是创建无限制通配符的数组是合法的。

禁止创建泛型数组，这表明泛型一般不可能返回它的元素类型数组（部分解决方案请见第29条）。这也意味着在结合使用可变参数（varargs）方法（见第42条）和泛型时会出现令人费解的警告。这是由于每当调用可变参数方法时，就会创建一个数组来存在varargs参数。如果这个数组的元素类型不是可具体化的（reifiable），就会得到一条警告。关于这些警告，除了把它们禁止（见第24条），并且避免在API中混合使用泛型与可变参数之外，别无他法。

当得到泛型数组创建错误时，最好的解决方法通常是优先使用集合类型List<E>，而不是数组类型E[]。这样可能会损失一些性能或者简洁性，但是换回的却是更高的类型安全性和互用性。

用列表代码数组。下面的reduce方法编译时就没有任何错误或者警告：
// List-based generic reduction
static <E> E reduce(List<E> list, Function<E> f, E initVal) {
    List<E> snapshot;
    synchronized(list) {
        snapshot = new ArrayList<E>(list);
    }
    E result = initVal;
    for (E e : snapshot) {
        result = f.apply(result, e);
    }
    return result;
}
这个版本的代码比数组版的代码稍微冗长一点，但是可以确定在运行时不会得到ClassCastException异常，为此也值了。
总之，数组和泛型有着非常不同的类型规则。数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型提供了编译时的类型安全，没有运行时类型安全。一般来说，数组和泛型不能很好的混合使用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，第一反应是应该用列表代替数组。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第26条：优先考虑泛型 P109
一般来说，将集合声明参数化，以及使用JDK所提供的泛型和泛型方法，这些都不太困难。编写自己的泛型会比较困难一些，但是值得花些时间去学习如何编写。
考虑第6条的简单的堆栈实现：（搜索public class Stack）
这个类是泛型化（generification）的主要备选对象，换句话说，可以适当地强化这个类来利用泛型。根据实际情况来看，必须转换从堆栈里弹出的对象，以及可能在运行时失败的那些转换。将类泛型化的第一个步骤是给它的声明添加一个或者多个类型参数。在这个例子中有一个类型参数，它表示堆栈的元素类型，这个参数的名称通常为E（见第44条）。

下一步是用相应的类型参数替换所有的Object类型，然后试着编译最终的程序：
// Initial attempt to generify Stack = won't compile!
package test;

import java.util.Arrays;
import java.util.EmptyStackException;

public class Stack<E> {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new E[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E o) {
        ensureCapacity();
        elements[size++] = o;
    }

    public E pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        E result = elements[--size];
        elements[size] = null;
        return result;
    }

    public int size() {
        return size;
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
通常将至少得到一个错误或者警告，这个类也不例外。幸运的是，这个类只产生一个错误，如下：
elements = new E[DEFAULT_INITIAL_CAPACITY];
Error:(12, 20) java: 创建泛型数组

如第25条所述，不能创建不可具体化的（non-reifiable）类型的数组，如E。每当编写用数组支持的泛型时，都会出现这个问题。解决这个问题的两种方法。第一种，直接绕过创建泛型数组的禁令：创建一个Object的数组，并将它转换成泛型数组类型。现在错误是消除了，但是编译器会产生一条警告。这种用法是合法的，但（整体上而言）不是类型安全的：
public Stack() {
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}

编译器不可能证明你的程序是类型安全的，但是你可以证明。你自己必须确保未受检的转换不会危及到程序的类型安全性。相关的数组（即elements变量）保存在一个私有的域中，永远不会被返回到客户端，或者传给任何其他方法。这个数组中保存的唯一元素，是传给push方法的那些元素，它们的类型为E，因此未受检的转换不会有任何危害。

一旦证明了未受检的转换是安全的，就要在尽可能小的范围中禁止警告（见第24条）。在这种情况下，构造器只包含未受检的数组创建，因此可以在整个构造器中禁止这条警告。通过增加一条注解来完成禁止，Stack能够正确无误地进行编译，就可以使用它了，无需显式的转换，也无需担心会出现ClassCastException异常：
// The elements array will contain only E instances from push(E).
// This is sufficient to ensure type safety, but the runtime
// type of the array won't be E[]: it will always be Objects[]!
@SuppressWarnings("unchecked")
public Stack() {
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}

消除Stack中泛型数组创建错误的第二种方法是，将elements域的类型从E[]改为Object[]。这么做会得到一条不同的错误：
E result = elements[--size];
Error:(24, 28) java: 不兼容的类型: java.lang.Object无法转换为E

通过把从数组中获取到的元素由Object转换成E，可以将这条错误变成一条警告：
unchecked cast:
E result = (E) elements[--size];

由于E是一个不可具体化的（non-reifiable）类型，编译器无法在运行时检验转换。你还是可以自己证实未受检的转换是安全的，因此可以禁止该警告。根据第24条建议，只要在包含未受检转换的任务上禁止警告，而不是在整个pop方法上就可以了，如下：
public E pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }

    @SuppressWarnings("unchecked")
    E result = (E) elements[--size];
    
    elements[size] = null;
    return result;
}

具体选择这两种方法中的哪一种来处理泛型数组创建错误，主要看个人偏好。所有其他的东西都一样，但是禁止数组类型的未受检转换比禁止标题类型（scalar type）的更加危险，所以建议采用第二种方案。但是在比Stack更实际的泛型类中，或许代码中会有多个地方需要从数组中读取元素，因此选择第二种方案需要多次转换成E，而不是只转换成E[]，这也是第一种方案之所以更常用的原因。

看来上述的示例与第25条相矛盾了，第25条鼓励优先使用列表而非数组。实际上并不可能总是或者总想在泛型中使用列表。Java并不是生来就支持列表，因此有些泛型如ArrayList，则必须在数组上实现。为了提升性能，其他泛型如HashMap也在数组上实现。

绝大多数泛型就像我们的Stack示例一样，因为它们的类型参数没有限制，可以创建Stack<Object>、Stack<int[]>、Stack<List<String>>，或者任何其他对象引用类型的Stack。注意不能创建基本类型的Stack：企图创建Stack<int>或者Stack<double>会产生一个编译时错误。这是Java泛型系统根本的局限性。可以通过使用基本包装类型（boxed primitive type）来避开这条限制（见第49条）。

有些泛型限制了可允许的类型参数值。如，考虑java.util.concurrent.DelayQueue，其声明如下：
class DelayQueue<E extends Delayed> implements BlockingQueue<E>;

类型参数列表（<E extends Delayed>）要求实际的类型参数E必须是java.util.concurrent.Delayed的一个子类型。它允许DelayQueue实现及其客户端在DelayQueue的元素上利用Delayed方法，无需显式的转换，也没有出现ClassCastException的风险。类型参数E被称作有限制的类型参数（bounded type parameter）。注意，子类型关系确定了，每个类型都是它自身的子类型，因此创建DelayQueue<Delay>是合法的。

总而言之，使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的。只要时间允许，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端（见第23条）。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第27条：优先考虑泛型方法 P113
如类可以从泛型中受益一样，方法也一样。静态工具方法尤其适合于泛型化。Collections中的所有“算法”方法（例如binarySearch和sort）都泛型化了。

编写泛型方法与编写泛型类型相类似。如下面的方法，返回两个集合的联合：
package test;

import java.util.HashSet;
import java.util.Set;

public class GenericMethodTest {
    public static Set union(Set s1, Set s2) {
        Set result = new HashSet(s1);
        result.addAll(s2);
        return result;
    }
}
这个方法可以编译，但是有两条警告。
Information:java: E:\Program Files\JetBrains\JavaProject\JUnitProject\src\main\java\test\GenericMethodTest.java使用了未经检查或不安全的操作。
Information:java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。

为了修正这些警告，使方法变成是类型安全的，要将方法声明修改为声明一个类型参数。声明类型参数的类型参数列表，处在方法的修饰符及其返回类型之间。在这个示例中，类型参数列表为<E>，返回类型为Set<E>。类型参数的命名惯例与泛型方法以 及泛型的相同（见第26条和第44条）。

// Generic method
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}

至少对于简单的泛型方法而言，就这么回事了。现在该方法编译时不会产生任何警告，并提供了类型安全性，也更容易使用。以下是一个执行该方法的简单程序。程序中不包含转换，编译时不会有错误或者警告：
package test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GenericMethodTest {
    // Generic method
    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    // Simple program to exercise generic method
    public static void main(String[] args) {
        Set<String> guys = new HashSet<>(Arrays.asList("Tom", "Dick", "Harry"));
        Set<String> stooges = new HashSet<>(Arrays.asList("Larry", "Moe", "Dick"));
        Set<String> aflCio = union(guys, stooges);
        System.out.println(aflCio);
    }
}
输出：
[Moe, Tom, Harry, Larry, Dick]

union方法的局限性在于，三个集合的类型（两个输入参数和一个返回值）必须全部相同。利用有限制的通配符类型（bounded wildcard type），可以使这个方法变得更加灵活（见第28条）。

泛型方法的一个显著特性是，无需明确指定类型参数的值，不像调用泛型构造器的时候是必须指定的。编译器通过检查方法参数的类型来计算类型参数的值。对于上述的程序而言，编译器发现union的两个参数都是Set<String>类型，因此知道类型参数E必须为String。这个过程称作类型推导（type inference）。

如第1条所述，可以利用泛型方法调用所提供的类型推导，使创建参数化类型实例的过程变得轻松。提醒一下，在调用泛型构造器的时候，要明确传递类型参数的值可能有点麻烦。类型参数出现在了变量声明的左右两边，显得有些冗余：
// Parameterized type instance creation with constructor
Map<String, List<String>> anagrams = new HashMap<String, List<String>>(); //当前1.8版本右边参数并不需要提供

为了消除这种冗余，可以编写一个泛型静态工厂方法（generic static factory method），与想要使用的每个构造器相对应。例如，下面是一个与无参的HashMap构造器相对应的泛型静态工厂方法：
// Generic static factory method
public static <K, V> HashMap<K, V> newHashMap() {
    return new HashMap<K, V>();
}

通过这个泛型静态方法，可以用下面这段简洁的代码来取代上面那个重复的声明：
// Parameterized type instance creation with static factory
Map<String, List<String>> anagrams = newHashMap();

在泛型上调用构造器，如果语言所做的类型推导与调用泛型方法时所做的相同，那就好了。截至Java 1.6 发行版本还不行。（Java 1.8 已经可以， 1.7 是否支持不确定）

相关的模式是泛型单例工厂（generic singleton factory）。有时，会需要创建不可变但又适合于许多不同类型的对象。由于泛型是通过擦除（见第25条）实现的，可以给所有必要的类型参数使用单个对象，但是需要编写一个静态工厂方法，重复地给每个必要的类型参数分发对象。这种模式最常用于函数对象（见第21条），如Collection.reverseOrder，但也适用于像Collections.emptySet这样的集合。

假设且个接口，描述了一个方法，该方法接受和返回某个类型T值：
package test;

public interface UnaryFunction<T> {
    T apply(T arg);
}


现在假设要提供一个恒等函数（identity function）。如果在每次需要的时候都重新创建一个，这样会很浪费，因为它是无状态的（stateless）。如果泛型被具体化了，每个类型都需要一个恒等函数，但是它们被擦除以后，就只需要一个泛型单例。请看以下示例：
package test;

import java.util.stream.Stream;

public class GenericSingletonFactory {
    // Generic singleton factory pattern
    private static UnaryFunction<Object> IDENTITY_FUNCTION = new UnaryFunction<Object>() {
        @Override
        public Object apply(Object arg) {
            return arg;
        }
    };

    // IDENTITY_FUNCTION is stateless and its type parameter is
    // unbounded so it's safe to share one instance across all types
    @SuppressWarnings("unchecked")
    public static <T> UnaryFunction<T> identityFunction() {
        return (UnaryFunction<T>) IDENTITY_FUNCTION;
    }

    // Sample program to exercise generic singleton
    public static void main(String[] args) {
        String[] strings = {"jute", "hemp", "nylon"};
        UnaryFunction<String> sameString = identityFunction();
        Stream.of(strings).map(e -> sameString.apply(e)).forEach(System.out::println);

        UnaryFunction<Number> sameNumber = identityFunction();
        Stream.of(1, 2.0, 3L).map(e -> sameNumber.apply(e)).forEach(System.out::println);
    }
}
输出：
jute
hemp
nylon
1
2.0
3

IDENTITY_FUNCTION转换成（UnaryFunction<T>），产生了一条未受检的转换警告，因为UnaryFunction<Object>对于每个T来说并非都是个UnaryFunction<T>。但是恒等函数很特殊：它返回未被修改的参数，因此我们知道无论T的值是什么，用它作为UnaryFunction<T>都是类型安全的。因此，可以放心地禁止由这个转换所产生的未受检转换警告。一旦禁止，代码在编译时就会出现任何错误或者警告。

虽然相对少见，但是通过某个包含该类型参数本身的表达式来限制类型参数是允许的。这就是递归类型限制（recursive type bound）。递归类型限制最普遍的用途与Comparable接口有关，它定义类型的自然顺序：
public interface Comparable<T> {
    int compareTo(T o);
}

类型参数T定义的类型，可以与实现Comparable<T>的类型的元素进行比较。实际上，几乎所有的类型都只能与它们自身的类型的元素相比较。因此。例如String实例Comparable<String>，Integer实现Comparable<Integer>，等。

有许多方法都带有一个实现Comparable接口的元素列表，为了对列表进行排序，并在其中进行搜索，计算出它的最小值或者最大值，等等。要完成这其中的任何一项工作，要求列表中的每个元素要都能够与列表中的每个其他元素相比较，换句话说，列表的元素可以互相比较（mutually comparable）。下面是如何表达这种约束条件的一个示例：
// Using a recursive type bound to express mutual comparability
public static <T extends Comparable<T>> T max(List<T> list) {...}

类型限制<T extends Comparable<T>>，可以读作“针对可以与自身进行比较的每个类型T”，这与互比性的概念或多或少有些一致。

下面的方法就带有上述声明。它根据元素的自然顺序计算列表的最大值，编译时没有出现错误或者警告：
package test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class GenericTest {
    public static <T extends Comparable<T>> T max(List<T> list) { //如果把类型限制写为<T>，则编译错误无法解析方法t.compareTo
        Iterator<T> i = list.iterator();
        T result = i.next();
        while (i.hasNext()) {
            T t = i.next();
            if (t.compareTo(result) > 0) {
                result = t;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<String> strings = Arrays.asList("hello", "good", "day");
        System.out.println(max(strings));

        List<Integer> integers = Arrays.asList(5, 3, 8);
        System.out.println(max(integers));

        // 未判断List是否为空，会抛出异常
//        strings = new ArrayList<>();
//        System.out.println(max(strings));
    }
}
输出：
hello
8

递归类型限制可能比这个要复杂得多，幸运的是，这种情况并不经常发生。如果理解了这种习惯用法及其通配符变量（见第28条），就能够处理在实践中遇到的许多递归类型限制了。

总之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也更加容易。就像类型一样，应该确保新方法可以不用转换就能使用，这通常意味着要将它们泛型化。并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会破坏现有的客户端。（见第23条）
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第27条：利用有限制通配符来提升API的灵活性 P117
有时候，我们需要的灵活性要比不可变类型所能提供的更多。考虑第26条中的堆栈，下面是它的公共API：
public class Stack<E> {
    public Stack();
    public void push(E e);
    public E pop();
    public boolean isEmpty();
}

假设想要增加一个方法，让它按顺序将一系列元素全部放到堆栈中。第一次尝试：
// pushAll method without wildcard type deficient!
public void pushAll(Iterable<E> src) {
    for (E e : src) {
        push(e);
    }
}

这个方法编译时正确无误，但是并非尽如人意。如果Iterable src的元素类型与堆栈的完全匹配，就没有问题。但是假如一个Stack<Number>，并且调用了push(intVal)，这里的intVal就是Integer类型，这是可以的，因为Integer是Number的一个子类型。因此从逻辑上来说，下面的这个方法应该也可以：
Stack<Number> numberStack = new Stack<Number>();
Iterable<Integer> integers = ...;
numberStack.pushAll(integers);

如果尝试这么做，就会得到下面的错误消息，如前所述，参数化类型是不可变的：
pushAll(Iterable<Number>) in Stack<Number> cannot be applied to (Iterable<Integer)

//
package test;

import java.util.Arrays;
import java.util.EmptyStackException;
import java.util.List;

public class Stack<E> {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    @SuppressWarnings("unchecked")
    public Stack() {
        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E o) {
        ensureCapacity();
        elements[size++] = o;
    }

    public void pushAll(List<E> src) { // 书中这里写的有问题，Iterable<E>对象，不能用for (E e : src)来遍历
        for (E e : src) {
            push(e);
        }
    }

    public E pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        E result = elements[--size];
        elements[size] = null;
        return result;
    }

    public int size() {
        return size;
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }

    public static void main(String[] args) {
        Stack<Number> numberStack = new Stack<>();
        numberStack.push(3);
        List<Integer> integers = Arrays.asList(4, 5, 6);
        numberStack.pushAll(integers); //编译错误。但是这里如果直接写pushAll(Arrays.asList(4, 5, 6))是可以编译和运行过的，asList中的T参数化为Number类型
    }
}

幸运的是，有一种解决办法。Java提供了一种特殊的参数化类型，称作有限制的通配符类型（bounded wildcard type），来处理类似的情况。pushAll的输入参数类型不应该为“E的Iterable接口”，而应该为“E的某个子类型的Iterable接口”，有一个通配符类型正符合此间：Iterable<? extends E>。（使用关键字extends有些误导：回忆一下第26条中的说法，确定了子类型（subtype）后，每个类型都是自身的子类型，即便它没有将自身扩展。）修改pushAll来使用这个类型：
// Wildcard type for parameter that serves as an E producer
public void pushAll(List<? extends E> src) {
    for (E e : src) {
        push(e);
    }
}
这个函数同样可以写成如下形式，不过T类型在此函数中并无用处，所以可以用?通配符来代替T类型
public <T extends E> void pushAll(List<T> src) {
    for (E e : src) {
        push(e);
    }
}

修改了之后，不仅Stack可以正确无误地编译，没有通过初始的pushAll声明进行编译的客户端代码也一样可以。因为Stack及其客户端正确无误地进行了编译，就知道一切都是类型安全的了。

现在假设想要编写一个popAll方法，使之与pushAll方法相呼应。popAll方法从堆栈中弹出每个元素，并将这些元素添加到指定的集合中。
通配符类型同样提供了一种解决办法。popAll的输入参数类型不应该为“E的集合”，而应该为“E的某种超类的集合”（这里的超类是确定的，因此E是它自身的一个超类型）。仍然有一个通配符类型正是符合此意：Collection<? super E>。修改popAll来使用它：
package test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.EmptyStackException;
import java.util.List;

public class Stack<E> {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    @SuppressWarnings("unchecked")
    public Stack() {
        elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E o) {
        ensureCapacity();
        elements[size++] = o;
    }

    public <T extends E> void pushAll(List<T> src) {
        for (E e : src) {
            push(e);
        }
    }

    public E pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        E result = elements[--size];
        elements[size] = null;
        return result;
    }

    public void popAll(Collection<? super E> dst) {
        while (!isEmpty()) {
            dst.add(pop());
        }
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }

    public static void main(String[] args) {
        Stack<Number> numberStack = new Stack<>();
        numberStack.push(3);
        List<Integer> integers = Arrays.asList(4, 5, 6);
        numberStack.pushAll(integers);

        List<Object> objects = new ArrayList<>();
        numberStack.popAll(objects);
        System.out.println(objects);
    }
}
输出：
[6, 5, 4, 3]

做了这个变动之后，Stack和客户端代码就都可以正确无误地编译了。

结论很明显。为了获得最大限度的灵活性，在要表示生产者或者消费者的输入参数上使用通配符类型。如果鞯个输入参数既是生产者，又是消费者，那么通配符类型对你就没有什么好处了：因为你需要的是严格的类型匹配，这是不用任何通配符而得到的。

下面的助词符便于让你记住要使用哪种通配符类型：
PECS表示 producer-extends, consumer-super 。

如果参数化类型表示一个T生产者，就使用<? extends T>；如果它表示一个T消费者，就使用<? super T>。（我的理解是，生产者就是往外出对象；消费者就是往里面进对象。）在Stack示例中，pushAll的src参数产生E实例供Stack使用，因此src相应的类型为Iterable<? extends E>；popAll的dst参数通过Stack消费E实例，因此dst相应的类型为Collection<? super E>。PECS这个助词符突出了使用通配符类型的基本原则。Naftalin和Wadler称之为Get and Put Principle。

记住这个助词符，来看一些之前条目中提到过的方法声明。第25条中的reduce方法有这条声明：
static <E> E reduce(List<E> list, Function<E> f, E initVal)

虽然列表既可以消费也可以产生值，reduce方法还是只用它的list参数作为E生产者（producer），因此它的声明就应该使用一个extends E的通配符类型。参数f表示既可以消费又可以产生E实例的函数，因此通配符类型不适合它。得到的方法声明如下：
//Wildcard type for parameter that serves as an E producer
static <E> E reduce(List<? extends E> list, Function<E> f, E initVal)
这一变化的区别是，假设你有一个List<Integer>，想通过Function<Number>把它简化。它不能通过初始声明进行编译，但是一旦添加了有限制的通配符类型，就可以了。

看第27条中的union方法，下面是声明：
public static <E> Set<E> union(Set<E> s1, Set<E> s2)

s1和s2这两个参数都是E消费者，因此根据PECS，这个声明应该是：
public static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2)

注意返回类型仍然是Set<E>。不要用通配符类型作为返回类型。除了为用户提供额外的灵活性之外，它还会强制用户在客户端代码中使用通配符类型。

如果使用得当，通配符类型对于类的用户来说几乎是无形的。它们使方法能够接受它们应该接受的参数，并拒绝那些应该拒绝的参数。如果类的用户必须考虑通配符类型，类的API或许就会出错。

修改过的union声明，你可能会以为可以像这样编写：
Set<Integer> integers = ...;
Set<Double> doubles = ...;
Set<Number> numbers = union(integers, doubles);
但是这么做会得到下面的错误消息：
类型不匹配

//但是用Java 1.8可以正常编译
package test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class GenericMethodTest {
    // Generic method
    public static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    // Simple program to exercise generic method
    public static void main(String[] args) {
        Set<Integer> integers = new HashSet<>(Arrays.asList(1, 2, 3));
        Set<Double> doubles = new HashSet<>(Arrays.asList(4.0, 5.1, 6.2));
        Set<Number> numbers = union(integers, doubles); //如果写成这种，会提示<Number>不需要，编译器可以自行推断出泛型类型。Set<Number> numbers = GenericMethodTest.<Number>union(integers, doubles); 并且如果要加<Number>，则必须加类GenericMethodTest.
        System.out.println(numbers);
    }
}
    
有一种办法可以处理这种错误。如果编译器不能推断你希望它拥有的类型，可以通过一个显式的类型参数（explicit type parameter）来告诉它要使用哪种类型。这种情况不太经常发生，这是好事，因为显式的类型参数不太优雅。增加这个显式的类型参数之后，程序可以正确无误地进行编译：
Set<Number> numbers = Union.<Number>union(integers, doubles);

看第27条的max方法，以下是初始的声明：
public static <T extends Comparable<T>> T max(List<T> list) 
下面是修改过的使用通配符类型的声明：
public static <T extends Comparable<? super T>> T max(List<? extends T> list)

为了从初始声明中得到修改后的版本，要应用PECS转换两次。最直接的是运用到参数List。它产生T实例，因此将类型从List<T>改成List<? extends T>。更灵活的是运用到类型参数T。这是第一次见到将通配符运用到类型参数。最初T被指定用来扩展Comparable<T>，但是T的comparable消费T实例（并产生表示顺序关系的整值）。因此，参数化类型Comparable<T>被有限制通配符类型Comparable<? super T>取代。comparable始终是消费者，因此使用时始终应该是Comparable<? super T>优先于Comparable<T>。对于comparator也一样，因此使用时始终应该是Comparator<? super T>优先于Comparator<T>。

修改过的max声明可能是整本书中最复杂的方法声明了。所增加的复杂代码确实起作用了。下面是一个简单的列表示例，在初始的声明中不允许这样，修改过的版本则可以：
List<ScheduledFuture<?>> scheduledFutures = ...;

不能将初始方法声明运用到这个列表的原因在于，java.util.concurrent.ScheduledFuture没有实现Comparable<ScheduledFuturn>接口。相反，它是扩展Comparable<Delayed>接口的Delayed接口的子接口。换句话说，ScheduleFuture实例并非只能与其他ScheduledFuture实例相比较，它可以与任何Delayed实例相比较，这就足以导致初始声明时就会被拒绝。

修改过的max声明有一个小小的问题：它阻止方法进行编译。下面的方法包含了修改过的声明：
public static <T extends Comparable<? super T>> T max(List<? extends T> list) {
    Iterator<? extends T> i = list.iterator(); //这里写成Iterator<T>将编译错误
    T result = i.next();
    while (i.hasNext()) {
        T t = i.next();
        if (t.compareTo(result) > 0) {
            result = t;
        }
    }
    return result;
}

意味着list不是一个List<T>，因此它的iterator方法没有返回Iterator<T>。它返回T的某个子类型的一个iterator，因此用它代替iterator声明，它使用了一个有限制的通配符类型：
Iterator<? extends T> i = list.iterator();

这是必须对方法体所做的唯一修改。迭代器的next方法返回的元素属于T的某个子类型，可以被安全地保存在类型T的一个变量中。

还有一个与通配符有关的话题。类型参数与通配符之间具有双重性，许多方法都可以利用其中一个或者另一个进行声明。如，下面是可能的两种静态方法声明，来交换列表中的两个被索引的项目。第一个使用无限制的类型参数（见第27条），第二个使用无限制的通配符：
// Two possible declarations for the swap method
public static <E> void swap(List<E> list, int i, int j);
public static void swap(List<?> list, int i, int j);

在公共API中，第二种更好一些，因为它更简单。将它传到一个列表中――任何列表――方法就会交换被索引的元素。不用担心类型参数。一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它。如果是无限制的类型参数，就用无限制的通配符取代它；如果是有限制的类型参数，就用有限制的通配符取代它。

将第二种声明用于swap方法会有一个问题，它优先使用通配符而非类型参数：下面这个简单的实现都不能编译：
package test;

import java.util.Arrays;
import java.util.List;

public class GenericTest {
    public static void swap(List<?> list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }

    public static void main(String[] args) {
        List<String> strings = Arrays.asList("hello", "good", "day");
        swap(strings, 0, 1);
    }
}

编译会产生这条没有什么用处的错误消息：
Error:(9, 41) java: 不兼容的类型: java.lang.Object无法转换为capture#1, 共 ?

不能将元素放回到刚刚从中取出的列表中，这似乎不太对劲。问题在于list的类型为List<?>，不能把null之外的任何值放到List<?>中。幸运的是，有一种方式可以实现这个方法，无需求助于不安全的转换或者原生态类型（raw type）。这种想法就是编写一个私有的辅助方法来捕捉通配符类型。为了捕捉类型，辅助方法必须是泛型方法，像下面这样：
package test;

import java.util.Arrays;
import java.util.List;

public class GenericTest {
    public static void swap(List<?> list, int i, int j) {
        swapHelper(list, i, j);
    }

    // Private help method for wildcard capture
    private static <E> void swapHelper(List<E> list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }

    public static void main(String[] args) {
        List<String> strings = Arrays.asList("hello", "good", "day");
        swap(strings, 0, 1);
        System.out.println(strings);
    }
}

swapHelper方法知道list是一个List<E>。因此，它知道从这个列表中取出的任何值均为E类型，并且知道将E类型的任何值放进列表都是安全的。swap这个有些费解的实现编译起来却是正确无误的。它允许我们导出swap这个比较好的基于通配符的声明，同时在内部利用更加复杂的泛型方法。swap方法的客户端不一定要面对更加复杂的swapHelper声明，但是它们的确从中受益。

总而言之，在API中使用通配符类型虽然比较需要技巧，但是使API变得灵活得多。如果编写的是将被广泛使用的类库，则一定要适当地利用通配符类型。记住基本的原则：producer-extends, consumer-super(PECS)。还要记住所有的comparable和comparator都是消费者。
//------------------------------------------------------------------------------------------------
//Effective Java 第5章 泛型 P97
//第29条：优先考虑类型安全的异构容器 P123
泛型最常用于集合，如Set和Map，以及单元素的容器，如ThreadLocal和AtomicReference。这些用法中，它都充当了被参数化了的容器，这样就限制每个容器只能有固定数目的类型参数。一般来说，这种情况正是你想要的。一个Set只有一个类型参数，表示它的元素类型；一个Map有两个类型参数，表示它的键和值类型；诸如此类。

有时候会需要更多的灵活性。例如，数据库行可以有任意多的列，如果能以类型安全的方式访问所有列就好了。幸运的是，有一种方法可以很容易地做到这一点。这种想法就是将键（key）进行参数化而不是将容器（container）参数化。然后将参数化的键提交给容器，来插入或者获取值。用泛型系统来确保值的类型与它的键相符。

简单地示例一下这种方法：考虑Favorites类，它允许其客户端从任意数量的其他类中，保存并获取一个“最喜爱”的实例。Class对象充当参数化键的部分。之所以可以这样，是因为类Class在Java 1.5 版本中被泛型化了。类的类型从字面上来看不再只是简单的Class，而是Class<T>。如，String.class属于Class<String>类型，Integer.class属于Class<Integer>类型。当一个类的字面文字被用在方法中，来传达编译时和运行时的类型信息时，就被称作type token。

Favorites类的API很简单。它看起来就像一个简单的map，除了键（而不是map）被参数化之外。客户端在设置和获取最喜爱的实例时提交Class对象。下面就是这个API：
//
package test;

import java.util.HashMap;
import java.util.Map;

// Typesafe heterogeneous container pattern - API and implementation
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        if (type == null) {
            throw new NullPointerException("Type is null");
        }
        favorites.put(type, instance);
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
//        Object obj = favorites.get(type); //用这个方法来判断，输出将是null null test.Favorites。
//        if (obj.getClass() == type.getClass()) { //以String来例，obj.getClass()将得到String，type.getClass将得到Class，所以判定为false。还没有写出instanceof的代码？
//            return (T) obj;
//        }
//        return null;
    }

    public static void main(String[] args) {
        Favorites f = new Favorites();
        f.putFavorite(String.class, "Java");
        f.putFavorite(Integer.class, 0xcafebabe); //f.putFavorite(Number.class, 0xcafebabe);
        f.putFavorite(Class.class, Favorites.class);
        String favoriteString = f.getFavorite(String.class);
        int favoriteInteger = f.getFavorite(Integer.class); //Number favoriteInteger = f.getFavorite(Number.class);这样也可以
        Class<?> faovriteClass = f.getFavorite(Class.class);
        System.out.printf("%s %x %s%n", favoriteString, favoriteInteger, faovriteClass.getName());
    }
}
输出：
Java cafebabe test.Favorites

Favorites实例是类型安全（typesafe）的：当你向它请求String的时候，它从来不会返回一个Integer给你。同时它也是异构的（heterogeneous）：不像普通的map，它的所有键都是不同类型的。因此，我们将Favorites称作类型安全的异构容器（typesafe heterogeneous container）。

这里发生了一些微妙的事情。每个Favorites实例都得到一个称作favorites的私有Map<Class<?>, Object>的支持。你可能认为由于无限制通配符类型的关系，将不能把任何东西放进这个Map，但事实正好相反。要注意的是通配符类型是嵌套的：它不是属于通配符类型的Map的类型，而是它的键的类型。由此可见，每个键都可以有一个不同的参数化类型：一个可以是Class<String>，接下来是Class<Integer>等等。异构就是从这里来的。

第二件要注意的事情是，favorites Map的值类型只是Object。换句话说，Map并不能保证键和值之间的类型关系，即不能保证每个值的类型都与键的类型相同。事实上，Java的类型系统还没有强大到足以表达这一点。但我们知道这是事实，并在获取favorite的时候利用了这一点。

putFavorite方法的实现很简单：它只是把（从指定的Class对象到指定favorite实例的）一个映射放到favorites中。如前所述，这是放弃了键和值之间的“类型联系”，因此无法知道这个值是键的一个实例。但是没关系，因为getFavorites方法能够并且的确重新建立了这种联系。

cast方法是Java的cast操作符的动态模拟。它只检验它的参数是否为Class对象所表示的类型的实例。如果是，就返回参数，否则就抛出ClassCastException异常。getFavorite中的cast调用永远不会抛出ClassCastException异常，并假设客户端代码正确无误地进行编译。也就是说，我们知道favorites映射中的值会始终与键的类型相匹配。

假设cast方法只返回它的参数，cast方法的签名充分利用了Class类被泛型化的这个事实。它的返回类型是Class对象的类型参数：
public class Class<T> {
    T cast(Object obj);
}
这正是getFavorite方法所需要的，也正是让我们不必借助于未受检地转换成T就能确保Favorites类型安全的东西。

Favorites类有两种局限性值得注意。首先，恶意的客户端可以很轻松地破坏Favorites实例的类型安全，只要以它的原生态形式（raw form）使用Class对象。但会造成客户端代码在编译时产生未受检的警告。你可以很容易地利用原生态类型HashSet（见第23条）将String放进HashSet<Integer>中。也就是主产，如果愿意付出一点代价，就可以拥有运行时的类型安全。确保Favorites永远不违背它的类型约束条件的方式是，让putFavorite方法检验instance是否真的是type所表示的类型的实例。只要使用一个动态转换：
例如，可以通过如下代码破坏类型安全：
Class stringClass = String.class;
f.putFavorite(stringClass, 123);
String favoriteString = f.getFavorite(String.class);
编译通过，运行时只能在getFavorite时抛出ClassCastException：
Exception in thread "main" java.lang.ClassCastException: Cannot cast java.lang.Integer to java.lang.String

修改如下：
// Achieving runtime type safety with a dynamic cast
public <T> void putFavorite(Class<T> type, T instance) {
    if (type == null) {
        throw new NullPointerException("Type is null");
    }
    favorites.put(type, type.cast(instance));
}
将在f.putFavorite(stringClass, 123);时即运行错误

java.util.Collections中有一些集合包装类采用了同样的技巧。它们称作checkedSet、checkedList、checkedMap，诸如此类。除了一个集合（或者映射）之外，它们的静态工厂还采用一个（或者两个）Class对象。静态工厂属于泛型方法，确保Class对象和集合的编译时类型相匹配。包装类给它们所封装的集合增加了具体化。如果有人试图将Coin放进你的Collection<Stamp>，包装类就会在运行时抛出ClassCastException异常。用这些包装类在混有泛型和遗留代码的应用程序中追溯“谁把错误的类型元素添加到了集合中”很有帮助。

Favorites类的第二种局限性在于它不能用在不可具体化的（non-reifiable）类型中（见第25条）。换句话说，你可以保存最喜爱的String或者String[]，但不能保存最喜爱的List<String>。如果试图保存最喜欢的List<String>，程序就不能进行编译。原因在于你无法为List<String>获得一个Class对象：List<String>.Class是个语法错误，这也是件好事。List<String>和List<Integer>共用一个Class对象，即List.class。如果从“字面（type literal）”上来看，List<String>.class和List<Integer>.class是合法的，并返回了相同的对象引用，就会破坏Favorites对象的内部结构。

对于第二种局限性，还没有完全令人满意的解决办法。有一种办法称作super type token，它在解决这一局限性做了很多努力，但是这种方法仍有它自身的局限性。

注解API（见第35条）广泛利用了有限制的类型令牌。如，这是一个在运行时读取注解的方法。这个方法来自AnnotatedElement接口，它通过 表示类、方法、域及其他程序元素的反射类型来实现：
public <T extends Annotation> T getAnnotation(Class<T> annotationType);
参数annotationType是一个表示注解类型的有限制的类型令牌。如果元素有这种类型的注解，该方法就将它返回，如果没有，则返回null。被注解的元素本质上是个类型安全的异构容器，容器的键属于注解类型。

假设有一个类型Class<?>的对象，并且想将它传给一个需要有限制的类型令牌的方法，例如getAnnotation。你可以将对象转换成Class<? extends Annotation>，但是这种转换是非受检的，会产生一条编译时警告（见第24条）。幸运的是，类Class提供了一个安全（且动态）地执行这种转换的实例方法。该方法称作asSubClass，它将调用它的Class对象转换成用其参数表示的类的一个子类。如果转换成功，该方法返回它的参数；如果失败，则抛出ClassCastException异常。

以下示范了如何利用asSubClass方法在编译时读取类型未知的注解。这个方法编译时没有出现错误或者警告：
// Use of asSubClass to safely cast to a bounded type token
static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) {
    Class<?> annotationType = null; //Unbounded type token
    try {
        annotationType = Class.forName(annotationTypeName);
    } catch (Exception ex) {
        throw new IllegalArgumentException(ex);
    }
    return element.getAnnotation(annotationType.asSubClass(Annotation.class));
}

总而言之，集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对这种类型安全的异构容器，可以用Class对象作为键。以这种方式使用的Class对象称作类型令牌。你也可以使用定制的键类型。例如，用一个DatabaseRow类型表示一个数据库行（容器），用泛型Column<T>作为它的键。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
Java 1.5 发行版本中增加了两个新的引用类型：一个新的类型称作枚举类型（enum type），一种新的接口称作注解类型（annotation type）。
//第30条：用enum代替int常量 P128
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD}
Java的枚举类型是功能十分齐全的类，功能比其他语言中的对待物要强大得多，Java的枚举本质上是int值。

Java枚举类型背后的基本想法非常简单：它们就是通过公有的静态final域为每个枚举常量导出实例的类。因为没有可以访问的构造器，枚举类型是真正的final。因为客户端既不能创建枚举类型的实例，也不能对它进行扩展，因此很可能没有实例，而只有声明过的枚举常量。换句话说，枚举类型是实例受控的。它们是单例（Singleton）的泛型化（见第3条），本质上是单元素的枚举。枚举类型为类型安全的枚举（typesafe enum）框框工提供了语言方面的支持。

枚举提供了编译时的类型安全。如果声明一个参数的类型为Apple，就可以保证，被传到该参数上的任何非null的对象引用一定属于三个有效的Apple值之一。试图传递类型错误的值时，会导致编译时错误，就像试图将某种枚举类型的表达式赋给另一种枚举类型的变量，或者试图利用==操作符比较不同枚举类型的值一样。

包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。你可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端之间提供了一个隔离层：常量值并没有被编译到客户端代码中，而是在枚举模式之中。最终，可以通过调用toString方法，将枚举转换成可打印的字符串。

除了完善了int枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。它们提供了所有Object方法（见第3章）的高级实现，实现了Comparable（见第12条）和Serializable接口（见第11章），并针对枚举类型的可任意改变性设计了序列化方式。

枚举类型可以利用任何适当的方法来增强枚举类型。枚举类型可以先作为枚举常量的一个简单集合，随着时间推移再演变成为全功能的抽象。

举个有关枚举类型的好例子，比如太阳系中的8颗行星。每颗行星都有质量和半径，通过这两个属性可以计算出它的表面策略。从而给定物体的质量，就可以计算出一个物体在行星表面上的重量。每个枚举常量后面括号中的数值就是传递给构造器的参数。在这个例子中，它们就是行星的质量和半径：
//
package test;

public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS(4.869e+24, 6.052e6),
    EARTH(5.975e+24, 6.378e6),
    MARS(6.419e+24, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN(5.685e+26, 6.027e7),
    URANUS(8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.477e7),;
    private final double mass; //In kilograms
    private final double radius; //In meters
    private final double surfaceGravity; //In m / s^2

    // Universal gravitational constant in m^3 / kg s^2
    private static final double G = 6.67300E-11;

    // Constructor
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        this.surfaceGravity = G * mass / (radius * radius);
    }

    public double mass() {
        return mass;
    }

    public double radius() {
        return radius;
    }

    public double surfaceGravity() {
        return surfaceGravity;
    }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}

编写一个像Planet这样的枚举类型并不难。为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。枚举天生就是不可变的，因此所有的域都应该为final的（见第15条）。它们可以是公有的，但最好将它们做成是私有的，并提供公有的访问方法（见第14条）。在Planet这个示例中，构造器还计算和保存表面重力，但这正是一种优化。每当surfaceWeight方法用到策略时，都会根据质量和半径重新计算，并返回它在该常量所表示的行星上的重量。

虽然Planet枚举很简单。它的功能却强大得出奇。下面是一个简短的程序，根据某个物体在地球上的重量（以任意单位），打印出一张很棒的表格，显示出该物体在所有8颗行星上的重量（用相同的单位）：
//
package test;

import java.util.stream.Stream;

public class WeightTable {
    public static void main(String[] args) {
        double earthWeight = 175;//Double.parseDouble(args[0]);
        double mass = earthWeight / Planet.EARTH.surfaceGravity();
        Stream.of(Planet.values()).forEach(planet -> System.out.printf("Weight on %s is %f%n", planet, planet.surfaceWeight(mass))); //换行用的是%n，C语言中则用\n
    }
}
输出：
Weight on MERCURY is 66.133672
Weight on VENUS is 158.383926
Weight on EARTH is 175.000000
Weight on MARS is 66.430699
Weight on JUPITER is 442.693902
Weight on SATURN is 186.464970
Weight on URANUS is 158.349709
Weight on NEPTUNE is 198.846116

Planet有一个静态的values方法，按照声明顺序返回它的值数组。还要注意toString方法返回每个枚举值的声明名称，使得println和printf的打印变得更加容易。如果不满意这种字符串表示法，可以通过覆盖toString方法对它进行修改。

与枚举常量关联的有些行为，可能只需要用在定义了枚举的类或者包中。这种行为最好被实现成私有的或者包级私有的方法。于是，每个枚举常量都带有一组隐蔽的行为，这使得包含该枚举的类或者包在遇到这种常量时都可以做出适当的反应。就像其他的类一样，除非迫不得已要将枚举方法导出至它的客户端，否则都应该将它声明为私有的，如有必要，则声明为包级私有的（见第13条）。

如果一个枚举具有普遍适用性，就应该成为一个顶层类（top-level class）；如果它只是被用在一个特定的顶层类中，它就应该成为该顶层类的一个成员类（见第22条）。例如，java.math.RoundingMode枚举表示十进制小数的舍入模式（rounding mode）。这些舍入模式用于BigDecimal类，但是它们提供了一个非常有用的抽象，这种抽象本质上又不属于BigDecimal类。通过使RoundingMode变成一个顶层类，库的设计者鼓励任何需要舍入模式的程序员重用这个枚举，从而增强API之间的一致性。

Planet示例中所示的方法对于大多数枚举类型来说就足够了，但有时候会需要更多的方法。每个Planet常量都关联了不同的数据，但有时候需要将本质上不同的行为（behavior）与每个常量关联起来。如，假设在编写一个枚举类型，来表示计算器的四大基本操作（加减乘除），想要提供一个方法来执行每个常量所表示的算术运算。有一种方法是通过启用枚举的值来实现：
//
package test;

public enum Operation {
    PLUS, MINUS, TIMES, DIVIDE,;

    // Do the arithmetic op represented by this constant
    double apply(double x, double y) {
        switch (this) {
            case PLUS: return x + y;
            case MINUS: return x - y;
            case TIMES: return x * y;
            case DIVIDE: return x / y;
        }
        throw new AssertionError("Unknown op: " + this);
    }
}

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class OperationTest {
    @Test
    public void testOperationApply() {
        assertEquals(10, Operation.PLUS.apply(3, 7), 1e-1); //double比较，需要有精度，1 * 10^-1
        assertEquals(-4, Operation.MINUS.apply(3, 7), 1e-1);
        assertEquals(21, Operation.TIMES.apply(3, 7), 1e-1);
        assertEquals(0.4, Operation.DIVIDE.apply(3, 7), 1e-1);
    }
}

这段代码可行，但是不太好看。如果没有throw语句，它就不能进行编译，虽然从技术角度来看代码的结束部分是可以执行到的，但是实际上是不可能执行到这行代码的。更糟糕的是，这段代码很脆弱。如果添加了新的枚举常量，却忘记给switch添加相应的条件，枚举仍然可以编译，但是当你试图运用新的运算时，就会运行失败。

有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的apply方法，并在特定于常量的类主体（constant-specific class body）中，用具体的方法覆盖每个常量的抽象apply方法。这种方法被称作特定于常量的方法实现（constant-specific method implementation）。
//
package test;

// Enum type with constant-specific method implementations
public enum Operation {
    PLUS {
        @Override
        double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS {
        @Override
        double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES {
        @Override
        double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE {
        @Override
        double apply(double x, double y) {
            return x / y;
        }
    };

    abstract double apply(double x, double y);
}

如果给Operation的第二种版本添加新的常量，你就不可能忘记提供apply方法，因为该方法就紧跟在每个常量声明之后。即便你真的忘记了，编译器也会提醒你，因为枚举类型中的抽象方法必须被它所有常量中的具体方法所覆盖。

特定于常量的方法实现可以与特定于常量的数据结合起来。如，下面的Operation覆盖了toString来返回通常与该操作关联的符号：
//
package test;

// Enum type with constant-specific class bodies and data
public enum Operation {
    PLUS("+") {
        @Override
        double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES("*") {
        @Override
        double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        @Override
        double apply(double x, double y) {
            return x / y;
        }
    };

    private final String symbol;

    Operation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
    
    abstract double apply(double x, double y);
}

有些情况下，在枚举中覆盖toString非常有用。如，上述的toString实现使得打印算术表达式变得非常容易，如这段小程序所示：
//
package test;

import java.util.stream.Stream;

public class OperationMainTest {
    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        Stream.of(Operation.values()).forEach(op -> System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y)));
    }
}
输出：
2.000000 + 4.000000 = 6.000000
2.000000 - 4.000000 = -2.000000
2.000000 * 4.000000 = 8.000000
2.000000 / 4.000000 = 0.500000

枚举类型有一个自动产生的valueOf(String)方法，将常量的名字转变成常量本身。如果在枚举类型中覆盖了toString，要考虑编写一个fromString方法，将定制的字符串表示法变回相应的枚举。下列代码（适当地改变了类型名称）可以为任何枚举完成这一技巧，只要每个常量都有一个独特的字符串表示法：
//
package test;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

// Implementing a fromString method on an enum type
public enum Operation {
    PLUS("+"), MINUS("-"), TIMES("*"), DIVIDE("/");

    private static final Map<String, Operation> STRING_TO_ENUM = new HashMap<>(); //这里应该命名为STRING_TO_ENUM还是stringToEnum？

    static {
        Stream.of(Operation.values()).forEach(op -> STRING_TO_ENUM.put(op.toString(), op));
    }

    public static Operation fromString(String symbol) {
        return STRING_TO_ENUM.get(symbol);
    }

    private final String symbol;

    Operation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
}

//
package test;

import java.util.stream.Stream;

public class OperationMainTest {
    public static void main(String[] args) {
        Stream.of(Operation.values()).forEach(op -> System.out.printf("%s represent %s%n", op.toString(), Operation.fromString(op.toString())));
    }
}
输出：
+ represent +
- represent -
* represent *
/ represent /

注意，常量被创建之后，Operation常量从静态代码块中被放入到了stringToEnum的map中，试图使每个常量都从自己的构造器将自身放入到map中，会导致编译时错误。因为如果这是合法的，就会抛出NullPointerException异常。枚举构造器不可以访问枚举的静态域，除了编译时常量域之外。这一限制是有必要的，因为构造器运行的时候，这些静态域还没有被初始化。

特定于常量的方法实现有一个美中不足的地方，它们使得在枚举常量中共享代码变得更加困难了。如，考虑用一个枚举表示薪资包中的工作天数。这个枚举有一个方法，根据给定某工人的基本工资（按小时）以衣当天的工作时间，来计算他当天的报酬。在五个工作日中，超过正常八小时的工作时间都产生加班工资；在双休日中，所有工作都产生加班工资。利用switch语句，很容易通过将多个case标签分别应用到两个代码片断中，来完成这一计算。为了简洁起见，这个示例中使用了double，但是注意double并不是适合薪资应用程序（见第48条）的数据类型。
//
package test;

public enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    private static final int HOURS_PER_SHIFT = 8;

    double pay(double hoursWorked, double payRate) {
        double basePay = hoursWorked * payRate;
        double overtimePay; //Calculate overtime pay
        switch (this) {
            case SATURDAY:
            case SUNDAY:
                overtimePay = hoursWorked * payRate / 2;
            default:
                overtimePay = hoursWorked <= HOURS_PER_SHIFT ? 0 : (hoursWorked - HOURS_PER_SHIFT) * payRate / 2;
        }
        return basePay + overtimePay;
    }
}
不可否认，这段代码十分简洁，但是从维护角度来看，它非常危险。假设将一个元素添加到该枚举中，或者是一个表示假期天数的特殊值，但是忘记给switch语句添加相应的case。程序依然可以编译，但是pay方法会悄悄地将假期的工资计算成与正常工作日的相同。

你真正想要的就是每当添加一个枚举常量时，就强制选择一种加班报酬策略。有一种很好的方法可以实现这一点。这种想法就是将加班工资计算移到一个私有的嵌套枚举中，将这个策略枚举（strategy enum）的实例传到PayrollDay枚举的构造器中。之后PayrollDay枚举将加班工资计算委托给策略枚举，PayrollDay中就不需要switch语句或者特定于常量的方法实现了。虽然这种模式没有switch语句那么简洁，但更加安全，也更加灵活：
//
package test;

// The Strategy enum pattern
public enum PayrollDay {
    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY),
    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);

    private final PayType payType;

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    double pay(double hoursWorked, double payRate) {
        return payType.pay(hoursWorked, payRate);
    }

    // The strategy enum type
    private enum PayType {
        WEEKDAY {
            @Override
            double overtimePay(double hours, double payRate) {
                return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT) * payRate / 2;
            }
        },
        WEEKEND {
            @Override
            double overtimePay(double hours, double payRate) {
                return hours * payRate / 2;
            }
        };

        private static final int HOURS_PER_SHIFT = 8;

        abstract double overtimePay(double hours, double payRate);

        double pay(double hourWorked, double payRate) {
            double basePay = hourWorked * payRate;
            return basePay + overtimePay(hourWorked, payRate);
        }
    }
}

如果枚举中的switch语句不是在枚举中实现特定于常量的行为的一种很好的选择，那么它们还有什么用处呢？枚举中的switch语句适合于给外部的枚举类型增加特定于常量的行为。例如，假设Operation枚举不受你的控制，你希望它有一个实例方法来返回每个运算的反运算。可以用下列静态方法模拟这种效果：
// Switch on an enum to simulate a missing method
public static Operation inverse(Operation op) {
    switch (op) {
        case PLUS: return Operation.MINUS;
        case MINUS: return Operation.PLUS;
        case TIMES: return Operation.DIVIDE;
        case DIVIDE: return Operation.TIMES;
        default: throw new AssertionError("Unknown op: " + op);
    }
}

一般来说，枚举会优先使用comparable而非int常量。与int常量相比，枚举有个小小的性能缺点，即装载和初始化枚举时会有空间和时间的成本。除了受资源约束的设备，例如手机和烤面包机之外，在实践中不必在意这个问题。

使用枚举的场景是每当需要一组固定常量的时候。这包括“天然的枚举类型”，例如行星、一周的天数以及棋子的数目等等。但它也包括你在编译时就知道其所有可能值的其他集合，例如菜单的选项、操作代码以及命令行标记等。枚举类型中的常量集并不一定要始终保持不变。专门设计枚举特性是考虑到枚举类型的二进制兼容演变。

总而言之，与int常量相比，枚举类型的优势是很明显的。枚举要易读得多，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于“每个常量与属性的关联”以及“提供行为受这个属性影响的方法”。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果有多个枚举常量同时共享相同的行为，则考虑策略枚举。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第31条：用实例域代替序数 P137
许多枚举天生就与一个单独的int值相关联。所有的枚举都有一个ordinal方法，它返回每个枚举常量在类型中的数字位置。可以试着从序数中得到关联的int值：
//
package test;

// Abuse of ordinal to derive an associated value - DON'T DO THIS
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;

    public int numberOfMusicians() {
        return ordinal() + 1;
    }
}

//
package test;

import org.junit.Test;

import java.util.stream.Stream;

public class EnsembleTest {
    @Test
    public void testEnumOrdinal() {
        Stream.of(Ensemble.values()).forEach(ensemble -> System.out.printf("Musicians of %s is %d%n", ensemble, ensemble.numberOfMusicians()));
    }
}
输出：
Musicians of SOLO is 1
Musicians of DUET is 2
Musicians of TRIO is 3
Musicians of QUARTET is 4
Musicians of QUINTET is 5
Musicians of SEXTET is 6
Musicians of SEPTET is 7
Musicians of OCTET is 8
Musicians of NONET is 9
Musicians of DECTET is 10

如果要增加枚举值，并且对应的演奏家不是序数值，则无法完成。

永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中：
package test;

public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
    NONET(9), DECTET(10), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;

    Ensemble(int size) {
        this.numberOfMusicians = size;
    }

    public int numberOfMusicians() {
        return numberOfMusicians;
    }
}

Enum规范中谈到ordinal时这么写道：“大多数程序员都不需要这个方法。它是设计成用于像EnumSet和EnumMap这种基于枚举的通用数据结构的”。除非在编写的是这种数据结构，否则最好完全避免使用ordinal方法。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第32条：用EnumSet代替位域 P138
如果一个枚举类型的元素主要用于集合中，一般就使用int枚举模式（见第30条），将2的不同位数赋予每个常量：
//
package test;

// Bit field enumeration constants - OBSOLETE!
public class Text {
    public static final int STYLE_BOLD = 1 << 0; //1
    public static final int STYLE_ITALIC = 1 << 1; //2
    public static final int STYLE_UNDERLINE = 1 << 2; //4
    public static final int STYLE_STRIKETHROUGH = 1 << 3; //8

    // Parameter is bitwise OR of zero or more STYLE_ constants
    public void applyStyles(int styles) {
        //...
    }
}

这种表示法让你用OR位运算将几个常量合并到一个集合中，称作位域（bit field）：
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);

位域表示法也允许利用位操作，有效地执行像union（联合）和intersection（交集）这样的集合操作。但位域有着int枚举常量的所有缺点，甚至更多。当位域以数字形式打印时，翻译位域比翻译简单的int枚举常量要困难得多。甚至，要遍历位域表示的所有元素也没有很容易的方法。

有些程序优先使用枚举而非int常量，他们在需要传递多组常量集时，仍然倾向于使用位域。其实没有理由这么做，因为还有更好的替代方法。java.util包提供了EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合。这个类实现Set接口，提供了丰富的功能、类型安全性，以及可以从任何其他Set实现中得到的互用性。但是在内部具体的实现上，每个EnumSet内容都表示为位矢量。如果底层的枚举类型有64个或者更少的元素――大多如此――整个EnumSet就是用单个long来表示，因此它的性能比得上位域的性能。批处理，如果removeAll和retainAll，都是利用位算法来实现的，就像手工替位域实现得那样。但是可以避免手工位操作时容易出现的错误以及不太雅观的代码，因为EnumSet替你完成了这项艰巨的工作。

下面是前一个范例改成枚举代替位域后的代码，它更加简短、更加清楚，也更加安全：
package test;

import java.util.Set;

// EnumSet - a modern replacement for bit fields
public class Text {
    public enum Style {BOLD, ITALIC, UNDERLINE, STRIKETHROUGH}

    // Any set could be passed in, but EnumSet is clearly best
    public void applyStyles(Set<Style> styleSet) {
        //...
    }
}

下面是将EnumSet实例传递给applyStyles方法的客户端代码。EnumSet提供了丰富的静态工厂来轻松创建集合，其中一个如这个代码所示：
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));

注意applyStyles方法采用的是Set<Style>而非EnumSet<Style>。虽然看起来好像所有的客户端都可以将EnumSet传到这个方法，但是最好还是接受接口类型而非接受实现类型。这是考虑到可能会有特殊的客户端要传递一些其他的Set实现，并且没有什么明显的缺点。

总而言之，正是因为枚举类型要用在集合（Set）中，所以没有理由用位置来表示它。EnumSet类集位域的简洁和性能优势及第30条中所述的枚举类型的所有优点于一身。实际上EnumSet有个缺点，即截止Java 1.6 发行版本，它都无法创建不可变的EnumSet，但是这一点可能在即将出来的版本中得到修正。同时，可以用Collections.unmodifiableSet将EnumSet封装起来，但是简洁性和性能会受到影响。

Enumset是个虚类，我们只能通过它提供的静态方法来返回Enumset的实现类的实例。
返回EnumSet的两种不同的实现：如果EnumSet大小小于64，
就返回RegularEnumSet实例(当然它继承自EnumSet)，这个EnumSet实际上至用了一个long来存储这个EnumSet。
如果 EnumSet大小大于等于64，则返回JumboEnumSet实例，它使用一个long[]来存储。这样做的好处很明显： 大多数情况下返回的RegularEnumSet效率比JumboEnumSet高很多。

//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第32条：用EnumMap代替序数索引 P140
有时候，可能会利用ordinal方法（见第31条）来索引数组的代码。如下这个简化的类，用来表示一种烹饪用的香草：
package test;

public class Herb {
    public enum Type {ANNUAL, PERENNIAL, BIENNIAL}

    private final String name;
    private final Type type;

    public Herb(String name, Type type) {
        this.name = name;
        this.type = type;
    }

    @Override
    public String toString() {
        return name;
    }
}

//
package test;

import java.util.HashSet;
import java.util.Set;

public class HerbCategorier {
    public static void main(String[] args) {
        Herb[] garden = new Herb[]{new Herb("A", Herb.Type.ANNUAL),
            new Herb("B", Herb.Type.BIENNIAL),
            new Herb("C", Herb.Type.ANNUAL),
            new Herb("D", Herb.Type.PERENNIAL)};

        Set<Herb>[] herbsByType = (Set<Herb>[]) new Set[Herb.Type.values().length];
        for (int i = 0; i < herbsByType.length; i++) {
            herbsByType[i] = new HashSet<>();
        }

        for (Herb h : garden) {
            herbsByType[h.getType().ordinal()].add(h);
        }

        // Print the results
        for (int i = 0; i < herbsByType.length; i++) {
            System.out.printf("%s: %s%n", Herb.Type.values()[i], herbsByType[i]);
        }
    }
}
输出：
ANNUAL: [C, A]
PERENNIAL: [D]
BIENNIAL: [B]

这种方法可行，但是隐藏着许多问题。数组不能与泛型（见第25条）兼容，程序需要进行未受检的转换，并能不能正确无误地进行编译。因为数组不知道它的索引代表着什么，你必须手工标注（label）这些索引的输出。但是这种方法最严重的问题在于，当你访问一个按照枚举的充数进行索引的数组时，使用正确的int值就是你的职责了；int不能提供枚举的类型安全。如果使用了错误的值，程序就会悄悄地完成错误的工作，或者幸运的话，会抛出ArrayIndexOutOfBoundException异常。

有一种更好的方法可以达到同样的效果。数组实际上充当着从枚举到值的映射，因此可能还要用到Map。有一种非常快速的Map实现专门用于枚举键，称作java.util.EnumMap。以下就是用EnumMap改写后的程序：
package test;

import java.util.EnumMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class HerbCategorier {
    public static void main(String[] args) {
        Herb[] garden = new Herb[]{new Herb("A", Herb.Type.ANNUAL),
            new Herb("B", Herb.Type.BIENNIAL),
            new Herb("C", Herb.Type.ANNUAL),
            new Herb("D", Herb.Type.PERENNIAL)};

        Map<Herb.Type, Set<Herb>> herbsByType = new EnumMap<>(Herb.Type.class);//这里也可以用HashMap，new HashMap<>()，但是这样就没有枚举存储的序数顺序保证了
        for (Herb.Type t : Herb.Type.values()) {
            herbsByType.put(t, new HashSet<>());
        }

        for (Herb h : garden) {
            herbsByType.get(h.getType()).add(h);
        }
        System.out.println(herbsByType);
    }
}
输出：
{ANNUAL=[C, A], PERENNIAL=[D], BIENNIAL=[B]}

这段程序更简短、更清楚，也更加安全，运行速度方面可以与使用序数的程序相媲美。它没有不安全的转换；不必手工标注这些索引的输出，因为映射键知道如何将自身翻译成可打印字符串的枚举；计算数组索引时也不可能出错。EnumMap在运行速度方面之所以能与通过序数索引的数组相媲美，是因为EnumMap在内部使用了这种数组。但是它对程序员隐藏了这种实现细节，集Map的丰富功能和类型安全与数组的快速于一身。注意EnumMap构造器采用键类型的Class对象：这是一个有限制的类型令牌（bounded type token），它提供了运行时的泛型信息（见第29条）。

还可能见到按照序数进行索引（两次）的数组的数组，该序数表示两个枚举值的映射。如，下面的这个程序就是使用这样一个数组将两个阶段映射到一个阶段过滤中（从液体到固定称作凝固，从液体到气体称作沸腾等）。
//
package test;

public enum Phase {
    SOLID, LIQUID, GAS;

    public enum Transition {
        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT,;
        // Rows indexed by src-ordinal, cols by dst-ordinal
        private static final Transition[][] TRANSITIONS = {
            {null, MELT, SUBLIME},
            {FREEZE, null, BOIL},
            {DEPOSIT, CONDENSE, null}
        };

        // Returns the phase transition from one phase to another
        public static Transition from(Phase src, Phase dst) {
            return TRANSITIONS[src.ordinal()][dst.ordinal()];
        }
    }
}

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class PhaseTest {
    @Test
    public void testTransition() {
        assertEquals(Phase.Transition.FREEZE, Phase.Transition.from(Phase.LIQUID, Phase.SOLID));
        assertEquals(Phase.Transition.MELT, Phase.Transition.from(Phase.SOLID, Phase.LIQUID));
        //扩展一个新状态的测试：assertEquals(null, Phase.Transition.from(Phase.SOLID, Phase.PLASMA));
    }
}

这段程序可行，看起来也比较优雅，但是事实并非如此。编译器无法知道序数和数组索引之间的关系。如果在过滤表中出了错，或者在修改Phase或者Phase.Transition枚举类型的时候忘记将它更新，程序就会在运行时失败。这种失败的形式可能为ArrayIndexOutOfBoundsException、NullPointerException或者（更糟糕的是）没有任何提示的错误行为。这张表的大小是阶段个数的平方，即便非null项的数量比较少。

同样，利用EnumMap依然可以做得更好一些。每个阶段过渡都是通过一对阶段枚举进行索引的，最好将这种关系表示为一个map，这个map的键是一个枚举（起始阶段），值为另一个map，这第二个map的键为第二个枚举（目标阶段），它的值为结果（阶段过渡），即形成了Map（起始阶段，Map（目标阶段，阶段过渡））这种形式。一个阶段过滤所关联的两个阶段，最好通过“数据与阶段过渡枚举之间的关联”来获取，之后用该阶段过渡枚举来初始化嵌套的EnumMap。
//
package test;

import java.util.EnumMap;
import java.util.Map;
import java.util.stream.Stream;

public enum Phase {
    SOLID, LIQUID, GAS; //扩展一个状态：SOLID, LIQUID, GAS, PLASMA;

    public enum Transition {
        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),
        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),
        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID); //扩展两种状态转换：IONIZE(GAS, PLASMA), DEIONIZE(PLASMA, GAS);，其余代码一行不用修改

        private final Phase src;
        private final Phase dst;

        Transition(Phase src, Phase dst) {
            this.src = src;
            this.dst = dst;
        }

        // Initialize the phase transition map
        private static final Map<Phase, Map<Phase, Transition>> m = new EnumMap<>(Phase.class);

        static {
            Stream.of(Phase.values()).forEach(p -> m.put(p, new EnumMap<>(Phase.class)));
            Stream.of(Transition.values()).forEach(trans -> m.get(trans.src).put(trans.dst, trans));
        }

        // Returns the phase transition from one phase to another
        public static Transition from(Phase src, Phase dst) {
            return m.get(src).get(dst);
        }
    }
}

现在假设想要给系统添加一个新的阶段：plasma（离子）或者电离气体。只有两个过渡与这个阶段关联：电离化，它将气体变成离子，以及消电离化，将离子变成气体。为了更新基于数组的程序，必须给Phase添加一种新常量，给Phase.Transition添加两种新常量，用一种新的16个元素的版本取代原来9个元素的数组的数组。如果给数组添加的元素过多或者过少，或者元素放置不妥当，可就麻烦了：程序可以编译，但是会在运行时失败。为了更新基于EnumMap的版本，所要做的就是必须将PLASMA添加到Phase列表中，并将IONIZE(GAS, PLASMA)和DEIONIZE(PLASMA, GAS)添加到Phase.Transition的列表中。程序会自行处理所有其他的事情，你几乎没有机会出错。从内部来看，Map的Map都实现了数组的数组，因此在提升了清楚性、安全性和易维护性的同时，在空间或者时间上还几乎不用任何开销。

总而言之，最好不要用序数来索引数组，而要使用EnumMap。如果所表示的这种关系是多维的，就使用EnumMap<..., EnumMap<...>>。应用程序的程序员在一般情况下都不使用Enum.ordinal，即使要用也很少，因此这是一种特殊情况（见第31条）。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第34条：用接口模拟可伸缩的枚举 P144
对于可伸缩的枚举类型而言，至少有一种具有说服力的用例，这就是操作码（operation code），也称作opcode。操作码是指这样的枚举类型：它的元素表示在某种机器上的那些操作，例如第30条中的Operation类型，它表示一个简单的计算器中的某些函数。有时候，要尽可能地让API的用户提供它们自己的操作，这样可以有效地扩展API所提供的操作集。

有一种很好的方法可以利用枚举类型来实现这种效果。由于枚举类型可以通过给操作码类型和（属于接口的标准实现的）枚举定义接口，来实现任意接口，基本的想法就是利用这一事实。如，以下是第30条中的Operation类型的扩展版本：
//
package test;

public interface Operation {
    double apply(double x, double y);
}

//
package test;

public enum BasicOperation implements Operation {
    PLUS("+") {
        @Override
        public double apply(double x, double y) {
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        public double apply(double x, double y) {
            return x - y;
        }
    },
    TIMES("*") {
        @Override
        public double apply(double x, double y) {
            return x * y;
        }
    },
    DIVIDE("/") {
        @Override
        public double apply(double x, double y) {
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
}

//
package test;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class OperationTest {
    @Test
    public void testBasicOperation_Plus() {
        Operation plus = BasicOperation.PLUS;
        assertEquals(10, plus.apply(3, 7), 1e-10);
    }
}

虽然枚举类型（BasicOperation）不是可扩展的，但接口类型（Operation）则是可扩展的，它是用来表示API中的操作的接口类型。可以定义另一个枚举类型，它实现这个接口，并用这个新类型的实例代替基本类型。如，假设想要定义一个上述操作类型的扩展，由求幂（exponentiation）和求余（remainder）操作组成。所要做的就是编写一个枚举类型，让它实现Operation接口：
//
package test;

public enum ExtendedOperation implements Operation {
    EXP("^") {
        @Override
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    REMAINDER("%") {
        @Override
        public double apply(double x, double y) {
            return x % y;
        }
    };

    private final String symbol;

    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }
}

//
@Test
public void testExtendedOperation_Exp() {
    Operation exp = ExtendedOperation.EXP;
    assertEquals(8, exp.apply(2, 3), 1e-10);
}

在可以使用基础操作的任何地方，都可以使用新的操作，只要API是被写成采用接口类型（Operation）而非实现（BasicOperation）。注意，在枚举中，不必像在不可扩展的枚举中所做的那样，利用特定于实例的方法实现来声明抽象的apply方法。这是因为抽象的方法（apply）是接口（Operation）的一部分。

不仅可以在任何需要“基本枚举”的地方单独传递一个“扩展枚举”的实例，而且除了那些基本类型的元素之外，还可以传递完整的扩展枚举类型，并使用它的元素。如，通过下面的这个测试程序，体验一下定义过的所有扩展过的操作：
//
package test;

import java.util.stream.Stream;

public class MainTest {
    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        test(BasicOperation.class, x, y);
        test(ExtendedOperation.class, x, y);
    }

    private static <T extends Enum<T> & Operation> void test(Class<T> opSet, double x, double y) {
        Stream.of(opSet.getEnumConstants()).forEach(op -> System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y)));
    }
}
输出：
10.000000 + 5.000000 = 15.000000
10.000000 - 5.000000 = 5.000000
10.000000 * 5.000000 = 50.000000
10.000000 / 5.000000 = 2.000000
10.000000 ^ 5.000000 = 100000.000000
10.000000 % 5.000000 = 0.000000

注意扩展过的操作类型的类的字面文字（ExtendedOperation.class）从main被传递给了test方法，来描述被扩展操作的集合。这个类的字面文字充当有限制的类型令牌（见第29条）。opSet参数中公认很复杂的声明（<T extends Enum<T> & Operation> Class<T>）确保了Class对象既表示枚举又表示Operation的子类型，这正是遍历元素和执行与每个元素相关联的操作时所需要的。

第二种方法是使用Collection<? extends Operation>，这是个有限制的通配符类型（bounded wildcard type）（见第28条），作为opSet参数的类型：
//
package test;

import java.util.Arrays;
import java.util.Collection;

public class MainTest {
    public static void main(String[] args) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        test(Arrays.asList(BasicOperation.values()), x, y);
        test(Arrays.asList(ExtendedOperation.values()), x, y);
    }

    private static void test(Collection<? extends Operation> opSet, double x, double y) {
        opSet.stream().forEach(op -> System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y)));
    }
}
输出同上

这样得到的代码没有那么复杂，test方法也比较灵活一些：它允许调用者将多个实现类型的操作合并到一起。另一方面，也放弃了在指定操作上使用EnumSet（见第32条）和EnumMap（见第33条）的功能，因此，除非需要灵活地合并多个实现类型的操作，否则可能最好使用有限制的类型令牌。

用接口模拟可伸缩枚举有个小小的不足，即无法将实现从一个枚举类型继承到另一个枚举类型。在上述Operation的示例中，保存和获取与某项操作相关联的符号的逻辑代码，可以复制到BasicOperation和ExtendedOperation中。在这个例子中是可以的，因为复制的代码非常少。如果共享功能比较多，则可以将它封装在一个辅助类或者静态辅助方法中，来避免代码的复制工作。

总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。这样允许客户端编写自己的枚举来实现接口。如果API是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第35条：注解优先于命名模式 P147
Java 1.5 发行版本之前，一般使用命名模式（naming pattern）表明有些程序元素需要通过某种工具或者框架进行特殊处理。例如，JUnit测试框架原本要求它的用户一定要用test作为测试方法名称的开头。这种方法可行，但有几个严重的缺点。首先，文字拼写错误会导致失败，且没有任何提示。
命名模式的第二个缺点是，无法确保它们只用于相应的程序元素上。
命名模式的第三个缺点是，它们没有提供将参数值与程序元素关联起来的好方法。

注解很好地解决了所有的问题。假设想要定义一个注解类型来指定简单的测试，它们自动运行，并在抛出异常时失败。以下就是这样的一个注解类型，命名为Test：
// Marker annotation type declaration
package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Indicates that the annotated method is a test method.
 * Use only on parameterless static methods.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}

Test注解类型的声明就是它自身通过Retention和Target注解进行了注解。注解类型声明中的这种注解被称作元注解（meta-annotation）。@Retention(RetentionPolicy.RUNTIME)元注解表明，Test注解应该在运行时保留。如果没有保留，测试工具就无法知道Test注解。@Target(ElementType.METHOD)元注解表明，Test注解只在方法声明中才是合法的：它不能运用到类声明、域声明或者其他程序元素上。

注意Test注解声明上方的注释：“Use only on parameterless static methods.（只用于无参的静态方法）”。如果编译器能够强制这一限制最好，但是它做不到。编译器可以替你完成多少错误检查，这是有限制的，即便是利用注解。如果Test注解放在实例方法的声明中，或者放在带有一个或者多个参数的方法中，测试程序还是可以编译，让测试工具在运行时来处理这个问题。

下面是现实应用中的Test注解，称作标记注解（marker annotation），因为它没有参数，只是“标注”被注解的元素。如果程序员拼错了Test，或者将注解应用到程序元素而非方法声明，程序就无法编译：
//
package test;

// Program containing marker annotations
public class Sample {
    @Test
    public static void m1() {
    }

    public static void m2() {
    }

    @Test
    public static void m3() {
        throw new RuntimeException("Boom");
    }

    public static void m4() {
    }

    @Test
    public void m5() {
    }

    public static void m6() {
    }

    @Test
    public static void m7() {
        throw new RuntimeException("Crash");
    }

    public static void m8() {
    }
}

Sample类有8个静态方法，其中4个被注解为测试。这4个中有两个抛出了异常：m3和m7，另外两个则没有：m1和m5。但是其中一个没有抛出异常的被注解方法：m5，是一个实例方法，因此不属于注解的有效使用。总之，Sample包含4项测试：一项会通过，两项会失败，另一项无效。没有用Test注解进行标注的4个方法会被测试工具忽略。

Test注解对Sample类的语义没有直接的影响。它们只负责提供信息供相关的程序使用。更一般地讲，注解永远不会改变被注解代码的语义，但是使它可以通过工具进行特殊的处理，例如像这样简单的测试运行类：
//args[0]=test.Sample
package test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(Test.class)) {
                tests++;
                try {
                    m.invoke(null); //m5会失败是由于它不是静态方法，不能直接由Method.invoke()来触发，必须绑定在对象上才可以触发，所以抛异常了
                    passed++;
                } catch (InvocationTargetException wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    System.out.println(m + " failed: " + exc);
                } catch (Exception exc) {
                    System.out.println("INVALID @Test: " + m);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n", passed, tests - passed);
    }
}
输出：
INVALID @Test: public void test.Sample.m5()
public static void test.Sample.m7() failed: java.lang.RuntimeException: Crash
public static void test.Sample.m3() failed: java.lang.RuntimeException: Boom
Passed: 1, Failed: 3

测试运行工具在命令行上使用完全匹配的类名，通过调用Method.invoke反射式地运行类中所有标注了Test的方法。isAnnotationPresent方法告知该工具要运行哪些方法。如果测试方法抛出异常，反射机制就会它封装在InvocationTargetException中。该工具捕捉到了这个异常，并打印失败报告，包含测试方法抛出的原始异常，这些信息是通过getCause方法从InvocationTargetException中提取出来的。

如果尝试通过反射调用测试方法时抛出InvocationTargetException之外的任何异常，表明编译时没有捕捉到Test注解的无效用法。这种用法包括实例方法的注解，或者带有一个或者多个参数的方法的注解，或者不可访问的方法的注解。测试运行类中的第二个catch块捕捉到了这些Test用法错误，并打印出相应的错误消息。

现在要针对只在抛出特殊异常时才成功的测试添加支持。为此需要一个新的注解类型：
//
package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 *  Indicates that the annotated method is a test method that
 *  must throw the designated exception to succeed
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception> value();
}

这个注解的参数类型是Class<? extends Exception>。这个通配符类型无疑很绕口。它在英语中的意思是：某个扩展Exception的类的Class对象，它允许注解的用户指定任何异常类型。这种用法是有限制的类型令牌（见第29条）的一个示例。下面就是实际应用中的这个注解。注意类名称被用作了注解的参数值：
//
package test;

// Program containing annotations with a parameter
public class Sample2 {
    @ExceptionTest(ArithmeticException.class)
    public static void m1() {
        int i = 0;
        i = i / i;
    }

    @ExceptionTest(ArithmeticException.class)
    public static void m2() { // Should fail (wrong exception)
        int[] a = new int[0];
        int i = a[0];
    }

    @ExceptionTest(ArithmeticException.class)
    public static void m3() { // Should fail (no exception)
    }
}

修改一下测试运行工具来处理新的注解，如下：
//
package test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(ExceptionTest.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("Test %s failed: no exception%n", m);
                } catch (InvocationTargetException wrappedEx) {
                    Throwable exc = wrappedEx.getCause();
                    Class<? extends Exception> excType = m.getAnnotation(ExceptionTest.class).value();
                    if (excType.isInstance(exc)) {
                        passed++;
                    } else {
                        System.out.printf("Test %s failed: excepted %s, got %s%n", m, excType.getName(), exc);
                    }
                } catch (Exception exc) {
                    System.out.println("INVALID @Test: " + m);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n", passed, tests - passed);
    }
}
输出：
Test public static void test.Sample2.m3() failed: no exception
Test public static void test.Sample2.m2() failed: excepted java.lang.ArithmeticException, got java.lang.ArrayIndexOutOfBoundsException: 0
Passed: 1, Failed: 2

这段代码类似于用来处理Test注解的代码，但有一处不同：这段代码提取了注解参数的值，并用它检验测试抛出的异常是否为正确的类型。没有显式的转换，因此没有出现ClassCastException的危险。编译过的测试程序确保它的注解参数表示的是有效的异常类型，需要提醒一点：有可能注解参数在编译时是有效的，但是表示特定异常类型的类文件在运行时却不再存在。在这咱希望很少出现的情况下，测试运行类会抛出TypeNotPresentException异常。

将上面的异常测试示例再深入一点，想像测试可以在抛出任何一种指定异常时都得到通过。注解机制有一种工具，使得支持这种用法变得十分容易。假设将ExceptionTest注解的参数类型改成Class对象的一个数组：
//
package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// Annotation type with an array parameter
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception>[] value();
}

注解中数组参数的语法十分灵活。它是进行过优化的单元素数组。使用了ExceptionTest新版的数组参数之后，之前的所有ExceptionTest注解仍然有效，并产生单元素的数组。为了指定多元素的数组，要用花括号（{}）将元素包围起来，并用逗号（,）将它们隔开：
@ExceptionTest({IndexOutOfBoundsException.class, NullPointerException.class})
public static void doublyBad() {
    List<String> list = new ArrayList<>();
    list.addAll(5, null); // This method throws IndexOutOfBoundsException
}

修改测试运行工具来处理新的ExceptionTest相当简单。下面的代码代替了原来的代码：
//
package test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class testClass = Class.forName(args[0]);
        for (Method m : testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(ExceptionTest.class)) {
                tests++;
                try {
                    m.invoke(null);
                    System.out.printf("Test %s failed: no exception%n", m);
                } catch (InvocationTargetException wrappedEx) {
                    Throwable exc = wrappedEx.getCause();
                    Class<? extends Exception>[] excTypes = m.getAnnotation(ExceptionTest.class).value();
                    int oldPassed = passed;
                    for (Class<? extends Exception> excType : excTypes) {
                        if (excType.isInstance(exc)) {
                            passed++;
                            break;
                        }
                    }
                    if (passed == oldPassed) {
                        System.out.printf("Test %s failed: excepted %s %n", m, exc);
                    }
                } catch (Exception exc) {
                    System.out.println("INVALID @Test: " + m);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n", passed, tests - passed);
    }
}

本条目中开发的测试框架只是一个试验，但它清楚地示范了注解之于命名模式的优越性。它这还只是揭开了注解功能的冰山一角。如果是在编写一个需要程序员给源文件添加信息的工具，就要定义一组适当的注解类型。既然有了注解，就完全没有理由再使用命名模式了。

也就是说，除了“工具铁匠（toolsmiths――特定的程序员）”之外，大多数程序员都不必定义注解类型。但是所有的程序员都应该使用Java平台提供的预定义的注解类型（见第36条和24条）。还要考虑使用IDE或者静态分析工具所提供的任何注解。这种注解可以提升由这些工具所提供的诊断信息的质量。但是要注意这些注解还没有标准化，因此如果变换工具或者形成标准，就有很多工具要做了。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第36条：坚持使用Override注解 P152
如果坚持使用这个注解，可以防止一大类的非法错误。

应该在你想覆盖超类声明的每个方法声明中使用Override注解。这一规则有个小小的例外。如果你在编写一个没有标注为抽象的类，并且确信它覆盖了抽象的方法，在这种情况下，就不必将Override注解放在该方法上了。在没有声明为抽象的类中，如果没有覆盖抽象的超类方法，编译器就会发出一条错误消息。但是，你可能希望关注类中所有覆盖超类方法的方法，在这种情况下，也可以放心地标注这些方法。

总而言之，如果在你想要的每个方法声明中使用Override注解来覆盖超类声明，编译器就可以替你防止大量的错误，但是有一个例外。在具体的类中，不必标注你确信覆盖了抽象方法声明的方法（虽然这么做也没有什么坏处）。
//------------------------------------------------------------------------------------------------
//Effective Java 第6章 枚举和注解 P128
//第37条：用标记接口定义类型 P152
标记接口（marker interface）是没有包含方法声明的接口，而只是指明（或者“标明”）一个类实现了具有某种属性的接口。例如，考虑Serializable接口（见第11章）。通过实现这个接口，类表明它的实例可以被写到ObjectOutputStream（或者“被序列化”）。

package java.io;

public interface Serializable {
}

可能听说过标记注解（见第35条）使得标记接口过时了。这种断言是不正确的。标记接口有两点胜过标记注解。首先，也是最重要的一点是，标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型。这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误。

就Serializable标记接口而言，如果它的参数没有实现该接口，ObjectOutputStream.write(Object)方法将会失败。令人不解的是，ObjectOutputStream API的创建者在声明write方法时并没有利用Serializable接口。该方法的参数类型应该为Serializable而非Object。因此，试着在没有实现Serializable的对象上调用ObjectOutputStream.write，只会在运行时失败，但也并不一定如此。

标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定。如果注解类型利用@Target(ElementType.TYPE)声明，它就可以被应用到任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它将唯一的接口扩展成它适用的接口。

Set接口可以说就是这种有限制的标记接口（restricted marker interface）。它只适用于Collection子类型，但是它不会添加除了Collection定义之外的方法。一般情况下，不把它当作是标记接口，因为它改进了几个Collection方法契约，包括add、equals和hashCode。但是很容易想像只适用于某种特殊接口的子类型的标记接口，它没有改进接口的任何方法的契约。这种标记接口可以描述整个对象的某个约束条件，或者表明实现能够利用其他某个类的方法进行处理（就像Serializable接口表明实现可以通过ObjectOutputStream进行处理一样）。

标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给已被使用的注解类型添加更多的信息。随着时间的推移，简单的标记注解类型可以演变成更加丰富的注解类型。这种演变对于标记接口而言则是不可能的，因为它通过不可能在实现接口之后再给它添加方法（见第18条）。

标记注解的另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。

如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或者扩展接口。如果标记只应用给类和接口，就要问问自己：要编写一个还是多个只接受有这种标记的方法？如果是这种情况，就应该优先使用标记接口而非注解。这样就可以用接口作为相关方法的参数类型，它真正可以为你提供编译时进行类型检查的好处。

如果对第一个问题的回答是否定的，就要再问问自己：我要永远限制这个标记只用于特殊接口的元素吗？如果是，最好将标记定义成该接口的一个子接口。如果这两个问题的答案都是否定的，或者就应该使用标记注解。

总而言之，标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。如果你发现自己在编写的是目标为ElementType.TYPE的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否会更加适合。

从某种意义上说，本条目与第19条中“如果不想定义类型就不要使用接口”的说法相反。本条目最接近的意思是说：如果想要定义类型，一定要使用接口。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第38条：检查参数的有效性 P156
如果传递无效的参数值给方法，这个方法在执行之前先对参数进行了检查，那么它很快就会失败，并且清楚地出现适当的异常（exception）。

对于公有的方法，要用Javadoc的@throws标签（tag）在文档中说明违反参数值限制时会抛出的异常（见第62条）。这样的异常通常为IllegalArgumentException、IndexOutOfBoundsException或NullPointerException（见第60条）。一旦在文档中记录了对于方法参数的限制并且记录了一旦违反这些限制将要抛出的异常，强加这些限制就是非常简单的事情了。下面是一个典型的例子：

/**
 * Returns a BigInteger whose value is (this mod m). This method
 * differs from the remainder method in that it always returns a 
 * non-negative BigInteger
 *
 * @param m the modulus, whick must be positive
 * @return this mod m
 * @throws ArithmeticException if m is less than or equal to 0
*/
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) {
        throw new ArithmeticException("Modulus <= 0: " + m);
    }
    //... Do the computation
}

对于未被导出的方法（unexported method），作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只将有效的参数值传递进来。因此，非公有的方法通常应该使用断言（assertion）来检查它们的参数，具体做法如下：
// Private helper function for a recursive sort
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    // ... Do the computation
}

从本质上讲，这些断言是在声称被断言的条件将会为真，无论外围包的客户端如何使用它。不同于一般的有效性检查，断言如果失败，将会抛出AssertionError。也不同于一般的有效性检查，如果它们没有起到作用，本质上也不会有成本开销，除非通过将-ea（或者-enableassertions）标记（flag）传递给Java解释器，来启用它们。

对于有些参数，方法本身没有用到，却被保存起来供以后使用，检验这类参数的有效性尤其重要。如，考虑第83页中的静态工厂方法（搜static List<Integer> intArrayAsList(final int[] a) {），它的参数为一个int数组，并返回该数组的List视图。如果这个方法的客户端要传递null，该方法就会抛出一个NullPointerException。因为该方法包含一个显式的条件检查。如果省略了这个条件检查，它就会返回一个指向新建List实例的引用，一旦客户端企图使用这个引用，立即就会抛出NullPointerException。到那时，要想找到List实例的来源可能就非常困难了，从而使得调试工作极大地复杂化了。

如前所述，有些参数被方法保存起来供以后使用，构造器正是代表了这种原则的一种特殊情形。检查构造器参数的有效性是非常重要的，这样可以避免构造出来的对象违反了这个类的约束条件。

在方法执行它的计算任务之前，应该先检查它的参数，这一规则也有例外。一个很重要的例外是，在有些情况下，有效性检查工作非常昂贵，或者根本不切实际的，而且有效性检查已隐含在计算过程中完成。如果Collections.sort(List)。如果这些对象不能相互比较，其中的某个比较操作就会抛出ClassCastException，这正是sort方法所应该做的事情。因此，提前检查列表中的元素是否可以相互比较，这并没有多大意义。然后，请注意，不加选择地使用这种方法将会导致失去失败原子性（failure atomicity）（见第64条）。

有些，某些计算会隐式地执行必要的有效性检查，但是如果检查不成功，就会抛出错误的异常。由于无效的参数值而导致计算过程抛出的异常，与文档中标明这个方法将抛出的异常并不相符。在这种情况下，应该使用第61条中讲述的异常转译（exception translation）技术，将计算过程中抛出的异常转换为正确的异常。

不要从本条目的内容中得出这样的结论：对参数的任何限制都是件好事。相反，在设计方法时，应该使它们尽可能地通用，并符合实际的需要。假如方法对于它能接受的所有参数值都能够完成合理的工作，对参数的限制就应该是越少越好。然后，通常情况下，有些限制对于被实现的抽象来说是固有的。

简而言之，当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的形状处，通过显式的检查来实话这些限制。养成这样的习惯是非常重要的。只要有效性检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利地得到偿还了。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第39条：必要时进行保护性拷贝 P159
编写一些面对客户的不良行为时仍能保持健壮性的类，是非常值得投入时间去做的事情。
没有对象的帮助时，虽然另一个类不可能修改对象的内部状态，但是对象很容易在无意识的情况下提供这种帮助。如，考虑下面的类，它声称可以表示一段不可变的时间周期：
//
package test;

import java.util.Date;

public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start of end is null
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + " after " + end);
        }

        this.start = start;
        this.end = end;
    }

    public Date start() {
        return start;
    }

    public Date end() {
        return end;
    }

    @Override
    public String toString() {
        return String.format("Period from %tF to %tF.", start, end);
    }

    public static void main(String[] args) {
        // Attack the internals of a Period instance
        Date start = new Date();
        Date end = new Date();
        Period period = new Period(start, end);
        System.out.println(period);

        end.setYear(10);// Modifies internals of period!
        System.out.println(period);
    }
}
输出：
Period from 2017-04-21 to 2017-04-21.
Period from 2017-04-21 to 1910-04-21.

乍一看，这个类似乎是不可变的，并且强加了约束条件：周期的起始时间（start）不能在结束时间（end）之后。然后，因为Date类本身是可变的，因此很容易违反这个约束条件，如上。

为了保护Period实例的内部信息避免受到这种攻击，对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的，并且使用备份对象作为Period实例的组件，而不使用原始的对象：
// Repaired constructor - makes defensive copies of parameters
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0) {
        throw new IllegalArgumentException(start + " after " + end);
    }
}

用了新的构造器之后，上述的攻击对于Period实例不再有效。保护性拷贝是在检查参数的有效性（见第38条）之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。虽然这样做看起来有点不太自然，却是必要的。这样做可以避免在“危险阶段（window of vulnerability）”期间从另一个线程改变类的参数，这里的危险阶段是指从检查参数开始，直到拷贝参数之间的时间段。（在计算机安全社区中，这被称作Time-Of-Check/Time-Of-Use或者TOCTOU攻击。这是否和第38条有些相悖？）

同时也请注意，我们没有用Date的clone方法来进行保护性拷贝。因为Date是非final的，不能保证clone方法一定返回类为java.util.Date的对象：它有可能返回专门出于恶意的目的而设计的不可信子类的实例。例如，这样的子类可以在每个实例被创建的时候，把指向该实例的引用记录到一个私有的静态列表中，并且允许攻击者访问这个列表。这将使得攻击者可以自由地控制所有的实例。为了阻止这种攻击，对于参数类型可以被不可信息方子类化的参数，请不要使用clone方法进行保护性拷贝。

虽然替换构造器就可以成功地避免上述的攻击，但是改变Period实例仍然是有可能的，因为它的访问方法提供了对其可变内部成员的访问能力：
// Second attack on the internals of a Period instance
public static void main(String[] args) {
    Date start = new Date();
    Date end = new Date();
    Period period = new Period(start, end);
    System.out.println(period);

    period.end().setYear(10);
    System.out.println(period);
}
为了防御这第二种攻击，只需修改这两个访问方法，使它返回可变内部域的保护性拷贝即可：
// Repaired accessors - make defensive copies of internal fields
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}

采用了新的构造器和新的访问方法之后，Period真正是不可变的了。不管程序员多么恶意，或者多么不合格，都绝对不会违反“周期的起始时间不能落后于结束时间”这个约束条件。因为除了Period类自身之外，其他任何类都无法访问Period实例中的任何一个可变域。这些域被真正封装在对象的内部。

访问方法与构造器不同，它们在进行保护性拷贝的时候允许使用clone方法。之所以如此，是因为我们知道，Period内部的Date对象的类是java.util.Date，而不可能是其他某个潜在的不可信子类。也就是说，基于第11条中所阐述的原因，一般情况下，最好使用构造器或者静态工厂。

参数的保护性拷贝并不仅仅针对不可变类。每当编写方法或者构造器时，如果它要允许客户提供的对象进入内部数据结构中，则有必要考虑一下，客户提供的对象是否有可能是可变的。如果是，就要考虑你的类是否能够容忍对象进入数据结构之后发生变化。如果答案是否定的，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。如，如果你正在拷贝使用由客户提供的对象引用作为内部Set实例的元素，或者作为内部Map实例的键（key），就应该意识到，如果这个对象在插入之后再被修改，Set或者Map的约束条件就会遭到破坏。

在内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样的道理。不管类是否为不可变的，在把一个指向内部可变组件的引用给客户端之前，也应该加倍认真地考虑。解决方案是，应该返回性拷贝。记住长度非零的数组总是可变的。因此，在把内部数组返回给客户端之前，应该总要进行保护性拷贝。另一种解决方案是：给客户端返回该数组的不可变视图（immutable view）。这两种方法在第13条中都已经演示过了。

可以肯定地说，只要有可能，都应该使用不可变的对象作为对象内部的组件，这样就不必要再为保护性拷贝（见第15条）操心。在前面的Period例子中，值得一提的是，有经验的程序员通常使用Date.getTime()返回的long基本类型作为内部的时间表示法，而不是使用Date对象引用。这样做主要因为Date是可变的。

保护性拷贝可能会带来相关的性能损失，这种说法并不总是正确的。如果类信任它的调用者不会修改内部的组件，可能因为类及其客户端都是同一个包的双方，那么不进行保护性拷贝也是可以的。在这种情况下，类的文档中就必须清楚地，调用者绝不能修改受到影响的参数或者返回值。

即便跨越包的作用范围，也并不总是适合在将可变参数整合到对象中之前，对它进行保护性拷贝。有一些方法和构造器的调用，要求参数所引用的对象必须有个显式的交接（handoff）过程。当客户端调用这样的方法时，它承诺以后不再直接修改该对象。如果方法或者构造器期望接管一个由客户端提供的可变对象，它就必须在文档中明确地指明这一点。

简而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第40条：谨慎设计方法签名 P163
谨慎地选择方法的名称。方法的名称应该始终遵循标准的命名习惯（见第56条）。

不要过于追求提供便利的方法。

避免过长的参数列表。目标是四个参数，或者更少。相同类型的长参数序列格外有害。
有三种方法可以缩短过长的参数列表。第一种是把方法分解成多个方法，每个方法只需要这些参数的一个子集。如果不小心，这样做会导致方法过多，但是通过提升它们的正交性（orthogonality），还可以减少（reduce）方法的数目。
缩短长参数列表的第二种方法是创建辅助类（helper class），用来保存参数的分组。这些辅助类一般为静态成员类（见第22条）。如果一个频繁出现的参数序列可以被看作是代表了某个独特的实例，则建议使用这种方法。如，你正在编写一个表示纸牌游戏的类，经常要传递一个两参数的序列来表示纸牌的点数和花色。如果增加辅助类来表示一张纸牌，并且把每个参数序列都换成这个辅助类的单个参数，那么这个纸牌游戏类的API以及它的内部表示都可能会得到改进。
结合了前两种方法特征的第三种方法是，从对象构建到方法调用都采用Builder模式（见第2条）。如果方法带有多个参数，尤其是当它们中有些是可选的时候，最好定义一个对象来表示所有参数，并允许客户端在这个对象上进行多次“setter”调用，每次调用都设置一个参数，或者设置一个较小的相关的集合。一旦设置了需要的参数，客户端就调用对象的“执行（execute）”方法，它对参数进行最终的有效性检查，并执行实际的计算。

对于参数类型，要优先使用接口而不是类（请见第52条）。只要有适当的接口可用来定义参数，就优先使用这个接口，而不是使用实现该接口的类。如，没有理由在编写方法时使用HashMap类来作为输入，应当使用Map接口作为参数。如果使用的是类而不是接口，则限制了客户端只能传入特定的实现，如果碰巧输入的数据是以其他的形式存在，就会导致不必要的、可能非常昂贵的拷贝操作。

对于boolean参数，要优先使用两个元素的枚举类型。它使代码更易于阅读和编写，尤其当你在使用支持自动完成功能的IDE的时候。它也使以后更易于添加更多的选项。如，可能会有一个Thermometer类型，它带有一个静态工厂方法，而这个静态工厂方法的签名压根传入这个枚举的值：
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
Thermometer.newInstance(TemperatureScale.CELSIUS)不仅比Thermomter.newInstance(true)更有用，而且你也可以在未来的发行版本中将KELVIN添加到TemperatureScale中，无需非得给Thermometer添加新的静态工厂。还可以将依赖于温度刻度单位的代码重构到枚举常量的方法中（见第30条）。例如，每个刻度单位都可以有一个方法，它带有一个double值，并将它规格化成摄氏度。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第41条：慎用重载 P165
下面这个程序意图是好的，试图根据一个集合（collection）是Set、List，还是其他的集合类型，来对它进行分类：
//
package test;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

public class CollectionClassifier {
    public static String classify(Set<?> set) {
        return "Set";
    }

    public static String classify(List<?> list) {
        return "List";
    }

    public static String classify(Collection<?> collection) {
        return "Unknown Collection";
    }

    public static void main(String[] args) {
        Collection<?>[] collections = {new HashSet<String>(), new ArrayList<BigInteger>(), new HashMap<String, String>().values()};
        Stream.of(collections).forEach(c -> System.out.println(classify(c)));
    }
}
输出：
Unknown Collection
Unknown Collection
Unknown Collection

可能期望程序会打印出“Set”，“List”以及“Unknown Collection”，实际打印了“Unknown Collection”三次。因为classify方法被重载（overloaded）了，而要调用哪个重载（overloading）方法是在编译时就做出决定 的。对于for循环中的全部三次迭代，参数的编译时类型是相同的：Collection<?>。每次迭代的运行时类型都是不同的，但这并不影响对重载方法的选择。因为该参数的编译时类型是Collection<?>，所以，唯一合适的重载方法是第三个：classify(Collection<?>)，在循环的每次迭代中，都会调用这个重载方法。

这个程序的行为有悖常理，因为对于重载方法（overloaded method）的选择是静态的，而对于被覆盖的方法（overridden method）的选择则是动态的。选择被覆盖的方法是正确版本是在运行时进行的，选择的依据是被调用方法所在对象的运行时类型。当一个子类包含的方法声明与其祖先类中的方法声明具有相同的签名时，方法就被覆盖了。如果实例方法在子类中被覆盖了，并且这个方法是在该子类的实例上被调用的，那么子类中的覆盖方法（overriding method）将会执行，而不管该子类实例的编译时类型是什么。考虑下面的程序：（略）

与重载的情形相比，对象的运行时类型并不影响“哪个重载版本将被执行”；选择工作是在编译时进行的，完全基本参数的编译时类型。

在CollectionClassifier这个示例中，程序的意图是：期望编译器根据参数的运行时类型自动将调用分发给适当的重载方法，以此来识别出参数的类型，就好像Wine的例子中的name方法所做的那样。方法重载机制完全没有提供这样的功能。假设需要有个静态方法，这个程序的最佳修改方案是，用单个方法来替换这三个重载的classify方法，并在这个方法中做一个显式的instanceof测试：
public static String classify(Collection<?> c) {
    return c instanceof Set ? "Set" :
        c instanceof List ? "List" : "Unknown Collection";
}

因为覆盖机制是规范，而重载机制是例外，所以覆盖机制满足了人们对于方法调用行为的期望。重载机制很容易使这些期望落空。如果API的普通用户根本不知道“对于一组给定的参数，其中的哪个重载方法将会被调用”，那么，使用这样的API就很可能导致错误。这些错误要等到运行时发生了怪异的行为之后才会显现出来，许多程序员无法诊断出这样的错误。因此，应该避免胡乱地使用重载机制。

怎么才算胡乱使用重载机制，这个问题仍胡争议。安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数（varargs），保守的策略是根本不要重载它，除第42条中所述的情形之外。这项限制并不麻烦，因为你始终可以给方法起不同的名称，而不使用重载机制。

如，考虑ObjectOutputStream类。对于每个基本类型，以及几种引用类型，它的write方法都有一种变形。这些变形方法并不是重载write方法，而是具有诸如writeBoolean(boolean)、writeInt(int)和writeLong(long)这样的签名。与重载方法相比较，这种命名模式带来的好处是，有可能提供相应名称的读方法，比如readBoolean()、readInt()和readLong()。实际上，ObjectInputStream类正是提供了这样的读方法。

对于构造器，你没有选择使用不同名称的机会：一个类的多个构造器总是重载的。在许多情况下，可以选择静态工厂，而不是构造器（见第1条）。对于构造器，还不用担心重载和覆盖的相互影响，因为构造器不可能被覆盖。或许你有可能导出多个具有相同参数数目的构造器，所以有必要了解一下如何安全地做到这一点。

在Java 1.5 发行版本之前，所有的基本类型都根本不同于所有的引用类型，但是当自动装箱出现之后，就不再如此了，它会真正的麻烦。考虑如下程序：
//
package test;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.IntStream;

public class SetList {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>();
        List<Integer> list = new ArrayList<>();

        IntStream.range(-3, 3).forEach(i -> {
            set.add(i);
            list.add(i);
        });

        IntStream.range(0, 3).forEach(i -> {
            set.remove(i);
            list.remove(i);
        });

        System.out.println(set + " " + list);
    }
}
输出：
[-3, -2, -1] [-2, 0, 2]

像大多数人一样，希望程序从集合和列表中除去非负数值（0，1和2），并打印出[-3, -2, -1] [-3, -2, -1]。事实上，程序从集合中去除了非负数，还从列表中去除了奇数值，打印出[-3, -2, -1] [-2, 0, 2]。将这种行为称之为混乱，已是保守的说法。

实际发生的情况是：set.remove(i)调用选择重载方法remove(E)，这里的E是集合（Integer）的元素类型，将i从int自动装箱到Integer中。这是你所期待的行为，因此程序不会从集合中去除正值。另一方法，list.remove(i)调用选择重载方法remove(int i)，它从列表的指定位置上去除元素。为了解决这个问题，要将list.remove的参数转换成Integer，迫使选择正确的重载方法。另一种方法是，可以调用Integer.valueOf(i)，并将结果传给list.remove。这两种方法都如我们所料，打印出[-3, -2, -1] [-3, -2, -1]：
IntStream.range(0, 3).forEach(i -> {
    set.remove(i);
    list.remove((Integer) i); // or list.remove(Integer.valueOf(i));
});

这种情形清楚地说明了，自动装箱和泛型成了Java语言的一部分之后，谨慎重载显得更加重要了。

有时候，尤其在更新现有类的时候，可能会被迫违反本条目的指导原则。如，自从Java 1.4 发行版本以来，String类就已经有一个contentEquals(StringBuffer)方法。在Java 1.5 发行版本中，新增了一个称作CharSequence的接口，用来为StringBuffer、StringBuilder、String、CharBuffer以及其他类似的类型提供公有接口，为实现这个接口，对它们全都进行了改造。在Java平台中增加CharSequence的同时，String也配备了重载的contentEquals方法，即contentEquals(CharSequence)方法，这个方法表示，当且仅当此String表示与CharSequence序列相同的char值时，返回true。

尽管这样的重载很显示违反了本条目的指导原则，但是只要当这两个重载方法在同样的参数上被调用时，它们执行相同的功能，重载就不会带来危害。程序员可能并不知道哪个重载函数会被调用，但只要这两个方法返回相同的结果就行。确保这种行为的标准做法是，让更具体化的重载方法把调用转发给更一般化的重载方法：
public booleam contentEquals(StringBuffer sb) {
    return contentEquals((CharSequence) sb);
}

虽然Java平台类库很大程度上遵循了本条目中的建议，但是也有诸多的类违背了。如，String类导出两个重载的静态工厂方法：valueOf(char[])和valueOf(Object)，当这两个方法被传递了同样的对象引用时，它们所做的事情完全不同。没有正当的理由可以解释这一点，它应该被看作是一种反常行为，有可能会造成真正的混淆。

简而言之，“能够重载方法”并不意味着就“应该重载方法”。一般情况下，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。在某些情况下，特别是涉及构造器的时候，要遵循这条建议也许是不可能的。在这种情况下，至少应该避免这样的情形：同一组参数只需经过类型转换就可以被传递给不同的重载方法。如果不能避免这种情形，如，因为正在改造一个现在的类以实现新的接口，就应该保证：当传递同样的参数时，所有重载方法的行为必须一致。如果不能做到这一点，程序员就很难有效地使用被重载的主就去或者构造器，他们就不能理解它为什么不能正常工作。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第42条：慎用可变参数 P170
Java 1.5 发行版本中增加了可变参数（varargs）方法，一般称作variable arity method（可匹配不同长度的变量的方法）。可变参数方法接受0个或者多个指定类型的参数。可变参数机制通过先创建一个数组，数组的大小为在调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。

如下面是一个可变参数方法，带有int参数的一个序列，并返回它们的总和：
//
package test;

public class VarargsTest {
    public static void main(String[] args) {
        System.out.println(sum(1, 2, 3));
        System.out.println(sum());
    }
    
    // Simple use of varargs
    private static int sum(int... args) {
        int sum = 0;
        for (int arg : args) {
            sum += arg;
        }
        return sum;
    }
}
输出：
6
0

有时候，有必要编写需要1个或者多个某种类型参数的方法，而不是需要0个或者多个。例如，假设想要计算多个int参数的最小值。如果客户端没有传递参数，那这个方法的定义就不太好了。你可以在运行时检查数组长度：
// The WRONG way to use varargs to pass one of more arguments
private static int min(int... args) {
    if (args.length == 0) {
        throw new IllegalArgumentException("Too few arguments");
    }
    int min = args[0];
    for (int i = 1; i < args.length; i++) {
        if (args[i] < min) {
            min = args[i];
        }
    }
    return min;
}
这种解决方案有几个问题。其中最严重的问题是，如果客户端调用这个方法时，并没有传递参数进去，它就会在运行时而不是编译时失败。另一个问题是，这段代码很不美观。你必须在args中包含显式的有效性检查，除非将min初始化为Integer.MAX_VALUE，否则将无法使用for_each循环，这样的代码也不美观。

幸运的是，有一种更好的方法可以实现想要的这种效果。声明该方法带有两个参数，一个是指定类型的正常参数，另一个是这种类型的varargs参数。这种解决方案解决了前一个示例中的所有不足。
//
package test;

public class VarargsTest {
    public static void main(String[] args) {
        System.out.println(min(1, 3, 2));
    }

    // The right way to use varargs to pass one of more arguments
    private static int min(int firstArg, int... remainingArgs) {
        int min = firstArg;
        for (int arg : remainingArgs) {
            if (arg < min) {
                min = arg;
            }
        }
        return min;
    }
}
输出：
1

如你所见，当你真正需要让一个方法带有不定数量的参数时，可变参数就非常有效。可变参数是为printf而设计的，它是在Java 1.5 发行版本中添加到平台中的，为了核心的反射机制（见第53条），在该发行版本中改造成利用可变参数。printf和和反射机制都从可变参数中极大地受益。

可以将以数组当作final参数的现有方法，改造成以可变参数代替，而不影响现有的客户端，但是可以并不意味着应该这么做！考虑Arrays.asList的情形。这个方法从来都不是设计成用来将多个参数集中到一个列表中的，但是当平台中增加了可变参数时，将它改造成这么做似乎是个好办法，因此，可以变成可以这样：
List<String> homophones = Arrays.asList("to", "too", "two");

这种用法有效，但是这么用就是个大错误。在Java 1.5 发行版本之前，打印数组内容的常见做法如下：
// Obsolete idiom to print an array!
System.out.println(Arrays.asList(myArray));

这种做法在当时是必需的，因为数组从Object继承了它们的toString实现，因此直接在数组上调用toString，会产生没有意义的字符串。这种做法只在对象引用类型的数组上才有用，但是如果不小心在基本类型的数组上尝试这么做，程序将无法编译。如：
int[] ints = {1, 2, 3};
System.out.println(Arrays.asList(ints));

由于在Java 1.5 发行版本中，令人遗憾地决定 将Arrays.asList改造成可变参数方法，现在这个程序可以通过编译，并且没有错误或者警告。但是运行这个程序时，会输出无意识的也是无意义的结果：[[I@a987ac]。Arrays.asList方法现在“增强”为使用可变参数，将int类型的数组digits的对象引用集中到数组的单个元素数组中，并忠实地将它包装到List<int[]>实例中。打印这个列表会导致在列表中调用toString，从而导致在它唯一的元素int数组上调用toString，产生上述令人遗憾的结果。

//
package test;

import java.util.Arrays;

public class VarargsTest {
    public static void main(String[] args) {
        int[] ints = {1, 2, 3};
        System.out.println(Arrays.asList(ints));

        String[] strings = {"hello", "world"};
        System.out.println(Arrays.asList(strings));

        System.out.println(Arrays.asList(1, 2, 3));
    }
}

输出：
[[I@a987ac]
[hello, world]
[1, 2, 3]

从好的方法看，将数组转变成字符串的Arrays.asList做法现在是过时的，当前的做法要健壮得多。也是在Java 1.5 发行版本中，Arrays类得到了补充完整的Arrays.toString方法（不是可变参数方法！），专门为了将任何类型的数组转变成字符串而设计的。如果用Arrays.toString代替Arrays.asList，这个程序就会产生想要结果：
//
package test;

import java.util.Arrays;

public class VarargsTest {
    public static void main(String[] args) {
        int[] ints = {1, 2, 3};
        // The right way to print an array
        System.out.println(Arrays.toString(ints));

        String[] strings = {"hello", "world"};
        System.out.println(Arrays.toString(strings));
    }
}
输出：
[1, 2, 3]
[hello, world]

如果不改造Arrays.asList，更好的办法则是给Collections添加一个新的方法，专门用来将它的参数集中到列表中：
public static <T> List<T> gather(T... args) {
    return Arrays.asList(args);
}

这种方法可以提供收集功能，而不会危及对现有Arrays.asList方法的类型检查。

这个教训很显示，不必改造具有final数组参数的每个方法，只当确实是在数量不定的值上执行调用时才使用可变参数。

有两个方法签名特别可疑：
ReturnType1 suspect1(Object... args) {}
<T> ReturnType2 suspect2(T... args) {}
带有上述任何一种签名的方法都可以接受任何参数列表。改造之前进行的任何编译时的类型检查都会丢失，Arrays.asList发生的情形正在说明了这一点。

在重视性能的情况下，使用可变参数机制要特别小心。可变参数方法的每次调用都会导致进行一次数组分配和初始化。如果凭经验确定无法承受这一成本，但又需要可变参数的灵活性，还有一种模式可以让你如愿以偿。假设确定对某个方法95%的调用会有3个或者更少的参数，就声明该方法的5个重载，每个重载方法带有0至3个普通参数，当参数的数目超过3个时，就使用一个可变参数方法：
public void foo() { }
public void foo(int a1) { }
public void foo(int a1, int a2) { }
public void foo(int a1, int a2, int a3) { }
public void foo(int a1, int a2, int a3, int... rest) { }

现在你知道了，所有调用中只有5%参数数量超过3个的调用需要创建数组。就像大多数的性能优化一样，这种方法通常不太恰当，但是一旦真正需要它时，它可就帮上大忙了。

EnumSet类对它的静态工厂使用这种方法，最大限度地减少创建枚举集合的成本。当时这么做是必要的，因为枚举集合为位域提供在性能方面有竞争力的替代方法，这是很重要的（见么32条）。

简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。如果使用不当，会产生混乱的结果。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第43条：返回零长度的数组或者集合，而不是null P174
对于一个返回null而不是零长度数组或者集合的方法，几乎每次用到该方法时都需要这种曲折的处理方式。这样做很容易出错，因为编写客户端程序的程序员可能会忘记写这种专门的代码来处理null返回值。返回null而不是零长度的数组也会使返回数组或者集合的方法本身变更得更加复杂。

有时候有人认为：null返回值比零长度数组更好，因为它避免了分配数组所需要的开销。这种观点是站不住脚的，原因有两点。第一，在这个级别上担心性能问题是不明智的，除非分析表明这个方法正是造成性能问题的真正源头（见第55条）。第二，对于不返回任何元素的调用，每次返回同一个零长度数组是有可能的，因为零长度数组是不可变的，而不可变对象有可能被自由地共享（见第15条）。实际上，当你使用标准做法（standard idiom）把一些元素从一个集合转存到一个类型化的数组（typed array）中时，它正是这样做的：
//
package test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class EmptyStringArrayTest {
    // The right way to return an array from a collection
    private final List<String> strings = new ArrayList<>();

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * @return an array containing all strings
     */
    public String[] getStrings() {
        return strings.toArray(EMPTY_STRING_ARRAY);
    }

    public static void main(String[] args) {
        EmptyStringArrayTest emptyStringArrayTest = new EmptyStringArrayTest();
        System.out.println(Arrays.toString(emptyStringArrayTest.getStrings()));

        String[] stringArray = {"hello", "world", "good", "luck", "how", "are", "you"};
        List<String> stringList = Arrays.asList("nice", "weather");
        String[] anotherStringArrays = stringList.toArray(stringArray);
        System.out.println(Arrays.toString(anotherStringArrays));
    }
}
输出：
[]
[nice, weather, null, luck, how, are, you]

在这种习惯用法中，零长度数组常量被传递给toArray方法，以指明所期望的返回类型。正常情况下，toArray方法分配了返回的数组，但是，如果集合是空的，它将使用零长度的输入数组，Collection.toArray(T[])的规范保证：如果输入数组大到足够容纳这个集合，它就将返回这个输入数组。因此，这种做法永远也不会分配零长度的数组。

同样的，集合值的方法也可以做成在每当需要返回空集合时都返回同一个不可变的空集合。Collections.emptySet、emptyList和emptyMap方法提供的正是你所需要的，如下所示：
// The right way to return a copy of a collection
public List<String> getStringList() {
    if (strings.isEmpty()) {
        return Collections.emptyList(); // Always returns same list
    }
    else {
        return new ArrayList<String>(strings); //这里只保证新new出来的ArrayList<>是与原来的strings内存不一致，List中存储的每一个String还是原来的对象。
    }
}

简而言之，返回类型为数组或集合的方法没理由返回null，而是返回一个零长度的数组或者集合。这种习惯做法（指返回null）很有可能是从C程序设计语言中沿袭过来的，在C语言中，数组长度是与实际的数组分开返回的。在C语言中，如果返回的数组长度为零，再分配一个数组就没有任何好处。
//------------------------------------------------------------------------------------------------
//Effective Java 第7章 方法 P156
//第44条：为所有导出的API元素编写文档注释 P176
为了正确地编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释。
方法的文档注释应该简洁地描述出它和客户端之间的约定。

下面这个简短的文档注释演示了所有这些习惯做法：
/**
 * Returns the element at the specified position in this list.
 * <p>This method is <i>not</i> guaranteed to run in constant
 * time. In some implementations it may run in time proportional
 * to the element position.
 *
 * @param index of element to return; must be 
 *        non-negative and less than the size of this list
 * @return the element at the specified position in this list
 * @throws IndexOutOfBoundException if the index is out of range
           ({@code index < 0 || index >= this.size()})
 */
E get(int index);

每个文档注释的第一句话（如下所示）成了该注释所属元素的概要描述（summary description）。如，第177页中文档注释中的概要描述为“返回这个列表中指定位置上的元素”。概要描述必须独立地描述目标元素的功能。为了避免混淆，同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述。特别要注意重载的情形，在这种情况下，往往很自然地在描述中使用同样的第一句话（但在文档注释中这是不可接受的）。

简而言之，要为API编写文档，文档注释是最好、最有效的途径。对于所有可导出的API元素来说，使用文档注释应该被看作是强制性的。要采用一致的风格来遵循标准的约定。记住，在文档注释内部出现任何HTML标签都是允许的，但是HTML元字符必须要经过转义。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第45条：将局部变量的作用域最小化 P181
要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。
几乎每个局部变量的声明都应该包含一个初始化表达式。如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与try-catch语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检的异常（checked exception），该变量就必须在try块的内部被初始化。如果变量的值必须在try块的外部被使用到，它就必须在try块之前被声明，但是在try块之前，它还不能被“有意义地初始化”。请参照第202页中的例子。

循环中提供了特殊的机会来将变量的作用域最小化。（无论是传统的还是for-each形式的）for循环，都允许声明循环变量（loop variable），它们的作用域被限定在正好需要的范围之内。（这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。）因此，如果在循环终止之后不再需要循环变量的内部，for循环就优先于while循环。

例如，下面是一种遍历集合的首先做法（见第46条）：
// Preferred idiom for iterating over a collection
for (Element e : c) {
    doSomething(e);
}

在Java 1.5 发行版本之前，首先的做法如下（现在仍然有适用之处）：
// No for-each loop or generics before release 1.5
for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomething((Element) i.next());
}

使用for循环，犯这种“剪切-粘贴”错误的可能性就会大大降低，因为通常没有必要在两个循环中使用不同的变量名。循环是完全独立的，所以重用元素（或者迭代器）变量的名称不会有任何危害。实际上，这也是很流行的做法。

使用for循环与使用while循环相比还有另外一个优势：更简短，从而增强了可读性。
下面是另外一种对局部变量的作用域进行最小化的循环做法：
for (int i = 0, n = expensiveComputation(); i < n; i++) {
    doSomething(i);
}

关于这种做法要关注的一点是，它具有两个循环变量：i和n，两者具有完全相同的作用域。第二个变量n被用来保存第一个变量的极限值，从而避免在每次迭代中执行冗余计算的开销。通常，如果循环测试中涉及方法调用，它可以保证在每次迭代中都会返回同样的结果，就应该使用这种做法。

最后一种“将局部变量的作用域最小化”的方法是使方法小而集中。如果把两个操作（activity）合并到同一个方法中，与其中一个操作相关的局部变量就有可能会出现在执行另一个操作的代码范围之内。为了防止这种情况发生，只要把这个方法分成两个，每个方法各执行一个操作。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第46条：for-each循环优先于传统的for循环 P184
传统的for循环做法都比while循环（见第45条）更好，但是它们也并不完美。迭代器和索引变量都会造成一些混乱。而且，它们也代表着出错的可能。迭代器和索引变量在每个循环中出现三次，其中有两次让你很容易出错。一旦出错，就无法保证编译器能够发现错误。

Java 1.5 发行版本中引入的for-each循环，通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。这种模式同样适用于集合和数组：
注意，利用for-each循环不会有性能损失，甚至用于数组也一样。实际上，在某些情况下，比起普通的for循环，它还稍有些性能优势，因为它对数组索引的边界值只计算一次。虽然可以手工完成这项工作（见第45条），但程序员并不总会这么做。

在对多个集合进行嵌套式迭代时，for-each循环相对于传统for循环的这种优势还会更加明显。

for-each循环不仅让你遍历集合和数组，还让你遍历任何实现Iterable接口的对象。这个简单的接口由单个方法组成，与for-each循环同时被增加到Java平台中。下面就是这个接口的示例：
public interface Iterable<E> {
    // Returns an iterator over the elements in this iterable
    Iterable<E> iterator();
}

实现Iterable接口并不难。如果你在编写的类型表示是一组元素，即便你选择不让它实现Collection，也要让它实现Iterable。这样可以允许用户利用for-each循环遍历你的类型，会令用户永远感激不尽的。

总之，for-each循环在简洁性和预防Bug方法有着传统的for循环无法比拟的优势，并且没有性能操作。应该尽可能地使用for-each循环。有三种常见的情况无法使用for-each循环：
1. 过滤――如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove方法。
2. 转换――如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
3. 平行迭代――如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移（就如上述关于有问题的牌和骰子的示例中无意中所示范的那样）。
在以上任何一种情况下，就要使用普通的for循环，要警惕本条目中提到的陷阱，并且要确保做到最好。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第47条：了解和使用类库 P187
假设希望产生位于0和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写出如下方法：

这个方法看起来不错，但却有三个缺点：第一个缺点是，如果n是一个比较小的2的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点是，如果n不是2的乘方，那么平均起来，有些数会比其的数出现得更为频繁。如果n比较大，这个缺点就会非常明显。这可以通过下面的程序直观地体现出来，它会竹一百万个经过细心指定的范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：
package test;

import java.util.Random;

public class RandomTest {
    private static final Random rnd = new Random();

    // Common but deeply flawed!
    static int random(int n) {
        return Math.abs(rnd.nextInt()) % n;
    }

    public static void main(String[] args) {
        int n = 2 * (Integer.MAX_VALUE / 3);
        int low = 0;
        for (int i = 0; i < 1000000; i++) {
            if (random(n) < n / 2) {
                low++;
            }
        }
        System.out.println(low);
    }
}
输出：
666877

如果random方法工作正常的话，这个程序打印出来的数将接近于一百万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于666666。由random方法产生的数字有2/3 落在随机数取值范围的前半部分。

random方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，返回一个落在指定范围之外的数。这是因为这个方法试图通过调用Math.abs，将rnd.nextInt()返回的值映射为一个非负整数int。如果nextInt()返回Integer.MIN_VALUE，那么Math.abs也会返回Integer.MIN_VALUE，假设n不是2的乘方，那么取模操作符（%）将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。

为了编写能修正这三个缺点的random方法，有必要了解关于伪随机数生成器、数论和2的求补算法的相关知识。已经有现成的成果可以为你所用。它被称为Random.nextInt(int)，自Java 1.2 发行版本以来，它已经成了Java平台的一部分。

使用标准类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。

使用标准类库的第三个好处是，它们的性能往往会随着时间的推移而不断提高，无需你做任何努力。

使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读、更易维护、更易被大多数的开发人员重用。

有两种工具值得特别一提。在1.2 发行版本中，Collections Framework（集合框架）被加入到了java.util包中。它应该成为每个程序员基本工具箱中的一部分。Collections Framework是一个统一的体系结构，用来表示和操作集合，允许它们对集合进行独立于表示细节的操作。

1.5 发行版本中，在java.util.concurrent包中增加了一组并发实用工具。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。java.util.concurrent的高级部分，也应该是每个程序员基本工具箱中的一部分（见第68条和第69条）。

任何一组类库中所提供的功能总是难免会有遗漏。如果你所需要的功能不存在，那么就只能自己实现这些功能，别无选择。

总而言之，不要重新发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。一般而言，类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移而不断改进。这并不是在影射你作为一个程序员的能力。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能够给予的投入。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第48条：如果需要精确的答案，请避免使用float和double P190
float和double类型尤其不适合于货币计算，因为要让一个float或者double精确地表示0.1 （或者10的任何其他负数次方值）是不可能的。

例如，假设你口袋里有$1，你看到货架上有糖果，票价为10美分，20美分，一直到$1。从标价为10美分的糖果开始，一直到不能支付，可以买多少颗糖果？还会找回多少零头？下面是一个简单的程序，用来解决这个问题：
package test;

public class DoubleTest {
    public static void main(String[] args) {
        double funds = 1.00;
        int itemBought = 0;
        for (double price = .10; funds >= price; price += .10) {
            funds -= price;
            itemBought++;
        }
        System.out.println(itemBought + " items bought.");
        System.out.println("Change: $" + funds);
    }
}
输出：
3 items bought.
Change: $0.3999999999999999

答案是不正确的！解决这个问题的正确办法是使用BigDecimal、int或者long进行货币计算。下面使用BigDecimal类型代替double：
package test;

import java.math.BigDecimal;

public class DoubleTest {
    public static void main(String[] args) {
        final BigDecimal TEN_CENTS = new BigDecimal("0.10");

        int itemBought = 0;
        BigDecimal funds = new BigDecimal("1.00");
        for (BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = price.add(TEN_CENTS)) {
            itemBought++;
            funds = funds.subtract(price);
        }
        System.out.println(itemBought + " items bought.");
        System.out.println("Money left over: $" + funds);
    }
}
输出：
4 items bought.
Money left over: $0.00

然而，使用BigDecimal有两个缺点：与使用基本运算类型相比，这样做很不方便，而且很慢。对于解决这样的一个简单的问题，后一种缺点并不要紧，但是前一种缺点可能会让你很不舒服。

除了使用BigDecimal之外，还有一种办法是使用int或者long，到底选用int或者long要取决于所涉及数值的大小，同时要自己处理十进制小数点。在这个示例中，最明显的做法是以分为单位进行计算，而不是以元为单位。如下：
package test;

public class DoubleTest {
    public static void main(String[] args) {
        int itemBought = 0;
        int funds = 100;
        for (int price = 10; funds >= price; price += 10) {
            itemBought++;
            funds -= price;
        }
        System.out.println(itemBought + " items bought.");
        System.out.println("Money left over: " + funds + " cents");
    }
}
输出：
4 items bought.
Money left over: 0 cents

总而言之，对于任何需要精确答案的计算任务，请不要使用float或者double。如果想让系统来记录十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal。使用BigDecimal还且一些额外的好处，它允许你完全控制舍入，每当一个操作涉及舍入的时候，它允许你从8种舍入模式中选择其一。如果你正通过法定要求的舍入行为进行业务计算，使用BigDecimal是非常方便的。如果性能非常关键，并且你又不介意自己记录十进制小数点，而且所涉及的数值又不太大，就可以使用int或者long。如果数值范围没有超过9位十进制数字，就可以使用int；如果不超过18位数字，就可以使用long。如果数值可能超过18位数字，就必须使用BigDecimal。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第49条：基本类型优先于装箱基本类型 P190
基本类型和装箱基本类型之间有三个主要区别。第一，基本类型只有值，而装箱基本类型则具有它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。第二，基本类型只有功能完备的值，而每个装箱基本类型除了它对应基本类型的所有功能值之外，还有个非功能值：null。最后一点区别是，基本类型通常比装箱基本类型更节省时间和空间。

考虑下面这个比较器：
package test;

import java.util.Comparator;

public class AutoBoxTest {
    public static void main(String[] args) {
        // Broken comparator - can you spot the flaw?
        //Comparator<Integer> naturalOrder = (first, second) -> first < second ? -1 : (first == second ? 0 : 1);
        Comparator<Integer> naturalOrder = new Comparator<Integer>() {
            @Override
            public int compare(Integer first, Integer second) {
                return first < second ? -1 : (first == second ? 0 : 1);
            }
        };

        System.out.println(naturalOrder.compare(new Integer(42), new Integer(42)));
    }
}
输出：
1

问题出在执行计算表达式first == second上，它在两个对象引用上执行同一性比较（identity comparison）。两个Integer为不同对象，所以返回false，比较器会错误地返回1，表示第一个Integer值大于第二个。对装箱基本类型运用==操作符几乎总是错误的。

修正这个问题的最清楚做法是添加两个快点变量，来保存first和second的int值，并在这些变量上执行所有的比较操作。这样可以避免大量的同一性比较：
package test;

import java.util.Comparator;

public class AutoBoxTest {
    public static void main(String[] args) {
        Comparator<Integer> naturalOrder = new Comparator<Integer>() {
            @Override
            public int compare(Integer first, Integer second) {
                int f = first;
                int s = second;
                return f < s ? -1 : (f == s ? 0 : 1);
            }
        };

        System.out.println(naturalOrder.compare(new Integer(42), new Integer(42)));
    }
}
输出：
0

考虑这个小程序：
package test;

public class Unbelievable {
    private static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("Unbelievable");
        }
    }
}
在计算表达式（i == 42 ）时抛出NullPointerException异常。问题在于，i是个Integer，而不是int，就像所有的对象引用域一样，它的初始值为null。当程序计算表达式(i == 42)时，它会将Integer与int进行比较。几乎在任何一种情况下，当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，这种情况无一例外。如果null对象引用被自动白条，就会得到一个NullPointerException异常。修改这个问题很简单，声明i是个int而不是Integer就可以了。

最后，考虑第5条中的这个程序：
//Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量（sum）声明为装箱基本类型Long，而不是基本类型long。程序编译起来没有错误或者警告，变量被反复地装箱和拆箱，导致明显的性能下降。

什么时候应该使用装箱基本类型呢？有几个合理的用处。第一个是作为集合中的元素、键和值。不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更通用的特例。在参数化类型（见第5章）中，必须使用装箱基本类型作为类型参数，因为Java不允许使用基本类型。例如，你不能将变量声明为ThreadLocal<int>类型，因此必须使用ThreadLocal<Integer>代替。最后，在进行反射的方法调用（见第53条）时，必须使用装箱基本类型。

总之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！自动装箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险。当程序用==操作符比较两个装箱基本类型时，它做了个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱，当程序进行拆箱时，会抛出NullPointerException异常。最后，当程序装箱了基本类型值时，会导致高开销和不必要的对象创建。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第50条：如果其他类型更合适，则尽量避免使用字符串 P195
--字符串不适合代替其他的值类型。
--字符串不适合代替枚举类型。
--字符串不适合代替聚集类型。
--字符串也不适合代替能力表（capabilities）。
总而言之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚集类型。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第51条：当心字符串连接的性能 P198
为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级的时间。这是由于字符串不可变（见第15条）而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝。
为了获得可以接受的性能，请使用StringBuilder替代String，来存储建造中的对账单。（Java 1.5 发行版本中增加了非同步StringBuilder类，代替了现在已经过时的StringBuffer类。）：
public String statement() {
    StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
    for (int i = 0; i < numItems(); i++) {
        b.append(lineForItem(i));
    }
    return b.toString();
}
使用StringBuilder比String的做法要快85倍。连接String的做法的开销随项目数量而呈平方级增加，第二种做法则是线性增加，所以，项目数越大，性能的差别会越显著。注意，第二种做法预先分配了一个StringBuilder，使它大到足以容纳结果字符串。即便因为预先不知道字符串长度，使用了默认大小的StringBuilder，它仍然比第一种做法快50倍。

原则很简单：不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要。相反，应该使用StringBuilder的append方法。另一种方法是，使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第52条：通过接口引用对象 P195
第40条中有一个建议：应该使用接口而不是用类作为参数的类型。更一般地讲，应该优先使用接口而不是类来引用对象。如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。只有当利用构造器创建某个对象的时候，才真正需要引用这个对象的类。
考虑Vector的情形，它是List接口的一个实现。在声明变量的时候应该养成这样的习惯：
// Good - uses interface as tyep
List<Subscriber> subscribers = new Vector<Subscriber>();
而不是像这样的声明：
// Bad - uses class as type
Vector<Subscriber> subscribers = new Vector<Subscriber>();

如果养成了用接口作为类型的习惯，你的程序将会更加灵活。当决定更换实现时，所要做的就只是改变构造器中类的名称（或者使用一个不同的静态工厂）。如，第一个声明可以被改变为：
List<Subscriber> subscribers = new ArrayList<Subscriber>();

有一点值得注意：如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供同样的功能。如，如果第一个声明周围的代码依赖于Vector的同步策略，在声明中用ArrayList代替Vector就是不正确的。如果依赖于实现的任何特殊属性，就要在声明变量的地方给这些需求建立相应的文档说明。

为什么要改变实现呢？因为新的实现提供了更好的性能，或者因为它提供了期望得到的额外功能。有个真实的例子与ThreadLocal类有关。
如果没有合适的接口存在，完全可以用类而不是接口来引用对象。如，考虑值类（value class），比如String和BigInteger。记住，值类很少会用多个实现编写。它们通常是final的，并且很少有对应的接口。使用这种值类作为参数、变量、域或者返回类型是再合适不过的了。更一般地讲，如果具体类没有相关联的接口，不管它是否表示一个值，你都没有别的选择，只有通过它的类来引用它的对象。Random类就属于这种情形。

不存在适当接口类型的第二种情形是，对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（class-based framework），就应该用相关的基类（base class）（往往是抽象类）来引用这个对象，而不是用它的实现类。java.util.TimerTask抽象类就属性这种情形。

不存在适当接口类型的最后一种情形是，类实现了接口，但是它提供了接口中不存在的额外方法――如LinkedHashMap。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例。这很少应该被用作参数类型（见第40条）。

以上这些例子并不全面，只是代表了一些“适合于用类来引用对象”的情形。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活；如果不是，则使用类层次结构中提供了必须功能的最基础的类。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第53条：接口优先于反射机制 P201
反射机制允许一个类使用另一个类，即便当前者被编译的时候后者还根本不存在。然而，这种能力也要付出代价：
--丧失了编译时类型检查的好处，包括异常检查。
--执行反射访问所需要的代码非常笨拙和冗长。
--性能损失。

反射功能只是在设计时（design time）被用到。通常，普通应用程序在运行时不应该以反射方式访问对象。

有些复杂的应用程序需要使用反射机制。这些示例中包括类浏览器、对象监视器、代码分析工具、解释型的内嵌式系统。在RPC（远程过程调用）系统中使用反射机制也是非常合适的，这样可以不再需要存根编译器（stub compiler）。如果对自己的应用程序是否也属于这一类应用程序而感到怀疑，它很有可能就不属于这一类。

使用只是以非常有限的形式使用反射机制，虽然也要付出少许代码，但是可以获得许多好处。对于有些程序，它们必须用到在编译时无法获取的类，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类（见第52条）。如果是这种情况，就可以以反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。

如，下面程序创建了一个Set<String>实例，它的类是由第一个命令行参数指定的，该程序把其余的命令行参数插入到这个集合中，然后打印该集合。
//TestReflect.java
package test;

import java.util.Arrays;
import java.util.Set;

public class TestReflect {
    // Reflective instantiation with interface access
    public static void main(String[] args) {
        // Translate the class name into a Class object
        Class<?> cl = null;
        try {
            cl = Class.forName(args[0]);
        } catch (ClassNotFoundException e) {
            System.err.println("Class not found.");
            System.exit(1);
        }

        // Instantiate the class
        Set<String> s = null;
        try {
            s = (Set<String>) cl.newInstance();
        } catch (IllegalAccessException e) {
            System.err.println("Class not accessible.");
            System.exit(1);
        } catch (InstantiationException e) {
            System.err.println("Class not instantiable.");
            System.exit(1);
        }

        // Exercise the set
        s.addAll(Arrays.asList(args).subList(1, args.length));
        System.out.println(s);
    }
}
入参：java.util.HashSet "d" "e" "a"
输出：[a, d, e]

入参：java.util.TreeSet "d" "e" "a"
输出：[a, d, e]

这个程序所演示的方法是非常强大的。这个程序可以很容易地变成一个通用的集合测试器，通过侵入式地操作一个或者多个集合实例，并检查是否遵守Set接口的约定，以此来验证指定的Set实现。同样地，它也可以变成一个通用的集合性能分析工具。实际上，它所演示的这种方法足以实现一个成熟的服务提供者框架（service provider framework）（见第1条）。绝大多数情况下，使用反制机制需要的也正是这种方法。

这个示例演示了反射机制的两个缺点。第一，这个例子会产生3个运行时错误，如果不使用反射方式的实例化，这3个错误都会成为编译时错误。第二，根据类名生成它的实例需要20行冗长的代码，而调用一个构造器可以非常简洁地只使用一行代码。然而，这些缺点还仅仅局限于实例化对象的那部分代码。一旦对象被实例化，它与其他的Set实例就难以区分。在实际的程序中，通过这种限定使用反射的方法，绝大部分代码可以不受影响。

编译程序会有警告，与程序中使用了泛型有关，但它并不能说明真正的问题。要了解禁止这种警告的最佳方法，请参见第24条。

另一个值得注意的附带问题是，这个程序使用了System.exit。很少有需要调用这个方法的时候，它会终止整个VM（虚拟机）。但是，它对于命令行有效性的非法终止是很合适的。

简而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第54条：谨慎地使用本地方法 P204
Java Native Interface（JNI）允许Java应用程序只可以调用本地方法（native method），所谓本地方法是指用本地程序设计语言（比如C或者C++）来编写的特殊方法。本地方法在本地语言中可以执行任意的计算任务，并返回到Java程序设计语言。

使用本地方法来提高性能的做法不值得提倡。

使用本地方法有一些严重的缺点。因为本地语言不是安全的（见第39条），所以，使用本地方法的应用程序也不再能免受内存毁坏错误的影响。本地语言是与平台相关的，使用本地方法的应用程序也不再是可自由移植的。使用本地方法的应用程序也更难调试。在进入和退出本地代码时，需要相关的固定开销，所以，如果本地代码只是做少量的工作，本地方法就可能降低（decrease）性能。最后一点，需要“胶合代码”的本地方法编写起来单调乏味，并且难以阅读。

总而言之，在使用本地方法之前务必三思。极少数情况下会需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层资源，或者遗留代码库，也要尽可能少使用本地代码，并且要全面进行测试。本地代码中的一个Bug就有可能破坏整个应用程序。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第55条：谨慎地进行优化 P205
关于优化的深刻真理：优化的弊大于利，特别是不成熟的优化。

不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。

必须在设计过程中考虑到性能问题。

努力避免那些限制性能的设计决策。

要考虑API设计决策的性能后果。

一般而言，好的API设计也会带来好的性能。为获得好的性能而对API进行包装，这是一种非常不好的想法。导致你对API进行包装的性能因素可能会在平台未来的发行版本中，或者在将来的底层软件中不复存在，但是被包装的API以及由它引起的问题将永远困扰着你。

回想Jackson的两条优化规则：“不要优化”以及“（仅针对专家）还是不要优化”。可以再增加一条：在每次试图做优化之前和之后，要对性能进行测量。

性能剖析工具有助于你决定应该把优化的重心放在哪里。

如果将要在多个JVM实现和多种硬件平台上运行程序，很重要的一点是，需要在每个Java实现上测量优化效果。有时候，还必须在从不同JVM实现或者硬件平台上得到的性能结果之中进行权衡。

总而言之，不要费力去编写快速的程序――应该努力编写好的程序，速度自然会随之而来。在设计系统的时候，特别是在设计API、线程层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它足够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的低层优化也无法弥补算法的选择不当。必要时重复这个过程，在每次改变之后都要测量性能，直到满意为止。
//------------------------------------------------------------------------------------------------
//Effective Java 第8章 通用程序设计 P181
//第56条：遵守普遍接受的命名惯例 P208
总而言之，把标准的命名惯例当作一种内存的机制来看待，并且学着用它们作为第二特性。字面惯例是非常直接和明确的；语法惯例则更复杂，也更松散。下面这句话引自《The Java Language Specification》：“如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。”请运用常识。
//------------------------------------------------------------------------------------------------
//Effective Java 第9章 异常 P211
//第57条：只针对异常的情况才使用异常 P211
在现代的JVM实现上，基于异常的模式比标准模式要慢得多。

异常应该只用于异常的情况下；它们永远不应该用于正常的控制流。更一般地，应该优先使用标准的、容易理解的模式，而不是那些声称可以提供更好性能的、弄巧成拙的方法。

这条原则对于API设计也有启发。设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有“状态相关（state-dependent）”的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有个单独的“状态测试（state-testing）”方法，即指示是否要以调用这个状态相关的方法。如，Iterator接口有一个“状态相关”的next方法，和相应的状态测试方法hasNext。这使得利用传统的for循环（以及for-each循环，在这里，是在内部使用hasNext方法）对集合进行迭代的标准模式成为可能：
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    //...
}

如果Iterator缺少hasNext方法，客户端将被迫改用下面的做法：
// Do not use this hideous code for iteration over a collection!
try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
        Foo foo = i.next();
        // ...
    }
} catch (NoSuchElementException e) {
}
这非常类似于本条目刚开始时对数组进行迭代的例子。除了代码繁琐且令人误解之外，这个基于异常的模式可能执行起来也比标准模式更差，并且还可能掩盖系统中其他不相关部分中的Bug。
//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------
Spring是什么
轻量级的控制反转（IoC）和面向切面（AOP）的容器框架

//UnitTestBase.java
package com.imooc.base;

import org.junit.After;
import org.junit.Before;
import org.springframework.beans.BeansException;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.util.StringUtils;

public class UnitTestBase {

    private ClassPathXmlApplicationContext context;

    private String springXmlpath;

    public UnitTestBase() {
    }

    public UnitTestBase(String springXmlpath) {
        this.springXmlpath = springXmlpath;
    }

    @Before
    public void before() {
        if (StringUtils.isEmpty(springXmlpath)) {
            springXmlpath = "classpath*:spring-*.xml";
        }
        try {
            context = new ClassPathXmlApplicationContext(springXmlpath.split("[,\\s]+"));
            context.start();
        } catch (BeansException e) {
            e.printStackTrace();
        }
    }

    @After
    public void after() {
        context.destroy();
    }

    @SuppressWarnings("unchecked")
    protected <T extends Object> T getBean(String beanId) {
        try {
            return (T) context.getBean(beanId);
        } catch (BeansException e) {
            e.printStackTrace();
            return null;
        }
    }

    protected <T extends Object> T getBean(Class<T> clazz) {
        try {
            return context.getBean(clazz);
        } catch (BeansException e) {
            e.printStackTrace();
            return null;
        }
    }

}

//InjectionServiceTest.java
package com.imooc.ioc.injection.service;

import com.imooc.base.UnitTestBase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;


@RunWith(BlockJUnit4ClassRunner.class)
public class InjectionServiceTest extends UnitTestBase {

    public InjectionServiceTest() {
        super("classpath:spring-injection.xml");
    }

    @Test
    public void testSetter() {
        InjectionService service = super.getBean("injectionService");
        service.save("这是要保存的数据");
    }

    @Test
    public void testCons() {
        InjectionService service = super.getBean("injectionService");
        service.save("这是要保存的数据");
    }
}

//
package com.imooc.ioc.injection.service;

public interface InjectionService {
    void save(String arg);
}

//
package com.imooc.ioc.injection.service;

import com.imooc.ioc.injection.dao.InjectionDAO;

public class InjectionServiceImpl implements InjectionService {
    public void init() {
        System.out.println("InjectionServiceImpl.init()");
    }

    private InjectionDAO injectionDAO;

    //构造注入
    public InjectionServiceImpl(InjectionDAO injectionDAO1) {
        this.injectionDAO = injectionDAO1;
    }

    //设值注入
    public void setInjectionDAO(InjectionDAO injectionDAO) {
        this.injectionDAO = injectionDAO;
    }

    public void save(String arg) {
        //模拟业务操作
        System.out.println("Service接收参数：" + arg);
        arg += ":" + this.hashCode();
        injectionDAO.save(arg);
    }
}

//
package com.imooc.ioc.injection.dao;

public interface InjectionDAO {
    void save(String arg);
}

//
package com.imooc.ioc.injection.dao;

public class InjectionDAOImpl implements InjectionDAO {

    public void save(String arg) {
        System.out.println("保存数据：" + arg);
    }
}

//spring-injection.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd" >

    <!-- 设值注入 -->
   <!--<bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl">-->
       <!--<property name="injectionDAO" ref="injectionDAO"></property>-->
   <!--</bean>-->

    <!-- 构造注入 -->
    <bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl" init-method="init">
        <constructor-arg name="injectionDAO1" ref="injectionDAO"></constructor-arg>
    </bean>

    <bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"></bean>
</beans>

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>SpringProjectGroup</groupId>
    <artifactId>SpringProjectGroup</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
        <dependency>
            <groupId>org.sonatype.sisu</groupId>
            <artifactId>sisu-inject-bean</artifactId>
            <version>1.4.2</version>
        </dependency>
        <dependency>
            <groupId>aopalliance</groupId>
            <artifactId>aopalliance</artifactId>
            <version>1.0</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjrt</artifactId>
            <version>1.8.10</version>
        </dependency>
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.9</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>4.3.13.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-dao</artifactId>
            <version>1.2.9</version>
        </dependency>
    </dependencies>
</project>
//------------------------------------------------------------------------------------------------
3-2 Bean的生命周期

//初始化
package com.imooc.ioc.injection.service;

import com.imooc.ioc.injection.dao.InjectionDAO;
import org.springframework.beans.factory.InitializingBean;

public class InjectionServiceImpl implements InjectionService, InitializingBean { //第1种，实现InitializingBean方法
    private InjectionDAO injectionDAO;

    public void init() { //第2种，配置init-method="init"
        System.out.println("InjectionServiceImpl.init()");
    }

    public void afterPropertiesSet() throws Exception {
        System.out.println("InjectionServiceImpl.afterPropertiesSet()");
    }

    //构造注入
    public InjectionServiceImpl(InjectionDAO injectionDAO1) {
        this.injectionDAO = injectionDAO1;
    }

    //设值注入
    public void setInjectionDAO(InjectionDAO injectionDAO) {
        this.injectionDAO = injectionDAO;
    }

    public void save(String arg) {
        //模拟业务操作
        System.out.println("Service接收参数：" + arg);
        arg += ":" + this.hashCode();
        injectionDAO.save(arg);
    }
}

//销毁
-实现DisposableBean接口
-配置destroy-method

//配置全局默认初始化、销毁方法
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"
        default-init-method="init" default-destroy-method="destroy"> //类可以不配置方法，则不执行，配置就会执行
即便方法为private，也可以执行到：private void init()

优先级
//
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"
        default-init-method="start" default-destroy-method="stop">

    <!-- 设值注入 -->
   <!--<bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl">-->
       <!--<property name="injectionDAO" ref="injectionDAO"></property>-->
   <!--</bean>-->

    <!-- 构造注入 -->
    <bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl" init-method="initMethod" destroy-method="destroyMethod">
        <constructor-arg name="injectionDAO1" ref="injectionDAO"></constructor-arg>
    </bean>

    <bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"></bean>
</beans>

//
package com.imooc.ioc.injection.service;

import com.imooc.ioc.injection.dao.InjectionDAO;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class InjectionServiceImpl implements InjectionService, InitializingBean, DisposableBean {
    private InjectionDAO injectionDAO;

    private void initMethod() {
        System.out.println("InjectionServiceImpl.initMethod()");
    }

    private void destroyMethod() {
        System.out.println("InjectionServiceImpl.destroyMethod()");
    }

    private void start() {
        System.out.println("InjectionServiceImpl.start()");
    }

    private void stop() {
        System.out.println("InjectionServiceImpl.stop()");
    }

    public void afterPropertiesSet() throws Exception {
        System.out.println("InjectionServiceImpl.afterPropertiesSet()");
    }

    public void destroy() throws Exception {
        System.out.println("InjectionServiceImpl.destroy()");
    }

    //构造注入
    public InjectionServiceImpl(InjectionDAO injectionDAO1) {
        this.injectionDAO = injectionDAO1;
    }

    //设值注入
    public void setInjectionDAO(InjectionDAO injectionDAO) {
        this.injectionDAO = injectionDAO;
    }

    public void save(String arg) {
        //模拟业务操作
        System.out.println("Service接收参数：" + arg);
        arg += ":" + this.hashCode();
        injectionDAO.save(arg);
    }
}

输出：
四月 28, 2018 10:32:55 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sat Apr 28 22:32:55 CST 2018]; root of context hierarchy
四月 28, 2018 10:32:55 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-injection.xml]
InjectionServiceImpl.afterPropertiesSet()
InjectionServiceImpl.initMethod()
四月 28, 2018 10:32:55 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sat Apr 28 22:32:55 CST 2018]; root of context hierarchy
InjectionServiceImpl.destroy()
InjectionServiceImpl.destroyMethod()

可以看到：接口方法>类方法或默认全局方法（类方法如果有会覆盖默认全局方法）
//------------------------------------------------------------------------------------------------
3-3 Aware接口

package com.imooc.ioc.injection.service;

import com.imooc.base.UnitTestBase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;


@RunWith(BlockJUnit4ClassRunner.class)
public class InjectionServiceTest extends UnitTestBase {

    public InjectionServiceTest() {
        super("classpath:spring-injection.xml");
    }

    @Test
    public void testSetter() {
        InjectionService service = super.getBean("injectionService");
//        System.out.println("testSetter: " + service.hashCode());
    }
}

//spring*.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl" scope="prototype"></bean> //这里配置为prototype将导致运行错误，有两个对象在同时创建，修改为singleton则正常运行，如果没有scope属性则默认是singleton方式

    <bean id="injectionDAO" class="com.imooc.ioc.injection.dao.InjectionDAOImpl"></bean>
</beans>

//InjectionServiceImpl
package com.imooc.ioc.injection.service;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class InjectionServiceImpl implements InjectionService, ApplicationContextAware, BeanNameAware {
    private String beanName;

    public void save(String arg) {
        System.out.println("InjectionServiceImpl.save()");
    }

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println("InjectionServiceImpl.setApplicationContext(): " + applicationContext.getBean(this.beanName).hashCode());//通过获取的beanName创建对象
    }

    public void setBeanName(String name) {
        this.beanName = name;
        System.out.println("InjectionServiceImpl.setBeanName(): " + name);
    }
}

四月 28, 2018 11:17:11 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sat Apr 28 23:17:11 CST 2018]; root of context hierarchy
四月 28, 2018 11:17:11 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-injection.xml]
InjectionServiceImpl.setBeanName(): injectionService
InjectionServiceImpl.setApplicationContext(): 9852548
四月 28, 2018 11:17:11 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sat Apr 28 23:17:11 CST 2018]; root of context hierarchy
//------------------------------------------------------------------------------------------------
3-4 AutoWiring
//AutoWiringServiceTest.java
package com.imooc.ioc.autowiring.service;

import com.imooc.base.UnitTestBase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;


@RunWith(BlockJUnit4ClassRunner.class)
public class AutoWiringServiceTest extends UnitTestBase {

    public AutoWiringServiceTest() {
        super("classpath:spring-autowiring.xml");
    }

    @Test
    public void testSay() {
        AutoWiringService service = super.getBean("autoWiringService");
        service.say("hello");
    }
}

//AutoWiringService.java
package com.imooc.ioc.autowiring.service;

import com.imooc.ioc.autowiring.dao.AutoWiringDAO;

public class AutoWiringService {
    private AutoWiringDAO autoWiringDAO; //byType是与成员变量类型相匹配，与变量名称没关系

    public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) {
        this.autoWiringDAO = autoWiringDAO;
    }

    public void say(String word) {
        this.autoWiringDAO.say(word);
    }
}

//AutoWiringDAO.java
package com.imooc.ioc.autowiring.dao;

public class AutoWiringDAO {
    public void say(String word) {
        System.out.println("AutoWiringDAO: " + word);
    }
}

//spring-autowiring.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"
        default-autowire="byName">

    <bean id="autoWiringService" class="com.imooc.ioc.autowiring.service.AutoWiringService"></bean>

    <bean id="autoWiringDAO" class="com.imooc.ioc.autowiring.dao.AutoWiringDAO"></bean> //byName是通过set方法匹配，只要id与set方法名称一样即可
</beans>

//constructor
package com.imooc.ioc.autowiring.service;

import com.imooc.ioc.autowiring.dao.AutoWiringDAO;

public class AutoWiringService {
    private AutoWiringDAO autoWiringDAO;
    private String str;

    //构造方法是和参数类型匹配，不依赖变量名称
    public AutoWiringService(AutoWiringDAO autoWiringDAO) { //如果提供了constructor，则在没有默认构造函数的时候，byName和byType两种方法将抛异常，无默认构造函数
        System.out.println("AutoWiringService()");
        this.autoWiringDAO = autoWiringDAO;
    }
    
    //优先与多个参数的匹配
    public AutoWiringService(AutoWiringDAO autoWiringDAO, String str) {
        System.out.println("AutoWiringService() two parameters");
        this.str = str;
        this.autoWiringDAO = autoWiringDAO;
    }


    public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) {
        System.out.println("setAutoWiringDAO()");
        this.autoWiringDAO = autoWiringDAO;
    }

    public void say(String word) {
        this.autoWiringDAO.say(word);
    }
}

//
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"
        default-autowire="constructor">

    <bean id="autoWiringService" class="com.imooc.ioc.autowiring.service.AutoWiringService"></bean>

    <bean id="autoWiringDAO" class="com.imooc.ioc.autowiring.dao.AutoWiringDAO"></bean>
    <bean class="java.lang.String"></bean>//不配置这行，将与one parameter匹配
</beans>
输出：
四月 29, 2018 12:32:41 上午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sun Apr 29 00:32:41 CST 2018]; root of context hierarchy
四月 29, 2018 12:32:41 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-autowiring.xml]
AutoWiringService() two parameters
AutoWiringDAO: hello
四月 29, 2018 12:32:41 上午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@14caa3f: startup date [Sun Apr 29 00:32:41 CST 2018]; root of context hierarchy
//------------------------------------------------------------------------------------------------
3-5 Resources https://www.imooc.com/video/3758
所有的Application都继承于ResourceLoader
Resource getResource(String s);

入参可以是：
classpath:config.txt
file:d:\\config.txt
url:https://xxx
config.txt（依赖于ApplicationContext的创建方式）

//------------------------------------------------------------------------------------------------
4-1 Bean的作用域及定义的注释实现
//spring-beanannotation.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <context:component-scan base-package="com.imooc.ioc.annotation"></context:component-scan>
</beans>

//
package com.imooc.ioc.annotation;

import org.springframework.stereotype.Component;

@Scope("prototype")//默认为singleton
@Component //@Component("myBeanAnnotation")
public class BeanAnnotation {

    public void say(String word) {
        System.out.println("BeanAnnotation: " + word);
    }
}

//
package com.imooc.ioc.annotation;

import com.imooc.base.UnitTestBase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

@RunWith(BlockJUnit4ClassRunner.class)
public class BeanAnnotationTest extends UnitTestBase {
    public BeanAnnotationTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testSay() {
        BeanAnnotation bean = super.getBean("beanAnnotation"); //myBeanAnnotation
        bean.say("This is a test.");
    }
}

//------------------------------------------------------------------------------------------------
4-2 Bean之Autowired注解

//
package com.imooc.ioc.annotation.injection.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.imooc.ioc.annotation.injection.dao.InjectionDAO;

@Service
public class InjectionServiceImpl implements InjectionService {

    //要有无参数的构造函数
    @Autowired
    private InjectionDAO injectionDAO;

    //构造函数
    // @Autowired
    // public InjectionServiceImpl(InjectionDAO injectionDAO) {
        // this.injectionDAO = injectionDAO;
    // }
    
    //setter
    // @Autowired
    // public void setInjectionDAO(InjectionDAO injectionDAO) {
        // this.injectionDAO = injectionDAO;
    // }

    public void save(String arg) {
        //模拟业务操作
        System.out.println("Service接收参数：" + arg);
        arg += ":" + this.hashCode();
        injectionDAO.save(arg);
    }
}

//InjectionServiceTest.java
package com.imooc.ioc.annotation.injection.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class InjectionServiceTest extends UnitTestBase {
    public InjectionServiceTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testAutowired() {
        InjectionService service = super.getBean("injectionServiceImpl");
        service.save("hello");
    }
}

//------------------------------------------------------------------------------------------------
4-3 使用Autowired注解众所周知的解析依赖性接口
如BeanFactory、ApplicationContext
//
package com.imooc.ioc.annotation.multibean;

public interface BeanInterface {
}

//
package com.imooc.ioc.annotation.multibean;

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Order(value=2) //Order顺序只影响List中的排序
@Component
public class BeanImplOne implements BeanInterface {
}

//继承org.springframework.core.Ordered来排序
// package com.imooc.ioc.annotation.multibean;

// import org.springframework.core.Ordered;
// import org.springframework.stereotype.Component;

// @Component
// public class BeanImplOne implements BeanInterface, Ordered {
    // @Override
    // public int getOrder() {
        // return 2;
    // }
// }


//
package com.imooc.ioc.annotation.multibean;

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Order(value=1)
@Component
public class BeanImplTwo implements BeanInterface {
}



//
package com.imooc.ioc.annotation.multibean;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class BeanInvoker {

    @Autowired
    private List<BeanInterface> list;

    @Autowired
    private Map<String, BeanInterface> map;

    public void say() {
        if (null != list) {
//            list.stream().forEach(e -> System.out.println(e.getClass().getName()));
            list.forEach(e -> System.out.println(e.getClass().getName()));
        } else {
            System.out.println("list is null.");
        }

        if (null != map && !map.isEmpty()) {
            for (Map.Entry<String, BeanInterface> entry : map.entrySet()) {
                System.out.println(String.format("Key: %s, value: %s",  entry.getKey(), entry.getValue()));
            }
        }
    }
}


//test
package com.imooc.ioc.annotation.injection.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;
import com.imooc.ioc.annotation.multibean.BeanInvoker;

@RunWith(BlockJUnit4ClassRunner.class)
public class InjectionTest extends UnitTestBase {
    public InjectionTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testMultBean() {
        BeanInvoker invoker = super.getBean("beanInvoker");
        invoker.say();
    }
}
输出：
四月 29, 2018 4:45:58 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 16:45:58 CST 2018]; root of context hierarchy
四月 29, 2018 4:45:58 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from URL [file:/E:/Program%20Files/JetBrains/JavaProject/SpringProject/target/classes/spring-beanannotation.xml]
com.imooc.ioc.annotation.multibean.BeanImplOne
com.imooc.ioc.annotation.multibean.BeanImplTwo
Key: beanImplOne, value: com.imooc.ioc.annotation.multibean.BeanImplOne@16856dd
Key: beanImplTwo, value: com.imooc.ioc.annotation.multibean.BeanImplTwo@1b45159
四月 29, 2018 4:45:58 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 16:45:58 CST 2018]; root of context hierarchy

//------------------------------------------------------------------------------------------------
4-4 使用Autowired注解 @Qualifier
package com.imooc.ioc.annotation.multibean;

import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class BeanInvoker {

    @Autowired
    private List<BeanInterface> list;

    @Autowired
    private Map<String, BeanInterface> map;

    @Autowired
    @Qualifier("beanImplTwo") //如果不指定，运行报错，不知道自动绑定哪个
    private BeanInterface beanInterface;

    public void say() {
        if (null != list) {
            list.forEach(e -> System.out.println(e.getClass().getName()));
        } else {
            System.out.println("list is null.");
        }

        if (null != map && !map.isEmpty()) {
            for (Map.Entry<String, BeanInterface> entry : map.entrySet()) {
                System.out.println(String.format("Key: %s, value: %s",  entry.getKey(), entry.getValue()));
            }
        }
    }

    public void sayBean() {
        if (null != beanInterface) {
            System.out.println(beanInterface.getClass().getName());
        } else {
            System.out.println("beanInterface is null");
        }
    }
}

//------------------------------------------------------------------------------------------------
4-5 @Bean

//
package com.imooc.ioc.annotation.javabased;

public interface Store {
}

//
package com.imooc.ioc.annotation.javabased;

public class StringStore implements Store {

    public void init() {
        System.out.println("This is init().");
    }

    public void destroy() {
        System.out.println("This is destroy().");
    }
}

//
package com.imooc.ioc.annotation.javabased;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class StoreConfig {

    @Bean(name = "myStringStore", initMethod = "init", destroyMethod = "destroy") //init和destroy方法需要在返回的对象StringStore中定义
    public Store stringStore() {
        return new StringStore();
    }
}

//JavaBasedTest.java
package com.imooc.ioc.annotation.javabased;

import com.imooc.base.UnitTestBase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

@RunWith(BlockJUnit4ClassRunner.class)
public class JavaBasedTest extends UnitTestBase {
    public JavaBasedTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void test() {
        Store store = super.getBean("myStringStore"); //没有指定@Bean name参数的情况下，id是函数方法名称
        System.out.println(store.getClass().getName());
    }
}
输出：
四月 29, 2018 6:30:53 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 18:30:53 CST 2018]; root of context hierarchy
四月 29, 2018 6:30:53 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from URL [file:/E:/Program%20Files/JetBrains/JavaProject/SpringProject/target/classes/spring-beanannotation.xml]
四月 29, 2018 6:30:53 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
This is init().
com.imooc.ioc.annotation.javabased.StringStore
This is destroy().
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 18:30:53 CST 2018]; root of context hierarchy

//------------------------------------------------------------------------------------------------
4-5 Bean装配之基于Java的容器注解 @ImportResource和@Value

//用xml配置
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <context:annotation-config/>
        <context:property-placeholder location="classpath:com/acme/jdbc.properties"/>
        <bean class="com.acme.AppConfig"/>
        <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
        </bean>
</beans>


//基于java配置
//MyDriverManager.java
package com.imooc.ioc.annotation.javabased;

public class MyDriverManager {
    public MyDriverManager(String url, String userName, String password) {
        System.out.println("url: " + url);
        System.out.println("userName: " + userName);
        System.out.println("password: " + password);
    }
}

//StoreConfig.java
package com.imooc.ioc.annotation.javabased;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;

@Configuration
@ImportResource("classpath:config.xml")
//@ImportResource("classpath:config.properties")//异常，这里导入的资源是Bean配置文件
public class StoreConfig {

    @Value("${url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${password}")
    private String password;

    @Bean
    public MyDriverManager myDriverManager() {
        return new MyDriverManager(url, username, password);
    }
}

//config.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <context:property-placeholder location="classpath:config.properties"/>
</beans>

//config.properties
password=root
url=127.0.0.1
jdbc.username=root

//JavaBasedTest.java
package com.imooc.ioc.annotation.javabased;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class JavaBasedTest extends UnitTestBase {
    public JavaBasedTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testMyDriverManager() {
        MyDriverManager manager = super.getBean("myDriverManager");
        System.out.println(manager.getClass().getName());
    }
}

这里的关系是：
ImportResource引入的是Bean配置文件
在Bean配置文件中配置properties资源文件
在@Configuration类中用${XXX}字符串


//------------------------------------------------------------------------------------------------
4-7 基于Java的Bean配置 @Bean和@Scope
//
package com.imooc.ioc.annotation.javabased;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;

@Configuration
public class StoreConfig {
    @Bean
    @Scope(value = "prototype", proxyMode = ScopedProxyMode.DEFAULT)
    public Store stringStore() {
        return new StringStore();
    }
}

//
package com.imooc.ioc.annotation.javabased;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class JavaBasedTest extends UnitTestBase {
    public JavaBasedTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testBeanScope() {
        Store store = super.getBean("stringStore");
        System.out.println(store.hashCode());

        store = super.getBean("stringStore");
        System.out.println(store.hashCode());
    }
}
//------------------------------------------------------------------------------------------------
4-8 基于泛型的自动装配
//
package com.imooc.ioc.annotation.javabased;

public interface Store<T> {
}

//
package com.imooc.ioc.annotation.javabased;

public class StringStore implements Store<String> {
}

//
package com.imooc.ioc.annotation.javabased;

public class IntegerStore implements Store<Integer> {
}


//
package com.imooc.ioc.annotation.javabased;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class StoreConfig {

    @Autowired
    private Store<String> stringStore;//根据泛型类型自动获取对应Bean类，则调用stringStore方法获取StringStore类

    @Autowired
    private Store<Integer> integerStore;

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }

    @Bean(name = "stringStoreTest")
    public Store stringStoreTest() { //如果这里返回值定义为StringStore，则有两个函数返回为StringStore，在构造private Store<String> stringStore前，会把所有的返回值为StringStore的Bean函数调用一遍，走到下行sout语句时，stringStore还没有构造好，抛出空指针异常
        //如果这里返回类型为Store，则初始化是按照stringStore(), integerStore(), stringStoreTest()来调用
        //如果这里返回类型为StringStore，则初始化是按照stringStore(), stringStoreTest()，integerStore()来调用
        System.out.println("stringStore: " + stringStore.getClass().getName());
        System.out.println("integerStore: " + integerStore.getClass().getName());
        return new StringStore();
    }
}

//
package com.imooc.ioc.annotation.javabased;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class JavaBasedTest extends UnitTestBase {
    public JavaBasedTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testGeneric() {
        Store store = super.getBean("stringStoreTest");//在调用这个函数时，不会再走到Store stringStoreTest()函数里
    }
}
输出：
四月 29, 2018 8:28:40 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 20:28:40 CST 2018]; root of context hierarchy
四月 29, 2018 8:28:40 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from URL [file:/E:/Program%20Files/JetBrains/JavaProject/SpringProject/target/classes/spring-beanannotation.xml]
stringStore: com.imooc.ioc.annotation.javabased.StringStore
integerStore: com.imooc.ioc.annotation.javabased.IntegerStore

四月 29, 2018 8:28:41 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@a8195f: startup date [Sun Apr 29 20:28:40 CST 2018]; root of context hierarchy


//自定义Autowire类型，CustomAutowireConfigurer是BeanFactoryPostProcessor的子类，通过它可以注册自己的qualifier注解类型。
//------------------------------------------------------------------------------------------------
4-9 Bean装配之Spring对JSR支持的说明 
参考CSDN：https://blog.csdn.net/yizhicxy/article/details/52129585

//
package com.imooc.ioc.annotation.jsr;

import org.springframework.stereotype.Repository;

@Repository
public class JsrDAO {
    public void save() {
        System.out.println("JsrDAO invoked.");
    }
}

//
package com.imooc.ioc.annotation.jsr;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;

import org.springframework.stereotype.Service;

@Service
public class JsrService {
    @Resource
    private JsrDAO jsrDAO;

//    @Resource
    public void setJsrDAO(JsrDAO jsrDAO) {
        this.jsrDAO = jsrDAO;
    }

    @PostConstruct
    public void init() {
        System.out.println("JsrService.init()");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("JsrService.destroy()");
    }

    public void save() {
        jsrDAO.save();
    }
}

//test
package com.imooc.ioc.annotation.jsr;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;

import org.springframework.stereotype.Service;

@Service
public class JsrService {
    @Resource
    private JsrDAO jsrDAO;

//    @Resource
    public void setJsrDAO(JsrDAO jsrDAO) {
        this.jsrDAO = jsrDAO;
    }

    @PostConstruct
    public void init() {
        System.out.println("JsrService.init()");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("JsrService.destroy()");
    }

    public void save() {
        jsrDAO.save();
    }
}


//Spring 3.0对javax.inject的支持
//JsrDAO.java
package com.imooc.ioc.annotation.jsr;

import org.springframework.stereotype.Repository;

//@Repository //定义为接口后将无法Bean实例化JsrDAO
public interface JsrDAO {
    default void save() {
        System.out.println("JsrDAO invoked.");
    }
}

@Repository
class JsrDAOImpl1 implements JsrDAO {
    @Override
    public void save() {
        System.out.println("JsrDAOImpl1 invoked.");
    }
}

@Repository
class JsrDAOImpl2 implements JsrDAO {
    @Override
    public void save() {
        System.out.println("JsrDAOImpl2 invoked.");
    }
}

//JsrService.java
package com.imooc.ioc.annotation.jsr;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Named;

//@Service
@Named
public class JsrService {
//    @Resource
//    @Inject
    private JsrDAO jsrDAO;

//    @Resource
    @Inject
    public void setJsrDAO(@Named("jsrDAOImpl2") JsrDAO jsrDAO) { //这里用@Named指定用哪个类来自动绑定，功能同@Qualifier
        this.jsrDAO = jsrDAO;
    }

    @PostConstruct
    public void init() {
        System.out.println("JsrService.init()");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("JsrService.destroy()");
    }

    public void save() {
        jsrDAO.save();
    }
}

//JsrTest.java
package com.imooc.ioc.annotation.jsr;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class JsrTest extends UnitTestBase {

    public JsrTest() {
        super("classpath*:spring-beanannotation.xml");
    }

    @Test
    public void testJsr() {
        JsrService service = super.getBean("jsrService");
        service.save();
    }
}
输出：
JsrService.init()
JsrDAOImpl2 invoked.
JsrService.destroy()
//------------------------------------------------------------------------------------------------
专题三 AOP

AOP实现方式
预编译 --AspectJ
运行期动态代理（JDK动态代理、CGLib动态代理）--SpringAOP、JbossAOP

//------------------------------------------------------------------------------------------------
5-4 Advice应用

aop:around对应method的第一个参数必须为ProceedingJoinPoint类型
//
package com.imooc.aop.schema.advice.biz;

public class AspectBiz {

    public void biz() {
        System.out.println("AspectBiz biz.");
//        throw new RuntimeException();
    }

    public void init(String bizName, int times) {
        System.out.println(String.format("AspectBiz init() bizName: %s, times: %s", bizName, times));
    }
}


//
package com.imooc.aop.schema.advice;

import org.aspectj.lang.ProceedingJoinPoint;

public class MoocAspect {

    public void before() {
        System.out.println("MoocAspect before.");
    }

    public void afterReturning() {
        System.out.println("MoocAspect afterReturning.");
    }

    public void afterThrowing() {
        System.out.println("MoocAspect afterThrowing.");
    }

    public void after() {
        System.out.println("MoocAspect after.");
    }

    public Object around(ProceedingJoinPoint pjp) {
        Object obj = null;
        try {
            System.out.println("MoocAspect around1.");
            obj = pjp.proceed();
            System.out.println("MoocAspect around2.");
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return obj;
    }

    public Object aroundInit(ProceedingJoinPoint pjp, String bizName, int times) {
        System.out.println(String.format("MoocAspect aroundInit() bizName: %s, times: %s", bizName, times));
        Object obj = null;
        try {
            System.out.println("MoocAspect aroundInit1.");
            obj = pjp.proceed();
            System.out.println("MoocAspect aroundInit2.");
        } catch (Throwable e) {
            e.printStackTrace();
        }
        return obj;
    }
}



//AOPSchemaAdviceTest.java
package com.imooc.aop.schema.advice;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.aop.schema.advice.biz.AspectBiz;
import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class AOPSchemaAdviceTest extends UnitTestBase {
    public AOPSchemaAdviceTest() {
        super("classpath:spring-aop-schema-advice.xml");
    }

    @Test
    public void testBiz() {
        AspectBiz biz = super.getBean("aspectBiz");
        biz.biz();
    }

    @Test
    public void testInit() {
        AspectBiz biz = super.getBean("aspectBiz");
        biz.init("hello", 3);
    }
}

//spring-aop-schema-advice.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd">

    <bean id="moocAspect" class="com.imooc.aop.schema.advice.MoocAspect"></bean>

    <bean id="aspectBiz" class="com.imooc.aop.schema.advice.biz.AspectBiz"></bean>

    <aop:config>
        <aop:aspect id="moocAspectAOP" ref="moocAspect">
            <aop:pointcut expression="execution(* com.imooc.aop.schema.advice.biz.*Biz.*(..))" id="moocPointcut"/>
            <aop:before method="before" pointcut-ref="moocPointcut"/>
            <aop:after-returning method="afterReturning" pointcut-ref="moocPointcut"/>
            <aop:after-throwing method="afterThrowing" pointcut-ref="moocPointcut"/>
            <aop:after method="after" pointcut-ref="moocPointcut"/>
            <aop:around method="around" pointcut-ref="moocPointcut"/>
            <aop:around method="aroundInit" pointcut="execution(* com.imooc.aop.schema.advice.biz.AspectBiz.init(String, int))
                                         and args(bizName, times)"/>

            <!--<aop:declare-parents types-matching="com.imooc.aop.schema.advice.biz.*(+)"-->
            <!--implement-interface="com.imooc.aop.schema.advice.Fit"-->
            <!--default-impl="com.imooc.aop.schema.advice.FitImpl"/>-->
        </aop:aspect>
    </aop:config>

</beans>
输出：
五月 01, 2018 1:03:18 上午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1444d75: startup date [Tue May 01 01:03:18 CST 2018]; root of context hierarchy
五月 01, 2018 1:03:18 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-aop-schema-advice.xml]
MoocAspect before.
MoocAspect around1.
五月 01, 2018 1:03:18 上午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@1444d75: startup date [Tue May 01 01:03:18 CST 2018]; root of context hierarchy
五月 01, 2018 1:03:18 上午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1edc48a: startup date [Tue May 01 01:03:18 CST 2018]; root of context hierarchy
五月 01, 2018 1:03:18 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-aop-schema-advice.xml]
AspectBiz biz.
MoocAspect around2.
MoocAspect after.
MoocAspect afterReturning.
MoocAspect before.
MoocAspect around1. //这里的顺序和xml中的配置先后有关系
MoocAspect aroundInit() bizName: hello, times: 3
MoocAspect aroundInit1.
AspectBiz init() bizName: hello, times: 3
MoocAspect aroundInit2.
MoocAspect around2.
MoocAspect after.
MoocAspect afterReturning.
五月 01, 2018 1:03:18 上午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@1edc48a: startup date [Tue May 01 01:03:18 CST 2018]; root of context hierarchy

Process finished with exit code 0

//------------------------------------------------------------------------------------------------
5-6 Introduction

//
package com.imooc.aop.schema.advice;

public interface Fit {
    void filter();
}

//
package com.imooc.aop.schema.advice;

public class FitImpl implements Fit {
    @Override
    public void filter() {
        System.out.println("FitImpl filter()");
    }
}


//
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.0.xsd">

    <bean id="moocAspect" class="com.imooc.aop.schema.advice.MoocAspect"></bean>

    <bean id="aspectBiz" class="com.imooc.aop.schema.advice.biz.AspectBiz"></bean>

    <aop:config>
        <aop:aspect id="moocAspectAOP" ref="moocAspect">
            <aop:declare-parents types-matching="com.imooc.aop.schema.advice.biz.*(+)"
                                 implement-interface="com.imooc.aop.schema.advice.Fit"
                                 default-impl="com.imooc.aop.schema.advice.FitImpl"/>
        </aop:aspect>
    </aop:config>
</beans>
输出：
FitImpl filter()

schema-defined aspects只支持singleton model
//------------------------------------------------------------------------------------------------
5-7 Advisors

//Invoke.java
package com.imooc.aop.schema.advisors.service;

import org.springframework.dao.PessimisticLockingFailureException;
import org.springframework.stereotype.Service;

@Service
public class InvokeService {
    public void invoke() {
        System.out.println("InvokeService ......");
    }

    public void invokeException() {
        throw new PessimisticLockingFailureException("");
    }
}


//ConcurrentOperationExecutor.java
package com.imooc.aop.schema.advisors;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.dao.PessimisticLockingFailureException;

public class ConcurrentOperationExecutor {

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;

    private int order = 1;

    public void setMaxRetries(int maxRetries) {
        this.maxRetries = maxRetries;
    }

    public int getOrder() {
        return order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
        int numAttempts = 0;
        PessimisticLockingFailureException lockingFailureException;
        do {
            numAttempts++;
            System.out.println("Try times: " + numAttempts);
            try {
                return pjp.proceed();
            } catch (PessimisticLockingFailureException ex) {
                lockingFailureException = ex;
            }
        } while (numAttempts <= maxRetries);

        System.out.println("Try error: " + numAttempts);
        throw lockingFailureException;
    }
}


//AOPSchemaAdvisorsTest.java
package com.imooc.aop.schema.advisors;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.aop.schema.advisors.service.InvokeService;
import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class AOPSchemaAdvisorsTest extends UnitTestBase {
    public AOPSchemaAdvisorsTest() {
        super("classpath:spring-aop-schema-advisors.xml");
    }

    @Test
    public void testSave() {
        InvokeService service = super.getBean("invokeService");
        service.invoke();

        System.out.println();
        service.invokeException();
    }
}

//spring-aop-schema-advisors.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <context:component-scan base-package="com.imooc.aop.schema"></context:component-scan>

    <aop:config>
        <aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor">
            <aop:pointcut id="idempotentOperation"
                expression="execution(* com.imooc.aop.schema.advisors.service.*.*(..)) " />
<!--                  expression="execution(* com.imooc.aop.schema.service.*.*(..)) and -->
<!--                                 @annotation(com.imooc.aop.schema.Idempotent)" /> -->
            <aop:around pointcut-ref="idempotentOperation" method="doConcurrentOperation" />
        </aop:aspect>
    </aop:config>
    
    <bean id="concurrentOperationExecutor" class="com.imooc.aop.schema.advisors.ConcurrentOperationExecutor">
        <property name="maxRetries" value="3" />
        <property name="order" value="100" />
    </bean>

 </beans>
输出：
五月 01, 2018 3:22:35 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh
信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@133adc: startup date [Tue May 01 15:22:35 CST 2018]; root of context hierarchy
五月 01, 2018 3:22:35 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions
信息: Loading XML bean definitions from class path resource [spring-aop-schema-advisors.xml]
五月 01, 2018 3:22:35 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor <init>
信息: JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
Try times: 1

五月 01, 2018 3:22:35 下午 org.springframework.context.support.ClassPathXmlApplicationContext doClose
信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@133adc: startup date [Tue May 01 15:22:35 CST 2018]; root of context hierarchy
InvokeService ......

Try times: 1
Try times: 2
Try times: 3
Try times: 4
Try times: 5
Try times: 6
Try error: 6
//------------------------------------------------------------------------------------------------
6-1 Spring AOP API 在代码中实现切入点等（第5章介绍的是基于xml的配置）

//------------------------------------------------------------------------------------------------
6-2 6-3 ProxyFactoryBean
//https://blog.csdn.net/cpzhong/article/details/6423333 JDK动态代理和CGLIB代码

//
package com.imooc.aop.api;

public interface BizLogic {
    String save();
}

//
package com.imooc.aop.api;

public class BizLogicImpl implements BizLogic {
    @Override
    public String save() {
        System.out.println("BizLogicImpl: save()");
        return "BizLogicImpl save";
//        throw new RuntimeException();
    }
}

//
package com.imooc.aop.api;

import java.lang.reflect.Method;

import org.springframework.aop.AfterReturningAdvice;

public class MoocAfterReturningAdvice implements AfterReturningAdvice {

    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("MoocAfterReturningAdvice: " + method.getName() + "     " +
            target.getClass().getName() + "     " + returnValue);
    }
}

//
package com.imooc.aop.api;

import java.lang.reflect.Method;

import org.springframework.aop.MethodBeforeAdvice;

public class MoocBeforeAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, Object o) throws Throwable {
        System.out.println("MoocBeforeAdvice: " + method.getName() + "    " + o.getClass().getName());
    }
}

//
package com.imooc.aop.api;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MoocMethodInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("MoocMethodInterceptor1: " + invocation.getMethod().getName() +
            "    " + invocation.getStaticPart().getClass().getName());
        Object obj = invocation.proceed();
        System.out.println("MoocMethodInterceptor2 returnValue: " + obj);
        return obj;
    }
}

//
package com.imooc.aop.api;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MoocThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(Exception ex) throws Throwable {
        System.out.println("MoocThrowsAdvice afterThrowing 1");
    }

    public void afterThrowing(Method method, Object[] args, Object target, Exception ex) throws Throwable {
        System.out.println("MoocThrowsAdvice afterThrowing 2: " + method.getName() + "    " + target.getClass().getName());
    }
}

//
package com.imooc.aop.api.introduction;

public interface Lockable {
    void lock();

    void unlock();

    boolean locked();
}

//
package com.imooc.aop.api.introduction;

import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.support.DelegatingIntroductionInterceptor;

public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {
    private boolean locked;

    @Override
    public void lock() {
        this.locked = true;
    }

    @Override
    public void unlock() {
        this.locked = false;
    }

    @Override
    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() && invocation.getMethod().getName().startsWith("set")) {
            throw new RuntimeException();
        }
        return super.invoke(invocation);
    }
}

//
package com.imooc.aop.api.introduction;

import org.springframework.aop.support.DefaultIntroductionAdvisor;

public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    private static final long serialVersionUID = -171332350782163120L;

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}


//AOPApiTest.java
package com.imooc.aop.api;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class AOPApiTest extends UnitTestBase {
    public AOPApiTest() {
        super("classpath:spring-aop-api.xml");
    }

    @Test
    public void testSave() {
        BizLogic logic = super.getBean("bizLogicImpl");
        logic.save();
    }
}

//spring-aop-api.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="moocBeforeAdvice" class="com.imooc.aop.api.MoocBeforeAdvice"></bean>

    <bean id="moocAfterReturningAdvice" class="com.imooc.aop.api.MoocAfterReturningAdvice"></bean>

    <bean id="moocMethodInterceptor" class="com.imooc.aop.api.MoocMethodInterceptor"></bean>

    <bean id="moocThrowsAdvice" class="com.imooc.aop.api.MoocThrowsAdvice"></bean>

    <bean id="bizLogicImplTarget" class="com.imooc.aop.api.BizLogicImpl"></bean>

    <!--这种切入点配置方式可以指定特定的方法-->
    <!--<bean id="pointcutBean" class="org.springframework.aop.support.NameMatchMethodPointcut">-->
        <!--<property name="mappedNames">-->
            <!--<list>-->
                <!--<value>sa*</value>-->
            <!--</list>-->
        <!--</property>-->
    <!--</bean>-->

    <!--<bean id="defaultAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">-->
        <!--<property name="advice" ref="moocBeforeAdvice"/>-->
        <!--<property name="pointcut" ref="pointcutBean"/>-->
    <!--</bean>-->

    <!--<bean id="bizLogicImpl" class="org.springframework.aop.framework.ProxyFactoryBean">-->
        <!--<property name="target">-->
            <!--<ref bean="bizLogicImplTarget"/>-->
        <!--</property>-->
        <!--<property name="interceptorNames">-->
            <!--<list>-->
                <!--<value>defaultAdvisor</value>-->
                <!--<value>moocAfterReturningAdvice</value>-->
                <!--<value>moocMethodInterceptor</value>-->
                <!--<value>moocThrowsAdvice</value>-->
            <!--</list>-->
        <!--</property>-->
    <!--</bean>-->


    <!--这里创建代理的目的就是为了执行各种Advice，如果不使用代理，则直接获取到的bizLogicImpl类，就无法执行Advice-->
    <!--<bean id="bizLogicImpl" class="org.springframework.aop.framework.ProxyFactoryBean">-->
        <!--&lt;!&ndash;proxyInterfaces属性被设置为一个或多个全限定接口名，基于JDK的接口将被创建&ndash;&gt;-->
        <!--&lt;!&ndash;如果proxyInterfaces属性没有被设置，但是目标类实现了一个（或者多个）接口，那么ProxyFactoryBean将自动检测到这个目标类已经实现了至少一个接口，创建一个基于JDK的代理&ndash;&gt;-->
        <!--<property name="proxyInterfaces">-->
            <!--<value>com.imooc.aop.api.BizLogic</value>-->
        <!--</property>-->
        <!--<property name="target">-->
            <!--<bean class="com.imooc.aop.api.BizLogicImpl"></bean>-->
            <!--&lt;!&ndash;<ref bean="bizLogicImplTarget"/>&ndash;&gt;-->
        <!--</property>-->
        <!--<property name="interceptorNames">-->
            <!--<list>-->
                <!--<value>moocBeforeAdvice</value>-->
                <!--<value>moocAfterReturningAdvice</value>-->
                <!--<value>moocMethodInterceptor</value>-->
                <!--<value>moocThrowsAdvice</value>-->
                <!--&lt;!&ndash;<value>mooc*</value> &lt;!&ndash;用*做通配符，只能匹配所有拦截器加入通知链，即Interceptor&ndash;&gt;&ndash;&gt;-->
            <!--</list>-->
        <!--</property>-->
    <!--</bean>-->


    <bean id="baseProxyBean" class="org.springframework.aop.framework.ProxyFactoryBean"
          lazy-init="true" abstract="true"></bean>

    <bean id="bizLogicImpl" parent="baseProxyBean">
        <property name="target">
            <bean class="com.imooc.aop.api.BizLogicImpl"></bean>
        </property>
        <property name="proxyInterfaces">
            <value>com.imooc.aop.api.BizLogic</value>
        </property>
        <property name="interceptorNames">
            <list>
                <value>moocBeforeAdvice</value>
                <value>moocAfterReturningAdvice</value>
                <value>moocMethodInterceptor</value>
                <value>moocThrowsAdvice</value>
            </list>
        </property>
    </bean>

</beans>
输出：
MoocBeforeAdvice: save    com.imooc.aop.api.BizLogicImpl
MoocMethodInterceptor1: save    java.lang.reflect.Method
BizLogicImpl: save()
MoocMethodInterceptor2 returnValue: BizLogicImpl save
MoocAfterReturningAdvice: save     com.imooc.aop.api.BizLogicImpl     BizLogicImpl save
//------------------------------------------------------------------------------------------------
7-2 Advice定义及实例

//
package com.imooc.aop.aspectj.biz;

import org.springframework.stereotype.Service;

@Service
public class MoocBiz {

    public String save(String arg) {
        System.out.println("MoocBiz save: " + arg);
        return "Return value: " + arg;
//        throw new RuntimeException("Save failed.");
    }
}

//
package com.imooc.aop.aspectj;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MoocAspect {

    @Pointcut("execution(* com.imooc.aop.aspectj.biz.*Biz.*(..))")
    public void pointcut() {

    }

    @Pointcut("within(com.imooc.aop.aspectj.biz.*)")
    public void bizPointcut() {

    }

//    @Before("execution(* com.imooc.aop.aspectj.biz.*Biz.*(..))")
    @Before("pointcut()") //使用pointcut()函数对应的切入点
    public void before() {
        System.out.println("Before");
    }

    @AfterReturning(pointcut = "bizPointcut()", returning = "returnValue")
    public void afterReturning(Object returnValue) { //这里的入参名就是注解中的"returnValue"
        System.out.println("AfterReturning: " + returnValue);
    }

    @AfterThrowing(pointcut = "pointcut()", throwing = "e")
    public void afterThrowing(RuntimeException e) {
        System.out.println("After throwing: " + e.getMessage());
    }

    @After("pointcut()")
    public void after() {
        System.out.println("After");
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("Around 1");
        Object obj = pjp.proceed();
//        Object obj = pjp.proceed(new Object[] {"hello"}); //可以构造入参，会把原函数的入参修改成新的入参
        System.out.println("Around 2: " + obj);
        return obj;
    }
}

//spring-aop-aspectj.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <context:component-scan base-package="com.imooc.aop.aspectj"/>
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

</beans>

//
package com.imooc.aop.aspectj;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.BlockJUnit4ClassRunner;

import com.imooc.aop.aspectj.biz.MoocBiz;
import com.imooc.base.UnitTestBase;

@RunWith(BlockJUnit4ClassRunner.class)
public class AspectJTest extends UnitTestBase {
    public AspectJTest() {
        super("classpath:spring-aop-aspectj.xml");
    }

    @Test
    public void test() {
        MoocBiz biz = getBean("moocBiz");
        biz.save("This is a test.");
    }
}
输出：
Around 1
Before
MoocBiz save: This is a test.
After
AfterReturning: Return value: This is a test.
//------------------------------------------------------------------------------------------------
7-3 Advice扩展
//给Advice传递参数
//
package com.imooc.aop.aspectj;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MoocMethod {
    String value();
}

//
package com.imooc.aop.aspectj.biz;

import org.springframework.stereotype.Service;

import com.imooc.aop.aspectj.MoocMethod;

@Service
public class MoocBiz {

    @MoocMethod(value = "MoocBiz save MoocMethod.")
    public String save(String arg) {
        System.out.println("MoocBiz save: " + arg);
        return "Return value: " + arg;
//        throw new RuntimeException("Save failed.");
    }
}


//
package com.imooc.aop.aspectj;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class MoocAspect {

    @Pointcut("execution(* com.imooc.aop.aspectj.biz.*Biz.*(..))")
    public void pointcut() {

    }

    @Pointcut("within(com.imooc.aop.aspectj.biz.*)")
    public void bizPointcut() {

    }

//    @Before("execution(* com.imooc.aop.aspectj.biz.*Biz.*(..))")
    @Before("pointcut()") //使用pointcut()函数对应的切入点
    public void before() {
        System.out.println("Before");
    }

    @Before("pointcut() && args(arg)")
    public void beforeWithParam(String arg) {
        System.out.println("BeforeWithParam: " + arg);
    }

    @Before("pointcut() && @annotation(moocMethod)")
    public void beforeWithAnnotation(MoocMethod moocMethod) {
        System.out.println("BeforeWithAnnotation: " + moocMethod.value());
    }

    @Before("pointcut() && args(arg) && @annotation(moocMethod)")
    public void beforeWithAnnotationAndParam(String arg, MoocMethod moocMethod) {
        System.out.println("BeforeWithAnnotationAndParam: " + moocMethod.value() + ", arg: " + arg);
    }

    @AfterReturning(pointcut = "bizPointcut()", returning = "returnValue")
    public void afterReturning(Object returnValue) { //这里的入参名就是注解中的"returnValue"
        System.out.println("AfterReturning: " + returnValue);
    }

    @AfterThrowing(pointcut = "pointcut()", throwing = "e")
    public void afterThrowing(RuntimeException e) {
        System.out.println("After throwing: " + e.getMessage());
    }

    @After("pointcut()")
    public void after() {
        System.out.println("After");
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("Around 1");
        Object obj = pjp.proceed();
//        Object obj = pjp.proceed(new Object[] {"hello"}); //可以构造入参，会把原函数的入参修改成新的入参
        System.out.println("Around 2: " + obj);
        return obj;
    }
}
输出：
Around 1
Before
BeforeWithAnnotation: MoocBiz save MoocMethod.
BeforeWithAnnotationAndParam: MoocBiz save MoocMethod., arg: This is a test.
BeforeWithParam: This is a test.
MoocBiz save: This is a test.
Around 2: Return value: This is a test.
After
AfterReturning: Return value: This is a test.


@perthis @pertarget
//------------------------------------------------------------------------------------------------
Jdbc连接数据库 https://www.cnblogs.com/GarfieldEr007/p/5746137.html
//DbHelper.java
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class DbHelper {
    public static final String url = "jdbc:mysql:///hibernate?serverTimezone=UTC";
//    public static final String url = "jdbc:mysql://127.0.0.1/hibernate?serverTimezone=UTC";
//    public static final String url = "jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC";
    public static final String name = "com.mysql.cj.jdbc.Driver";
    public static final String user = "root";
    public static final String password = "root123";

    public Connection conn = null;
    public PreparedStatement pst = null;

    public DbHelper(String sql) {
        try {
            Class.forName(name);//指定连接类型
            conn = DriverManager.getConnection(url, user, password);//获取连接
            pst = conn.prepareStatement(sql);//准备执行语句
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            this.conn.close();
            this.pst.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

//JdbcConnection.java
package jdbc;

import java.sql.ResultSet;
import java.sql.SQLException;

public class JdbcConnection {

    static String sql = null;
    static DbHelper db1 = null;
    static ResultSet ret = null;

    public static void main(String[] args) {
        sql = "select * from t_students_copy1";//SQL语句
        db1 = new DbHelper(sql);//创建DBHelper对象

        try {
            ret = db1.pst.executeQuery();//执行语句，得到结果集  
            while (ret.next()) {
                String uid = ret.getString(1);
                String ufname = ret.getString(2);
                String ulname = ret.getString(3);
                String udate = ret.getString(4);
                System.out.println(uid + "\t" + ufname + "\t" + ulname + "\t" + udate );
            }//显示数据  
            ret.close();
            db1.close();//关闭连接  
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
//------------------------------------------------------------------------------------------------
1-2 ORM
https://www.imooc.com/video/7702

Object Relationship Mapping：对象/关系映射

//------------------------------------------------------------------------------------------------
1-11 通过Hibernate API编写

//Students.java
package entity;

import java.util.Date;

//学生类
public class Students {
    //Java Beans类的四个基本原则
    //1.公有类
    //2.提供公有的不带参数的默认构造方法
    //3.属性私有
    //4.属性setter/getter封装

    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String address;//地址

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, String address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "entity.Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", address='" + address + '\'' +
            '}';
    }
}

//Students.hbm.xml 先通过Idea的Database视图建立数据库连接，再通过Persistence视图自动生成 https://blog.csdn.net/xubaifu1997/article/details/66476446
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="entity.Students" table="t_students" schema="hibernate">
        <id name="sid" type="int" column="sid"/>
        <property name="sname" type="java.lang.String" column="sname"/>
        <property name="gender" type="java.lang.String" column="gender"/>
        <property name="birthday" type="java.util.Date" column="birthday"/>
        <property name="address" type="java.lang.String" column="address"/>
    </class>

    <!--<class name="entity.Students" table="t_students">-->
        <!--<id name="sid" type="int">-->
            <!--<column name="sid" />-->
            <!--<generator class="assigned" />--><!--主键生成策略，assigned是程序赋值，native是自动生成-->
        <!--</id>-->
        <!--<property name="sname" type="java.lang.String">--><!--开发人员的习惯是先设计数据库，然后再进行映射。因此，length基本上不用配置-->
            <!--<column name="sname" />-->
        <!--</property>-->
        <!--<property name="gender" type="java.lang.String">-->
            <!--<column name="gender" />-->
        <!--</property>-->
        <!--<property name="birthday" type="java.util.Date">-->
            <!--<column name="birthday" />-->
        <!--</property>-->
        <!--<property name="address" type="java.lang.String">-->
            <!--<column name="address" />-->
        <!--</property>-->
    <!--</class>-->
</hibernate-mapping>

//hibernate.cfg.xml 这个文件名称不能修改，在Hibernate框架加载配置文件Configuration config = new Configuration().configure();时，代码写死的文件名hibernate.cfg.xml，修改会导致无法找到配置文件
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
  <session-factory>
    <!--  mysql账户名  -->
    <property name="connection.username">root</property>

    <!--  mysql密码  -->
    <property name="connection.password">root123</property>

    <!--  mysql驱动  -->
    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

    <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为 8.0.11， 并且安装了MySQL的Connector：MySQL Connector/J-->
    <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

    <!--  数据库方言  -->
    <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

    <!--  显示sql语句  不配置这个参数或者配置为false，就不会在Console显示Sql语句，下面的format_sql参数也没用了-->
    <property name="show_sql">true</property>

    <!--  格式化sql语句  不配置或者配置为false，则显示在Console中的Sql语句为一行，不方便阅读-->
    <property name="format_sql">true</property>

    <!--  默认Schema 建表的时候增加前缀Schema 没看到效果-->
    <!--<property name="default_schema">hibernate</property>-->

    <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
    <!--  create：每次生成新的表结构  update：表不存在则新建表，表结构不同则增加列，但是无法修改vachar长度，表存在则更新表数据，最常用  create-drop：先创建表再删除表  validate：对表结构验证，如果表结构与定义不同，则会在创建会话工厂buildSessionFactory()时就提前报错出来，如果不使用valiate参数，则会在执行Sql语句时报错-->
    <!--  https://www.cnblogs.com/feilong3540717/archive/2011/12/19/2293038.html-->
    <property name="hbm2ddl.auto">create</property>

    <!--使用getCurrentSession()方法获取session时需要设置此参数，本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
    <property name="hibernate.current_session_context_class">thread</property>

    <mapping resource="entity/Students.hbm.xml"/>
    <!--<mapping class="entity.Students"/>-->
  </session-factory>
</hibernate-configuration>

//StudentsTest.java
package entity;

import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.jdbc.Work;
import org.hibernate.service.ServiceRegistry;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class StudentsTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        //创建配置对象
        Configuration config = new Configuration().configure();
        //创建服务注册对象
//        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();
        //创建会话工厂
//        sessionFactory = new MetadataSources(serviceRegistry).buildMetadata().buildSessionFactory();;
//        sessionFactory = config.buildSessionFactory(serviceRegistry); //hibernate4.35之前sessionFactory获取方式
        sessionFactory = config.buildSessionFactory(); //如果不用这种创建方法，会报unknown entity错误。hibernate4.35之后sessionFactory获取方式 https://www.cnblogs.com/jinjiyese153/p/6902785.html
        //会话对象
        session = sessionFactory.openSession();
        //开启事务
        transaction = session.beginTransaction();
    }

    @After
    public void destroy() {
        transaction.commit();//提交事务，如果没有这行语句，则不会提交插入数据的操作，但是建表的会执行
        session.close();//关闭会话
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSaveStudents() {
        //生成学生对象
        Students s = new Students(1, "张三丰", "男", new Date(), "武当山");
        session.save(s);//保存对象进数据库

        // 如果不用transaction提交事务，则需要让jdbc的connection自动提交
        // session.doWork(new Work() {
            // @Override
            // public void execute(Connection connection) throws SQLException {
                // connection.setAutoCommit(true);
            // }
        // });
        // session.save(s);//保存对象进数据库
        // session.flush();//需要flush才会提交
    }
}

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>hibernate</groupId>
  <artifactId>hibernate</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>hibernate</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <!-- 添加Junit依赖 -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>

    <!-- 添加mysql驱动依赖 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.11</version>
    </dependency>

    <!-- 添加hibernate依赖包 -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>5.2.6.Final</version>
    </dependency>
  </dependencies>

  <build>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.0.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.7.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.20.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

//------------------------------------------------------------------------------------------------
2-3 session简介 https://www.imooc.com/video/7714
不建议直接使用jdbc的connection操作数据库，而是通过使用session操作数据库。
session可以理解为操作数据库的对象。
session与connection是多对一关系，每个session都有一个与之对应的connection，一个connection不同时刻可以供多个session使用。
把对象保存在关系数据库中需要调用session的各种方法，如：save()，update()，delete()，createQuery()等。
//------------------------------------------------------------------------------------------------
2-4 transaction简介
hibernate对数据的操作都是封装在事务当中，并且默认是非自动提交的方式。所以用session保存对象时，如果不开启事务，并且手工提交，对象并不会真正保存在数据库中。
如果想让hibernate像jdbc那样自动提交事务，必须调用session对象的doWork()方法，获得jdbc的connection后，设置其为自动提交事务模式。（注意：通常并不推荐这样做）
//------------------------------------------------------------------------------------------------
2-5 session详解
//SessionTest.java
package hibernate;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.junit.Test;

public class SessionTest {
    @Test
    public void testOpenSession() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.openSession();
        if (session != null) {
            System.out.println("openSession创建成功");
        } else {
            System.out.println("openSession创建失败");
        }
        session.close();//需要手工关闭
    }

    @Test
    public void testGetCurrentSession() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        if (session != null) {
            System.out.println("getCurrentSession创建成功");
        } else {
            System.out.println("getCurrentSession创建失败");
        }
    }
}


//------------------------------------------------------------------------------------------------
2-6 session详解
openSession与getCurrentSession区别：
1. getCurrentSession在事务提交或者回滚之后会自动关闭，而openSession需要手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出。
2. openSession每次创建新的session对象，getCurrentSession使用现有的session对象。

//------------------------------------------------------------------------------------------------
3-1 Hibernate单表操作 https://www.imooc.com/video/7736

//------------------------------------------------------------------------------------------------
3-2 单一主键
assigned 由java应用程序负责生成（手工赋值）
native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等

参考https://www.cnblogs.com/hoobey/p/5508992.html
//Students.hbm.xml
<id name="sid" type="int">
    <column name="sid" />
    <generator class="native" />
    <!--<generator class="assigned" />-->
</id>

//StudentsTest.java
@Test
public void testSaveStudents() {
    //生成学生对象
//        Students s = new Students(3, "张三丰", "男", new Date(), "武当山");
    Students s = new Students();
    s.setSid(100); //如果配置了generator为native，即便这里设置了sid，仍使用自动增长的值，这里的设置不起作用
    s.setSname("张三丰");
    s.setGender("男");
    s.setBirthday(new Date());
    s.setAddress("武当山");
    session.save(s);//保存对象进数据库
}
不设置setSid()，自增
1    张三丰    男    2018-05-05 17:16:43    武当山
2    张三丰    男    2018-05-05 17:17:45    武当山
3    张三丰    男    2018-05-05 17:17:57    武当山

//------------------------------------------------------------------------------------------------
3-3 单表映射 基本类型
<property name="birthday" type="date">
    <column name="birthday" />
</property>
修改为date，存储为：
1    张三丰    男    2018-05-06    武当山

修改为time，存储为：
1    张三丰    男    07:12:36    武当山

修改为timestamp，存储为：
1    张三丰    男    2018-05-06 07:13:47    武当山

//------------------------------------------------------------------------------------------------
3-4 对象类型
以Blob类型为例：
//Students.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="entity.Students" table="t_students">
        <id name="sid" type="int">
            <column name="sid" />
            <generator class="native" />
            <!--<generator class="assigned" />-->
        </id>
        <property name="sname" type="string" length="20">
            <column name="sname" />
        </property>
        <property name="gender" type="java.lang.String">
            <column name="gender" />
        </property>
        <property name="birthday" type="timestamp">
            <column name="birthday" />
        </property>
        <property name="address" type="java.lang.String">
            <column name="address" />
        </property>
        <property name="picture" type="java.sql.Blob">
            <column name="picture" />
        </property>
    </class>
</hibernate-mapping>

//Students.java
package entity;

import java.sql.Blob;
import java.util.Date;

//学生类
public class Students {
    //Java Beans类的四个基本原则
    //1.公有类
    //2.提供公有的不带参数的默认构造方法
    //3.属性私有
    //4.属性setter/getter封装

    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String address;//地址
    private Blob picture;//照片

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, String address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public Blob getPicture() {
        return picture;
    }

    public void setPicture(Blob picture) {
        this.picture = picture;
    }

    @Override
    public String toString() {
        return "entity.Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", address='" + address + '\'' +
            '}';
    }
}

//hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
  <session-factory>
    <!--  mysql账户名  -->
    <property name="connection.username">root</property>

    <!--  mysql密码  -->
    <property name="connection.password">root123</property>

    <!--  mysql驱动  -->
    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

    <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为8.0.11，并且安装了MySQL的Connector：MySQL Connector/J-->
    <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

    <!--  数据库方言  -->
    <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

    <!--  显示sql语句  -->
    <property name="show_sql">true</property>

    <!--  格式化sql语句  -->
    <property name="format_sql">true</property>

    <!--<property name="hibernate.default_schema">hibernate</property>-->
    <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
    <property name="hbm2ddl.auto">update</property>

    <!--本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
    <property name="hibernate.current_session_context_class">thread</property>
    
    <mapping resource="entity/Students.hbm.xml"/>
    <!--<mapping class="entity.Students"/>-->
  </session-factory>
</hibernate-configuration>

//StudentsTest.java
package entity;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.sql.Blob;
import java.util.Date;

import org.hibernate.Hibernate;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class StudentsTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        //创建配置对象
        Configuration config = new Configuration().configure();
        //创建会话工厂
        sessionFactory = config.buildSessionFactory(); //hibernate4.35之后sessionFactory获取方式 https://www.cnblogs.com/jinjiyese153/p/6902785.html
        //会话对象
        session = sessionFactory.openSession();
        //开启事务
        transaction = session.beginTransaction();
    }

    @After
    public void destroy() {
        transaction.commit();//提交事务
        session.close();//关闭会话
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testWriteBlob() throws Exception {
        Students s = new Students(1, "张三丰", "男", new Date(), "武当山");
        //先获得照片文件
        URL url = this.getClass().getClassLoader().getResource("pics/boy.gif");//获取resources下文件方法，参考https://www.cnblogs.com/acm-bingzi/p/mavenResources.html
        File f = new File(url.toURI().getPath());//空格处理成%20，导致路径找不到，需要用toURI方法转换，参考https://blog.csdn.net/hikvision_java_gyh/article/details/44655447
        //获得照片文件的输入流
        InputStream input = new FileInputStream(f);
        //创建一个Blob对象
        Blob image = Hibernate.getLobCreator(session).createBlob(input, input.available());//输入流和字节长度
        //设置照片属性
        s.setPicture(image);
        //保存学生
        session.save(s);
    }

    @Test
    public void testReadBlob() throws Exception {
        Students s = session.get(Students.class, 1);
        //获得Blob对象
        Blob image = s.getPicture();
        //获得照片的输入流
        InputStream input = image.getBinaryStream();
        //创建输出流
        File f = new File("e:" + File.separator + "dest.gif");
        //获得输出流
        OutputStream output = new FileOutputStream(f);
        //创建缓冲区
        byte[] buffer = new byte[input.available()];
        input.read(buffer);
        output.write(buffer);
        input.close();
        output.close();
    }
}

//在resources/pics/boy.gif有个图片
执行完两个测试用例，在"e:/dest.gif"路径下有个与之前一样的照片文件
1    张三丰    男    2018-05-06 07:52:39    武当山    (BLOB) 11.74 KB
//------------------------------------------------------------------------------------------------
3-5 组件属性
实例类中的某个属性属于用户自定义的类的对象

//Address.java
package entity;
//地址类
public class Address {
    private String postcode;//邮编
    private String phone;//电话
    private String address;//地址

    public Address() {
    }

    public Address(String postcode, String phone, String address) {
        this.postcode = postcode;
        this.phone = phone;
        this.address = address;
    }

    public String getPostcode() {
        return postcode;
    }

    public void setPostcode(String postcode) {
        this.postcode = postcode;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Address{" +
            "postcode='" + postcode + '\'' +
            ", phone='" + phone + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}


//Students.java
package entity;

import java.sql.Blob;
import java.util.Date;

//学生类
public class Students {
    //Java Beans类的四个基本原则
    //1.公有类
    //2.提供公有的不带参数的默认构造方法
    //3.属性私有
    //4.属性setter/getter封装

    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private Address address;//地址
    private Blob picture;//照片

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, Address address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public Blob getPicture() {
        return picture;
    }

    public void setPicture(Blob picture) {
        this.picture = picture;
    }

    @Override
    public String toString() {
        return "entity.Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", address='" + address + '\'' +
            '}';
    }
}

//Students.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="entity.Students" table="t_students">
        <id name="sid" type="int">
            <column name="sid" />
            <generator class="native" />
            <!--<generator class="assigned" />-->
        </id>
        <property name="sname" type="string" length="20">
            <column name="sname" />
        </property>
        <property name="gender" type="java.lang.String">
            <column name="gender" />
        </property>
        <property name="birthday" type="timestamp">
            <column name="birthday" />
        </property>
        <!--<property name="address" type="java.lang.String">
            <column name="address" />
        </property>-->
        <!--component表示一个用户自定义的组件属性-->
        <component name="address" class="entity.Address">
            <property name="postcode" column="postcode"/>
            <property name="phone" column="phone"/>
            <property name="address" column="address"/>
        </component>
        <property name="picture" type="java.sql.Blob">
            <column name="picture" />
        </property>
    </class>
</hibernate-mapping>

//StudentsTest.java
package entity;

import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class StudentsTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        //创建配置对象
        Configuration config = new Configuration().configure();
        //创建会话工厂
        sessionFactory = config.buildSessionFactory(); //hibernate4.35之后sessionFactory获取方式 https://www.cnblogs.com/jinjiyese153/p/6902785.html
        //会话对象
        session = sessionFactory.openSession();
        //开启事务
        transaction = session.beginTransaction();
    }

    @After
    public void destroy() {
        transaction.commit();//提交事务
        session.close();//关闭会话
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSaveStudents() {
        //生成学生对象
//        Students s = new Students(3, "张三丰", "男", new Date(), "武当山");
        Students s = new Students();
        s.setSname("张三丰");
        s.setGender("男");
        s.setBirthday(new Date());
        Address address = new Address("266100", "021-55667788", "西安市");
        s.setAddress(address);
        session.save(s);//保存对象进数据库
    }
}
数据库：
1    张三丰    男    2018-05-06 08:30:26    西安市        266100    021-55667788

//------------------------------------------------------------------------------------------------
3-6 单表操作CRUD实例
save
update
delete
get/load(查询单个记录)

//StudentsTest.java
package entity;

import java.util.Date;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class StudentsTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        //创建配置对象
        Configuration config = new Configuration().configure();
        //创建会话工厂
        sessionFactory = config.buildSessionFactory(); //hibernate4.35之后sessionFactory获取方式 https://www.cnblogs.com/jinjiyese153/p/6902785.html
        //会话对象
        session = sessionFactory.openSession();
        //开启事务
        transaction = session.beginTransaction();
    }

    @After
    public void destroy() {
        transaction.commit();//提交事务
        session.close();//关闭会话
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSaveStudents() {
        //生成学生对象
//        Students s = new Students(3, "张三丰", "男", new Date(), "武当山");
        Students s = new Students();
        s.setSid(100);
        s.setSname("张三丰");
        s.setGender("男");
        s.setBirthday(new Date());
        Address address = new Address("266100", "021-55667788", "西安市");
        s.setAddress(address);
        session.save(s);//保存对象进数据库
    }

    @Test
    public void testGetStudents() {
        Students s = session.get(Students.class, 100);//修改成不存在的sid，打印出null
        System.out.println(s);//注掉这行代码，也可以看到Console中打出了到数据库中查询的select语句
        System.out.println(s.getClass().getName());//输出entity.Students
    }

    @Test
    public void loadGetStudents() {
        Students s = session.load(Students.class, 100);//修改成不存在的sid，抛出异常org.hibernate.ObjectNotFoundException
        System.out.println(s);//注掉这行代码，在Console中看不到查询的select语句
        System.out.println(s.getClass().getName());//输出entity.Students_$$_jvstb5f_0
    }

    @Test
    public void updateGetStudents() {
        Students s = session.get(Students.class, 100);
        s.setGender("女");
        session.save(s);
    }

    @Test
    public void deleteGetStudents() {
        Students s = session.get(Students.class, 100);
        session.delete(s);
    }
}

--get与load的区别
1. 在不考虑缓存的情况下，get方法会在调用之后立即向数据库发出sql语句，返回持久化对象。
load方法会在调用后返回一个代理对象。
该代理对象只保存了实体对象的id，直到使用对象的非主键属性时才会发出sql语句。
2. 查询数据库中不存在的数据时，get方法返回null
load方法抛出异常org.hibernate.ObjectNotFoundException

//------------------------------------------------------------------------------------------------
4-1 Hibernate课程总结 https://www.imooc.com/video/7816
1. 什么是ORM？为什么要使用Hibernate？
2. Hibernate开发的基本步骤？
（1）编写配置文档hibernate.cfg.xml
（2）编写实体类
（3）生成对应实体类的映射文件并添加到配置文档中
（4）调用Hibernte API进行测试
3. 什么是session？一个jdbc的connection对象
4. openSession与getCurrentSession
5. 单表操作常用方法有哪些？
6. get与load
//------------------------------------------------------------------------------------------------
Hibernate注解 https://www.imooc.com/video/10069
JPA：全称Java Persistence API
JPA是标准接口，Hibernate是实现，但是其功能是JPA的超集。
Hibernate如何实现与JPA的关系？
通过hibernate-annotation、hibernate-entitymanager和hibernate-core三个组件来实现。
一般在实现开发中，优先考虑使用JPA注解，这样更有利于程序的移植和扩展。

注解的分类：
--类级别注解
--属性级别注解
--映射关系注解

@Entity 实体类
@Table
@Embeddable 嵌入类
//------------------------------------------------------------------------------------------------
1-3 类级别注解之@Entity注解
@Entity：映射实体类
@Entity(name="tableName")
name:可选，对应数据库中的一个表。若表名与实体类名相同，则可以省略。
注意：使用@Entity时必须指定实体类的主键属性。

//Students.java
package com.entity;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.Date;

//学生类
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private String address;//地址

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, String address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    @Id
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}

//hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
  <session-factory>
    <!--  mysql账户名  -->
    <property name="connection.username">root</property>

    <!--  mysql密码  -->
    <property name="connection.password">root123</property>

    <!--  mysql驱动  -->
    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

    <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为8.0.11，并且安装了MySQL的Connector：MySQL Connector/J-->
    <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

    <!--  数据库方言  -->
    <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

    <!--  显示sql语句  -->
    <property name="show_sql">true</property>

    <!--  格式化sql语句  -->
    <property name="format_sql">true</property>

    <!--<property name="hibernate.default_schema">hibernate</property>-->
    <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
    <property name="hbm2ddl.auto">update</property>

    <!--本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
    <property name="hibernate.current_session_context_class">thread</property>
    
    <mapping class="com.entity.Students"/>
  </session-factory>
</hibernate-configuration>

//StudentsTest.java
package com.entity;

import java.util.EnumSet;

import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }
}
//------------------------------------------------------------------------------------------------
1-4 类级别注解之@Table注解
@Table(name="", catalog="", schema="")
@Entity配合使用，只能标注在实体的Class定义处，表示实体对应的数据库表的信息。
name：可选，映射表的名称，默认表名和实体名称一致，只有在不一致的情况下才需要指定表名。
catelog：可选，表示Catalog名称，默认为Catalog("")。
schema：可选，表示Schema名称，默认为Schema("")。

//Students.java
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
//------------------------------------------------------------------------------------------------
1-5 类级别注解之@Embeddable注解
@Embeddable表示一个非Entity类可以嵌入到另一个Entity类中作为属性而存在。

//Address.java
package com.entity;

import javax.persistence.Embeddable;

//地址类
@Embeddable //表示是一个嵌入类，这个类的对象在另一个实体类中充当属性
public class Address {
    private String postcode;//邮编
    private String phone;//电话
    private String address;//地址

    public Address() {
    }

    public Address(String postcode, String phone, String address) {
        this.postcode = postcode;
        this.phone = phone;
        this.address = address;
    }

    public String getPostcode() {
        return postcode;
    }

    public void setPostcode(String postcode) {
        this.postcode = postcode;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Address{" +
            "postcode='" + postcode + '\'' +
            ", phone='" + phone + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}

//Students.java
package com.entity;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

//学生类
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Address address;

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, Address address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    @Id
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}

//------------------------------------------------------------------------------------------------
2-1 属性级别注解
@Id
@SequenceGenerator
@GeneratedValue
@Colunn
@Embedded
@EmbeddedId
@Lob
@Version
@Basic
@Transient

//------------------------------------------------------------------------------------------------
2-2 @Id
必须，定义了映射到数据库表的主键的属性，一个实体类可以有一个或者多个属性被映射为主键，可置于主键属性或者getXxxx()前。

如果有多个属性定义为主键属性，该实例类必须实现serializable接口。

本地测试Hibernate 5.2.6 ，MySQL80不需要实现serializable接口。以下测试都在此版本

如果@Id一个放在get方法上，一个放在另外一个不同的属性上，那么最后生成的主键只有get方法的那一个，属性的就无效。get方法的优先级大于属性

//Students.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import java.io.Serializable;
import java.util.Date;

//学生类
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students /*implements Serializable */{
    @Id
    private int sid;//学号
    @Id
    @Column(length = 8)//不加@Column注解也可以生成表和主键
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Address address;

    public Students() {
    }

    public Students(int sid, String sname, String gender, Date birthday, Address address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}

//------------------------------------------------------------------------------------------------
2-3 @GeneratedValue
@GeneratedValue(strategy=GenerationType, generator="")
可选，用于定义主键生成策略。
strategy表示主键生成策略，取值有：
1. GenerationType.AUTO：根据底层数据库自动选择（默认）
2. GenerationType.IDENTITY：根据数据库的Identity字段生成
3. GenerationType.SEQUENCE：使用Sequence来决定主键的取值
4. GenerationType.TABLE：使用指定表来决定主键取值，结合@TableGenerator使用

如：
@Id
@TableGenerator(name="tab_cat_gen", allocationSize=1)
@GeneratedValue(strategy=GenerationType.Table)
Generator-表示主键生成器的名称，这个属性通常和ORM框架相关，如：Hibernate可以指定uuid等主键生成方式
//------------------------------------------------------------------------------------------------
2-4 @GeneratedValue （二）
https://www.cnblogs.com/hoobey/p/5508992.html

//
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    @Id
    @GeneratedValue //不写默认就是GenerationType.AUTO
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Address address;
    //...
}

当前生成了一个t_students表，又生成了hibernate_sequence表。在hibernate_sequence表中保存了主键增长值。
有个问题，又定义了一个NewStudents表，会往hibernate_sequence表中插入了两条为1的数据，每次往Students或NewStudents表中任意插入一条数据，都会使hibernate_sequence表中数据增长1。

//
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) //这种定义方式是自动增长的
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Address address;
    //...
}
建表语句：
create table t_students (
   sid integer not null auto_increment,
    address varchar(255),
    phone varchar(255),
    postcode varchar(255),
    birthday datetime,
    gender varchar(255),
    major varchar(255),
    sname varchar(255),
    primary key (sid)
)

String类型定义为主键
//
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    @Id
    //注释掉@GeneratedValue即可正常建表，但是必须手工设置String主键值，如果不手工设置，则第一次插入数据时，int默认为0，可以插入，第二次插入的时候就会主键冲突
    //@GeneratedValue(strategy = GenerationType.AUTO) //这种形式建表无问题，同时会生成hibernate_sequence表，插入数据时抛异常：org.hibernate.id.IdentifierGenerationException: Unknown integral data type for ids : java.lang.String；IDENTITY这个值建表失败
    private String sid;//学号
    //...
}

//
package com.entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        Students students = new Students();
        students.setSid("10");//手工赋值
        students.setSname("张三丰");
        students.setGender("男");
        students.setBirthday(new Date());
        students.setMajor("武术");
        students.setAddress(new Address("200120", "13677778888", "武当山"));

        session.save(students);
        transaction.commit();
    }
}

或者用如下手工赋值方式指定String主键@Id：
@Id
@GeneratedValue(generator = "sid")
@GenericGenerator(name = "sid", strategy = "assigned")
private String sid;//学号


用native方式给int赋值
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    @Id
//    @GeneratedValue(strategy = GenerationType.AUTO) //不写默认就是GenerationType.AUTO
    @GeneratedValue(generator = "sid")
    @GenericGenerator(name = "sid", strategy = "native") //这里是native，主键必须是数值类型，改成String，则建表失败
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Address address;

    public Students() {
    }
    //...
}
//------------------------------------------------------------------------------------------------
2-6 属性级别注解之@Column
可将属性映射到列，使用该注解来覆盖默认值，@Column描述了数据库表中该字段的详细定义，这对于根据JAP注解生成数据库表结构的工具非常有作用。
常用属性：
name
nullable
unique
length
insertable
updateable
//------------------------------------------------------------------------------------------------
2-7 属性级别注解之@Embedded
注释属性的，表示该属性的类是嵌入类。
注意：同时嵌入类也必须标注@Embeddable注解。

实测在属性address上增加@Embedded后，即便不在嵌入类上增加@Embeddable注解，同时可以建表和插入数据成功，只不过address上会有提示：
'Embedded' attribute type should not be 'Address'。
如果在getAddress()方法上增加@Embedded后，如果不在嵌入类上增加@Embeddable注解，就会建表失败。
但是如果一个注解都没有，就有问题。

@Embedded
private Address address;

或者加在get方法上。
//------------------------------------------------------------------------------------------------
2-8 属性级别注解之EmbeddedId
使用嵌入式主键类实现复合主键。
注意：嵌入式主键类必须实现Serializable接口、必须有默认的public无参数的构造方法、必须覆盖equals和hashcode()方法。

实测没有覆盖equals和hashcode()方法，也可以正常建表和插入数据
//StudentsPK.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Embeddable;
import java.io.Serializable;

@Embeddable
public class StudentsPK implements Serializable {

    private static final long serialVersionUID = -7643136722691461927L; //如果不implements Serializable则建表成功，插入数据报错org.hibernate.MappingException: Composite-id class must implement Serializable: com.entity.StudentsPK
    @Column(length = 18)
    private String id;//身份证号
    @Column(length = 8)
    private String sid;//学号

    public StudentsPK() {
    }

    public StudentsPK(String id, String sid) {
        this.id = id;
        this.sid = sid;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getSid() {
        return sid;
    }

    public void setSid(String sid) {
        this.sid = sid;
    }
}

//
package com.entity;

import javax.persistence.Embedded;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.util.Date;

//学生类
@Entity//这里生成的数据库表名是全小写的students @Entity(name = "t_students")
@Table(name = "t_students", schema = "hibernate") //这里加了name属性之后，@Entity注解里就不需要name属性了
public class Students {
    @EmbeddedId
    private StudentsPK pk;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    @Embedded
    private Address address;

    public Students() {
    }

    public Students(StudentsPK pk, String sname, String gender, Date birthday, Address address) {
        this.pk = pk;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public StudentsPK getPk() {
        return pk;
    }

    public void setPk(StudentsPK pk) {
        this.pk = pk;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + pk +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}

//StudentsTest.java
package com.entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        Students students = new Students();
        StudentsPK pk = new StudentsPK("123456789012345678", "S0001234");
        students.setPk(pk);
        students.setSname("张三丰");
        students.setGender("男");
        students.setBirthday(new Date());
        students.setMajor("武术");
        students.setAddress(new Address("200120", "13677778888", "武当山"));

        session.save(students);
        transaction.commit();
    }
}
//------------------------------------------------------------------------------------------------
2-9 属性级别注解之@Transient
可选，表示该属性并非一个到数据库表的字段的映射，ORM框架将忽略该属性，如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则ORM框架默认其注解为@Basic

import javax.persistence.Transient;

@Transient
private double salary;
//------------------------------------------------------------------------------------------------
3-1 Hibernate关联映射注解 https://www.imooc.com/video/10083
1. 一对一单向外键
2. 一对一双向外键关联
3. 一对一单向外键联合主键
4. 多对一单向外键关联
5. 一对多单向外键关联
6. 一对多双向外键关联
7. 多对多单向外键关联

//------------------------------------------------------------------------------------------------
3-2 实体之间的映射关系
--一对一：一个公民对应一个身份证号码。
--一对多（多对一）：一个公民有多个银行账号。
--多对多：一个学生有多个老师，一个老师有多个学生

//------------------------------------------------------------------------------------------------
3-3 关联映射注解之一对一单向外键
@OneToOne(cascade=CascadeType.all)//全级联关系，级联增加，级联删除，级联更新
@JoinColumn(name="pid", unique=true)//name表示主表中的外键字段名
注意：保存时应该先保存外键对象，再保存主表对象。

//IdCard.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.hibernate.annotations.GenericGenerator;

@Entity
public class IdCard {
    @Id
    @GeneratedValue(generator = "pid")
    @GenericGenerator(name = "pid", strategy = "assigned")
    @Column(length = 18)
    private String pid;//身份证号码
    private String sname;//学生的姓名

    public IdCard() {
    }

    public IdCard(String pid, String sname) {
        this.pid = pid;
        this.sname = sname;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }
}

//Students.java
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import java.util.Date;

//学生类
@Entity(name = "t_students")
public class Students {
    private IdCard idCard;//身份证
    private int sid;//学号
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业

    public Students() {
    }

    public Students(IdCard idCard, int sid, String gender, Date birthday, String major) {
        this.idCard = idCard;
        this.sid = sid;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
    }

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "pid", unique = true)//在IdCard只有一个主键的情况下，这种定义方式就够了，name就是主控表外键的列名称；如果IdCard有两个主键，则这种定义方式就不够了，建表提示需要有两个外键，见下例
    public IdCard getIdCard() {
        return idCard;
    }

    public void setIdCard(IdCard idCard) {
        this.idCard = idCard;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}

//StudentsTest.java
package com.entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);//在已经有t_students和idcard表的情况下，如果手工在数据库中删除idcard表，会报被外键引用无法删除的错误。而用程序运行的时候，代码会先删除主控表的外键，再删除两个表，就没有问题了
        // Hibernate: 
            // alter table t_students 
               // drop 
               // foreign key FKkabunwku3uvmp85vfsuvjk4fh
        // Hibernate: 
            // drop table if exists idcard
        // Hibernate: 
            // drop table if exists t_students
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        IdCard card = new IdCard("123456789012345678", "张无忌");
        Students students = new Students(card, "男", new Date(), "太极拳");
        //先保存身份证类对象
        session.save(card);
        session.save(students);

        transaction.commit();
    }
    
    @Test
    public void testUpdateIdCard() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        IdCard card = session.get(IdCard.class, "123456789012345678");
        card.setPid("987654321098765432");
        session.save(card);//主键不能被更新，抛异常：javax.persistence.PersistenceException: org.hibernate.HibernateException: identifier of an instance of com.entity.IdCard was altered from 123456789012345678 to 987654321098765432

        transaction.commit();
    }
}

//IdCard有两个主键时：
//IdCard.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToOne;

import java.io.Serializable;

import org.hibernate.annotations.GenericGenerator;

@Entity
public class IdCard implements Serializable { //有多个主键时，必须实现Serializable接口
    private static final long serialVersionUID = -6668320870961885830L;

    @Id
    @GeneratedValue(generator = "pid")
    @GenericGenerator(name = "pid", strategy = "assigned")
    @Column(length = 18)
    private String pid;//身份证号码
    private String sname;//学生的姓名
    @Id
    @GeneratedValue(generator = "addr")
    @GenericGenerator(name = "addr", strategy = "assigned")
    @Column(length = 18)
    private String address;

    public IdCard() {
    }

    public IdCard(String pid, String sname, String address) {
        this.pid = pid;
        this.sname = sname;
        this.address = address;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}

//------------------------------------------------------------------------------------------------
3-5 一对一双向外键
--主控方的配置同一对一单向外键关系
--被控方 @OneToOne(mappedBy="card") //被控方
双向关联，必须设置mappedBy属性。因为双向关联只能交给一方去控制，不可能在双方都设置外键保存关联关系，否则双方都无法保存。

//
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToOne;

import org.hibernate.annotations.GenericGenerator;

@Entity
public class IdCard {
    @Id
    @GeneratedValue(generator = "pid")
    @GenericGenerator(name = "pid", strategy = "assigned")
    @Column(length = 18)
    private String pid;//身份证号码
    private String sname;//学生的姓名
    @OneToOne(mappedBy = "idCard")//这个指Students类的属性名
    private Students students;

    public IdCard() {
    }

    public IdCard(String pid, String sname) {
        this.pid = pid;
        this.sname = sname;
    }

    public String getPid() {
        return pid;
    }

    public void setPid(String pid) {
        this.pid = pid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public Students getStudents() {
        return students;
    }

    public void setStudents(Students students) {
        this.students = students;
    }
}

//
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import java.util.Date;

import org.hibernate.annotations.JoinColumnOrFormula;
import org.hibernate.annotations.JoinColumnsOrFormulas;

//学生类
@Entity(name = "t_students")
public class Students {
    private IdCard idCard;//身份证
    private int sid;//学号
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业

    public Students() {
    }

    public Students(IdCard idCard, String gender, Date birthday, String major) {
        this.idCard = idCard;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
    }

    @OneToOne(cascade = CascadeType.ALL)
    //name表示主控表外键时的字段，referencedColumnName表示引用的被控方属性字段
    @JoinColumnsOrFormulas(value = {
        @JoinColumnOrFormula(column = @JoinColumn(name = "fk_pid", referencedColumnName = "pid")),
        @JoinColumnOrFormula(column = @JoinColumn(name = "fk_address", referencedColumnName = "address"))
    })
    public IdCard getIdCard() {
        return idCard;
    }

    public void setIdCard(IdCard idCard) {
        this.idCard = idCard;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}
//------------------------------------------------------------------------------------------------
3-6 一对一双向外键联合主键
--创建主键类
--主键类必须实现serializable接口，重写hashCode()和equals()方法。

主键类：@Embeddable
实体类：@EmbeddedId
具体实现参考第二章

//------------------------------------------------------------------------------------------------
3-7 多对一单向外键
多方持有一方的引用，比如：多个学生对应一个班级（多对一）
@ManyToOne(cascade = {CascadeType.ALL}, fetch=FetchType.EAGER)
@JoinColumn(name="cid", referenceColumnName="CID")

//Students.java
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import java.util.Date;

//学生类
@Entity(name = "t_students")
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private ClassRoom classRoom;//班级

    public Students() {
    }

    public Students(String sname, String gender, Date birthday, String major, ClassRoom classRoom) {
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
        this.classRoom = classRoom;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @ManyToOne(cascade = {CascadeType.ALL}, fetch = FetchType.EAGER)
    @JoinColumn(name = "fk_cid", referencedColumnName = "cid")
    public ClassRoom getClassRoom() {
        return classRoom;
    }

    public void setClassRoom(ClassRoom classRoom) {
        this.classRoom = classRoom;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}

//ClassRoom.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.hibernate.annotations.GenericGenerator;

//班级实体类
@Entity(name = "t_classRoom")
public class ClassRoom {
    @Id
    @GeneratedValue(generator = "cid")
    @GenericGenerator(name = "cid", strategy = "assigned")
    @Column(length = 4)
    private String cid;//班级的编号
    private String cname;//班级的名字

    public ClassRoom() {
    }

    public ClassRoom(String cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public String getCid() {
        return cid;
    }

    public void setCid(String cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }
}

//StudentsTest.java
package com.entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        ClassRoom classRoom1 = new ClassRoom("C001", "软件工程");
        ClassRoom classRoom2 = new ClassRoom("C002", "网络工程");

        Students students1 = new Students("张三", "男", new Date(), "太极拳", classRoom1);
        Students students2 = new Students("李四", "男", new Date(), "太极拳", classRoom2);
        Students students3 = new Students("王五", "女", new Date(), "太极拳", classRoom1);
        Students students4 = new Students("赵六", "女", new Date(), "太极拳", classRoom2);

        session.save(classRoom1);
        session.save(classRoom2);
        session.save(students1);
        session.save(students2);
        session.save(students3);
        session.save(students4);

        transaction.commit();
    }
}
//------------------------------------------------------------------------------------------------
3-8 一个对多单向外键
一方持有多方的集合，一个班级有多个学生（一对多）。
@OneToMany(cascade={CascadeType.ALL}, fetch=FetchType.LAZY)
@JoinColumn(name="cid")
总结：多对一的时候，多方设置EAGER，一方设置LAZY

//Students.java
package com.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import java.util.Date;

//学生类
@Entity(name = "t_students")
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业

    public Students() {
    }

    public Students(String sname, String gender, Date birthday, String major) {
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}

//ClassRoom.java
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;

import java.util.Set;

import org.hibernate.annotations.GenericGenerator;

//班级实体类
@Entity(name = "t_classRoom")
public class ClassRoom {
    @Id
    @GeneratedValue(generator = "cid")
    @GenericGenerator(name = "cid", strategy = "assigned")
    @Column(length = 4)
    private String cid;//班级的编号
    private String cname;//班级的名字

    @OneToMany(cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)
    @JoinColumn(name = "fk_cid", referencedColumnName = "cid") //如果不加这行，将新建一个中间表，但是该表无法自动插入数据。这行表示，要在多方表中增加外键字段fk_cid，引用一方表的cid属性字段
    private Set<Students> students;

    public ClassRoom() {
    }

    public ClassRoom(String cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public String getCid() {
        return cid;
    }

    public void setCid(String cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }

    public Set<Students> getStudents() {
        return students;
    }

    public void setStudents(Set<Students> students) {
        this.students = students;
    }
}

//StudentsTest.java
package com.entity;

import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        ClassRoom classRoom1 = new ClassRoom("C001", "软件工程");
        ClassRoom classRoom2 = new ClassRoom("C002", "网络工程");

        Students students1 = new Students("张三", "男", new Date(), "太极拳");
        Students students2 = new Students("李四", "男", new Date(), "太极拳");
        Students students3 = new Students("王五", "女", new Date(), "太极拳");
        Students students4 = new Students("赵六", "女", new Date(), "太极拳");

        Set<Students> studentsSet1 = new HashSet<>();
        studentsSet1.add(students1);
        studentsSet1.add(students2);
        classRoom1.setStudents(studentsSet1);

        Set<Students> studentsSet2 = new HashSet<>();
        studentsSet2.add(students3);
        studentsSet2.add(students4);
        classRoom2.setStudents(studentsSet2);

        //先保存学生，再保存教室。Hibernate会先插入学生数据，再插入老师数据，最后再更新学生外键数据
        session.save(students1);
        session.save(students2);
        session.save(students3);
        session.save(students4);

        session.save(classRoom1);
        session.save(classRoom2);

        //如果先保存classRoom1和classRoom2，则Hibernate会先保存classRoom1、students1和students2，再保存classRoom2、students3和students4。后面保存students的四条保存语句写不写都没有关系，框架不会重复插入数据
        // session.save(classRoom1);
        // session.save(classRoom2);

        // session.save(students1);
        // session.save(students2);
        // session.save(students3);
        // session.save(students4);
        
        transaction.commit();
    }
}
//------------------------------------------------------------------------------------------------
3-9 一对多（多对一）双向外键
多方：多方持有一方的引用。
@ManyToOne(cascade = {CascadeType.ALL}, fetch=FetchType.EAGER)
@JoinColumn(name="cid", referenceColumnName="CID")

一方：一方持有多方的集合。
@OneToMany(cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)
@JoinColumn(name = "fk_cid", referencedColumnName = "cid")

//
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import java.util.Date;

//学生类
@Entity(name = "t_students")
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private ClassRoom classRoom;//多方持有一方的引用

    public Students() {
    }

    public Students(String sname, String gender, Date birthday, String major) {
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @ManyToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name = "fk_cid", referencedColumnName = "cid")//name = "fk_cid2"，则会在t_students表中生成两个外键字段fk_cid2和fk_cid
    public ClassRoom getClassRoom() {
        return classRoom;
    }

    public void setClassRoom(ClassRoom classRoom) {
        this.classRoom = classRoom;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}


//
package com.entity;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToMany;

import java.util.Set;

import org.hibernate.annotations.GenericGenerator;

//班级实体类
@Entity(name = "t_classRoom")
public class ClassRoom {
    @Id
    @GeneratedValue(generator = "cid")
    @GenericGenerator(name = "cid", strategy = "assigned")
    @Column(length = 4)
    private String cid;//班级的编号
    private String cname;//班级的名字

    @OneToMany(cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)
    @JoinColumn(name = "fk_cid", referencedColumnName = "cid")
    private Set<Students> students;

    public ClassRoom() {
    }

    public ClassRoom(String cid, String cname) {
        this.cid = cid;
        this.cname = cname;
    }

    public String getCid() {
        return cid;
    }

    public void setCid(String cid) {
        this.cid = cid;
    }

    public String getCname() {
        return cname;
    }

    public void setCname(String cname) {
        this.cname = cname;
    }

    public Set<Students> getStudents() {
        return students;
    }

    public void setStudents(Set<Students> students) {
        this.students = students;
    }
}

//
package com.entity;

import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        ClassRoom classRoom1 = new ClassRoom("C001", "软件工程");
        ClassRoom classRoom2 = new ClassRoom("C002", "网络工程");

        Students students1 = new Students("张三", "男", new Date(), "太极拳");
        Students students2 = new Students("李四", "男", new Date(), "太极拳");
        Students students3 = new Students("王五", "女", new Date(), "太极拳");
        Students students4 = new Students("赵六", "女", new Date(), "太极拳");

        //这里把学生的设置都交一方对象，无需手工设置Students::setClassRoom
        Set<Students> studentsSet1 = new HashSet<>();
        studentsSet1.add(students1);
        studentsSet1.add(students2);
        classRoom1.setStudents(studentsSet1);

        Set<Students> studentsSet2 = new HashSet<>();
        studentsSet2.add(students3);
        studentsSet2.add(students4);
        classRoom2.setStudents(studentsSet2);

        session.save(classRoom1);
        session.save(classRoom2);

        session.save(students1);
        session.save(students2);
        session.save(students3);
        session.save(students4);

        //无论是先存学生还是先存教室，如果@ManyToOne和@OneToMany设置的外键名字不一样，则多方增加的外键fk_cid2，无法插入数据
//        session.save(students1);
//        session.save(students2);
//        session.save(students3);
//        session.save(students4);
//
//        session.save(classRoom1);
//        session.save(classRoom2);

        transaction.commit();
    }
    
    @Test
    public void testGetStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        Students students =  session.get(Students.class, 1);//这里获取到学生对象，其成员变量classRoom已经有值，非null
    }
}
//------------------------------------------------------------------------------------------------
3-10 多对多单向外键
学生和教师构成多对多的关联关系。
其中一个多方持有另一个多方的集合对象（学生持有教师的集合）
创建中间表
//学生类
@ManyToMany
@JoinTable(
    name="teachers_students",
    joinColumns={@JoinColumn(name="sid")},
    inverseJoinColumns={@JoinColumn(name="tid")}
)

//Students.java
package com.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import java.util.Date;
import java.util.Set;

//学生类
@Entity(name = "t_students")
public class Students {
    private int sid;//学号
    private String sname;//姓名
    private String gender;//性别
    private Date birthday;//出生日期
    private String major;//专业
    private Set<Teachers> teachers;//学生持有教师的集合

    public Students() {
    }

    public Students(String sname, String gender, Date birthday, String major) {
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.major = major;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public int getSid() {
        return sid;
    }

    public void setSid(int sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    @ManyToMany
    @JoinTable(
        name = "t_teachers_students",
        joinColumns = {@JoinColumn(name = "fk_sid", referencedColumnName = "sid")},
        inverseJoinColumns = {@JoinColumn(name = "fk_tid", referencedColumnName = "tid")}
    )
    public Set<Teachers> getTeachers() {
        return teachers;
    }

    public void setTeachers(Set<Teachers> teachers) {
        this.teachers = teachers;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid=" + sid +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", major='" + major + '\'' +
            '}';
    }
}

//Teachers.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

import org.hibernate.annotations.GenericGenerator;

@Entity(name = "t_teachers")
public class Teachers {
    @Id
    @GeneratedValue(generator = "tid")
    @GenericGenerator(name = "tid", strategy = "assigned")
    @Column(length = 4)
    private String tid;//教师编号
    private String tname;//姓名

    public Teachers() {
    }

    public Teachers(String tid, String tname) {
        this.tid = tid;
        this.tname = tname;
    }

    public String getTid() {
        return tid;
    }

    public void setTid(String tid) {
        this.tid = tid;
    }

    public String getTname() {
        return tname;
    }

    public void setTname(String tname) {
        this.tname = tname;
    }
}

//StudentsTest.java
package com.entity;

import java.util.Date;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.Test;

public class StudentsTest {
    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        Teachers t1 = new Teachers("T001", "张老师");
        Teachers t2 = new Teachers("T002", "李老师");
        Teachers t3 = new Teachers("T003", "陈老师");
        Teachers t4 = new Teachers("T004", "刘老师");

        Students students1 = new Students("张三", "男", new Date(), "太极拳");
        Students students2 = new Students("李四", "男", new Date(), "太极拳");
        Students students3 = new Students("王五", "女", new Date(), "太极拳");
        Students students4 = new Students("赵六", "女", new Date(), "太极拳");

        Set<Teachers> teachers1 = new HashSet<>();
        teachers1.add(t1);
        teachers1.add(t2);

        Set<Teachers> teachers2 = new HashSet<>();
        teachers2.add(t2);
        teachers2.add(t3);

        Set<Teachers> teachers3 = new HashSet<>();
        teachers3.add(t3);
        teachers3.add(t4);

        Set<Teachers> teachers4 = new HashSet<>();
        teachers4.add(t2);
        teachers4.add(t4);

        students1.setTeachers(teachers1);
        students2.setTeachers(teachers2);
        students3.setTeachers(teachers3);
        students4.setTeachers(teachers4);

        session.save(t1);
        session.save(t2);
        session.save(t3);
        session.save(t4);

        session.save(students1);
        session.save(students2);
        session.save(students3);
        session.save(students4);

        transaction.commit();
    }
}

//t_students
"sid"    "birthday"    "gender"    "major"    "sname"
"1"    "12/5/2018 14:49:02"    "男"    "太极拳"    "张三"
"2"    "12/5/2018 14:49:02"    "男"    "太极拳"    "李四"
"3"    "12/5/2018 14:49:02"    "女"    "太极拳"    "王五"
"4"    "12/5/2018 14:49:02"    "女"    "太极拳"    "赵六"

//t_teachers
"tid"    "tname"
"T001"    "张老师"
"T002"    "李老师"
"T003"    "陈老师"
"T004"    "刘老师"

//t_teachers_students
"fk_sid"    "fk_tid"
"1"    "T001"
"1"    "T002"
"2"    "T002"
"4"    "T002"
"2"    "T003"
"3"    "T003"
"3"    "T004"
"4"    "T004"

//------------------------------------------------------------------------------------------------
3-12 多对多双向外键
双方持有对方的集合对象，其中一方设置
//教师类
@ManyToMany(mappedBy="teachers")
另一方：
//学生类
@ManyToMany
@JoinTable(
    name="teachers_students",
    joinColumns={@JoinColumn(name="sid")},
    inverseJoinColumns={@JoinColumn(name="tid")}
)

//其余代码同上
//Teachers.java
package com.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToMany;

import java.util.Set;

import org.hibernate.annotations.GenericGenerator;

@Entity(name = "t_teachers")
public class Teachers {
    @Id
    @GeneratedValue(generator = "tid")
    @GenericGenerator(name = "tid", strategy = "assigned")
    @Column(length = 4)
    private String tid;//教师编号
    private String tname;//姓名

    @ManyToMany(mappedBy = "teachers")
    private Set<Students> students;//教师持有的学生集合

    public Teachers() {
    }

    public Teachers(String tid, String tname) {
        this.tid = tid;
        this.tname = tname;
    }

    public String getTid() {
        return tid;
    }

    public void setTid(String tid) {
        this.tid = tid;
    }

    public String getTname() {
        return tname;
    }

    public void setTname(String tname) {
        this.tname = tname;
    }

    public Set<Students> getStudents() {
        return students;
    }

    public void setStudents(Set<Students> students) {
        this.students = students;
    }
}

//------------------------------------------------------------------------------------------------
Struts入门 3-2 struts2核心文件
struts.xml中包含的内容：
1. 全局属性
2. 用户请求和响应Action之间的对应关系
3. Action可能用到的参数和返回结果
4. 各种拦截器的配置

struts.properties
struts2框架的全局属性文件，自动加载。
该文件包含很多key-value对。
该文件完全可以配置在struts.xml文件中，使用constant元素。

struts2中struts.xml配置文件详解：https://www.cnblogs.com/wkrbky/p/5889328.html
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd">
<struts>
    <!-- 所有匹配*.action的请求都由struts2处理 -->
    <constant name="struts.action.extension" value="action" />
    <!-- 是否启用开发模式 -->
    <constant name="struts.devMode" value="true" />
    <!-- struts配置文件改动后，是否重新加载 -->
    <constant name="struts.configuration.xml.reload" value="true" />
    <!-- 设置浏览器是否缓存静态内容 -->
    <constant name="struts.serve.static.browserCache" value="false" />
    <!-- 请求参数的编码方式 -->
    <constant name="struts.i18n.encoding" value="utf-8" />
    <!-- 每次HTTP请求系统都重新加载资源文件，有助于开发 -->
    <constant name="struts.i18n.reload" value="true" />
    <!-- 文件上传最大值 -->
    <constant name="struts.multipart.maxSize" value="104857600" />
    <!-- 让struts2支持动态方法调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true" />
    <!-- Action名称中是否还是用斜线 -->
    <constant name="struts.enable.SlashesInActionNames" value="false" />
    <!-- 允许标签中使用表达式语法 -->
    <constant name="struts.tag.altSyntax" value="true" />
    <!-- 对于WebLogic,Orion,OC4J此属性应该设置成true -->
    <constant name="struts.dispatcher.parametersWorkaround" value="false" />

    <package name="basePackage" extends="struts-default">

    </package>
</struts>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN" "http://struts.apache.org/dtds/struts-2.5.dtd" >
<struts>

    <!-- include节点是struts2中组件化的方式 可以将每个功能模块独立到一个xml配置文件中 然后用include节点引用 -->
    <include file="struts-default.xml"></include>
    
    
    <!-- package提供了将多个Action组织为一个模块的方式
        package的名字必须是唯一的 package可以扩展 当一个package扩展自
        另一个package时该package会在本身配置的基础上加入扩展的package
        的配置 父package必须在子package前配置 
        name：package名称
        extends:继承的父package名称
        abstract:设置package的属性为抽象的 抽象的package不能定义action 值true:false
        namespace:定义package命名空间 该命名空间影响到url的地址，例如此命名空间为/test那么访问是的地址为http://localhost:8080/struts2/test/XX.action
     -->
    <package name="com.kay.struts2" extends="struts-default" namespace="/test">
        <interceptors>
            <!-- 定义拦截器 
                name:拦截器名称
                class:拦截器类路径
             -->
            <interceptor name="timer" class="com.kay.timer"></interceptor>
            <interceptor name="logger" class="com.kay.logger"></interceptor>
            <!-- 定义拦截器栈 -->
            <interceptor-stack name="mystack">
                <interceptor-ref name="timer"></interceptor-ref>
                <interceptor-ref name="logger"></interceptor-ref>
            </interceptor-stack>
        </interceptors>
        
        <!-- 定义默认的拦截器 每个Action都会自动引用
         如果Action中引用了其它的拦截器 默认的拦截器将无效 -->
        <default-interceptor-ref name="mystack"></default-interceptor-ref>
        
        
        <!-- 全局results配置 -->
        <global-results>
            <result name="input">/error.jsp</result>
        </global-results>
        
        <!-- Action配置 一个Action可以被多次映射(只要action配置中的name不同)
             name：action名称 包有命名空间时：http://localhost:8080/struts/db/hello.action 包没有命名空间时：http://localhost:8080/struts/hello.action
             class: 对应的类的路径
             method: 调用Action中的方法名
        -->
        <action name="hello" class="com.kay.struts2.Action.LoginAction">
            <!-- 引用拦截器
                name:拦截器名称或拦截器栈名称
             -->
            <interceptor-ref name="timer"></interceptor-ref>
        
            <!-- 节点配置
                name : result名称 和Action中返回的值相同
                type : result类型 不写则选用superpackage的type struts-default.xml中的默认为dispatcher
             -->
         <result name="success" type="dispatcher">/talk.jsp</result>
         <!-- 参数设置 
             name：对应Action中的get/set方法 
         -->
         <param name="url">http://www.sina.com</param>
        </action>
    </package>
</struts>

//工程搭建
//resources/struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <action name="hello" class="struts.HelloAction" method="hello">
            <result name="success">/index.jsp</result>
        </action>

        <action name="default" class="struts.HelloAction">
            <result name="success">/index.jsp</result>
        </action>
    </package>

</struts>

//resources/log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5p] %d %c - %m%n" />
        </Console>
        <File name="File" fileName="dist/my.log">
            <PatternLayout pattern="%m%n" />
        </File>
    </Appenders>

    <Loggers>
        <Logger name="mh.sample2.Log4jTest2" level="INFO">
            <AppenderRef ref="File" />
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>

//web/WEB-INF/web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>struts</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>struts</filter-name>
        <url-pattern>/*</url-pattern>   */后注释
    </filter-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>

//web/index.jsp
<%--
  Created by IntelliJ IDEA.
  User: Ben
  Date: 2018/5/13
  Time: 20:02
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>DingBenTestPage</title>
</head>
<body>
this is a jsp page.
<br> ${hello}
</body>
</html>


//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>struts</groupId>
  <artifactId>struts</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>struts</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-core</artifactId>
      <version>2.5.16</version>
    </dependency>
    <dependency>
      <groupId>jstl</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>
    <dependency>
      <groupId>struts</groupId>
      <artifactId>struts</artifactId>
      <version>1.0-SNAPSHOT</version>
    </dependency>
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <build>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.0.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.7.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.20.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

//struts.HelloAction
package struts;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionSupport;

public class HelloAction extends ActionSupport {
    HttpServletRequest request = ServletActionContext.getRequest();

    public String execute() {
        request.setAttribute("hello", "execute()!");
        return SUCCESS;
    }

    public String hello() {
        request.setAttribute("hello", "hello world!");
        return SUCCESS;
    }
}

//Idea maven搭建Struts工程：
https://www.cnblogs.com/liygheart/p/3628835.html
https://blog.csdn.net/pinebud55/article/details/53037937


//------------------------------------------------------------------------------------------------
4-2 访问Servlet API
提供了三种方式去访问Servlet API：
1. ActionContext
2. 实现***Aware接口
3. ServletActionContext


//------------------------------------------------------------------------------------------------
4-3 Action搜索顺序 https://www.imooc.com/video/8998 https://blog.csdn.net/taosst/article/details/6225272

//用函数返回值与result的name值匹配，匹配不到，就取最后一个jsp
//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <action name="hello" class="struts.HelloAction" method="hello">
            <result name="success">/index.jsp</result>
        </action>

        <action name="default" class="struts.HelloAction">
            <result name="success">/index.jsp</result>
        </action>
    </package>

    <!--包名 -->
    <package name="defaultNamespace" namespace="" extends="struts-default">
        <action name="good" class="struts.DefaultAction" method="good">
            <result name="success">/index.jsp</result>
        </action>

        <action name="" class="struts.DefaultAction">
            <result name="success">/index.jsp</result>
        </action>
    </package>

</struts>

//DefaultAction.java
package struts;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionSupport;

public class DefaultAction extends ActionSupport {

    HttpServletRequest request = ServletActionContext.getRequest();

    public String execute() {
        request.setAttribute("hello", "DefaultAction.execute()!");
        return SUCCESS;
    }

    public String good() {
        request.setAttribute("hello", "DefaultAction.hello world!");
        return SUCCESS;
    }
}

//------------------------------------------------------------------------------------------------
4-4 动态方法调用
指定method方法：struts.xml里，action 中配置method方法，指定调用的方法。

//如果不指定result的name属性，则返回函数无法找到匹配的jsp，显示的就是最后一个
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <action name="hello" class="struts.HelloAction" method="hello">
            <result >/index.jsp</result>
            <result >/add.jsp</result>
            <result >/update.jsp</result>
        </action>
    </package>

</struts>
输入：
http://localhost:8080/struts/hello
输出：
This is update.jsp

//使用感叹号方式，在struts2.5需要增加配置参数 https://blog.csdn.net/GS_Warriors/article/details/78406685
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods><!--struts2.5 需要多配置这一行-->
        <action name="hello" class="struts.HelloAction">
            <result name = "success">/index.jsp</result>
            <result name = "add">/add.jsp</result>
            <result name = "update">/update.jsp</result>
        </action>
    </package>

</struts>

//HelloAction.java
package struts;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionSupport;

public class HelloAction extends ActionSupport {
    HttpServletRequest request = ServletActionContext.getRequest();

    public String execute() {
        request.setAttribute("hello", "execute()!");
        return SUCCESS;
    }

    public String hello() {
        request.setAttribute("hello", "hello world!");
        return SUCCESS;
    }

    public String add() {
        return "add";
    }

    public String update() {
        return "update";
    }
}

//通配符方式调用
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="hello*" method="{1}" class="struts.HelloAction">
            <result name = "success">/index.jsp</result>
            <result name = "add">/{1}.jsp</result>
            <result name = "update">/{1}.jsp</result>
        </action>
    </package>

</struts>

浏览器输入：http://localhost:8080/struts/helloupdate
输出：This is update.jsp

//使用两个通配符
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" method="{2}" class="struts.{1}Action">
            <result name = "success">/index.jsp</result>
            <result name = "add">/{2}.jsp</result>
            <result name = "update">/{2}.jsp</result>
        </action>
    </package>

</struts>
浏览器输入：http://localhost:8080/struts/Hello_update.action
输出：This is update.jsp
浏览器输入：http://localhost:8080/struts/Hello_.action
输出：
this is a jsp page. 
execute()!
//------------------------------------------------------------------------------------------------
4-5 指定多个配置文件
//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--文件名 -->
    <include file="helloWorld.xml"></include>

</struts>

//helloWorld.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" method="{2}" class="struts.{1}Action">
            <result name = "success">/index.jsp</result>
            <result name = "add">/{2}.jsp</result>
            <result name = "update">/{2}.jsp</result>
        </action>
    </package>

</struts>

也可以访问到：http://localhost:8080/struts/Hello_update.action

也可以把helloWorld.xml放置到resources/hello/helloWorld.xml路径中，配置文件中参数配置如下：
<include file="hello/helloWorld.xml"></include>

//------------------------------------------------------------------------------------------------
4-6 默认Action

default-action-ref与*_*冲突：http://blog.sina.com.cn/s/blog_9772ef170101dczo.html

//这里下面不能配置*_*，否则会优先与*_*匹配，无法找到默认提供的action
//另外，default-action-ref、global-allowed-methods、action的先后顺序不能变，否则报编译错误
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <default-action-ref name="index"></default-action-ref>
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="index" class="struts.HelloAction" method="execute">
            <result>/error.jsp</result>
        </action>

        <action name="hello_*" method="{1}" class="struts.HelloAction">
            <result name = "success">/index.jsp</result>
            <result name = "add">/{1}.jsp</result>
            <result name = "update">/{1}.jsp</result>
        </action>
    </package>

</struts>

//error.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>ErrorPage</title>
</head>
<body>
Sorry, the page is not found!
</body>
</html>

输入：http://localhost:8080/struts/update.action
输出：Sorry, the page is not found!
//------------------------------------------------------------------------------------------------
4-7 Struts2后缀
//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--访问的后缀-->
    <constant name="struts.action.extension" value="html"/>
    <!--文件名 -->
    <include file="hello/helloWorld.xml"></include>

</struts>
输入：http://localhost:8080/struts/hello_update.html
输出：This is update.jsp

增加了后缀参数后，则浏览器访问时必须使用value定义的后缀，否则访问不到。（不能像之前默认一样不加.action后缀）
<constant name="struts.action.extension" value="html"/>

还可以将value值置为空，则可以不加后缀访问：
<constant name="struts.action.extension" value="html"/>
输入：http://localhost:8080/struts/hello_update

还可以配置用逗号分隔的多个后缀，则下例使用html、action或不加后缀都可以：
<constant name="struts.action.extension" value="html,action,"/>

有三个位置可以配置后缀：
struts.xml
struts.properties
web.xml

web.xml配置如下：
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>struts</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
        <init-param>
            <param-name>struts.action.extension</param-name>
            <param-value>html</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>struts</filter-name>
        <url-pattern>/*</url-pattern>  --*/
    </filter-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>
//------------------------------------------------------------------------------------------------
4-8 接收参数
1. 使用Action的属性接收参数
2. 使用Domain Model接收参数
3. 使用ModelDriven接收参数


1. 使用Action的属性接收参数
//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    <input type="submit" value="提交">
</form>
</body>
</html>

//success.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>LoginSuccessPage</title>
</head>
<body>
This is success.jsp after login.
</body>
</html>

//helloWorld.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <default-action-ref name="index"></default-action-ref>
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="index" class="struts.HelloAction" method="execute">
            <result>/error.jsp</result>
        </action>
        
        <action name="LoginAction" method="login" class="struts.LoginAction">
            <result>/success.jsp</result>
        </action>
    </package>

</struts>

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--访问的后缀-->
    <!--<constant name="struts.action.extension" value="html,action,"/>-->
    <!--文件名 -->
    <include file="hello/helloWorld.xml"></include>

</struts>

//LoginAction.java
package struts;

import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport {

    private String username;
    private String password;

    public String login() {
        System.out.println(String.format("Username: %s, password: %s", username, password));
        return SUCCESS;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

浏览器输入：http://localhost:8080/struts/login.jsp
会跳转到success.jsp：This is success.jsp after login.
控制台输出：
Username: 333, password: 444
Username: dingben, password: hello
说一下自己的理解：在这个界面中login.jsp，表单触发的action是LoginAction.action，此时会根据HelloWorld.xml中的LoginAction名称，调用到struts.LoginAction.login()方法中，再返回到success.jsp界面。

2. 使用Domain Model接收参数
//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="user.username"><!--这里的user指的是LoginAction的getter/setter方法名，如果方法名改为getUser2()/setUser2()，则这里name="user2.username"
    密码：<input type="password" name="user.password">
    <input type="submit" value="提交">
</form>
</body>
</html>

//User.java
package struts;

public class User {
    String username;
    String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

//LoginAction.java
package struts;

import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport {

    private User user;

    public String login() {
        System.out.println(String.format("User.username: %s, user.password: %s", user.getUsername(), user.getPassword()));
        return SUCCESS;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}

3. 使用ModelDriven接收参数（推荐使用这种方式）
//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    <input type="submit" value="提交">
</form>
</body>
</html>

//LoginAction.java 实现ModelDriven接口，去掉User的getter和setter方法，并提供user的初始化，再修改掉jsp中的user.
package struts;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

public class LoginAction extends ActionSupport implements ModelDriven<User> {

    private User user = new User();

    public String login() {
        System.out.println(String.format("User.username: %s, user.password: %s", user.getUsername(), user.getPassword()));
        return SUCCESS;
    }

    @Override
    public User getModel() {
        return user;
    }
}

另外，如果不提供setter和getter方法，只要把属性修改为public，也可以完成功能
//User.java
package struts;

public class User {
    public String username;
    public String password;
}

如果有复杂结构，如User中有List
//User.java
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    书籍1：<input type="text" name="bookList[0]">
    书籍2：<input type="text" name="bookList[1]">
    <input type="submit" value="提交">
</form>
</body>
</html>

//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    书籍1：<input type="text" name="bookList[0]">
    书籍2：<input type="text" name="bookList[1]">
    <input type="submit" value="提交">
</form>
</body>
</html>

输出：
User.username: 123, user.password: 456, user.bookList: [《雷雨》, 《背影》]

如果List的泛型是对象，也可以完成赋值：
//User.java
package struts;

import java.util.List;

public class User {
    private String username;
    private String password;
    private List<User> userList;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public List<User> getUserList() {
        return userList;
    }

    public void setUserList(List<User> userList) {
        this.userList = userList;
    }

    @Override
    public String toString() {
        return "User{" +
            "username='" + username + '\'' +
            '}';
    }
}

//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    子用户1：<input type="text" name="userList[0].username">
    子用户2：<input type="text" name="userList[1].username">
    <input type="submit" value="提交">
</form>
</body>
</html>

输出：User.username: 111, user.password: 222, user.userList: [User{username='333'}, User{username='444'}]

//------------------------------------------------------------------------------------------------
4-9 处理结果类型
<result name="success">/success.jsp</result>
result元素中的name就是result元素的逻辑视图名称。

<result>/success.jsp</result>
如果省略了name属性，系统将采用默认的name属性值，默认的name值是success。
路径前面是有一个斜杠/的，表示是项目的绝对路径，不带斜杠就是执行Action的相对路径（本地验证不带斜杠也可以正常展示）

com.opensymphony.xwork2.Action五个内置值：
SUCCESS = "success"; Action正确的执行完成，返回相应的视图，success是name属性的默认值；
NONE = "none"; 表示Action正确的执行完成，但并不返回任何视图；
ERROR = "error";表示Action执行失败，返回到错误处理视图；
LOGIN = "login";Action因为用户没有登录的原因没有正确执行，将返回该登录视图，要求用户进行登录验证；
INPUT = "input";Action的执行，需要从前端界面获取参数，INPUT就是代表这个参数输入的界面，一般在应用中，会对这些参数进行验证，如果验证没有通过，将自动返回到该视图。

//------------------------------------------------------------------------------------------------
4-10 关于input的代码演示 https://www.imooc.com/video/9004
//增加User.age属性
package struts;

import java.util.List;

public class User {
    private String username;
    private String password;
    private int age;
    private List<User> userList;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<User> getUserList() {
        return userList;
    }

    public void setUserList(List<User> userList) {
        this.userList = userList;
    }

    @Override
    public String toString() {
        return "User{" +
            "username='" + username + '\'' +
            '}';
    }
}

//login.jsp增加age框
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username">
    密码：<input type="password" name="password">
    年龄：<input type="text" name="age">
    子用户1：<input type="text" name="userList[0].username">
    子用户2：<input type="text" name="userList[1].username">
    <input type="submit" value="提交">
</form>
</body>
</html>

//helloWorld.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <default-action-ref name="index"></default-action-ref>
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="index" class="struts.HelloAction" method="execute">
            <result>/error.jsp</result>
        </action>

        <action name="LoginAction" method="login" class="struts.LoginAction">
            <result name="success">/success.jsp</result>
            <result name="input">/login.jsp</result>
        </action>
    </package>

</struts>

正常情况按视频演示，增加addFieldError时，会返回到input界面，但是本地测试，没有成功？？？
https://blog.csdn.net/u011726984/article/details/45150183


//参考https://blog.csdn.net/u011726984/article/details/45150183
//LoginAction-validation.xml要和LoginAction.java放在一起，但是关于age一定要是int输入，还是没有校验出来
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator 1.0.3//EN"
        "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<!-- 基于配置文件的表单验证
1,动作类中指定的方法进行验证:
    配置文件名：动作类名-动作名（配置文件中的动作名）-validation.xml，
如，UserAction-user_add-validation.xml

2,验证动作类中的所有方法:
    配置文件名：动作简单类名-validation.xml，如，UserAction-validation.xml
 -->
<validators>

    <validator type="requiredstring">
        <param name="fieldName">username</param>
        <message>用户名不能为空！</message>
    </validator>

    <field name="password">
        <field-validator type="requiredstring">
            <message>密码不能为空！</message>
        </field-validator>
        <field-validator type="regex">
            <param name="regex"><![CDATA[\w{6,16}]]></param>
            <message>密码可以为6~16位数字和字母的组合！</message>
        </field-validator>
    </field>
    
    <field name="age">
        <field-validator type="int">
            <message>年龄不能为空！</message>
        </field-validator>
    </field>
</validators>

//在代码中增加校验函数
//LoginAction.java
package struts;

import java.io.Serializable;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

public class LoginAction extends ActionSupport implements ModelDriven<User>, Serializable {

    private User user = new User();

    public String login() {
//        System.out.println("login()");
//        String username = user.getUsername();
//        if (null == username || username.isEmpty()) {
//            System.out.println("userName not exist");
//            addFieldError("username", "用户名不能为空");
//            return INPUT;//如果在这里配置，就必须增加return INPUT;
//        }

        System.out.println(String.format("User.username: %s, user.password: %s, user.userList: %s", user.getUsername(), user.getPassword(), user.getUserList()));
        return SUCCESS;
    }

    @Override
    public void validate() { //在这里校验，不用加return INPUT;
        System.out.println("validate()");

        if (user.getUsername() == null || "".equals(user.getUsername().trim())) {
            addFieldError("username", "用户名不能为空");
        }
        if (user.getPassword() == null || !user.getPassword().matches("\\w{6,16}")) {
            addFieldError("password", "密码不能为空且必须是6~16位的大小写字母或数字");
        }
    }

    @Override
    public User getModel() {
        return user;
    }
}

//login.jsp
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
<%@ taglib prefix="s" uri="/struts-tags" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<form action="LoginAction.action" method="post">
    用户名：<input type="text" name="username"><s:fielderror name="username"></s:fielderror>
    密码：<input type="password" name="password"><s:fielderror name="password"></s:fielderror>
    年龄：<input type="text" name="age">
    子用户1：<input type="text" name="userList[0].username">
    子用户2：<input type="text" name="userList[1].username">
    <input type="submit" value="提交">
</form>
</body>
</html>

//------------------------------------------------------------------------------------------------
4-11 处理结果类型
处理结果是通过在struts.xml使用<result/>标签配置结果。
根据位置的不同，分为两种结果：
局部结果：将<result/>作为<action/>元素的子元素配置
全局结果：将<result/>作为<global-result/>元素的子元素配置

<result name="...">
    <param name="location">resource</param>
</result>
子标签<param>具有两个属性：
1、 location：该属性定义了该视图对应的实际视图资源。
2、 parse：该参数指定是否可以在实际视图名字中使用OGNL表达式。struts2框架默认该属性为true，即支持OGNL表达式。OGNL：Object-Graph Navigation Language

示例：
//helloWorld.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <default-action-ref name="index"></default-action-ref>
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="index" class="struts.HelloAction" method="execute">
            <result>/error.jsp</result>
        </action>

        <action name="hello_*" method="{1}" class="struts.HelloAction">
            <result name = "success">/index.jsp</result>
            <result name = "add">
                <param name="location">/${#request.path}.jsp</param>
            </result>
            <result name = "update">/{1}.jsp</result>
        </action>
    </package>

</struts>

//HelloAction.java
package struts;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionSupport;

public class HelloAction extends ActionSupport {
    HttpServletRequest request = ServletActionContext.getRequest();

    public String execute() {
        request.setAttribute("hello", "execute()!");
        return SUCCESS;
    }

    public String hello() {
        request.setAttribute("hello", "hello world!");//增加属性，用于在jsp中使用
        return SUCCESS;
    }

    public String add() {
        request.setAttribute("path", "add");//增加属性，用于在xml中使用
        return "add";
    }

    public String update() {
        return "update";
    }
}

//------------------------------------------------------------------------------------------------
4-12 处理结果类型――type属性
<result name="success" type="XXX">/success.jsp</result>
type的默认值dispatcher，这个类型支持JSP视图技术。

struts支持多种视图技术，例如JSP、Valocity、FreeMarker等。

E:\Program Files\JetBrains\JavaProject\Maven\repository\org\apache\struts\struts2-core\2.5.16\struts2-core-2.5.16.jar!\struts-default.xml
<result-types>
    <result-type name="chain" class="com.opensymphony.xwork2.ActionChainResult"/>
    <result-type name="dispatcher" class="org.apache.struts2.result.ServletDispatcherResult" default="true"/>
    <result-type name="freemarker" class="org.apache.struts2.views.freemarker.FreemarkerResult"/>
    <result-type name="httpheader" class="org.apache.struts2.result.HttpHeaderResult"/>
    <result-type name="redirect" class="org.apache.struts2.result.ServletRedirectResult"/><!--重定向会丢失请求参数-->
    <result-type name="redirectAction" class="org.apache.struts2.result.ServletActionRedirectResult"/>
    <result-type name="stream" class="org.apache.struts2.result.StreamResult"/>
    <result-type name="velocity" class="org.apache.struts2.result.VelocityResult"/>
    <result-type name="xslt" class="org.apache.struts2.views.xslt.XSLTResult"/>
    <result-type name="plainText" class="org.apache.struts2.result.PlainTextResult" />
    <result-type name="postback" class="org.apache.struts2.result.PostbackResult" />
</result-types>

例如：
//helloWorld.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>
    <!--包名 -->
    <package name="front" namespace="/" extends="struts-default">
        <default-action-ref name="index"></default-action-ref>
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="index" class="struts.HelloAction" method="execute">
            <result>/error.jsp</result>
        </action>

        <action name="hello_*" method="{1}" class="struts.HelloAction">
            <result name = "success" type="plainText">/index.jsp</result><!--这里type使用plainText-->
            <result name = "add">
                <param name="location">/${#request.path}.jsp</param>
            </result>
            <result name = "update">/{1}.jsp</result>
        </action>
    </package>

</struts>

浏览器输入：http://localhost:8080/struts/hello
界面显示原始字符串：
<%--
  Created by IntelliJ IDEA.
  User: Ben
  Date: 2018/5/13
  Time: 20:02
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>DingBenTestPage</title>
</head>
<body>
this is a jsp page.
<br> ${hello}
</body>
</html>
//------------------------------------------------------------------------------------------------
2-1 Struts拦截器简介 https://www.imooc.com/video/8915
什么是拦截器
Struts大多数核心功能是通过拦截器实现的，每个拦截器完成某项功能。例如：数据转移、类型转换、数据校验。
拦截器方法在Action执行之前或者之后执行。

拦截器栈
--从结构上看，拦截器栈相当于多个拦截器的组合。
--在功能上看，拦截器栈也是拦截器。

拦截器的执行过程是一个递归的过程。
//------------------------------------------------------------------------------------------------
2-2 自定义拦截器
方式一：实现Interceptor接口
--void init(): 初始化拦截器所需资源
--void destroy(): 释放在init()中分配的资源
--String intercept(ActionInvocation ai) throws Exception
    --实现拦截器功能
    --利用ActionInvocation参数获取Action状态
    --返回result字符串作为逻辑视图

方式二：继承AbstractInterceptor类
--提供了init()和destroy()方法的空实现
--只需要实现intercept方法即可
//------------------------------------------------------------------------------------------------
3-2 拦截器示例
--创建拦截器
--在配置文件中定义拦截器并引用它

//index.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>计算执行Action花费的时间</title>
</head>
<body>
<a href="timer.action">访问Action并计算执行Action花费的时间</a>
</body>
</html>

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <!--注册拦截器-->
        <interceptors>
            <interceptor name="mytimer" class="interceptor.TimerInterceptor"></interceptor>
            <interceptor name="mytimer2" class="interceptor.TimerInterceptor2"></interceptor>
        </interceptors>
        <action name="timer" class="action.TimerAction" method="execute">
            <result>/success.jsp</result>
            <!--引用拦截器-->
            <interceptor-ref name="mytimer"></interceptor-ref>
            <interceptor-ref name="mytimer2"></interceptor-ref>
        </action>
    </package>

</struts>

//TimerAction.java
package action;

import com.opensymphony.xwork2.ActionSupport;

public class TimerAction extends ActionSupport {
    @Override
    public String execute() throws Exception {
        for (int i = 0; i < 10000; i++) {
            System.out.println("I love Java!");
        }
        return SUCCESS;
    }
}

//TimerInterceptor.java
package interceptor;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;

/*
 * 计算执行Action花费的时间
 */
public class TimerInterceptor extends AbstractInterceptor {
    //自动调用此方法，进行拦截操作
    @Override
    public String intercept(ActionInvocation invocation) throws Exception {
        //1. 执行Action之前
        long start = System.currentTimeMillis();
        //2. 执行下一个拦截器，如果已经是最后一个拦截器，则执行目标Action
        String result = invocation.invoke();
        //3. 执行Action之后
        long end = System.currentTimeMillis();
        System.out.println(String.format("TimerInterceptor：执行Action花费的时间：%s ms", end - start));
        return result;
    }
}

//TimerInterceptor2.java
package interceptor;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;

public class TimerInterceptor2 extends AbstractInterceptor {
    @Override
    public String intercept(ActionInvocation invocation) throws Exception {
        //1. 执行Action之前
        long start = System.currentTimeMillis();
        //2. 执行下一个拦截器，如果已经是最后一个拦截器，则执行目标Action
        String result = invocation.invoke();
        //3. 执行Action之后
        long end = System.currentTimeMillis();
        System.out.println(String.format("TimerInterceptor2：执行Action花费的时间：%s ms", end - start));
        return result;
    }
}

浏览器输入：http://localhost:8080/struts/
点击超链接后，输出：访问Action成功！
...
I love Java!
I love Java!
I love Java!
I love Java!
I love Java!
TimerInterceptor2：执行Action花费的时间：1186 ms
TimerInterceptor：执行Action花费的时间：1186 ms

//------------------------------------------------------------------------------------------------
4-2 Struts2内建拦截器
params拦截器
--负责将请求参数设置为Action属性

内建拦截器定义在包中：E:\Program Files\JetBrains\JavaProject\Maven\repository\org\apache\struts\struts2-core\2.5.16\struts2-core-2.5.16.jar!\struts-default.xml 的interceptors节点下
最后定义了一个默认的拦截器栈：<default-interceptor-ref name="defaultStack"/>

--只要在定义包的过程中继承struts-default包，那么defaultStack将是默认的拦截器。
<package name="default" namespace="/" extends="struts-default">
--当为包中的某个action显式指定了某个拦截器，则默认拦截器不会起作用。
--拦截器栈中的各个拦截器的顺序很重要。

//配置了自定义拦截器后，如果需要默认拦截器栈，需要手工引用
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="true"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <!--注册拦截器-->
        <interceptors>
            <interceptor name="mytimer" class="interceptor.TimerInterceptor"></interceptor>
            <interceptor name="mytimer2" class="interceptor.TimerInterceptor2"></interceptor>
        </interceptors>
        <action name="timer" class="action.TimerAction" method="execute">
            <result>/success.jsp</result>
            <!--为Action显示引用拦截器后，默认的拦截器栈将不再生效，需要手工引用-->
            <interceptor-ref name="defaultStack"></interceptor-ref>

            <!--引用拦截器-->
            <interceptor-ref name="mytimer"></interceptor-ref>
            <interceptor-ref name="mytimer2"></interceptor-ref>
        </action>
    </package>

</struts>
//------------------------------------------------------------------------------------------------
5-1 拦截器使用样例
登录后台管理界面时要求admin用户已经登录
//web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>struts</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>struts</filter-name>
        <url-pattern>/*</url-pattern> //*/
    </filter-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <!--注册拦截器-->
        <interceptors>
            <interceptor name="auth" class="interceptor.AuthInterceptor"></interceptor>
            <!--自定义拦截器栈myStack，组合了defaultStack和auth-->
            <interceptor-stack name="myStack">
                <interceptor-ref name="defaultStack"/>
                <interceptor-ref name="auth"/>
            </interceptor-stack>
        </interceptors>

        <!-- 通过此Action访问后台管理页面，需要判断用户是否已登陆，如果未登陆跳转到登陆页面-->
        <action name="auth">
            <result>/WEB-INF/page/manager.jsp</result>
            <result name="login">/login.jsp</result>
            <!--引用自定义的拦截器栈-->
            <interceptor-ref name="myStack"/>
        </action>

        <action name="login" class="action.LoginAction" method="login">
            <result>/WEB-INF/page/manager.jsp</result>
            <result name="error">/login.jsp</result>
        </action>
    </package>

</struts>

//index.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>StartPage</title>
</head>
Start page.
</body>
</html>

//login.jsp
<%--
  Created by IntelliJ IDEA.
  User: Ben
  Date: 2018/6/7
  Time: 0:18
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>LoginPage</title>
</head>
<body>
<h2>用户登陆</h2>
${loginError}
<form action="login.action" method="post">
    用户名：<input type="text" name="username"/><br/>
    密码：<input type="password" name="password"/><br/>
    <input type="submit" value="登陆"/>
</form>
</body>
</html>

//page/manager.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>ManagerPage</title>
</head>
<body>
后台管理页面，只有已登陆的用户才能访问！
</body>
</html>

//LoginAction.java
package action;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class LoginAction extends ActionSupport implements SessionAware {
    private String username;
    private String password;
    private Map<String, Object> session;

    @Override
    public void setSession(Map<String, Object> session) {
        this.session = session;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    //处理登陆请求
    public String login() {
        System.out.println(String.format("username = %s, password = %s", username, password));
        if (username == null) {
            return ERROR;
        }
        else if ("admin".equals(username) && "123".equals(password)) {
            session.put("loginInfo", username);
            return SUCCESS;
        } else {
            session.put("loginError", "用户名或密码不正确");
            return ERROR;
        }
    }
}

//AuthInterceptor.java
package interceptor;

import java.util.Map;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;

public class AuthInterceptor extends AbstractInterceptor {
    @Override
    public String intercept(ActionInvocation invocation) throws Exception {
        ActionContext context = ActionContext.getContext();
        Map<String, Object> session = context.getSession();
        if (session.get("loginInfo") != null) {
            return invocation.invoke();
        } else {
            return "login";
        }
    }
}

//------------------------------------------------------------------------------------------------
// 慕课网 使用Struts2+Hibernate开发学生管理系统 https://www.imooc.com/video/9026
2-1 用户登录模块
1. 项目分层
2. 创建MyHibernateSessionFactory
3. 设计用户接口和实现类
4. 设计所有Action父类
5. 设计用户Action类
6. 页面调用
7. 显示报错信息

--实体层
--数据库层
--接口层
--接口实现层
--动作层
--Jsp页面
体现了MVC模式，前4个是模型层（Model），第5个是控制层（Controller），第6个是视图层（View）

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/index.jsp</result>
        </action>
    </package>

</struts>

//log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5p] %d %c - %m%n" />
        </Console>
        <File name="File" fileName="dist/my.log">
            <PatternLayout pattern="%m%n" />
        </File>
    </Appenders>

    <Loggers>
        <Logger name="mh.sample2.Log4jTest2" level="INFO">
            <AppenderRef ref="File" />
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>

//hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!--  mysql账户名  -->
        <property name="connection.username">root</property>

        <!--  mysql密码  -->
        <property name="connection.password">root123</property>

        <!--  mysql驱动  -->
        <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

        <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为8.0.11，并且安装了MySQL的Connector：MySQL Connector/J-->
        <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

        <!--  数据库方言  -->
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

        <!--  显示sql语句  -->
        <property name="show_sql">true</property>

        <!--  格式化sql语句  -->
        <property name="format_sql">true</property>

        <!--<property name="hibernate.default_schema">hibernate</property>-->
        <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
        <property name="hbm2ddl.auto">update</property>

        <!--本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
        <property name="hibernate.current_session_context_class">thread</property>

        <mapping resource="entity/Students.hbm.xml"/>
        <mapping resource="entity/Users.hbm.xml"/>
    </session-factory>
</hibernate-configuration>

//生成实体类数据库表
//WebTest.java
package entity;

import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class WebTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        Configuration configuration = new Configuration().configure();//创建配置对象
        sessionFactory = configuration.buildSessionFactory();//创建会话工厂
        session = sessionFactory.getCurrentSession();//开启会话
        transaction = session.beginTransaction();//开启事务
    }

    @After
    public void destory() {
        transaction.commit();//事务提交
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }
}

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>webproject</groupId>
  <artifactId>webproject</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>entity</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>

    <!-- 添加mysql驱动依赖 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.11</version>
    </dependency>

    <!-- 添加hibernate依赖包 -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>5.2.6.Final</version>
    </dependency>

    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-core</artifactId>
      <version>2.5.16</version>
    </dependency>

    <dependency>
      <groupId>jstl</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>

    <!--<dependency>-->
      <!--<groupId>struts</groupId>-->
      <!--<artifactId>struts</artifactId>-->
      <!--<version>1.0-SNAPSHOT</version>-->
    <!--</dependency>-->

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.7</version>
    </dependency>

  </dependencies>

  <build>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.0.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.7.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.20.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>

//------------------------------------------------------------------------------------------------
2-2 数据库工厂类
//MyHibernateSessionFactory.java
package db;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

package db;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class MyHibernateSessionFactory {
    private static SessionFactory sessionFactory;//会话工厂属性

    //构造方法私有化，保证单例模式
    private MyHibernateSessionFactory() {
    }

    //公有的静态方法，获得会话工厂对象
    public static SessionFactory getSessionFactory() {
        if (sessionFactory == null) {
            Configuration config = new Configuration().configure();
            sessionFactory = config.buildSessionFactory();
        }
        return sessionFactory;
    }
}


//------------------------------------------------------------------------------------------------
2-3 设计用户接口和实现类
--用户业务逻辑接口
--用户业务逻辑实现类

//UsersDAO.java
package service;

import entity.Users;

//用户业务逻辑接口
public interface UsersDAO {
    //用户登录方法
    boolean usersLogin(Users user);
}

//UsersDAOImpl.java
package service.impl;

import db.MyHibernateSessionFactory;
import entity.Users;
import service.UsersDAO;

import java.util.List;

import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;

public class UsersDAOImpl implements UsersDAO {
    @Override
    public boolean usersLogin(Users user) {
        Transaction transaction;
        String hql;
        try {
            Session session = MyHibernateSessionFactory.getSessionFaction().getCurrentSession();
            transaction = session.beginTransaction();

            hql = "from Users where username=? and password=?";
            Query query = session.createQuery(hql);
            query.setParameter(0, user.getUsername());
            query.setParameter(1, user.getPassword());

            List list = query.list();
            transaction.commit();//提交事务
            return !list.isEmpty();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
//        finally {
//            if (transaction != null) {
//                //transaction.commit();//不能重复提交事务
//            }
//        }
    }
}

//UsersDAOImplTest.java
package service.impl;

import entity.Users;
import service.UsersDAO;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class UsersDAOImplTest {

    @Test
    public void testUsersLogin() {
        Users user = new Users(1, "zhangsan", "123456");
        UsersDAO usersDAO = new UsersDAOImpl();
        assertEquals(false, usersDAO.usersLogin(user)); //在数据库中插入了数据后，就可以正常获取到对象了，返回true
    }
}
//------------------------------------------------------------------------------------------------
2-4 设计所有Action父类
--设计action父类
--继承ActionSupport
--为了获得常用的内置对象采用耦合IOC方式注入属性
需要实现如下三个接口：ServletRequestAware/ServletResponseAware/ServletContextAware

//SuperAction.java
package action;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.struts2.interceptor.ServletRequestAware;
import org.apache.struts2.interceptor.ServletResponseAware;
import org.apache.struts2.util.ServletContextAware;

import com.opensymphony.xwork2.ActionSupport;

//所有Action动作的父类
public class SuperAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware {

    private static final long serialVersionUID = 5110053493783737838L;
    protected HttpServletRequest request;//请求对象
    protected HttpServletResponse response;//响应对象
    protected HttpSession session;//会话对象
    protected ServletContext application;//全局对象

    @Override
    public void setServletRequest(HttpServletRequest request) {
        this.request = request;
        this.session = this.request.getSession();
    }

    @Override
    public void setServletResponse(HttpServletResponse response) {
        this.response = response;
    }

    @Override
    public void setServletContext(ServletContext application) {
        this.application = application;
    }
}

//------------------------------------------------------------------------------------------------
2-5 设计用户Action类
--设计用户Action类，采用模型驱动接收表单数据。 
struts接收表单数据的方式：普通属性、领域对象、模型驱动。
//UsersAction.java
package action;

import entity.Users;
import service.UsersDAO;
import service.impl.UsersDAOImpl;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.ModelDriven;

public class UsersAction extends SuperAction implements ModelDriven<Users> {

    private static final long serialVersionUID = 1171517276988253426L;
    private Users user = new Users();

    //用户登录动作
    public String login() {
        UsersDAO usersDAO = new UsersDAOImpl();
        if (usersDAO.usersLogin(user)) {
            //在session中保存登录成功的用户名
            session.setAttribute("loginUserName", user.getUsername()); //对应JSP中的EL表达式
            return "login_success";
        } else {
            return "login_failure";
        }
    }

    //用户注销方法，用@SkipValidation可以跳过表单验证，即validation方法
    @SkipValidation
    public String logout() {
        if (session.getAttribute("loginUserName") != null) {
            session.removeAttribute("loginUserName");
        }
        return "logout_success";
    }

    //当校验失败的时候，validate函数默认返回INPUT，即"input"，所以必须要定义result name="input"的jsp页面
    @Override
    public void validate() {
        String username = user.getUsername();
        //用户名不能为空
        if (username == null || username.trim().isEmpty()) {
            this.addFieldError("usernameError", "用户名不能为空");
        }
        String password = user.getPassword();
        if (password == null || password.length() < 6) {
            this.addFieldError("passwordError", "密码长度不少于6位");
        }
    }

    @Override
    public Users getModel() {
        return this.user;
    }
}


//------------------------------------------------------------------------------------------------
2-6 页面调用 

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/hello.jsp</result>
        </action>
    </package>

    <package name="users" namespace="/users" extends="default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" class="action.{1}Action" method="{2}">
            <result name="login_success">/users/Users_login_success.jsp</result>
            <result name="login_failure">/users/Users_login.jsp</result>
            <result name="logout_success">/users/Users_login.jsp</result>
            <result name="input">/users/Users_login.jsp</result>
        </action>
    </package>
    
    <!--type="chain"表示执行链式操作，不是直接显示一个jsp，而是执行下一个action-->
    <package name="students" namespace="/students" extends="default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" class="action.{1}Action" method="{2}">
            <result name="query_success">/students/Students_query_success.jsp</result>
            <result name="delete_success" type="chain">Students_query</result>
        </action>
    </package>
</struts>
//------------------------------------------------------------------------------------------------
2-7 完成显示登录成功用户名和注销功能
参见2-5 节
//------------------------------------------------------------------------------------------------
2-8 完成表单验证功能

//------------------------------------------------------------------------------------------------
3-1 学生管理模块 https://www.imooc.com/video/9036
1. 显示学生资料
--添加测试数据
--设计学生业务逻辑接口
--设计学生业务逻辑接口实现类
--设计学生Action类
--页面调用
--显示数据

2. 删除学生资料
3. 学生主键生成策略
4. 添加学生资料
5. 修改学生资料

//添加测试数据
package entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class WebTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        Configuration configuration = new Configuration().configure();//创建配置对象
        sessionFactory = configuration.buildSessionFactory();//创建会话工厂
        session = sessionFactory.getCurrentSession();//开启会话
        transaction = session.beginTransaction();//开启事务
    }

    @After
    public void destory() {
        transaction.commit();//事务提交
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Students students1 = new Students("S0000001", "张三丰", "男", new Date(), "武当山");
        Students students3 = new Students("S0000003", "郭靖", "男", new Date(), "桃花岛");
        Students students2 = new Students("S0000002", "黄蓉", "女", new Date(), "桃花岛");

        session.save(students1);
        session.save(students2);
        session.save(students3);
    }
}
//------------------------------------------------------------------------------------------------
3-2 显示学生资料-设计学生业务逻辑接口

//StudentDAO.java
package service;

import entity.Students;

import java.util.List;

//学生的业务逻辑接口
public interface StudentsDAO {
    //查询所有学生资料
    List<Students> queryAllStudents();

    //根据学生编号查询学生资料
    Students queryStudentsBySid(String sid);

    //添加学生资料
    boolean addStudents(Students students);

    //修改学生资料
    boolean updateStudents(Students students);

    //删除学生资料
    boolean deleteStudents(String sid);
}

//------------------------------------------------------------------------------------------------
3-3 显示学生资料-实现显示学生资料业务逻辑

//StudentsDAOImpl.java
package service.impl;

import db.MyHibernateSessionFactory;
import entity.Students;
import service.StudentsDAO;

import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;

//学生业务逻辑接口的实现类
public class StudentsDAOImpl implements StudentsDAO {
    @Override
    public List<Students> queryAllStudents() {
        Transaction transaction;
        List<Students> studentsList = null;
        String hql;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();

            hql = "from Students";
            Query query = session.createQuery(hql);

            studentsList = query.list();
            transaction.commit();
            return studentsList;
        } catch (Exception e) {
            e.printStackTrace();
            return studentsList;
        }
    }

    @Override
    public Students queryStudentsBySid(String sid) {
        return null;
    }

    @Override
    public boolean addStudents(Students students) {
        students.setSid(getNewSid());
        Transaction transaction;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            session.save(students);
            transaction.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public boolean updateStudents(Students students) {
        return false;
    }

    @Override
    public boolean deleteStudents(String sid) {
        try {
            Transaction transaction;
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            Students s = session.get(Students.class, sid);
            session.delete(s);
            transaction.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    //生成学生的学号
    private String getNewSid() {
        Transaction transaction;
        String hql;
        String sid;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            //获得当前学生的最大编号
            hql = "select max(sid) from Students";
            Query query = session.createQuery(hql);
            sid = (String) query.uniqueResult();
            transaction.commit();

            if (StringUtils.isEmpty(sid)) {
                //给一个默认的最大编号
                sid = "S0000001";
            } else {
                String temp = sid.substring(1);//取后七位
                int i = Integer.parseInt(temp);//转成数字
                ++i;
                //再还原成字符串
                temp = String.valueOf(i);
                int len = temp.length();
                for (int j = 0; j < 7 - len; j++) {
                    temp = "0" + temp;
                }
                sid = "S" + temp;
            }
            return sid;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

//StudentsDAOImplTest.java
package service.impl;

import entity.Students;
import service.StudentsDAO;

import java.util.List;

import org.junit.Test;

public class StudentsDAOImplTest {
    @Test
    public void testQueryAllStudents() {
        StudentsDAO studentDAO = new StudentsDAOImpl();
        List<Students> studentsList = studentDAO.queryAllStudents();
        studentsList.forEach(System.out::println);
    }

    @Test
    public void testGetNewSid() {
        StudentsDAOImpl studentDAO = new StudentsDAOImpl();
        System.out.println(studentDAO.getNewSid());
    }
    
    @Test
    public void testAddStudents() {
        Students s = new Students();
        s.setSname("张三丰");
        s.setGender("男");
        s.setBirthday(new Date());
        s.setAddress("武当山");
        StudentsDAO studentsDAO = new StudentsDAOImpl();
        assertEquals(true, studentsDAO.addStudents(s));
    }
}
输出：
Students{sid='S0000001', sname='张三丰', gender='男', birthday=2018-06-13, address='武当山'}
Students{sid='S0000002', sname='黄蓉', gender='女', birthday=2018-06-13, address='桃花岛'}
Students{sid='S0000003', sname='郭靖', gender='男', birthday=2018-06-13, address='桃花岛'}
//------------------------------------------------------------------------------------------------
3-5 显示学生资料-页面调用与数据展现

//StudentsAction.java
package action;

import entity.Students;
import service.StudentDAO;
import service.impl.StudentDAOImpl;

import java.util.List;

public class StudentsAction extends SuperAction {

    private static final long serialVersionUID = 7524786985348374469L;

    //查询所有学生的动作
    public String query() {
        StudentDAO studentDAO = new StudentDAOImpl();
        List<Students> studentsList = studentDAO.queryAllStudents();
        //放进session中
        // if (studentsList != null && !studentsList.isEmpty()) {
        //即使studentsList为空，也要设置进session中，否则当数据库中没有students时，无法刷新列表
        if (studentsList != null) {
            session.setAttribute("students_list", studentsList);
        }
        return "query_success";
    }
    
    //删除学生动作
    public String delete() {
        StudentDAO studentDAO = new StudentDAOImpl();
        String sid = request.getParameter("sid");
        studentDAO.deleteStudents(sid);//调用删除方法
        return "delete_success";
    }
}

//------------------------------------------------------------------------------------------------
3-6 删除学生资料
--界面调用
--编写业务逻辑代码
--编写删除action
--测试

//------------------------------------------------------------------------------------------------
3-7 添加学生资料
--界面原型演示
--编写添加学生业务逻辑代码
--编写添加action
--页面调用
//------------------------------------------------------------------------------------------------
3-8 添加学生资料
--学生的主键生成策略
--编写添加学生业务逻辑代码

//------------------------------------------------------------------------------------------------
3-9 添加学生资料――实现添加学生资料业务逻辑
参见 service.impl.StudentsDAOImpl#addStudents

//------------------------------------------------------------------------------------------------
3-10 修改学生资料
--界面原型演示
--编写修改学生业务逻辑代码
--编写修改action

//------------------------------------------------------------------------------------------------
3-11 修改学生资料
--编写修改学生业务逻辑代码
--页面显示学生资料
--保存修改后的学生资料

//--完整代码
//SuperAction.java
package action;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.struts2.interceptor.ServletRequestAware;
import org.apache.struts2.interceptor.ServletResponseAware;
import org.apache.struts2.util.ServletContextAware;

import com.opensymphony.xwork2.ActionSupport;

//所有Action动作的父类
public class SuperAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware {

    private static final long serialVersionUID = 5110053493783737838L;
    protected HttpServletRequest request;//请求对象
    protected HttpServletResponse response;//响应对象
    protected HttpSession session;//会话对象
    protected ServletContext application;//全局对象

    @Override
    public void setServletRequest(HttpServletRequest request) {
        this.request = request;
        this.session = this.request.getSession();
    }

    @Override
    public void setServletResponse(HttpServletResponse response) {
        this.response = response;
    }

    @Override
    public void setServletContext(ServletContext application) {
        this.application = application;
    }
}


//StudentsAction.java
package action;

import entity.Students;
import service.StudentsDAO;
import service.impl.StudentsDAOImpl;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

public class StudentsAction extends SuperAction {

    private static final long serialVersionUID = 7524786985348374469L;

    //查询所有学生的动作
    public String query() {
        StudentsDAO studentDAO = new StudentsDAOImpl();
        List<Students> studentsList = studentDAO.queryAllStudents();
        //放进session中
        if (studentsList != null) {
            session.setAttribute("students_list", studentsList);
        }
        return "query_success";
    }

    //删除学生动作
    public String delete() {
        StudentsDAO studentDAO = new StudentsDAOImpl();
        String sid = request.getParameter("sid");
        studentDAO.deleteStudents(sid);//调用删除方法
        return "delete_success";
    }

    //添加学生动作
    public String add() throws Exception {
        Students students = new Students();
        students.setSname(request.getParameter("sname"));
        students.setGender(request.getParameter("gender"));

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        //方法1，设置时间为标准时间
        simpleDateFormat.setTimeZone(TimeZone.getTimeZone("GMT+00"));
        Date birthday = simpleDateFormat.parse(request.getParameter("birthday"));
        students.setBirthday(birthday);

        //方法2，手工给时间加8小时，变成标准时间
//        Calendar c = Calendar.getInstance();
//        c.setTime(birthday);
//        c.add(Calendar.HOUR, 8);//东8区，比标准时间慢8个小时，需要加8个小时，才是标准时间的日期
//        students.setBirthday(c.getTime());

        students.setAddress(request.getParameter("address"));
        StudentsDAO studentsDAO = new StudentsDAOImpl();
        studentsDAO.addStudents(students);
        return "add_success";
    }

    //修改学生资料动作
    public String modify() {
        //获得传递过来的学生编号
        String sid = request.getParameter("sid");
        StudentsDAO studentsDAO = new StudentsDAOImpl();
        Students students = studentsDAO.queryStudentsBySid(sid);
        //保存在会话中
        session.setAttribute("modify_students", students);
        return "modify_success";
    }

    //保存修改后的学生资料动作
    public String save() throws ParseException {
        Students students = new Students();
        students.setSid(request.getParameter("sid"));
        students.setSname(request.getParameter("sname"));
        students.setGender(request.getParameter("gender"));

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
        simpleDateFormat.setTimeZone(TimeZone.getTimeZone("GMT+00"));
        students.setBirthday(simpleDateFormat.parse(request.getParameter("birthday")));
        students.setAddress(request.getParameter("address"));
        StudentsDAO studentsDAO = new StudentsDAOImpl();
        studentsDAO.updateStudents(students);
        return "save_success";
    }
}

//UsersAction.java
package action;

import entity.Users;
import service.UsersDAO;
import service.impl.UsersDAOImpl;

import org.apache.struts2.interceptor.validation.SkipValidation;

import com.opensymphony.xwork2.ModelDriven;

public class UsersAction extends SuperAction implements ModelDriven<Users> {

    private static final long serialVersionUID = 1171517276988253426L;
    private Users user = new Users();

    //用户登录动作
    public String login() {
//        System.out.println(request.getParameter("username"));//表单中的name和password值，可以通过request.getParameter获取，而name和password又构成了user对象
//        System.out.println(request.getParameter("password"));

        UsersDAO usersDAO = new UsersDAOImpl();
        if (usersDAO.usersLogin(user)) {
            //在session中保存登录成功的用户名
            session.setAttribute("loginUserName", user.getUsername()); //对应JSP中的EL表达式
            return "login_success";
        } else {
            return "login_failure";
        }
    }

    //用户注销方法，用@SkipValidation可以跳过表单验证，即validation方法
    @SkipValidation
    public String logout() {
        if (session.getAttribute("loginUserName") != null) {
            session.removeAttribute("loginUserName");
        }
        return "logout_success";
    }

    @Override
    public void validate() {
        String username = user.getUsername();
        //用户名不能为空
        if (username == null || username.trim().isEmpty()) {
            this.addFieldError("usernameError", "用户名不能为空");
        }
        String password = user.getPassword();
        if (password == null || password.length() < 6) {
            this.addFieldError("passwordError", "密码长度不少于6位");
        }
    }

    @Override
    public Users getModel() {
        return this.user;
    }
}

//MyHibernateSessionFactory.java
package db;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class MyHibernateSessionFactory {
    private static SessionFactory sessionFactory;//会话工厂属性

    //构造方法私有化，保证单例模式
    private MyHibernateSessionFactory() {
    }

    //公有的静态方法，获得会话工厂对象
    public static SessionFactory getSessionFactory() {
        if (sessionFactory == null) {
            Configuration config = new Configuration().configure();
            sessionFactory = config.buildSessionFactory();
        }
        return sessionFactory;
    }
}

//Students.java
package entity;

import java.util.Date;

public class Students {
    private String sid;//学号
    private String sname;
    private String gender;
    private Date birthday;
    private String address;

    public Students() {
    }

    public Students(String sid, String sname, String gender, Date birthday, String address) {
        this.sid = sid;
        this.sname = sname;
        this.gender = gender;
        this.birthday = birthday;
        this.address = address;
    }

    public String getSid() {
        return sid;
    }

    public void setSid(String sid) {
        this.sid = sid;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Students{" +
            "sid='" + sid + '\'' +
            ", sname='" + sname + '\'' +
            ", gender='" + gender + '\'' +
            ", birthday=" + birthday +
            ", address='" + address + '\'' +
            '}';
    }
}

//Students.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>

    <class name="entity.Students" table="t_students" schema="hibernate">
        <id name="sid" type="java.lang.String" length="8">
            <generator class="assigned"/>
        </id>
        <property name="sname" type="java.lang.String"/>
        <property name="gender" type="java.lang.String"/>
        <property name="birthday" type="date"/>
        <property name="address" type="java.lang.String"/>
    </class>
</hibernate-mapping>


//Users.java
package entity;

public class Users {
    private int uid;
    private String username;
    private String password;

    public Users() {
    }

    public Users(int uid, String username, String password) {
        this.uid = uid;
        this.username = username;
        this.password = password;
    }

    public int getUid() {
        return uid;
    }

    public void setUid(int uid) {
        this.uid = uid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

//Users.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>

    <class name="entity.Users" table="t_users" schema="hibernate">
        <id name="uid" type="int" column="uid">
            <generator class="native"/>
        </id>
        <property name="username" type="java.lang.String" column="username"/>
        <property name="password" type="java.lang.String" column="password"/>
    </class>
</hibernate-mapping>


//UsersDAO.java
package service;

import entity.Users;

//用户业务逻辑接口
public interface UsersDAO {
    //用户登录方法
    boolean usersLogin(Users user);
}

//UsersDAOImpl.java
package service.impl;

import db.MyHibernateSessionFactory;
import entity.Users;
import service.UsersDAO;

import java.util.List;

import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;

public class UsersDAOImpl implements UsersDAO {
    @Override
    public boolean usersLogin(Users user) {
        Transaction transaction;
        String hql;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();

            hql = "from Users where username=? and password=?";
            Query query = session.createQuery(hql);
            query.setParameter(0, user.getUsername());
            query.setParameter(1, user.getPassword());

            List list = query.list();
            transaction.commit();//提交事务
            return !list.isEmpty();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
//        finally {
//            if (transaction != null) {
//                //transaction.commit();//不能重复提交事务
//            }
//        }
    }
}

//StudentsDAO.java
package service;

import entity.Students;

import java.util.List;

//学生的业务逻辑接口
public interface StudentsDAO {
    //查询所有学生资料
    List<Students> queryAllStudents();

    //根据学生编号查询学生资料
    Students queryStudentsBySid(String sid);

    //添加学生资料
    boolean addStudents(Students students);

    //修改学生资料
    boolean updateStudents(Students students);

    //删除学生资料
    boolean deleteStudents(String sid);
}

//StudentsDAOImpl.java
package service.impl;

import db.MyHibernateSessionFactory;
import entity.Students;
import service.StudentsDAO;

import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;

//学生业务逻辑接口的实现类
public class StudentsDAOImpl implements StudentsDAO {
    @Override
    public List<Students> queryAllStudents() {
        Transaction transaction;
        List<Students> studentsList = null;
        String hql;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();

            hql = "from Students";
            Query query = session.createQuery(hql);

            studentsList = query.list();
            transaction.commit();
            return studentsList;
        } catch (Exception e) {
            e.printStackTrace();
            return studentsList;
        }
    }

    @Override
    public Students queryStudentsBySid(String sid) {
        Transaction transaction;
        Students students = null;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            students = session.get(Students.class, sid);
            transaction.commit();
            return students;
        } catch (Exception e) {
            e.printStackTrace();
            return students;
        }
    }

    @Override
    public boolean addStudents(Students students) {
        students.setSid(getNewSid());
        Transaction transaction;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            session.save(students);
            transaction.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public boolean updateStudents(Students students) {
        Transaction transaction;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            session.update(students);
            transaction.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public boolean deleteStudents(String sid) {
        try {
            Transaction transaction;
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            Students s = session.get(Students.class, sid);
            session.delete(s);
            transaction.commit();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    //生成学生的学号
    private String getNewSid() {
        Transaction transaction;
        String hql;
        String sid;
        try {
            Session session = MyHibernateSessionFactory.getSessionFactory().getCurrentSession();
            transaction = session.beginTransaction();
            //获得当前学生的最大编号
            hql = "select max(sid) from Students";
            Query query = session.createQuery(hql);
            sid = (String) query.uniqueResult();
            transaction.commit();

            if (StringUtils.isEmpty(sid)) {
                //给一个默认的最大编号
                sid = "S0000001";
            } else {
                String temp = sid.substring(1);//取后七位
                int i = Integer.parseInt(temp);//转成数字
                ++i;
                //再还原成字符串
                temp = String.valueOf(i);
                int len = temp.length();
                for (int j = 0; j < 7 - len; j++) {
                    temp = "0" + temp;
                }
                sid = "S" + temp;
            }
            return sid;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

//hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!--  mysql账户名  -->
        <property name="connection.username">root</property>

        <!--  mysql密码  -->
        <property name="connection.password">root123</property>

        <!--  mysql驱动  -->
        <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

        <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为8.0.11，并且安装了MySQL的Connector：MySQL Connector/J-->
        <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

        <!--  数据库方言  -->
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

        <!--  显示sql语句  -->
        <property name="show_sql">true</property>

        <!--  格式化sql语句  -->
        <property name="format_sql">true</property>

        <!--<property name="hibernate.default_schema">hibernate</property>-->
        <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
        <property name="hbm2ddl.auto">update</property>

        <!--本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
        <property name="hibernate.current_session_context_class">thread</property>

        <mapping resource="entity/Students.hbm.xml"/>
        <mapping resource="entity/Users.hbm.xml"/>
    </session-factory>
</hibernate-configuration>

//log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5p] %d %c - %m%n" />
        </Console>
        <File name="File" fileName="dist/my.log">
            <PatternLayout pattern="%m%n" />
        </File>
    </Appenders>

    <Loggers>
        <Logger name="mh.sample2.Log4jTest2" level="INFO">
            <AppenderRef ref="File" />
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/hello.jsp</result>
        </action>
    </package>

    <package name="users" namespace="/users" extends="default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" class="action.{1}Action" method="{2}">
            <result name="login_success">/users/Users_login_success.jsp</result>
            <result name="login_failure">/users/Users_login.jsp</result>
            <result name="logout_success">/users/Users_login.jsp</result>
            <result name="input">/users/Users_login.jsp</result>
        </action>
    </package>

    <package name="students" namespace="/students" extends="default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="*_*" class="action.{1}Action" method="{2}">
            <result name="query_success">/students/Students_query_success.jsp</result>
            <result name="add_success">/students/Students_add_success.jsp</result>
            <result name="save_success">/students/Students_modify_success.jsp</result>
            <result name="modify_success">/students/Students_modify.jsp</result>
            <result name="delete_success" type="chain">Students_query</result>
        </action>
    </package>
</struts>

//WebTest.java
package entity;

import java.util.Date;
import java.util.EnumSet;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;
import org.hibernate.service.ServiceRegistry;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.schema.TargetType;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class WebTest {
    private SessionFactory sessionFactory;
    private Session session;
    private Transaction transaction;

    @Before
    public void init() {
        Configuration configuration = new Configuration().configure();//创建配置对象
        sessionFactory = configuration.buildSessionFactory();//创建会话工厂
        session = sessionFactory.getCurrentSession();//开启会话
        transaction = session.beginTransaction();//开启事务
    }

    @After
    public void destory() {
        transaction.commit();//事务提交
        sessionFactory.close();//关闭会话工厂
    }

    @Test
    public void testSchemaExport() {
        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure().build();//这里的configure()会调用hibernate.cfg.xml的配置资源文件
        Metadata metadata = new MetadataSources(serviceRegistry).buildMetadata();
        SchemaExport export = new SchemaExport();
        export.create(EnumSet.of(TargetType.DATABASE), metadata);
    }

    @Test
    public void testSaveStudent() {
        Students students1 = new Students("S0000001", "张三丰", "男", new Date(), "武当山");
        Students students3 = new Students("S0000003", "郭靖", "男", new Date(), "桃花岛");
        Students students2 = new Students("S0000002", "黄蓉", "女", new Date(), "桃花岛");

        session.save(students1);
        session.save(students2);
        session.save(students3);
    }
}

//StudentsDAOImplTest.java
package service.impl;

import entity.Students;
import service.StudentsDAO;

import java.util.Date;
import java.util.List;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class StudentsDAOImplTest {
    @Test
    public void testQueryAllStudents() {
        StudentsDAO studentDAO = new StudentsDAOImpl();
        List<Students> studentsList = studentDAO.queryAllStudents();
        studentsList.forEach(System.out::println);
    }

    @Test
    public void testGetNewSid() {
        StudentsDAOImpl studentDAO = new StudentsDAOImpl();
//        System.out.println(studentDAO.getNewSid());
    }

    @Test
    public void testAddStudents() {
        Students s = new Students();
        s.setSname("张三丰");
        s.setGender("男");
        s.setBirthday(new Date());
        s.setAddress("武当山");
        StudentsDAO studentsDAO = new StudentsDAOImpl();
        assertEquals(true, studentsDAO.addStudents(s));
    }
}

//UsersDAOImplTest.java
package service.impl;

import entity.Users;
import service.UsersDAO;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class UsersDAOImplTest {

    @Test
    public void testUsersLogin() {
        Users user = new Users(1, "zhangsan", "123456");
        UsersDAO usersDAO = new UsersDAOImpl();
        assertEquals(false, usersDAO.usersLogin(user));
    }
}

//index.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8"%>
<%
  String path = request.getContextPath();
  String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
  response.sendRedirect(path+"/users/Users_login.jsp");
%>

//tree.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
<head>
    <title>导航树</title>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <style type="text/css">@import url('components/dtree/dtree.css');</style>
    <script type="text/javascript">var dtreeIconBasePath = "components/dtree";</script>
    <script type="text/javascript"  src="components/dtree/dtree.js"></script>
</head>
<body>
<script type="text/javascript">
<%--学生管理列表的link写如下的绝对路径也可以：<%=path%>/students/Students_query.action--%>
var treeMenu = [
    { level:1, name:"学生管理"},
    { level:2, name:"学生列表", ico:"images/icon_default.gif",link:"students/Students_query.action"},
    { level:1, name:"教师管理"},
    { level:2, name:"教师列表", ico:"images/icon_default.gif",link:"role_list.html"},
    { level:1, name:"信息管理"},
    { level:2, name:"新闻管理", ico:"images/icon_default.gif",link:"news_list.html"},
    { level:2, name:"公告管理", ico:"images/icon_default.gif",link:"bulletin_list.html"},
    { level:1, name:"系统邮件", ico:"images/icon_default.gif"},
    { level:1, name:"网络文件", ico:"images/icon_default.gif",link:"complaint_list.html"}
];
</script>
<style>
* {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#menuControll{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0 10px;
    font-size:14px;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
</style>
<div id="menuControll">
菜单控制:【<a href="#" onclick="tree.openAll();this.blur();return false;" style="color:#333333;text-decoration:none">展开</a>】
【<a href="#" onclick="tree.closeAll();this.blur();return false;" style="color:#333333;text-decoration:none">折叠</a>】
</div>
<div class="dtree" style="margin:10px;">
<script type="text/javascript"> 
//建立新树
tree = new dTree('tree');
tree.config.target = "MainFrame";
tree.config.useCookies = false;
var selNum = -1;
var link = "";
//根目录
tree.add(0,-1,'管理中心', null, null, null, '', '');
var count = 0;
var pLevelIdArray = new Array();
pLevelIdArray[1] = 0;
var currLevel = 1;
for (var i=0; i<treeMenu.length; i++) {
    var item = treeMenu[i];
    var itemLevel = item.level;
    pLevelIdArray[itemLevel+1] = ++count;
    if (item.link!=null && item.link!="") {
        if (item.ico!=null) {
            tree.add(count, pLevelIdArray[itemLevel], item.name, item.link, null, null, item.ico, item.ico);
        } else {
            tree.add(count, pLevelIdArray[itemLevel], item.name, item.link);
        }
    } else {
        if (item.ico!=null) {
            tree.add(count, pLevelIdArray[itemLevel], item.name, null, null, null, item.ico, item.ico);
        } else {
            tree.add(count, pLevelIdArray[itemLevel], item.name);
        }
    }
    if (item.select) {
        selNum = count;
        link = item.link;
    }
}
document.write(tree);
tree.openAll();
if (selNum != -1) {
    tree.openTo(selNum,true);
    top.document.frames["MainFrame"].location.href=link;
}
</script>
</div>
</body>
</html>

//Users_login.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%@ taglib prefix="s" uri="/struts-tags"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!-- 这是一个html5 doctype声明 -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>用户登录</title>
    
</head>
<style type="text/css">
body{
    margin:0px;
    padding:0px;
    overflow:hidden;
}
#wrapper{
    position:absolute;
    width:100%;
    height:100%;
    min-width:1280px;
    min-height:680px;
    overflow-x:hidden;
    overflow-y:hidden;
    background-image: -moz-linear-gradient(top,#77D1F6, #2F368F);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #77D1F6),color-stop(1, #2F368F));
}
#header{
    height:100px;
    width:100%;
}
#logo{
    position:absolute;
    float:left;
    margin-left:5%;
    margin-top:30px;
    height:40px;
    width:160px;
    text-align:center;
}
#heading{
    position:relative;
    float:left;
    margin-left:20%;
    margin-top:-18px;
    height:110px;
    width:60%;
    border-radius: 18px;
    background-color:#1C75BC;
    opacity:0.6;
}
#heading #title{
    margin-top:40px;
    text-align:center;
    font-family:微软雅黑;
    font-size:24px;
    font-weight:bold;
}
#heading #subTitle{
    margin-top:10px;
    text-align:center;
    font-family:Courier New;
}
#main{
    margin-top:20px;
    height:500px;
    width:100%;
}
#mainBg{
    position:relative;
    float:left;
    margin-left:20%;
    margin-top:0px;
    height:500px;
    width:60%;
    border-radius: 18px;
    background-color:#000000;
    opacity:0.5;
}
#mainPanel{
    position:relative;
    margin:25px;
    height:450px;
    border-radius: 18px;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainPanel #left{
    float:left;
    border-right:2px solid #F6F6F6;
    position:relative;
    top:10%;
    height:80%;
    width:49%;
    border-right-style:groove;
}
#mainPanel #image{
    position:relative;
    height:256px;
    width:256px;
    left:15%;
    top:12%;
    background-image:url('../images/admin.png');
}
#mainPanel #right{
    float:left;
    position:relative;
    height:90%;
    width:49%;
    top:5%;
}
#welcome{
    margin-top:20px;
    height:60px;
    width:100%;
    vertical-align: middle;
    display: inline-block;
    line-height: 60px;
    text-align:center;
}
#welcome #welcome-text{
    font-size:38px;
    font-weight:bold;
    font-family:微软雅黑;
    text-shadow: 0 1px 1px #F6F6F6;
}
#user-name{
    height:35px;
    width:100%;
    margin-top:20px;
    vertical-align: middle;
    display: inline-block;
    line-height: 35px;
}
#user-password{
    margin-top:20px;
    height:35px;
    width:100%;
    vertical-align: middle;
    display: inline-block;
    line-height: 35px;
}
#user-checkcode{
    margin-top:20px;
    height:35px;
    width:100%;
    vertical-align: middle;
    display: inline-block;
    line-height: 35px;
}
#button-group{
    margin-top:10px;
    height:35px;
    width:100%;
    vertical-align: middle;
    display: inline-block;
    line-height: 35px;
    text-align:center;
}
#error-tip{
    margin-top:20px;
    margin-left:5%;
    height:40px;
    width:90%;
    vertical-align: middle;
    display: inline-block;
    line-height: 35px;
    text-align:center;
    border-bottom:2px solid #F6F6F6;
    border-bottom-style:groove;
}
#error-tip #tip-text{
    font-size:18px;
    font-weight:bold;
    font-family:微软雅黑;
    color:red;
}
.item{
    margin-left:20px;
    font-family:微软雅黑;
    font-size:20px;
    font-weight:bold;
    float: left;
    width:80px;
    margin-top: 3px;
    text-align: center;
    text-shadow: 0 1px 1px #F6F6F6;
}
.input{
    vertical-align: middle;
    display: inline-block;
}
#checkcode-img{
    margin-top:3px;
    height:20px;
    width:60px;
}
.form-input{
    height:20px;
}
.btn{
    border:1px solid #cccccc;
    cursor:pointer;
    margin:10px 5px;
    height:40px;
    width:80px;
    text-align:center;
    border-radius: 4px;
    border-color: #636263 #464647 #A1A3A5;
    text-shadow: 0 1px 1px #F6F6F6;
    background-image: -moz-linear-gradient(center top, #D9D9D9, #A6A6A6 49%, #A6A6A6 50%);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #D9D9D9),color-stop(1, #A6A6A6));
}
#footer{
    margin-top:20px;
    width:100%;
}
#footer #text{
    text-align:center;
    font-size:14px;
    font-family:微软雅黑;
    font-weight:bold;
}
</style>
<body>
<div id="wrapper">
    <div id="header">
        <div id="logo"></div>
        <div id="heading">
            <div id="title">后台管理系统</div>
            <div id="subTitle">Ver 1.0</div>
        </div>
    </div>
    <div id="main">
        <div id="mainBg">
            <div id="mainPanel">
                <div id="left">
                    <div id="image"></div>
                </div>
                <div id="right">
                    
                    <form name="loginForm" action="<%=path%>/users/Users_login.action" method="post">
                    <!-- start of login form -->
                    <div id="welcome">
                        <span id="welcome-text">管&nbsp;理&nbsp;登&nbsp;录</span>
                    </div>
                    <div id="user-name">
                        <span class="item">用户名:</span>
                        <span><input type="text" name="username" class="form-input"></span>
                    </div>
                    <div id="user-password">
                        <span class="item">密&nbsp;&nbsp;&nbsp;码:</span>
                        <span class="input"><input type="password" name="password" class="form-input"></span>
                    </div>
                    <div id="button-group">
                        <input type="submit" class="btn" value="登录"/>
                        <input type="reset" class="btn" value="重置"/>
                    </div>
                    <div>
                      <s:fielderror/> <!-- 显示表单验证的出错信息 -->
                    </div>
                    <!-- end of form -->
                    </form>
                    
                </div>
            </div>
        </div>
    </div>
    <div id="footer">
        <div id="text">Copyright ? 2009-2015 All Rights Reserved Powered By Simoniu</div>
    </div>
</div>
</body>
</html>

//Users_login_main.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    float:left;
    margin-right:10px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:center;
    width:98%;
    font-size:12px;
}
</style>
<body>
<div id="navi">
    <!-- 导航空白 -->
</div>
<div id="tips">
    <!-- 导航空白 -->
</div>
<div id="mainContainer">
   <img src="../images/welcome.jpg">
   <!--数据表格空白 -->
</div>
</body>
</html>

//Users_login_success.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>

<!DOCTYPE html>
<html>
<head>
    <title>后台管理</title>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/index.css" />
</head>
<body>
<div id="wrapper">
    <div id="header">
        <div id="logo">LOGO</div>
        <div id="title">后台管理系统</div>
        <div id="menu">
            <div id="menu_container">
                <ul id="menu_items">
                    <li class="menu_item on" style="border-radius:8px 0 0 8px" onmouseout="this.style.backgroundColor=''" onmouseover="this.style.backgroundColor='#77D1F6';this.style.borderRadius='8px 0 0 8px'"><a>系统管理</a></li>
                    <li class="menu_item" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'"><a>学生管理</a></li>
                    <li class="menu_item" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'"><a>新闻管理</a></li>
                    <li class="menu_item" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'"><a>网盘管理</a></li>
                    <li class="menu_item" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'"><a>相册管理</a></li>
                    <li class="menu_item" style="border-radius:8px 0 0 8px;border:0px;" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.borderRadius='0 8px 8px 0';this.style.fontWeight='bold'"><a>邮件管理</a></li>
                </ul>
            </div>
        </div>
        <div id="user_info">
            <div id="welcome">欢迎${sessionScope.loginUserName}使用本系统</div>
            <div id="logout"><a href="<%=path%>/users/Users_logout.action">安全退出</a></div>
        </div>
    </div>
    <div id="navigator">
        <iframe src="../tree.jsp"></iframe>
    </div>
    <div id="main">
        <iframe name="MainFrame" src="Users_login_main.jsp"></iframe>
    </div>
    <div id="footer">Copyright ? 2009-2015 All Rights Reserved Powered By Somoniu</div>
</div>
</body>
<script type="text/javascript">
function screenAdapter(){
    document.getElementById('footer').style.top=document.documentElement.scrollTop+document.documentElement.clientHeight- document.getElementById('footer').offsetHeight+"px";
        document.getElementById('navigator').style.height=document.documentElement.clientHeight-100+"px";
        document.getElementById('main').style.height=document.documentElement.clientHeight-100+"px";
        document.getElementById('main').style.width=window.screen.width-330+"px";
}

window.onscroll=function(){screenAdapter();};
window.onresize=function(){screenAdapter();};
window.onload=function(){screenAdapter();};
</script>
</html>

//Students_add.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%@ taglib prefix="s" uri="/struts-tags"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 1 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    margin-top:20px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:left;
    width:98%;
    font-size:16px;
}
</style>
<body>
<script type="text/javascript" src="../js/Calendar3.js"></script>

<div id="navi">
    <div id='naviDiv'>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;学生管理<span>&nbsp;
        <%--用如下href="students/Students_query.action" 可以显示出数据，但是没有样式--%>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;<a href="<%=path%>/students/Students_query.action">学生列表</a><span>&nbsp;
    </div>
</div>
<div id="tips">
</div>
<div id="mainContainer">
<!-- 从session中获取学生集合 -->
<strong>添加学生资料</strong>
<br>
<br>
<form name="addForm" action="<%=path%>/students/Students_add.action" method="post">
<table width="400" >
  <tr>
    <td width="30%">姓名：</td>
    <td><input type="text" name="sname" /></td>
  </tr>
  <tr>
    <td>性别：</td>
    <td><input type="radio" name="gender" value="男" checked="checked"/>男<input type="radio" name="gender" value="女"/>女</td>
  </tr>
  <tr>
    <td>出生日期：</td>
    <td><input name="birthday" type="text" id="control_date" size="20"
      maxlength="10" onclick="new Calendar().show(this);" readonly="readonly" />
    </td>
  </tr>
  <tr>
    <td>地址：</td>
    <td><input type="text" name="address" /></td>
  </tr>
  <tr>
    <td colspan="2" align="center"><input class="button" type="submit" value="添加"></td>
  </tr>
</table>
</form>
</div>
</body>
</html>

//Students_add_success.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    float:left;
    margin-right:10px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:center;
    width:98%;
    font-size:12px;
}
</style>
<body>
<div id="navi">
    <!-- 导航空白 -->
    <div id='naviDiv'>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;学生管理<span>&nbsp;
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;<a href="<%=path%>/students/Students_query.action">学生列表</a><span>&nbsp;
    </div>
</div>
<div id="tips">
    <!-- 导航空白 -->
</div>
<div id="mainContainer">
   <strong>添加成功，<a href="<%=path%>/students/Students_add.jsp">继续添加？</a>或<a href="<%=path%>/students/Students_query.action">返回学生列表？</a></strong>
   <!--数据表格空白 -->
</div>
</body>
</html>

//Students_modify.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%@ taglib prefix="s" uri="/struts-tags"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 1 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    margin-top:20px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:left;
    width:98%;
    font-size:16px;
}
</style>
<body>
<script type="text/javascript" src="../js/Calendar3.js"></script>

<div id="navi">
    <div id='naviDiv'>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;学生管理<span>&nbsp;
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;<a href="<%=path%>/students/Students_query.action">学生列表</a><span>&nbsp;
    </div>
</div>
<div id="tips">
</div>
<div id="mainContainer">
<!-- 从session中获取学生集合 -->
<strong>修改学生资料</strong>
<br>
<br>

<form name="modifyForm" action="<%=path%>/students/Students_save.action" method="post">
<table width="400" >
  <tr>
    <td width="30%">学号：</td>
    <td><input type="text" name="sid" value='<s:property value="#session.modify_students.sid"/>'  readonly="readonly"/></td>
  </tr>
  <tr>
    <td width="30%">姓名：</td>
    <td><input type="text" name="sname" value='<s:property value="#session.modify_students.sname"/>'/></td>
  </tr>
  <tr>
    <td>性别：</td>
    <td>
      <s:if test='%{#session.modify_students.gender=="男"}'>
         <input type="radio" name="gender" value="男" checked="checked"/>男
         <input type="radio" name="gender" value="女"/>女
      </s:if>
      <s:else>
         <input type="radio" name="gender" value="男" />男
         <input type="radio" name="gender" value="女" checked="checked"/>女
      </s:else>
      </td>
  </tr>
  <tr>
    <td>出生日期：</td>
    <td><input name="birthday" type="text" id="control_date" size="20"
      maxlength="10" onclick="new Calendar().show(this);" readonly="readonly" 
      value="<s:date name="#session.modify_students.birthday" format="yyyy-MM-dd"/>"
      />
    </td>
  </tr>
  <tr>
    <td>地址：</td>
    <td><input type="text" name="address" value='<s:property value="#session.modify_students.address"/>'/></td>
  </tr>
  <tr>
    <td colspan="2" align="center"><input class="button" type="submit" value="修改"></td>
  </tr>
</table>
</form>


</div>
</body>
</html>

//Students_modify_success.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    float:left;
    margin-right:10px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:center;
    width:98%;
    font-size:12px;
}
</style>
<body>
<div id="navi">
    <!-- 导航空白 -->
    <div id='naviDiv'>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;学生管理<span>&nbsp;
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;<a href="<%=path%>/students/Students_query.action">学生列表</a><span>&nbsp;
    </div>
</div>
<div id="tips">
    <!-- 导航空白 -->
</div>
<div id="mainContainer">
   <strong>修改成功，<a href="<%=path%>/students/Students_query.action">返回学生列表</a></strong>
   <!--数据表格空白 -->
</div>
</body>
</html>

//Students_query_success.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8" %>
<%@ taglib prefix="s" uri="/struts-tags"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!DOCTYPE html>
<html>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
<style type="text/css">
* {
    background: none repeat scroll 0 0 transparent;
    border: 0 none;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
    font-family:微软雅黑;
    overflow:hidden;
}
#navi{
    width:100%;
    position:relative;
    word-wrap:break-word;
    border-bottom:1px solid #065FB9;
    margin:0;
    padding:0;
    height:40px;
    line-height:40px;
    vertical-align:middle;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, 
#BFBFBF));
}
#naviDiv{
    font-size:14px;
    color:#333;
    padding-left:10px;
}
#tips{
    margin-top:10px;
    width:100%;
    height:40px;
}
#buttonGroup{
    padding-left:10px;
    float:left;
    height:35px;
}
.button{
    float:left;
    margin-right:10px;
    padding-left:10px;
    padding-right:10px;
    font-size:14px;
    width:70px;
    height:30px;
    line-height:30px;
    vertical-align:middle;
    text-align:center;
    cursor:pointer;
    border-color: #77D1F6;
    border-width: 1px;
    border-style: solid;
    border-radius: 6px 6px;
    -moz-box-shadow: 2px 2px 4px #282828;
    -webkit-box-shadow: 2px 2px 4px #282828;
    background-image: -moz-linear-gradient(top,#EBEBEB, #BFBFBF);
    background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #EBEBEB),color-stop(1, #BFBFBF));
}
#mainContainer{
    padding-left:10px;
    padding-right:10px;
    text-align:center;
    width:98%;
    font-size:12px;
}
</style>
<body>
<div id="navi">
    <div id='naviDiv'>
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;学生管理<span>&nbsp;
        <span><img src="../images/arror.gif" width="7" height="11" border="0" alt=""></span>&nbsp;<a href="<%=path%>/students/Students_query.action">学生列表</a><span>&nbsp;
    </div>
</div>
<div id="tips">
    <div id="buttonGroup">
        <div class="button" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'">
            <a href="<%=path%>/students/Students_add.jsp">添加学生</a>
        </div>
        <div class="button" onmouseout="this.style.backgroundColor='';this.style.fontWeight='normal'" onmouseover="this.style.backgroundColor='#77D1F6';this.style.fontWeight='bold'">
            <a>查找学生</a>
        </div>
    </div>
</div>
<div id="mainContainer">
<!-- 从session中获取学生集合 -->

<table class="default" width="100%">
    <col width="10%">
    <col width="20%">
    <col width="5%">
    <col width="20%">
    <col width="30%">
    <col width="15%">
    <tr class="title">
        <td>学号</td>
        <td>姓名</td>
        <td>性别</td>
        <td>出生日期</td>
        <td>地址</td>
        <td>操作</td>
    </tr>
    
    <!-- 遍历开始 -->
    <s:iterator value="#session.students_list" var="stu">
    <tr class="list">
        <td><s:property value="#stu.sid"/></td>
        <td><a href="<%=path%>/students/Students_modify.action?sid=<s:property value="#stu.sid"/>"><s:property value="#stu.sname"/></a></td>
        <td><s:property value="#stu.gender"/></td>
        <td><s:date name="#stu.birthday" format="yyyy年MM月dd日"/></td>
        <td><s:property value="#stu.address"/></td>
        <td><a href="<%=path%>/students/Students_delete.action?sid=<s:property value="#stu.sid"/>" onclick="javascript: return confirm('真的要删除吗？');">删除</a></td>
    </tr>
    </s:iterator>
    <!-- 遍历结束 -->
</table>
</div>
</body>
</html>

//------------------------------------------------------------------------------------------------
3-12 修改学生资料-实现修改学生资料

//------------------------------------------------------------------------------------------------
1-1 基于SSH之框架整合篇，基于SSH实现员工管理系统之框架整合篇教程 https://www.imooc.com/video/12461

//------------------------------------------------------------------------------------------------
3-1 创建项目引入jar包
struts2-convention-plugin-2.XXX.jar
--strut2的注解开发的jar包

struts2-spring-plugin-2.XXX.jar
--struts2用于整合spring的jar包

//------------------------------------------------------------------------------------------------
4-3 配置Action，Service，Dao的类 https://www.imooc.com/video/12468
Struts2和Srping整合的两种方式：
1. Action的类由Struts2自身去创建
//Action的配置和创建：struts.xml
    <package name="ssh" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="product_*" class="action.ProductAction" method="{1}"><!--这里写的class="action.ProductAction"，会由strut2创建Action类-->

        </action>
    </package>

//Service和DAO的配置和创建：applicationContext.xml
    <!-- 配置业务层的类 -->
    <bean id="productService" class="service.ProductService">
        <property name="productDao" ref="productDao"/>
    </bean>

    <!-- 配置DAO的类 -->
    <bean id="productDao" class="dao.ProductDao">

    </bean>
2. Action的类交给Spring框架创建
//Action的配置：struts.xml
    <package name="ssh" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="product_*" class="productAction" method="{1}"><!--这里写的class="productAction"，只是spring配置文件中的Action类Id-->

        </action>
    </package>

//Action、Service和DAO的配置和创建：applicationContext.xml
    <!-- 配置Action的类 -->
    <bean id="productAction" class="action.ProductAction" scope="prototype">
        <!-- 手动注入Service -->
        <property name="productService" ref="productService"/>
    </bean>

    <!-- 配置业务层的类 -->
    <bean id="productService" class="service.ProductService">
        <property name="productDao" ref="productDao"/>
    </bean>

    <!-- 配置DAO的类 -->
    <bean id="productDao" class="dao.ProductDao">

    </bean>
    
建议使用第二种方式，所有类的配置和创建都将由Spring完成，可以进行AOP增强，如果将由Strut2创建类则无法进行AOP。
//------------------------------------------------------------------------------------------------
5-1 创建数据库和映射文件-Spring整合Hiberante

基于hibernate.cfg.xml
//ProductAction.java
package action;

// 本来需要通过如下工厂方式获得Bean对象：
// WebApplicationContext wap = WebApplicationContextUtils.getWebApplicationContext(...);
// BookService bs = wap.getBeans("bookService");

// 使用了struts2-spring-plugin-XXX.jar后，就可以自动装配：
// org/apache/struts/struts2-core/2.5.16/struts2-core-2.5.16.jar!/org/apache/struts2/default.properties中将
// # struts.objectFactory = spring注释掉
// 后一句struts.objectFactory.spring.autoWire = name表示使用name自动装配
// org/apache/struts/struts2-spring-plugin/2.5.16/struts2-spring-plugin-2.5.16.jar!/struts-plugin.xml中<constant name="struts.objectFactory" value="spring" />将此工厂方法定义上

import domain.Product;
import service.ProductService;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

/**
 * 商品管理的Action类
 */
public class ProductAction extends ActionSupport implements ModelDriven<Product> {
    // 模型驱动使用的类
    private Product product = new Product();
    @Override
    public Product getModel() {
        return product;
    }

    // Struts和Spring整合过程中按名称自动注入的业务层类
    private ProductService productService;

    public void setProductService(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 保存商品的执行的方法
     */
    public String save() {
        System.out.println("Action的save方法执行了...");
        productService.save(product);
        return NONE;
    }
}

//ProductDao.java
package dao;

import domain.Product;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;

/**
 * 商品管理的DAO类
 */
public class ProductDao {

    /**
     * DAO中保存商品的方法
     * @param product
     */
    public void save(Product product) {
        System.out.println("DAO中的save方法执行了...");
        System.out.println(product);

        Configuration config = new Configuration().configure();
        SessionFactory sessionFactory = config.buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        Transaction transaction = session.beginTransaction();

        session.save(product);
        transaction.commit();
    }
}

//Product.java
package domain;

/**
 * 商品的实体
 */
public class Product {
    private Integer pid;
    private String pname;
    private Double price;

    public Integer getPid() {
        return pid;
    }

    public void setPid(Integer pid) {
        this.pid = pid;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Product{" +
            "pid=" + pid +
            ", pname='" + pname + '\'' +
            ", price=" + price +
            '}';
    }
}

//Product.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="domain.Product" table="t_product">
        <id name="pid" type="int" column="pid">
            <generator class="native"/>
        </id>

        <property name="pname" type="java.lang.String" column="pname" length="20"/>
        <property name="price" type="double" column="price"/>
    </class>
</hibernate-mapping>

//ProductService.java
package service;

import dao.ProductDao;
import domain.Product;

/**
 * 商品管理的业务层的类
 */
public class ProductService {
    // 业务层注入的DAO类
    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    /**
     * 业务层保存商品的方法
     * @param product
     */
    public void save(Product product) {
        System.out.println("Service的savey方法执行了...");
        productDao.save(product);
    }
}


//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">


    <!-- 配置Action的类 -->
    <bean id="productAction" class="action.ProductAction" scope="prototype">
        <!-- 手动注入Service -->
        <property name="productService" ref="productService"/>
    </bean>

    <!-- 配置业务层的类 -->
    <bean id="productService" class="service.ProductService">
        <property name="productDao" ref="productDao"/>
    </bean>

    <!-- 配置DAO的类 -->
    <bean id="productDao" class="dao.ProductDao">

    </bean>
</beans>

//hibernate.cfg.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!--  mysql账户名  -->
        <property name="connection.username">root</property>

        <!--  mysql密码  -->
        <property name="connection.password">root123</property>

        <!--  mysql驱动  -->
        <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

        <!--  mysql连接URL  这里修改mysql-connector-java.jar版本为8.0.11，并且安装了MySQL的Connector：MySQL Connector/J-->
        <property name="connection.url">jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</property>

        <!--  数据库方言  -->
        <property name="dialect">org.hibernate.dialect.MySQLDialect</property>

        <!--  显示sql语句  -->
        <property name="show_sql">true</property>

        <!--  格式化sql语句  -->
        <property name="format_sql">true</property>

        <!--<property name="hibernate.default_schema">hibernate</property>-->
        <!--  根据需要创建数据库  如果表存在，则会删除；如果表不存在，则新建；如果不加这个条件，则不会新建或删除表-->
        <property name="hbm2ddl.auto">update</property>

        <!--本地事务（jdbc事务）用thread参数 全局事务（jta事务）用jta参数-->
        <property name="hibernate.current_session_context_class">thread</property>

        <mapping resource="domain/Product.hbm.xml"/>
    </session-factory>
</hibernate-configuration>

//log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5p] %d %c - %m%n" />
        </Console>
        <File name="File" fileName="dist/my.log">
            <PatternLayout pattern="%m%n" />
        </File>
    </Appenders>

    <Loggers>
        <Logger name="mh.sample2.Log4jTest2" level="INFO">
            <AppenderRef ref="File" />
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>

//strut.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/hello.jsp</result>
        </action>
    </package>

    <package name="ssh" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <!--<action name="product_*" class="action.ProductAction" method="{1}">&lt;!&ndash;这里写的class="action.ProductAction"，会由strut2创建Action类&ndash;&gt;-->
        <action name="product_*" class="productAction" method="{1}">

        </action>
    </package>
</struts>


//web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--Spring的框架的核心监听器-->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

    <!--Struts2的框架的核心过滤器的配置-->
    <filter>
        <filter-name>struts</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>struts</filter-name>
        <url-pattern>/*</url-pattern> */
    </filter-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>

//addProduct.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h1>保存商品的页面</h1>
<s:form action="product_save" method="post" namespace="/" theme="simple">
    <table border="1" width="400">
        <tr>
            <td>商品名称</td>
            <td><s:textfield name="pname"/></td>
        </tr>
        <tr>
            <td>商品价格</td>
            <td><s:textfield name="price"/></td>
        </tr>
        <tr>
            <td colspan="2"><input type="submit" value="添加"/></td>
        </tr>
    </table>
</s:form>
</body>
</html>

//index.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8"%>
<%
  String path = request.getContextPath();
  String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
  response.sendRedirect(path+"/addProduct.jsp");
%>

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>webproject</groupId>
  <artifactId>webproject</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>entity</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>

    <!-- 添加mysql驱动依赖 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.11</version>
    </dependency>

    <!-- 添加hibernate依赖包 -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>5.2.6.Final</version>
    </dependency>

    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-core</artifactId>
      <version>2.5.16</version>
    </dependency>

    <dependency>
      <groupId>jstl</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>

    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-spring-plugin</artifactId>
      <version>2.5.16</version>
    </dependency>

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.7</version>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.25</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>5.0.7.RELEASE</version>
    </dependency>
  </dependencies>

  <build>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.0.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.7.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.20.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
  </build>
</project>


//-----使用Spring整合Hibernate，不配置hibernate.cfg.xml文件：
//ProductAction.java
package action;

// 本来需要通过如下工厂方式获得Bean对象：
// WebApplicationContext wap = WebApplicationContextUtils.getWebApplicationContext(...);
// BookService bs = wap.getBeans("bookService");

// 使用了struts2-spring-plugin-XXX.jar后，就可以自动装配：
// org/apache/struts/struts2-core/2.5.16/struts2-core-2.5.16.jar!/org/apache/struts2/default.properties中将
// # struts.objectFactory = spring注释掉
// 后一句struts.objectFactory.spring.autoWire = name表示使用name自动装配
// org/apache/struts/struts2-spring-plugin/2.5.16/struts2-spring-plugin-2.5.16.jar!/struts-plugin.xml中<constant name="struts.objectFactory" value="spring" />将此工厂方法定义上

import domain.Product;
import service.ProductService;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

/**
 * 商品管理的Action类
 */
public class ProductAction extends ActionSupport implements ModelDriven<Product> {
    // 模型驱动使用的类
    private Product product = new Product();
    @Override
    public Product getModel() {
        return product;
    }

    // Struts和Spring整合过程中按名称自动注入的业务层类
    private ProductService productService;

    public void setProductService(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 保存商品的执行的方法
     */
    public String save() {
        System.out.println("Action的save方法执行了...");
        productService.save(product);
        return NONE;
    }
}

//ProductDao.java
package dao;

import domain.Product;

import org.springframework.orm.hibernate5.support.HibernateDaoSupport;

/**
 * 商品管理的DAO类
 */
public class ProductDao extends HibernateDaoSupport {

    /**
     * DAO中保存商品的方法
     * @param product
     */
    public void save(Product product) {
        System.out.println("DAO中的save方法执行了...");
        System.out.println(product);
        this.getHibernateTemplate().save(product);
        
        //这是原来单独使用Hibernate的保存方式
//        Configuration config = new Configuration().configure();
//        SessionFactory sessionFactory = config.buildSessionFactory();
//        Session session = sessionFactory.getCurrentSession();
//        Transaction transaction = session.beginTransaction();
//
//        session.save(product);
//        transaction.commit();
    }
}

//Product.java
package domain;

/**
 * 商品的实体
 */
public class Product {
    private Integer pid;
    private String pname;
    private Double price;

    public Integer getPid() {
        return pid;
    }

    public void setPid(Integer pid) {
        this.pid = pid;
    }

    public String getPname() {
        return pname;
    }

    public void setPname(String pname) {
        this.pname = pname;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Product{" +
            "pid=" + pid +
            ", pname='" + pname + '\'' +
            ", price=" + price +
            '}';
    }
}

//Product.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="domain.Product" table="t_product">
        <id name="pid" type="int" column="pid">
            <generator class="native"/>
        </id>

        <property name="pname" type="java.lang.String" column="pname" length="20"/>
        <property name="price" type="double" column="price"/>
    </class>
</hibernate-mapping>

//ProductService.java
package service;

import dao.ProductDao;
import domain.Product;

import org.springframework.transaction.annotation.Transactional;

/**
 * 商品管理的业务层的类
 */
@Transactional
public class ProductService {
    // 业务层注入的DAO类
    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    /**
     * 业务层保存商品的方法
     * @param product
     */
    public void save(Product product) {
        System.out.println("Service的savey方法执行了...");
        productDao.save(product);
    }
}

//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!-- 引入外部的属性文件 -->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!-- 配置Hibernate的相关属性 在启动服务时，会把表t_product创建起来-->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <!-- 注入连接池 -->
        <property name="dataSource" ref="dataSource"/>
        <!-- 配置Hibernate的属性 -->
        <property name="hibernateProperties">
            <props>
                <!-- 这里如果不设置成MySQL5Dialect，则Hibernate生成建表语句时会加一句type=MyISAM，执行SQL时失败 https://blog.csdn.net/u014158770/article/details/66478060-->
                <!-- 改成MySQL5Dialect之后，建表语句最后为engine=MyISAM，但是此时建出来的表无法创建外键 https://blog.csdn.net/tongxinxiao/article/details/50617369 -->
                <!-- 修改言为MySQL55Dialect，建表语句最后为engine=InnoDB，此时可以正常增加外键 https://blog.csdn.net/tianyaleixiaowu/article/details/79468277-->
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</prop>
                <prop key="hibernate.show_sql">true</prop>
                <prop key="hibernate.format_sql">true</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
                <!-- https://blog.csdn.net/maoyuanming0806/article/details/61417995 -->
                <!-- 在hibernate5上不需要配置如下thread方式 -->
                <!--<prop key="hibernate.current_session_context_class">thread</prop>-->
                <!-- 或者配置如下 org.springframework.orm.hibernate5.SpringSessionContext -->
                <prop key="hibernate.current_session_context_class">org.springframework.orm.hibernate5.SpringSessionContext</prop>
            </props>
        </property>
        <!--配置Hibernate的映射文件-->
        <property name="mappingResources">
            <list>
                <value>domain/Product.hbm.xml</value>
            </list>
        </property>
    </bean>

    <!-- 配置Action的类 -->
    <bean id="productAction" class="action.ProductAction" scope="prototype">
        <!-- 手动注入Service -->
        <property name="productService" ref="productService"/>
    </bean>

    <!-- 配置业务层的类 -->
    <bean id="productService" class="service.ProductService">
        <property name="productDao" ref="productDao"/>
    </bean>

    <!-- 配置DAO的类 -->
    <bean id="productDao" class="dao.ProductDao">
        <!-- 注入到抽象类HibernateDaoSupport中的sessionFactory -->
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <!-- 开启注释事务 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>

//jdbc.properties
//注意这里的url地址原来是xml中配置时对于&是使用转义符&apm;使用的，配置在properties中时需要换成原连接符&
jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8&useSSL=false
jdbc.username=root
jdbc.password=root123

//log4j.properties
log4j.rootLogger=DEBUG,A1
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/hello.jsp</result>
        </action>
    </package>

    <package name="ssh" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <!--<action name="product_*" class="action.ProductAction" method="{1}">&lt;!&ndash;这里写的class="action.ProductAction"，会由strut2创建Action类&ndash;&gt;-->
        <action name="product_*" class="productAction" method="{1}">

        </action>
    </package>
</struts>

//addProduct.jsp和index.jsp文件与原来相同

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>webproject</groupId>
  <artifactId>webproject</artifactId>
  <version>1.0-SNAPSHOT</version>

  <name>entity</name>
  <!-- FIXME change it to the project's website -->
  <url>http://www.example.com</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.7</maven.compiler.source>
    <maven.compiler.target>1.7</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>

    <!-- 添加mysql驱动依赖 -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.11</version>
    </dependency>

    <!-- 添加hibernate依赖包 -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <!--<version>4.1.7.Final</version>-->
      <version>5.3.2.Final</version>
    </dependency>

    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-core</artifactId>
      <version>2.5.16</version>
    </dependency>

    <dependency>
      <groupId>jstl</groupId>
      <artifactId>jstl</artifactId>
      <version>1.2</version>
    </dependency>

    <dependency>
      <groupId>org.apache.struts</groupId>
      <artifactId>struts2-spring-plugin</artifactId>
      <version>2.5.16</version>
    </dependency>

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>4.0.1</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-core</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-api</artifactId>
      <version>2.11.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.7</version>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.25</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>5.0.7.RELEASE</version>
    </dependency>

    <dependency>
      <groupId>com.mchange</groupId>
      <artifactId>c3p0</artifactId>
      <version>0.9.5.2</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-orm</artifactId>
      <version>5.0.7.RELEASE</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.0.7.RELEASE</version>
    </dependency>
  </dependencies>

  <build>
    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
      <plugins>
        <plugin>
          <artifactId>maven-clean-plugin</artifactId>
          <version>3.0.0</version>
        </plugin>
        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
        <plugin>
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.7.0</version>
        </plugin>
        <plugin>
          <artifactId>maven-surefire-plugin</artifactId>
          <version>2.20.1</version>
        </plugin>
        <plugin>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.0.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-install-plugin</artifactId>
          <version>2.5.2</version>
        </plugin>
        <plugin>
          <artifactId>maven-deploy-plugin</artifactId>
          <version>2.8.2</version>
        </plugin>
      </plugins>
    </pluginManagement>
    
    <!--https://blog.csdn.net/swpu_lipan/article/details/78460852?utm_source=debugrun&utm_medium=referral
    https://www.cnblogs.com/machanghai/p/5456294.html-->
    <!--配置如下resources，才会把*.hbm文件拷贝到target目录，否则java中的配置文件不会拷贝，导致xxx.hbm.xml文件找不到的错误-->
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
            <filtering>true</filtering>
        </resource>
        <resource>
            <directory>src/main/resources</directory>
            <includes>
                <include>**/*.xml</include>
                <include>**/*.properties</include> 在IDE中配置时需要去注释*/
            </includes>
        </resource>
    </resources>
  </build>
</project>

//------------------------------------------------------------------------------------------------
SSH实现员工管理系统之案例实现篇
1-3 实体及映射的创建 
主要问题点在于外键的生成，使用引擎为MyISAM时，则无法创建外键，使用引擎为InnoDB时，可以正常创建外键
<!-- 这里如果不设置成MySQL5Dialect，则Hibernate生成建表语句时会加一句type=MyISAM，执行SQL时失败 https://blog.csdn.net/u014158770/article/details/66478060-->
<!-- 改成5之后，建表语句最后为engine=MyISAM，但是此时建出来的表无法创建外键 https://blog.csdn.net/tongxinxiao/article/details/50617369 -->
<!-- 修改言为MySQL55Dialect，建表语句最后为engine=InnoDB，此时可以正常增加外键 https://blog.csdn.net/tianyaleixiaowu/article/details/79468277-->
<prop key="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</prop>


//------------------------------------------------------------------------------------------------

//login2.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8"%>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>登陆</title>
<link type="text/css" rel="stylesheet" href="<%=path%>/style/reset.css">
<link type="text/css" rel="stylesheet" href="<%=path%>/style/main.css">
<!--[if IE 6]>
<script type="text/javascript" src="js/DD_belatedPNG_0.0.8a-min.js"></script>
<script type="text/javascript" src="js/ie6Fixpng.js"></script>
<![endif]-->
</head>

<body>
<div class="headerBar">
    <div class="logoBar login_logo">
        <div class="comWidth">
            <div class="logo fl">
                <a href="#"><img src="<%=path%>/images/logo.jpg" alt="慕课网"></a>
            </div>
            <h3 class="welcome_title">欢迎登陆</h3>
        </div>
    </div>
</div>
<form action="frame.html" method="post">
<div class="loginBox">
    <div class="login_cont">
        <ul class="login">
            <li class="l_tit">用户名</li>
            <li class="mb_10"><input type="text" class="login_input user_icon"></li>
            <li class="l_tit">密码</li>
            <li class="mb_10"><input type="text" class="login_input user_icon"></li>
            
            <li><input type="submit" value="" class="login_btn"></li>
        </ul>
        <div class="login_partners">
            <p class="l_tit">使用合作方账号登陆网站</p>
            <ul class="login_list clearfix">
                <li><a href="#">QQ</a></li>
                <li><span>|</span></li>
                <li><a href="#">网易</a></li>
                <li><span>|</span></li>
                <li><a href="#">新浪微博</a></li>
                <li><span>|</span></li>
                <li><a href="#">腾讯微薄</a></li>
                <li><span>|</span></li>
                <li><a href="#">新浪微博</a></li>
                <li><span>|</span></li>
                <li><a href="#">腾讯微薄</a></li>
            </ul>
        </div>
    </div>
    
</div>
</form>

<div class="hr_25"></div>
<div class="footer">
    <p><a href="#">慕课简介</a><i>|</i><a href="#">慕课公告</a><i>|</i> <a href="#">招纳贤士</a><i>|</i><a href="#">联系我们</a><i>|</i>客服热线：400-675-1234</p>
    <p>Copyright &copy; 2006 - 2014 慕课版权所有&nbsp;&nbsp;&nbsp;京ICP备09037834号&nbsp;&nbsp;&nbsp;京ICP证B1034-8373号&nbsp;&nbsp;&nbsp;某市公安局XX分局备案编号：123456789123</p>
    <p class="web"><a href="#"><img src="<%=path%>/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="<%=path%>/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="<%=path%>/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="<%=path%>/images/webLogo.jpg" alt="logo"></a></p>
</div>
</body>
</html>

//------------------------------------------------------------------------------------------------
2-2 SSH-案例：登录功能代码实现 https://www.imooc.com/video/12479
//https://blog.csdn.net/m0_37922841/article/details/80560127
在Hibernate5.3.1 中，HQL语句使用"?"参数占位符运行报错：
Caused by: org.hibernate.QueryException: 
Legacy-style query parameters (`?`) are no longer supported; use JPA-style ordinal parameters (e.g., `?1`) instead

并且：在Query查询时：setInteger()等方法已过时：

解决办法：
1.将HQL语句中的"?"改为JPA-style：
String hql = "from Student where age > ?0 and score < ?1";

2.方法过时问题解决：使用setParameter():
List<Student> list = createQuery .setParameter(0, 21) .setParameter(1, 95.0) .list();

3.使用别名方式写HQL语句：
String hql = "from Student where age > :myage and score < :myscore";


//https://www.cnblogs.com/DarrenChan/p/5528194.html find()方法使用介绍

//EmployeeDaoImpl.java
package dao.impl;

import dao.EmployeeDao;
import domain.Employee;

import java.util.List;

import org.springframework.orm.hibernate5.support.HibernateDaoSupport;

/**
 * 员工管理的DAO的实现类
 */
public class EmployeeDaoImpl extends HibernateDaoSupport implements EmployeeDao {
    /**
     * DAO中根据用户名和密码查询用户的方法
     * @param employee
     * @return
     */
    @Override
    public Employee findByUsernameAndPassword(Employee employee) {
        //find方法已经废弃了
//        String hql = "from Employee where username = ?0 and password = ?1";
//        List<Employee> employees = (List<Employee>) this.getHibernateTemplate().find(hql, employee.getUsername(), employee.getPassword());
        
        //可以使用findByExample方法，这里的employee里只有username和password为非null值，主键eid也有默认值0，但是Hibernate构造查询语句时会忽略主键和null值，查询语句如下：
    /**
    select
        this_.eid as eid1_1_0_,
        this_.ename as ename2_1_0_,
        this_.sex as sex3_1_0_,
        this_.birthday as birthday4_1_0_,
        this_.joinDate as joinDate5_1_0_,
        this_.eno as eno6_1_0_,
        this_.username as username7_1_0_,
        this_.password as password8_1_0_,
        this_.dno as dno9_1_0_ 
    from
        t_employee this_ 
    where
        (
            this_.username=? 
            and this_.password=?
        )
findByExample
1.不支持主键 
2.不支持关联 
3.不支持NULL
        */
        List<Employee> employees = this.getHibernateTemplate().findByExample(employee);
        if (!employees.isEmpty()) {
            return employees.get(0);
        }
        return null;
    }
}
//------------------------------------------------------------------------------------------------
3-1 Action、Dao、Service的创建和配置 https://www.imooc.com/video/12480
html文件直接打开正常显示，使用struts打开乱码。
把html用notepad++打开后，编码转成utf-8 ，再把浏览器的缓存清理掉，重启Tomcat服务器，就可以正常显示了。

//Spring Bean的prototype和singleton https://blog.csdn.net/q276513307/article/details/78393599
总结一下 
1. 对于有实例变量的类，要设置成prototype；没有实例变量的类，就用默认的singleton 
2. Action一般我们都会设置成prototype，而Service只用singleton就可以。 


//http://www.cnblogs.com/share2015/p/5321822.html
如果没有增加@Transactional/*(propagation = Propagation.REQUIRED)*/，则会报如下面的错误：
2018-07-14 17:30:19,552 [http-nio-8080-exec-10] [org.springframework.orm.hibernate5.HibernateTemplate]-[DEBUG] Could not retrieve pre-bound Hibernate session
org.hibernate.HibernateException: Could not obtain transaction-synchronized Session for current thread

//https://www.cnblogs.com/Loadhao/p/6553606.html @Transactional 注解的使用和注意
注解@Transactional cglib与java动态代理最大区别是代理目标对象不用实现接口,那么注解要是写到接口方法上，要是使用cglib代理，这是注解事物就失效了，为了保持兼容注解最好都写到实现类方法上。
Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。
//------------------------------------------------------------------------------------------------
4-3 修改员工 
这里value不能使用<s:property value="username">，struts标签里不能再套标签
<td><s:textfield name="username" value="%{model.username}"/></td>

//------------------------------------------------------------------------------------------------
SSH实现员工管理系统之案例实现篇 完整代码
//DepartmentAction.java
package action;

import domain.Department;
import domain.PageBean;
import service.DepartmentService;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

/**
 * 部门管理的Action类
 */
public class DepartmentAction extends ActionSupport implements ModelDriven<Department> {

    //模型驱动使用的对象，模型驱动的值默认在值栈中
    private Department department = new Department();
    @Override
    public Department getModel() {
        return department;
    }

    private int currPage = 1;
    public void setCurrPage(int currPage) {
        this.currPage = currPage;
    }

//    private int newPageSize = 1;
//
//    public int getNewPageSize() {
//        return newPageSize;
//    }
//
//    public void setNewPageSize(int newPageSize) {
//        this.newPageSize = newPageSize;
//    }

    //注入部门管理的Service
    private DepartmentService departmentService;

    public void setDepartmentService(DepartmentService departmentService) {
        this.departmentService = departmentService;
    }

    //提供一个查询方法
    public String findAll() {
        PageBean<Department> pageBean = departmentService.findByPage(currPage);
        //将pageBean存入值栈中
        ActionContext.getContext().getValueStack().push(pageBean);//这里如果没有push进来，则在jsp中就无法获取到相应的值
        return "findAll";
    }

    //跳转到添加部门页面的方法
    public String saveUI() {
        return "saveUI";
    }

    //添加部门的执行方法
    public String save() {
        departmentService.save(department);
        return "saveSuccess";
    }

    //编辑部门的执行方法
    public String edit() {
        department = departmentService.findById(department.getDid());
        return "editSuccess";
    }

    //修改部门的执行方法
    public String update() {
        departmentService.update(department);
        return "updateSuccess";
    }

    //删除部门的执行方法
    public String delete() {
        department = departmentService.findById(department.getDid());
        departmentService.delete(department);
        return "deleteSuccess";
    }
}


//EmployeeAction.java
package action;

import domain.Department;
import domain.Employee;
import domain.PageBean;
import service.DepartmentService;
import service.EmployeeService;

import java.util.List;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

/**
 * 员工管理的Action类
 */
public class EmployeeAction extends ActionSupport implements ModelDriven<Employee> {

    //模型驱动使用的对象
    private Employee employee = new Employee();

    @Override
    public Employee getModel() {
        return employee;
    }

    private int currPage = 1;
    public void setCurrPage(int currPage) {
        this.currPage = currPage;
    }

    //注入业务层类
    private EmployeeService employeeService;
    private DepartmentService departmentService;

    public void setEmployeeService(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    public void setDepartmentService(DepartmentService departmentService) {
        this.departmentService = departmentService;
    }

    /**
     * 登录执行的方法
     * @return
     */
    public String login() {
        System.out.println("login执行了...");
        //调用业务层的类
        Employee existEmployee = employeeService.login(this.employee);
        if (existEmployee == null) {
            //登录失败
            this.addActionError("用户名或密码错误！");
            return INPUT;
        } else {
            //登录成功
            ActionContext.getContext().getSession().put("existEmployee", existEmployee);
            return SUCCESS;
        }
    }

    /**
     * 分布查询员工的执行的方法
     */
    public String findAll() {
        PageBean<Employee> pageBean = employeeService.findByPage(currPage);
        //将pageBean存入值栈中
        ActionContext.getContext().getValueStack().push(pageBean);//这里如果没有push进来，则在jsp中就无法获取到相应的值
        return "findAll";
    }

    /**
     * 跳转到添加员工页面执行的方法
     */
    public String saveUI() {
        //查询所有部门
        List<Department> departments = departmentService.findAll();
        ActionContext.getContext().getValueStack().set("departments", departments);//集合用set，对象用push
        return "saveUI";
    }

    /**
     * 保存员工的执行的方法
     */
    public String save() {
        //如果要在Employee.hbm.xml中保留cascade="save-update"属性，那么这里就需要查出来Department的完整信息，再设置给employee，才能保证department的数据完整，不被更新为空值
        Department department = departmentService.findById(employee.getDepartment().getDid());
        if (department != null) {
            employee.setDepartment(department);
        }
        employeeService.save(employee);
        return "saveSuccess";
    }

    /**
     * 编辑员工的执行的方法
     */
    public String edit() {
        //根据员工ID查询员工
        employee = employeeService.findById(employee.getEid());
        //查询所有的部门
        List<Department> departments = departmentService.findAll();
        ActionContext.getContext().getValueStack().set("departments", departments);//集合用set，对象用push
        return "editSuccess";
    }

    /**
     * 修改员工的执行的方法
     */
    public String update() {
        Department department = departmentService.findById(employee.getDepartment().getDid());
        if (department != null) {
            employee.setDepartment(department);
        }
        employeeService.update(employee);
        return "updateSuccess";
    }

    /**
     * 删除员工的的执行方法
     */
    public String delete() {
        employee = employeeService.findById(employee.getEid());
        employeeService.delete(employee);
        return "delelteSuccess";
    }
}

//DepartmentDao.java
package dao;

import domain.Department;

import java.util.List;

/**
 * 部门管理的DAO层的接口类
 */
public interface DepartmentDao {
    int findCount();

    List<Department> findByPage(int begin, int pageSize);

    void save(Department department);

    Department findById(int did);

    void update(Department department);

    void delete(Department department);

    List<Department> findAll();
}

//DepartmentDaoImpl.java
package dao.impl;

import dao.DepartmentDao;
import domain.Department;

import java.util.List;

import org.hibernate.criterion.DetachedCriteria;
import org.springframework.orm.hibernate5.support.HibernateDaoSupport;

/**
 * 部门管理的DAO层的实现类
 */
public class DepartmentDaoImpl extends HibernateDaoSupport implements DepartmentDao {

    @Override
    public int findCount() {
        String hql = "select count(*) from Department";
        List<Long> list = (List<Long>) this.getHibernateTemplate().find(hql);
        if (!list.isEmpty()) {
            return list.get(0).intValue();
        }
        return 0;
    }

    /** 分页查询部门
     * @param begin
     * @param pageSize
     * @return
     */
    @Override
    public List<Department> findByPage(int begin, int pageSize) {
        DetachedCriteria criteria = DetachedCriteria.forClass(Department.class);
        List<Department> departments = (List<Department>) this.getHibernateTemplate().findByCriteria(criteria, begin, pageSize);
        return departments;
    }

    //DAO中保存部门的方法
    @Override
    public void save(Department department) {
        this.getHibernateTemplate().save(department);
    }

    //DAO中根据部门ID查询部门的方法
    @Override
    public Department findById(int did) {
        return this.getHibernateTemplate().get(Department.class, did);
    }

    //DAO中修改部门的方法
    @Override
    public void update(Department department) {
        this.getHibernateTemplate().update(department);
    }

    //DAO中删除部门的方法
    @Override
    public void delete(Department department) {
        this.getHibernateTemplate().delete(department);//传入对象可以级联删除，外键引用的子表也会一起删除
    }

    //DAO中查询所有部门的方法
    @Override
    public List<Department> findAll() {
        return (List<Department>) this.getHibernateTemplate().find("from Department");
    }
}

//EmployeeDao.java
package dao;

import domain.Employee;

import java.util.List;

/**
 * 员工管理的DAO的接口
 */
public interface EmployeeDao {
    Employee findByUsernameAndPassword(Employee employee);

    int findCount();

    List<Employee> findByPage(int begin, int pageSize);

    void save(Employee employee);

    Employee findById(int eid);

    void update(Employee employee);

    void delete(Employee employee);
}

//EmployeeDaoImpl.java
package dao.impl;

import dao.EmployeeDao;
import domain.Employee;

import java.util.List;

import org.hibernate.criterion.DetachedCriteria;
import org.springframework.orm.hibernate5.support.HibernateDaoSupport;

/**
 * 员工管理的DAO的实现类
 */
public class EmployeeDaoImpl extends HibernateDaoSupport implements EmployeeDao {
    /**
     * DAO中根据用户名和密码查询用户的方法
     * @param employee
     * @return
     */
    @Override
    public Employee findByUsernameAndPassword(Employee employee) {
//        String hql = "from Employee where username = ?0 and password = ?1";
//        List<Employee> employees = (List<Employee>) this.getHibernateTemplate().find(hql, employee.getUsername(), employee.getPassword());
        List<Employee> employees = this.getHibernateTemplate().findByExample(employee);
        if (!employees.isEmpty()) {
            return employees.get(0);
        }
        return null;
    }

    @Override
    public int findCount() {
        String hql = "select count(*) from Employee";
        List<Long> employeeCount = (List<Long>) this.getHibernateTemplate().find(hql);
        if (!employeeCount.isEmpty()) {
            return employeeCount.get(0).intValue();
        }
        return 0;
    }

    @Override
    public List<Employee> findByPage(int begin, int pageSize) {
        DetachedCriteria criteria = DetachedCriteria.forClass(Employee.class);
        List<Employee> employees = (List<Employee>) this.getHibernateTemplate().findByCriteria(criteria, begin, pageSize);
        return employees;
    }

    //DAO中优点员工的方法
    @Override
    public void save(Employee employee) {
        this.getHibernateTemplate().save(employee);
    }

    //DAO中根据员工ID查询员工的方法
    @Override
    public Employee findById(int eid) {
        return this.getHibernateTemplate().get(Employee.class, eid);
    }

    //DAO中修改员工的方法
    @Override
    public void update(Employee employee) {
        this.getHibernateTemplate().update(employee);
    }

    //DAO中删除员工的方法
    @Override
    public void delete(Employee employee) {
        this.getHibernateTemplate().delete(employee);
    }
}

//Department.java
package domain;

import java.util.HashSet;
import java.util.Set;

/**
 * 部门的实体
 */
public class Department {
    private int did;
    private String dname;
    private String ddesc;
    //员工的集合
    private Set<Employee> employees = new HashSet<>();

    public int getDid() {
        return did;
    }

    public void setDid(int did) {
        this.did = did;
    }

    public String getDname() {
        return dname;
    }

    public void setDname(String dname) {
        this.dname = dname;
    }

    public String getDdesc() {
        return ddesc;
    }

    public void setDdesc(String ddesc) {
        this.ddesc = ddesc;
    }

    public Set<Employee> getEmployees() {
        return employees;
    }

    public void setEmployees(Set<Employee> employees) {
        this.employees = employees;
    }
}

//Department.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="domain.Department" table="t_department">
        <id name="did" type="int" column="did">
            <generator class="native"/>
        </id>

        <property name="dname" type="java.lang.String" column="dname" length="20"/>
        <property name="ddesc" type="java.lang.String" column="ddesc" length="100"/>

        <!--关联关系映射-->
        <!--cascade="delete"才会级联删除从表-->
        <!--如果没有inverse="true"，说明双方都掌控维护权，导致部门修改时，员工不会同步修改；配置inverse="true"，让部门放弃维护权，则修改部门信息时，员工上的值会同步显示修改-->
        <set name="employees" cascade="delete" inverse="true">
            <key column="dno"/>
            <one-to-many class="domain.Employee"/>
        </set>
    </class>
</hibernate-mapping>

//Employee.java
package domain;

import java.util.Date;

/**
 * 员工的实体
 */
public class Employee {
    private int eid;
    private String ename;
    private String sex;
    private Date birthday;
    private Date joinDate;
    private String eno;
    private String username;
    private String password;
    //所属部门
    private Department department;

    public int getEid() {
        return eid;
    }

    public void setEid(int eid) {
        this.eid = eid;
    }

    public String getEname() {
        return ename;
    }

    public void setEname(String ename) {
        this.ename = ename;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public Date getJoinDate() {
        return joinDate;
    }

    public void setJoinDate(Date joinDate) {
        this.joinDate = joinDate;
    }

    public String getEno() {
        return eno;
    }

    public void setEno(String eno) {
        this.eno = eno;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Department getDepartment() {
        return department;
    }

    public void setDepartment(Department department) {
        this.department = department;
    }
}

//Employee.hbm.xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="domain.Employee" table="t_employee">
        <id name="eid" type="int" column="eid">
            <generator class="native"/>
        </id>

        <property name="ename" type="java.lang.String" column="ename" length="20"/>
        <property name="sex" type="java.lang.String" column="sex" length="10"/>
        <property name="birthday" type="date" column="birthday"/>
        <property name="joinDate" type="date" column="joinDate"/>
        <property name="eno" type="java.lang.String" column="eno" length="20"/>
        <property name="username" type="java.lang.String" column="username" length="20"/>
        <property name="password" type="java.lang.String" column="password" length="20"/>

        <!--https://blog.csdn.net/leisure_life/article/details/62229195-->
        <!-- 关联关系映射 在查询Employee值时，外键department默认lazy="true"，如果配置为lazy="false"则取消延迟加载，即立即加载，也可以直接在Web界面显示，推荐在web.xml配置过滤器的OpenSessionInViewFilter方式-->
        <!--这里如果参考视频教程配置了cascade="save-update"，则在save(employeer)的时候会更新department，而department的dname和ddesc并未在jsp中回填给employee，导致department表数据被清空-->
        <!--这里可以动态修改cascade="save-update"，说明hbm.xml文件并非只在建表时使用，在后续数据处理中也在使用-->
        <many-to-one name="department" cascade="save-update" class="domain.Department">
            <column name="dno" not-null="false"/>
        </many-to-one>
    </class>
</hibernate-mapping>

//PageBean.java
package domain;

import java.util.List;

/**
 * 分布封装的类
 */
public class PageBean<T> {
    private int currPage; //当前页数，list.jsp中的currPage变量是根据PageBean::getCurrentPage和setCurrentPage方法来读取和设置值的，与私有成员变量currPage无关
    private int pageSize; //每页显示的记录数
    private int totalCount; //总记录数
    private int totalPage; //总页数
    private List<T> pageDatas; //每页显示的数据

    public int getCurrPage() {
        return currPage;
    }

    public void setCurrPage(int currPage) {
        this.currPage = currPage;
    }

    public int getPageSize() {
        return pageSize;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    public int getTotalCount() {
        return totalCount;
    }

    public void setTotalCount(int totalCount) {
        this.totalCount = totalCount;
    }

    public int getTotalPage() {
        return totalPage;
    }

    public void setTotalPage(int totalPage) {
        this.totalPage = totalPage;
    }

    public List<T> getPageDatas() {
        return pageDatas;
    }

    public void setPageDatas(List<T> pageDatas) {
        this.pageDatas = pageDatas;
    }
}

//DepartmentService.java
package service;

import domain.Department;
import domain.PageBean;

import java.util.List;

/**
 * 部门管理的业务层的接口类
 */
public interface DepartmentService {
    PageBean<Department> findByPage(int currPage);

    void save(Department department);

    Department findById(int did);

    void update(Department department);

    void delete(Department department);

    List<Department> findAll();
}

//DepartmentServiceImpl.java
package service.impl;

import dao.DepartmentDao;
import domain.Department;
import domain.PageBean;
import service.DepartmentService;

import java.util.List;

import org.springframework.transaction.annotation.Transactional;

/**
 * 部门管理的业务层的实现类
 */
@Transactional
public class DepartmentServiceImpl implements DepartmentService {
    //自动注入
    private DepartmentDao departmentDao;
    private int pageSize;

    public void setDepartmentDao(DepartmentDao departmentDao) {
        this.departmentDao = departmentDao;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    //分页查询部分的方法
    @Override
    public PageBean<Department> findByPage(int currPage) {
        PageBean<Department> pageBean = new PageBean<>();
        //封装当前页数
        pageBean.setCurrPage(currPage);
        //封装每页显示记录数
        pageBean.setPageSize(pageSize);
        //封装总记录数：
        int totalCount = departmentDao.findCount();
        pageBean.setTotalCount(totalCount);
        //封装总页数
        double tc = totalCount;
        double num = Math.ceil(tc / pageSize);
        pageBean.setTotalPage((int) num);
        //封装每页显示的数据
        int begin = (currPage - 1) * pageSize;
        List<Department> pageDatas = departmentDao.findByPage(begin, pageSize);
        pageBean.setPageDatas(pageDatas);

        return pageBean;
    }

    //业务层保存部门的方法
    @Override
    public void save(Department department) {
        departmentDao.save(department);
    }

    //业务层根据部门ID查询部门的方法
    @Override
    public Department findById(int did) {
        return departmentDao.findById(did);
    }

    //业务层修改部门的方法
    @Override
    public void update(Department department) {
        departmentDao.update(department);
    }

    //业务层删除部门的方法
    @Override
    public void delete(Department department) {
        departmentDao.delete(department);
    }

    //查询所有部门的方法
    @Override
    public List<Department> findAll() {
        return departmentDao.findAll();
    }
}

//EmployeeService.java
package service;

import domain.Employee;
import domain.PageBean;

/**
 * 员工管理的业务层接口
 */
public interface EmployeeService {
    Employee login(Employee employee);

    PageBean<Employee> findByPage(int currPage);

    void save(Employee employee);

    Employee findById(int eid);

    void update(Employee employee);

    void delete(Employee employee);
}

//EmployeeServiceImpl.java
package service.impl;

import dao.EmployeeDao;
import domain.Employee;
import domain.PageBean;
import service.EmployeeService;

import java.util.List;

import org.springframework.transaction.annotation.Transactional;

/**
 * 员工管理的业务层实现类
 */
@Transactional
public class EmployeeServiceImpl implements EmployeeService {

    private EmployeeDao employeeDao;
    private int pageSize;

    public void setEmployeeDao(EmployeeDao employeeDao) {
        this.employeeDao = employeeDao;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    /**
     * 业务层的登录方法
     * @param employee
     * @return
     */
    @Override
    public Employee login(Employee employee) {
        Employee existEmployee = employeeDao.findByUsernameAndPassword(employee);
        return existEmployee;
    }

    @Override
    public PageBean<Employee> findByPage(int currPage) {
        PageBean<Employee> pageBean = new PageBean<>();
        //封装当前页数
        pageBean.setCurrPage(currPage);
        //封装每页显示记录数
        pageBean.setPageSize(pageSize);
        //封装总记录数：
        int totalCount = employeeDao.findCount();
        pageBean.setTotalCount(totalCount);
        //封装总页数
        double tc = totalCount;
        double num = Math.ceil(tc / pageSize);
        pageBean.setTotalPage((int) num);
        //封装每页显示的数据
        int begin = (currPage - 1) * pageSize;
        List<Employee> pageDatas = employeeDao.findByPage(begin, pageSize);
        pageBean.setPageDatas(pageDatas);

        return pageBean;
    }

    //业务层保存员工的方法
    @Override
    public void save(Employee employee) {
        employeeDao.save(employee);
    }

    //业务层根据员工ID查询员工的方法
    @Override
    public Employee findById(int eid) {
        return employeeDao.findById(eid);
    }

    //业务层修改员工的方法
    @Override
    public void update(Employee employee) {
        employeeDao.update(employee);
    }

    //业务层删除员工的方法
    @Override
    public void delete(Employee employee) {
        employeeDao.delete(employee);
    }
}

//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties,classpath:config.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!-- 配置Hibernate的相关属性 在启动服务时，会把表t_product创建起来-->
    <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <!-- 注入连接池 -->
        <property name="dataSource" ref="dataSource"/>
        <!-- 配置Hibernate的属性 -->
        <property name="hibernateProperties">
            <props>
                <!-- 这里如果不设置成MySQL5Dialect，则Hibernate生成建表语句时会加一句type=MyISAM，执行SQL时失败 https://blog.csdn.net/u014158770/article/details/66478060-->
                <!-- 改成5之后，建表语句最后为engine=MyISAM，但是此时建出来的表无法创建外键 https://blog.csdn.net/tongxinxiao/article/details/50617369 -->
                <!-- 修改言为MySQL55Dialect，建表语句最后为engine=InnoDB，此时可以正常增加外键 https://blog.csdn.net/tianyaleixiaowu/article/details/79468277-->
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</prop>
                <prop key="hibernate.show_sql">true</prop>
                <prop key="hibernate.format_sql">true</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
                <!-- https://blog.csdn.net/maoyuanming0806/article/details/61417995 -->
                <!-- 在hibernate5上不需要配置如下thread方式 -->
                <!--<prop key="hibernate.current_session_context_class">thread</prop>-->
                <!-- 或者配置如下 org.springframework.orm.hibernate5.SpringSessionContext -->
                <prop key="hibernate.current_session_context_class">org.springframework.orm.hibernate5.SpringSessionContext</prop>
            </props>
        </property>
        <!--配置Hibernate的映射文件-->
        <property name="mappingResources">
            <list>
                <value>domain/Department.hbm.xml</value>
                <value>domain/Employee.hbm.xml</value>
            </list>
        </property>
    </bean>

    <!-- 配置Action的类 -->
    <bean id="employeeAction" class="action.EmployeeAction" scope="prototype">
        <!-- 手动注入Service -->
        <property name="employeeService" ref="employeeService"/>
        <property name="departmentService" ref="departmentService"/>
    </bean>
    <bean id="departmentAction" class="action.DepartmentAction" scope="prototype">
        <property name="departmentService" ref="departmentService"/>
    </bean>

    <!-- 配置业务层的类 -->
    <bean id="employeeService" class="service.impl.EmployeeServiceImpl">
        <property name="employeeDao" ref="employeeDao"/>
        <property name="pageSize" value="${employee.pageSize}"/>
    </bean>
    <bean id="departmentService" class="service.impl.DepartmentServiceImpl">
        <property name="departmentDao" ref="departmentDao"/>
        <property name="pageSize" value="${department.pageSize}"/>
    </bean>

    <!-- 配置DAO的类 -->
    <bean id="employeeDao" class="dao.impl.EmployeeDaoImpl">
        <!-- 注入到抽象类HibernateDaoSupport中的sessionFactory -->
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>
    <bean id="departmentDao" class="dao.impl.DepartmentDaoImpl">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <!-- 开启注释事务 -->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>

//config.properties
department.pageSize=3
employee.pageSize=3

//jdbc.properties
jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8&useSSL=false
jdbc.username=root
jdbc.password=root123

//log4j.properties
log4j.rootLogger=DEBUG,A1
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
log4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
log4j.logger.org.hibernate.type.descriptor.sql.BasicExtractor=TRACE
log4j.logger.org.hibernate.SQL=DEBUG
log4j.logger.org.hibernate.engine.QueryParameters=DEBUG
log4j.logger.org.hibernate.engine.query.HQLQueryPlan=DEBUG
log4j.appender.STDOUT.Threshold=trace
log4j.category.org.hibernate.SQL=trace
log4j.category.org.hibernate.type=trace

//log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="warn">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="[%-5p] %d %c - %m%n" />
        </Console>
        <File name="File" fileName="dist/my.log">
            <PatternLayout pattern="%m%n" />
        </File>
    </Appenders>

    <Loggers>
        <Logger name="mh.sample2.Log4jTest2" level="INFO">
            <AppenderRef ref="File" />
        </Logger>
        <Root level="INFO">
            <AppenderRef ref="Console" />
        </Root>
    </Loggers>
</Configuration>

//struts.xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
        "http://struts.apache.org/dtds/struts-2.5.dtd">

<struts>

    <!-- 支持动态调用 -->
    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
    <!-- 设置开发模式 -->
    <constant name="struts.devMode" value="true"/>

    <!--包名 -->
    <package name="default" namespace="/" extends="struts-default">
        <action name="hello" class="action.HelloAction" method="hello">
            <result name="success">/hello.jsp</result>
        </action>
    </package>

    <package name="ssh" namespace="/" extends="struts-default">
        <global-allowed-methods>regex:.*</global-allowed-methods>
        <action name="employee_*" class="employeeAction" method="{1}">
            <result name="input">/login.jsp</result>
            <result name="success" type="redirect">/frame.jsp</result>
            <result name="findAll">/jsp/employee/listEmployee.jsp</result>
            <result name="saveUI">/jsp/employee/addEmployee.jsp</result>
            <result name="saveSuccess" type="redirectAction">employee_findAll</result>
            <result name="updateSuccess" type="redirectAction">employee_findAll</result>
            <result name="delelteSuccess" type="redirectAction">employee_findAll</result>
            <result name="editSuccess">/jsp/employee/editEmployee.jsp</result>
        </action>

        <action name="department_*" class="departmentAction" method="{1}">
            <result name="findAll">/jsp/department/listDepartment.jsp</result>
            <result name="saveUI">/jsp/department/addDepartment.jsp</result>
            <!--redirection后面为department_findAll或department_findAll.action都可以；chain只能为department_findAll，不能为action-->
            <result name="saveSuccess" type="redirectAction">department_findAll</result>
            <result name="updateSuccess" type="redirectAction">department_findAll</result>
            <result name="deleteSuccess" type="redirectAction">department_findAll</result>
            <result name="editSuccess">/jsp/department/editDepartment.jsp</result>
        </action>
    </package>
</struts>


//web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--Spring的框架的核心监听器-->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

    <!--配置此过滤器后，可以把employee的外键值加载显示在Web界面，否则为空-->
    <filter>
        <filter-name>OpenSessionInViewFilter</filter-name>
        <filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>OpenSessionInViewFilter</filter-name>
        <url-pattern>*.action</url-pattern>
    </filter-mapping>

    <!--Struts2的框架的核心过滤器的配置-->
    <filter>
        <filter-name>struts</filter-name>
        <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>struts</filter-name>
        <url-pattern>/*</url-pattern> */
    </filter-mapping>
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>webproject</groupId>
    <artifactId>webproject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <name>entity</name>
    <!-- FIXME change it to the project's website -->
    <url>http://www.example.com</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>1.7</maven.compiler.source>
        <maven.compiler.target>1.7</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>

        <!-- 添加mysql驱动依赖 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.11</version>
        </dependency>

        <!-- 添加hibernate依赖包 -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.3.2.Final</version>
        </dependency>

        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-core</artifactId>
            <version>2.5.16</version>
        </dependency>

        <dependency>
            <groupId>jstl</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>

        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-spring-plugin</artifactId>
            <version>2.5.16</version>
        </dependency>

        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.11.0</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.11.0</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.7</version>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.25</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>5.0.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.5.2</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-orm</artifactId>
            <version>5.0.7.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>5.0.7.RELEASE</version>
        </dependency>
    </dependencies>

    <build>
        <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
            <plugins>
                <plugin>
                    <artifactId>maven-clean-plugin</artifactId>
                    <version>3.0.0</version>
                </plugin>
                <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
                <plugin>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>3.0.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.7.0</version>
                </plugin>
                <plugin>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.20.1</version>
                </plugin>
                <plugin>
                    <artifactId>maven-jar-plugin</artifactId>
                    <version>3.0.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-install-plugin</artifactId>
                    <version>2.5.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-deploy-plugin</artifactId>
                    <version>2.8.2</version>
                </plugin>
            </plugins>
        </pluginManagement>

        <!--https://blog.csdn.net/swpu_lipan/article/details/78460852?utm_source=debugrun&utm_medium=referral
        https://www.cnblogs.com/machanghai/p/5456294.html-->
        <!--配置如下resources，才会把*.hbm文件拷贝到target目录，否则java中的配置文件不会拷贝，导致xxx.hbm.xml文件找不到的错误-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include> */
                </includes>
            </resource>
        </resources>
    </build>
</project>


//frame.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>员工管理系统</title>
</head>

<frameset rows="80,*">
    <frame name="top" src="${ pageContext.request.contextPath }/frame/top.jsp">
    <frameset cols="150,*" id="main">

        <frame src="${ pageContext.request.contextPath }/frame/left.jsp">
        <frame name="right" src="${ pageContext.request.contextPath }/frame/right.jsp">
    </frameset>
</frameset>
</html>

//index.jsp
<%@ page language="java" import="java.util.*" contentType="text/html; charset=utf-8"%>
<%
  String path = request.getContextPath();
  String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
  response.sendRedirect(path+"/login.jsp");
%>

//login.jsp
<%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>登陆</title>
<link type="text/css" rel="stylesheet" href="${ pageContext.request.contextPath }/style/reset.css">
<link type="text/css" rel="stylesheet" href="${ pageContext.request.contextPath }/style/main.css">
<!--[if IE 6]>
<script type="text/javascript" src="js/DD_belatedPNG_0.0.8a-min.js"></script>
<script type="text/javascript" src="js/ie6Fixpng.js"></script>
<![endif]-->
</head>

<body>
<div class="headerBar">
    <div class="logoBar login_logo">
        <div class="comWidth">
            <div class="logo fl">
                <a href="#"><img src="${ pageContext.request.contextPath }/images/logo.jpg" alt="慕课网"></a>
            </div>
            <h3 class="welcome_title">欢迎登陆</h3>
        </div>
    </div>
</div>
<s:form action="employee_login" method="post" namespace="/">
    <div class="loginBox">
        <h3><s:actionerror/></h3>
        <div class="login_cont">
            <ul class="login">
                <li class="l_tit">用户名</li>
                <li class="mb_10"><input type="text" name="username" class="login_input user_icon"></li>
                <li class="l_tit">密码</li>
                <li class="mb_10"><input type="text" name="password" class="login_input user_icon"></li>

                <li><input type="submit" value="" class="login_btn"></li>
            </ul>
            <div class="login_partners">
                <p class="l_tit">使用合作方账号登陆网站</p>
                <ul class="login_list clearfix">
                    <li><a href="#">QQ</a></li>
                    <li><span>|</span></li>
                    <li><a href="#">网易</a></li>
                    <li><span>|</span></li>
                    <li><a href="#">新浪微博</a></li>
                    <li><span>|</span></li>
                    <li><a href="#">腾讯微薄</a></li>
                    <li><span>|</span></li>
                    <li><a href="#">新浪微博</a></li>
                    <li><span>|</span></li>
                    <li><a href="#">腾讯微薄</a></li>
                </ul>
            </div>
        </div>

    </div>
</s:form>

<div class="hr_25"></div>
<div class="footer">
    <p><a href="#">慕课简介</a><i>|</i><a href="#">慕课公告</a><i>|</i> <a href="#">招纳贤士</a><i>|</i><a href="#">联系我们</a><i>|</i>客服热线：400-675-1234</p>
    <p>Copyright &copy; 2006 - 2014 慕课版权所有&nbsp;&nbsp;&nbsp;京ICP备09037834号&nbsp;&nbsp;&nbsp;京ICP证B1034-8373号&nbsp;&nbsp;&nbsp;某市公安局XX分局备案编号：123456789123</p>
    <p class="web"><a href="#"><img src="${ pageContext.request.contextPath }/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="${ pageContext.request.contextPath }/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="${ pageContext.request.contextPath }/images/webLogo.jpg" alt="logo"></a><a href="#"><img src="${ pageContext.request.contextPath }/images/webLogo.jpg" alt="logo"></a></p>
</div>
</body>
</html>

//addDepartment.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<html>
<head></head>
<body>
<table border="0" width="600px">
    <tr>
        <td align="center" style="font-size:24px; color:#666"> 部门添加</td>
    </tr>
    <tr>
        <td align="right">
            <a href="javascript:document.getElementById('saveForm').submit()">保存</a> &nbsp;&nbsp;
            <a href="javascript:history.go(-1)">退回</a>
        </td>
    </tr>
</table>
<br/>
<br>
<s:form id="saveForm" action="department_save" method="post" namespace="/" theme="simple">
    <table style="font-size:16px">
        <tr>
            <td>部门名称：</td>
            <td><s:textfield name="dname"/></td>
        </tr>
        <tr>
            <td>部门介绍：</td>
            <td></td>
        </tr>
        <tr>
            <td width="10%"></td>
            <td>
                <s:textarea name="ddesc" cols="50" rows="5"></s:textarea>
            </td>
        </tr>
    </table>
</s:form>
</body>
</html>

//editDepartment.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<html>
<head></head>
<body>
<table border="0" width="600px">
    <tr>
        <td align="center" style="font-size:24px; color:#666"> 部门编辑</td>
    </tr>
    <tr>
        <td align="right">
            <a href="javascript:document.getElementById('saveForm').submit()">保存</a> &nbsp;&nbsp;
            <a href="javascript:history.go(-1)">退回</a>
        </td>
    </tr>
</table>
<br/>
<br>
<s:form id="saveForm" action="department_update" method="post" namespace="/" theme="simple">
    <s:hidden name="did" value="%{model.did}"/>
    <table style="font-size:16px">
        <tr>
            <td>部门名称：</td>
            <td><s:textfield name="dname" value="%{model.dname}"/></td>
        </tr>
        <tr>
            <td>部门介绍：</td>
            <td></td>
        </tr>
        <tr>
            <td width="10%"></td>
            <td>
                <s:textarea name="ddesc" cols="50" rows="5" value="%{model.ddesc}"></s:textarea>
            </td>
        </tr>
    </table>
</s:form>
</body>
</html>

//listDepartment.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<html>
<head>
    <style type="text/css">
        .table1 {
            border: 1px solid #ddd;
            width: 900px;
        }

        thead {
            background-color: lightblue;
        }

    </style>
</head>
<body>
<table border="0" width="900px">
    <tr>
        <td align="center" style="font-size:24px; color:#666">部门管理</td>
    </tr>
    <tr>
        <td align="right"><a href="${ pageContext.request.contextPath }/department_saveUI.action">添加</a></td>
    </tr>
</table>
<br/>
<table cellspacing="0" border="1" class="table1">
    <thead>
    <tr>
        <th width="40%">部门名称</th>
        <th width="40%">部门描述</th>
        <th width="10%">编辑</th>
        <th width="10%">删除</th>
    </tr>
    </thead>
    <tbody>
    <s:iterator value="pageDatas" var="d">
    <tr>
        <td align="center"><s:property value="#d.dname"/></td>
        <td align="center"><s:property value="#d.ddesc"/></td>
        <td align="center"><a href="${ pageContext.request.contextPath }/department_edit.action?did=<s:property value="#d.did"/>"><img src="${ pageContext.request.contextPath }/images/编辑.png"></a></td>
        <td align="center"><a href="${ pageContext.request.contextPath }/department_delete.action?did=<s:property value="#d.did"/>" onclick="javascript: return confirm('真的要删除吗？');"><img src="${ pageContext.request.contextPath }/images/删除.png"></a></td>
    </tr>
    </s:iterator>
    </tbody>
</table>
<br/>


<table border="0" cellspacing="0" cellpadding="0" width="900px">
    <tr>
        <td align="right">
            <span>第<s:property value="currPage"/>/<s:property value="totalPage"/>页</span>&nbsp;&nbsp;
            <span>总记录数：<s:property value="totalCount"/>&nbsp;&nbsp;每页显示：<s:property value="pageSize"/></span>&nbsp;&nbsp;
            <%--<span>总记录数：<s:property value="totalCount"/>&nbsp;&nbsp;每页显示：--%>
                <%--<s:select name="pageSizeSelect" list="#{'10':'5', '20':'10'}" value="20"/>--%>
            <%--</span>&nbsp;&nbsp;--%>
            <span>
            <s:if test="currPage != 1">
                <a href="${ pageContext.request.contextPath }/department_findAll.action?currPage=1">[首页]</a>&nbsp;&nbsp;
                <a href="${ pageContext.request.contextPath }/department_findAll.action?currPage=<s:property value="currPage - 1"/>">[上一页]</a>&nbsp;&nbsp;
            </s:if>
            <s:if test="currPage != totalPage">
                <a href="${ pageContext.request.contextPath }/department_findAll.action?currPage=<s:property value="currPage + 1"/>">[下一页]</a>&nbsp;&nbsp;
                <%--<a href="<s:url action="department_findAll.action">--%>
                        <%--<s:param name="currPage" value="currPage + 1"/>--%>
                        <%--<s:param name="newPageSize" value="javascript:document.getElementById('pageSizeSelect').value"/>--%>
                    <%--</s:url>">[下一页]</a>&nbsp;&nbsp;--%>
                <a href="${ pageContext.request.contextPath }/department_findAll.action?currPage=<s:property value="totalPage"/>">[尾页]</a>&nbsp;&nbsp;
            </s:if>
            </span>
        </td>
    </tr>
</table>
</body>
</html>

//addEmployee.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<html>
<head></head>
<body>
<table border="0" width="600px">
    <tr>
        <td align="center" style="font-size:24px; color:#666"> 员工添加</td>
    </tr>
    <tr>
        <td align="right">
            <a href="javascript:document.getElementById('saveForm').submit()">保存</a>&nbsp;&nbsp;
            <a href="javascript:history.go(-1)">退回</a>
        </td>
    </tr>
</table>
<br/>

<s:form action="employee_save" id="saveForm" method="post" namespace="/" theme="simple">
<table border='0' cellpadding="0" cellspacing="10">
    <tr>
        <td>姓名：</td>
        <td><s:textfield name="ename"/></td>
        <td>性别：</td>
        <td><s:radio name="sex" list="{'男', '女'}" value="'男'"/></td>
    </tr>
    <tr>
        <td>用户名：</td>
        <td><s:textfield name="username"/></td>
        <td>密码：</td>
        <td><s:password name="password"/></td>
    </tr>
    <tr>
        <td>出生日期：</td>
        <td><s:textfield name="birthday"/></td>
        <td>入职时间：</td>
        <td><s:textfield name="joinDate"/></td>
    </tr>

    <tr>
        <td>所属部门：</td>
        <td><s:select name="department.did" list="departments" listKey="did" listValue="dname" headerKey="" headerValue="--请选择--"/></td>
        <td>编号：</td>
        <td><s:textfield name="eno"/></td>
    </tr>
</table>
</s:form>
</body>
</html>

//editEmployee.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<html>
<head></head>
<body>
<table border="0" width="600px">
    <tr>
        <td align="center" style="font-size:24px; color:#666"> 员工添加</td>
    </tr>
    <tr>
        <td align="right">
            <a href="javascript:document.getElementById('saveForm').submit()">保存</a>&nbsp;&nbsp;
            <a href="javascript:history.go(-1)">退回</a>
        </td>
    </tr>
</table>
<br/>

<s:form action="employee_update" id="saveForm" method="post" namespace="/" theme="simple">
<s:hidden name="eid" value="%{model.eid}"/>
    <table border='0' cellpadding="0" cellspacing="10">
    <tr>
        <td>姓名：</td>
        <td><s:textfield name="ename" value="%{model.ename}"/></td>
        <td>性别：</td>
        <td><s:radio name="sex" list="{'男', '女'}" value="%{model.sex}"/></td>
    </tr>
    <tr>
        <td>用户名：</td>
        <td><s:textfield name="username" value="%{model.username}"/></td>
        <td>密码：</td>
        <td><s:password name="password" value="%{model.password}" showPassword="true"/></td>
    </tr>
    <tr>
        <td>出生日期：</td>
        <td><input type="text" name="birthday" value="<s:date name="model.birthday" format="yyyy-MM-dd"/>"/></td>
        <td>入职时间：</td>
        <td><input type="text" name="joinDate" value="<s:date name="model.joinDate" format="yyyy-MM-dd"/>"/></td>
    </tr>

    <tr>
        <td>所属部门：</td>
        <td><s:select name="department.did" list="departments" value="%{model.department.did}" listKey="did" listValue="dname" headerKey="" headerValue="--请选择--"/></td>
        <td>编号：</td>
        <td><s:textfield name="eno" value="%{model.eno}"/></td>
    </tr>
</table>
</s:form>
</body>
</html>

//listEmployee.jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="/struts-tags" prefix="s"%>
<html>
<head>
    <style type="text/css">
        .table1{
            border:1px solid #ddd;
            width:900px;

        }
        thead{
            background-color:lightblue;
        }

    </style>
</head>
<body>
<table border="0" width="900px">
    <tr>
        <td align="center" style="font-size:24px; color:#666"> 员工管理</td>
    </tr>
    <tr>
        <td align="right" > <a href="${ pageContext.request.contextPath }/employee_saveUI.action">添加</a></td>
    </tr>
</table>
<br/>


<table cellspacing="0" border="1" class="table1">
    <thead>
    <tr>
        <td align="center">编号</td>
        <td align="center">员工姓名</td>
        <td align="center">性别</td>
        <td align="center">出生日期</td>
        <td align="center">入职时间</td>
        <td align="center">所属部门</td>
        <td align="center">编辑</td>
        <td align="center">删除</td>
    </tr>
    </thead>
    <tbody>
    <s:iterator value="pageDatas" var="e">
    <tr>
        <td align="center"><s:property value="#e.eno"/></td>
        <td align="center"><s:property value="#e.ename"/></td>
        <td align="center"><s:property value="#e.sex"/></td>
        <td align="center"><s:date name="#e.birthday" format="yyyy-MM-dd"/></td>
        <td align="center"><s:date name="#e.joinDate" format="yyyy-MM-dd"/></td>
        <td align="center"><s:property value="#e.department.dname"/></td>
        <td align="center"><a href="${ pageContext.request.contextPath }/employee_edit.action?eid=<s:property value="#e.eid"/>"><img src="${ pageContext.request.contextPath }/images/编辑.png"></a></td>
        <td align="center"><a href="${ pageContext.request.contextPath }/employee_delete.action?eid=<s:property value="#e.eid"/>" onclick="javascript: return confirm('真的要删除吗？');"><img src="${ pageContext.request.contextPath }/images/删除.png"></a></td>
    </tr>
    </s:iterator>
    </tbody>
</table>
<br/>

<table table border="0" cellspacing="0" cellpadding="0" width="900px">
    <tr>
        <td align="right">
            <span>第<s:property value="currPage"/>/<s:property value="totalPage"/>页</span>&nbsp;&nbsp;
            <span>总记录数：<s:property value="totalCount"/>&nbsp;&nbsp;每页显示：<s:property value="pageSize"/></span>&nbsp;&nbsp;
            <span>
            <s:if test="currPage != 1">
                <a href="${ pageContext.request.contextPath }/employee_findAll.action?currPage=1">[首页]</a>&nbsp;&nbsp;
                <a href="${ pageContext.request.contextPath }/employee_findAll.action?currPage=<s:property value="currPage - 1"/>">[上一页]</a>&nbsp;&nbsp;
            </s:if>
            <s:if test="currPage != totalPage">
                <a href="${ pageContext.request.contextPath }/employee_findAll.action?currPage=<s:property value="currPage + 1"/>">[下一页]</a>&nbsp;&nbsp;
                <a href="${ pageContext.request.contextPath }/employee_findAll.action?currPage=<s:property value="totalPage"/>">[尾页]</a>&nbsp;&nbsp;
            </s:if>
            </span>
        </td>
    </tr>
</table>
</body>
</html>
//------------------------------------------------------------------------------------------------
//Spring事务管理课程 https://www.imooc.com/video/9323
事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。

事务的特性：原子性、一致性、隔离性、持久性

原子性是的指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
一致性指事务前后数据的完整性必须保持一致。
隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离。
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即便数据库发生故障也不应该对其有任何影响。
//------------------------------------------------------------------------------------------------
//3-1 接口介绍
Spring事务管理
Spring事务管理高层抽象主要包括3个接口：
--PlatformTransactionManager
事务管理器
--TransactionDefinition
事务定义信息（隔离、传播、超时、只读）
--TransactionStatus
事务具体运行状态

//------------------------------------------------------------------------------------------------
//3-2 事务管理器PlatformTransactionManager
Spring为不同的持久化框架提供了不同的PlatTransactionManager接口实现
//------------------------------------------------------------------------------------------------
//3-3 事务隔离级别（四种）
隔离级别：
DEFAULT/READ_UNCOMMITED/READ_COMMITTED/REPEATABLE_READ/SERIALIZABLE
//------------------------------------------------------------------------------------------------
//3-4 TransactionDefinition定义事务传播行为
//------------------------------------------------------------------------------------------------
//3-5 TransactionStatus事务状态
//------------------------------------------------------------------------------------------------
//4-1 转账环境搭建
Spring支持两种方式事务管理
――编程式的事务管理
--在实际应用中很少使用
--通过TransactionTemplate手动管理事务
――使用XML配置声明式事务
--开发中推荐使用（代码侵入性最小）
--Spring的声明式事务是通过AOP实现的

//AccountService.java
package cn.muke.spring.demo1;
/**
 * 转账安全的业务层接口
 */
public interface AccountService {
    /**
     * @param out：转出账号
     * @param in：转入账号
     * @param money：转账金额
     */
    void transfer(String out, String in, double money);
}

//AccountServiceImpl.java
package cn.muke.spring.demo1;

/**
 * 转账安全的业务层实现类
 */
public class AccountServiceImpl implements AccountService {
    // 注入转账的Dao的类
    private AccountDao accountDao;

    public void setAccountDao(AccountDaoImpl accountDao) {
        this.accountDao = accountDao;
    }

    /**
     * @param out：转出账号
     * @param in：转入账号
     * @param money：转账金额
     */
    @Override
    public void transfer(String out, String in, double money) {
        accountDao.outMoney(out, money);
        //int i = 1 / 0;//测试抛出异常，钱是否转出账户，是否转入账户
        accountDao.inMoney(in, money);
    }
}


//AccountDao.java
package cn.muke.spring.demo1;

/**
 * 转账案例的DAO层的接口
 */
public interface AccountDao {
    /**
     * @param out：转出账号
     * @param money：转出金额
     */
    void outMoney(String out, double money);

    /**
     * @param in：转入账号
     * @param money：转入金额
     */
    void inMoney(String in, double money);
}

//AccountDaoImpl.java
package cn.muke.spring.demo1;

import org.springframework.jdbc.core.support.JdbcDaoSupport;

/**
 * 转账案例的DAO层的实现类
 */
public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {
    /**
     * @param out：转出账号
     * @param money：转出金额
     */
    @Override
    public void outMoney(String out, double money) {
        String sql = "update account set money = money - ? where name = ?";
        this.getJdbcTemplate().update(sql, money, out);
    }

    /**
     * @param in：转入账号
     * @param money：转入金额
     */

    @Override
    public void inMoney(String in, double money) {
        String sql = "update account set money = money + ? where name = ?";
        this.getJdbcTemplate().update(sql, money, in);
    }
}

//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
    
    <!--<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>-->

    <!--配置业务层类-->
    <bean id="accountService" class="cn.muke.spring.demo1.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>
    <!--配置DAO的类-->
    <bean id="accountDao" class="cn.muke.spring.demo1.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>
</beans>

//jdbc.properties
jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8&useSSL=false
jdbc.username=root
jdbc.password=root123

//测试 AccountServiceTest.java
package cn.muke.spring.demo1;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * 转账案例的测试类
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class AccountServiceTest {

    // 测试业务层类：
    @Resource(name = "accountService")
    private AccountService accountService;

    @Test
    public void testTransfer() {
        accountService.transfer("aaa", "bbb", 200);
    }
}

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>webproject</groupId>
    <artifactId>webproject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <name>entity</name>
    <url>http://www.example.com</url>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>1.7</maven.compiler.source>
        <maven.compiler.target>1.7</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>

        <!-- 添加mysql驱动依赖 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.12</version>
        </dependency>

        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.5.2</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.0.9.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.0.9.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.0.9.RELEASE</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.0.9.RELEASE</version>
        </dependency>

        <dependency>
            <groupId>aopalliance</groupId>
            <artifactId>aopalliance</artifactId>
            <version>1.0</version>
        </dependency>

        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.1</version>
        </dependency>
    </dependencies>

    <build>
        <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
            <plugins>
                <plugin>
                    <artifactId>maven-clean-plugin</artifactId>
                    <version>3.0.0</version>
                </plugin>
                <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging -->
                <plugin>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>3.0.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.7.0</version>
                </plugin>
                <plugin>
                    <artifactId>maven-surefire-plugin</artifactId>
                    <version>2.20.1</version>
                </plugin>
                <plugin>
                    <artifactId>maven-jar-plugin</artifactId>
                    <version>3.0.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-install-plugin</artifactId>
                    <version>2.5.2</version>
                </plugin>
                <plugin>
                    <artifactId>maven-deploy-plugin</artifactId>
                    <version>2.8.2</version>
                </plugin>
            </plugins>
        </pluginManagement>

        <!--https://blog.csdn.net/swpu_lipan/article/details/78460852?utm_source=debugrun&utm_medium=referral
        https://www.cnblogs.com/machanghai/p/5456294.html-->
        <!--配置如下resources，才会把*.hbm文件拷贝到target目录，否则java中的配置文件不会拷贝，导致xxx.hbm.xml文件找不到的错误-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include> */
                </includes>
                <filtering>true</filtering>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                </includes>
            </resource>
        </resources>
    </build>
</project>


//------------------------------------------------------------------------------------------------
//5-1 编程式的事务管理 https://www.imooc.com/video/9331
--在AccountService中使用TransactionTemplate
--TransactionTemplate依赖DataSourceTransactionManager
--DataSourceTransactionManager依赖DataSource构造

<bean id="accountService" class="cn.muke.spring.demo1.AccountServiceImpl">
    <property name="accountDao" ref="accountDao"/>
    <property name="transactionTemplate" ref="transactionTemplate"/>
</bean>

<!--配置事务管理的模板：Spring为了简化事务管理的代码而提供的类-->
<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
    <property name="transactionManager" ref="transactionManager"/>
</bean>

<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>


//AccountServiceImpl.java
package cn.muke.spring.demo1;

import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

/**
 * 转账安全的业务层实现类
 */
public class AccountServiceImpl implements AccountService {
    // 注入转账的Dao的类
    private AccountDao accountDao;

    public void setAccountDao(AccountDaoImpl accountDao) {
        this.accountDao = accountDao;
    }

    // 注入事务管理的模板
    private TransactionTemplate transactionTemplate;

    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    /**
     * @param out：转出账号
     * @param in：转入账号
     * @param money：转账金额
     */
    @Override
    public void transfer(final String out, final String in, final double money) {
        //要么全部成功，要么失败则回滚
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
                accountDao.outMoney(out, money);
                int i = 1 / 0;//测试抛出异常，钱是否转出账户，是否转入账户
                accountDao.inMoney(in, money);
            }
        });
    }
}

//applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">-->
        <!--<property name="dataSource" ref="dataSource"/>-->
    <!--</bean>-->

    <!--配置业务层类-->
    <bean id="accountService" class="cn.muke.spring.demo1.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="transactionTemplate" ref="transactionTemplate"/>
    </bean>
    <!--配置DAO的类-->
    <bean id="accountDao" class="cn.muke.spring.demo1.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>


    <!-- 配置事务管理器 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置事务管理的模板：Spring为了简化事务管理的代码而提供的类-->
    <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>
</beans>
//------------------------------------------------------------------------------------------------
//6-1 声明式事务管理方式一：基于TransactionProxyFactoryBean

//AccountServiceTest2.java
package cn.muke.spring.demo2;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Spring的声明式事务管理的方式一的测试类
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext2.xml")
public class AccountServiceTest2 {
    /**
     * 注入代理类：因为代理类进行增强的操作
     */
//    @Resource(name = "accountService")
    @Resource(name = "accountServiceProxy")
    private AccountService accountService;

    /**
     * 转账案例
     */
    @Test
    public void testTransfer() {
        accountService.transfer("aaa", "bbb", 200);
    }
}

//applicationContext2.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置业务层类-->
    <bean id="accountService" class="cn.muke.spring.demo2.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>
    <!--配置DAO的类-->
    <bean id="accountDao" class="cn.muke.spring.demo2.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置业务层的代理，对accountService进行增加过的代理类，基于AOP的方式-->
    <bean id="accountServiceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
        <!--配置目标对象-->
        <property name="target" ref="accountService"/>
        <!--注入事务管理器-->
        <property name="transactionManager" ref="transactionManager"/>
        <!--注入事务属性-->
        <property name="transactionAttributes">
            <props>
                <!--prop的格式 key="insert*"/"update*"/"*"
                    * PROPAGATION：事务的传播行为。
                    * ISOLATION：事务的隔离级别。
                    * readOnly：只读。（不可以修改、插入、删除）
                    * -Exception：发生哪些异常回滚事务。
                    * +Exception：发生哪些异常事务不回滚。
                -->
                <!--如果增加readOnly属性，如：PROPAGATION_REQUIRED,readOnly，则就算没有异常，转账也会异常，提示Connection is read-only. Queries leading to data modification are not allowed-->
                <!--如果增加异常，如PROPAGATION_REQUIRED,+ArithmeticException，则就算发生算术异常，事务也不回滚，则钱会转丢-->
                <prop key="transfer">PROPAGATION_REQUIRED</prop>
            </props>
        </property>
    </bean>
</beans>
//------------------------------------------------------------------------------------------------
//6-2 声明式事务管理方式二：基于AspectJ的XML方式
--引入aop和tx命名空间

//AccountServiceTest3.java
package cn.muke.spring.demo3;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Spring的声明式事务的方式二：基于AspectJ的XML方式配置。
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext3.xml")
public class AccountServiceTest3 {
    /**
     * 转账案例
     */
    @Resource(name = "accountService")
    private AccountService accountService;

    @Test
    public void testTransfer() {
        accountService.transfer("aaa", "bbb", 200);
    }
}

//需要在pom.xml中增加aspectjweaver的配置

//applicationContext3.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置业务层类-->
    <bean id="accountService" class="cn.muke.spring.demo3.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>
    <!--配置DAO的类-->
    <bean id="accountDao" class="cn.muke.spring.demo3.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置事务的通知：（事务的增强）-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <!--
                propagation:事务传播行为
                isolation:事务隔离级别
                read-only:只读
                rollback-for:发生哪些异常回滚
                no-rollback-for:发生哪些异常不回滚
                timeout:过期信息
            -->
            <tx:method name="transfer" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>

    <!--配置切面-->
    <aop:config>
        <!--配置切入点-->
        <aop:pointcut id="pointcut1" expression="execution(* cn.muke.spring.demo3.AccountService+.*(..))"/>
        <!--配置切面-->
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1"/>
    </aop:config>
</beans>
//------------------------------------------------------------------------------------------------
//6-3 声明式事务管理方式三：基于注解的方式

//AccountServiceTest4.java
package cn.muke.spring.demo4;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Spring的声明式事务管理的方式三：基于注释的事务管理的方式
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext4.xml")
public class AccountServiceTest4 {

    @Resource(name = "accountService")
    private AccountService accountService;

    /**
     * 转账案例
     */
    @Test
    public void testTransfer() {
        accountService.transfer("aaa", "bbb", 200);
    }
}

//applicationContext4.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!-- 引入外部的属性文件 https://blog.csdn.net/sf_climber/article/details/78850038-->
    <context:property-placeholder location="classpath:jdbc.properties"/>
    <!-- 配置连接池 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

    <!--配置业务层类-->
    <bean id="accountService" class="cn.muke.spring.demo4.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>
    <!--配置DAO的类-->
    <bean id="accountDao" class="cn.muke.spring.demo4.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--开启注解事务，配置了这个配置项之后，才能通过注释来管理事务-->
    <tx:annotation-driven transaction-manager="transactionManager"/>
</beans>

//AccountServiceImpl.java
package cn.muke.spring.demo4;

/**
 * 转账安全的业务层实现类
 */

import org.springframework.transaction.annotation.Transactional;

/**
 * @Transactional注解中的属性：
 *  propagation:事务中的传播行为
 *  isolation:事务的隔离级别
 *  readOnly:只读
 *  rollbackFor:发生哪些异常回滚
 *  noRollbackFor:发生哪些异常不回滚
 */
//@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = true)
@Transactional
public class AccountServiceImpl implements AccountService {
    // 注入转账的Dao的类
    private AccountDao accountDao;

    public void setAccountDao(AccountDaoImpl accountDao) {
        this.accountDao = accountDao;
    }

    /**
     * @param out：转出账号
     * @param in：转入账号
     * @param money：转账金额
     */
    @Override
    public void transfer(String out, String in, double money) {
        accountDao.outMoney(out, money);
//        int i = 1 / 0;//测试抛出异常，钱是否转出账户，是否转入账户
        accountDao.inMoney(in, money);
    }
}

//------------------------------------------------------------------------------------------------
//7-1 课程总结 https://www.imooc.com/video/9335
Spring将事务分成了两类：
--编程式事务管理：
    *手动编写代码进行事务管理（很少使用）
--声明式事务管理：
    *基于TransactionProxyFactoryBean的方式（很少使用，配置和管理比较麻烦）
        *需要为每个进行事务管理的类，配置一个TransactionProxyFactoryBean进行增强。
    *基于AspectJ的XML方式（经常使用，XML看起来比较清晰）
        *一旦配置好之后，类上不需要添加任何东西
    *基于注解方式（经常使用）
        *配置简单，但是需要在业务层类上添加一个@Transactional的注释
//------------------------------------------------------------------------------------------------
//1-1 Redis入门 https://www.imooc.com/video/14924

什么是NoSQL？
--NoSQL =  Not Only SQL
--非关系型的数据库

为什么需要NoSQL
--High Performance-高并发读写
--Huge Storage-海量数据的高效率存储和访问
--High Scalability && High Availablity-高可扩展性和高可用性

NoSQL数据库的四大分类
--键值（Key-Value）存储
--列存储
--文档数据库
--图形数据库

NoSQL的特点
--易扩展
--灵活的数据模型
--大数据量，高性能
--高可用
//------------------------------------------------------------------------------------------------
3-1 Redis的概述
高性能键值对数据库，支持的键值数据类型：
--字符串类型
--列表类型
--有序集合类型
--散列类型
--集合类型

Redis的应用场景：
--缓存
--任务队列
--网站访问统计
--数据过期处理
--应用排行榜
--分布式集群架构中的session分离
//------------------------------------------------------------------------------------------------
//5-1 Jedis入门 https://www.imooc.com/video/14927
*Jedis是Redis官方首先的Java客户端开发包

<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>2.9.0</version>
</dependency>

//JedisTest.java
package com.imooc.jedis;


import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class JedisTest {
    /**
     * 单实例的测试
     */
    @Test
    public void testJedisInstance() {
        //1. 设置IP地址和端口
        Jedis jedis = new Jedis("192.168.100.129", 6379);
        //2. 保存数据
        jedis.set("name", "imooc");
        //3. 获取数据
        String value = jedis.get("name");
        assertEquals("imooc", value);
    }

    /**
     * 连接池方式连接
     */
    @Test
    public void testJedisPool() {
        //获得连接池的配置对象
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        //设置最大连接数
        jedisPoolConfig.setMaxTotal(30);
        //设置最大空闲连接数
        jedisPoolConfig.setMaxIdle(10);

        // 获得连接池
        // 通过连接池获得连接，获得核心对象
        try (JedisPool jedisPool = new JedisPool(jedisPoolConfig, "192.168.100.129", 6379);
             Jedis jedis = jedisPool.getResource()) {
            //设置数据
            jedis.set("name", "张三");
            String value = jedis.get("name");
            assertEquals("张三", value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

用宿主机访问虚拟机Linux：
说明：默认情况下，如果没有没有开防火墙（ubuntu系统是ufw，通过sudo ufw status来查看），则可以在宿主机直接访问虚拟机系统。
但是由于redis默认只绑定了本机端口127.0.0.1 ，所以需要把配置文件redis.conf里的：bind 127.0.0.1 。该行注释掉，同时把：protected-mode yes修改为protected-mode no
再启动redis服务：./bin/redis-server ./redis.conf
即可正常访问。
（参考：https://blog.csdn.net/nocol123/article/details/74356752 https://blog.csdn.net/rangf/article/details/41733533）

//------------------------------------------------------------------------------------------------
//6-1 Redis的数据结构之字符串
五种数据类型：
*字符串（String）
*字符串列表（list）
*有序字符串集合（sorted set）
*哈希（hash）
*字符串集合（set）

Key定义的注意点：
*不要过长（最好不要超过1024个字节）
*不要过短
*统一的命名规范

存储String：
*二进制案例的，存入和获取的数据相同
*Value最多可以容纳的数据长度是512M

存储String常用命令
*赋值 set
*删除 del
*取值 get getset
*扩展命令 append
*数值增减 incr decr incrby decrby

//------------------------------------------------------------------------------------------------
//6-2 Redis的数据结构之哈希
存储Hash：
*String Key和String Value的map容器
*每一个Hash可以存储4294967295个键值对

存储Hash常用命令：
*赋值
*删除
*自学命令
*取值
*增加数字
//------------------------------------------------------------------------------------------------
//6-3 Redis的数据结构之list
存储list：
*ArrayList使用数组方式
*LinkedList使用双向链接方式
*双向链表中增加数据
*双向链表中删除数据

存储list常用命令：
*两端添加
*查看列表
*两端弹出
*获取列表元素个数
*扩展命令
//------------------------------------------------------------------------------------------------
//6-4 Redis的数据结构之set
存储Set
*和List类型不同的是，Set集合中不允许出现重复的元素
*可以做集合操作，如交集，差集，并集等
*Set可包含的最大元素数量是4294967295

存储set常用命令：
*添加/删除元素
*获得集合中的元素
*集合中的差集运算
*集合中的交集运算
*集合中的并集运算
*扩展命令

存储Set使用场景：
*跟踪一些唯一性数据
*用于维护数据对象之间的关联关系
//------------------------------------------------------------------------------------------------
//6-5 Redis的数据结构之Sorted-Set
存储Sorted-Set
*Sorted-Set和Set的区别
*Sorted-Set中的成员在集合中的位置是有序的

存储Sorted-Set常用命令：
*添加元素
*获得元素
*删除元素
*范围查询
*扩展命令

Sorted-Set使用场景：
*如大型在线游戏积分排行榜
*构建索引数据
//------------------------------------------------------------------------------------------------
//7-1 Redis的Keys的通用操作
get keys rename 等
//------------------------------------------------------------------------------------------------
//8-1 Redis的特性
*多数据库
有0-15 号共16个数据库，默认连接0号数据库，可以用select 0 来选择特定数据库。

*Redis事务
multi：开启事务
exec：提交事务
discard：回滚事务
//------------------------------------------------------------------------------------------------
//9-1 Redis的持久化的概述
两种持久化方式
*RDB方式
*AOF方式

持久化使用的方式：
*RDB持久化：定时写入硬盘
*AOF持久化：将操作写入日志，下次启redis服务时就将数据加载起来
*无持久化：单纯的缓存功能
*同时使用RDB和AOF
//------------------------------------------------------------------------------------------------
//9-2 Redis的持久化的RDB方式
RDB
*优势：
整个Redis数据库只包括一个硬盘文件
性能最大化，启服务时只起几个子进程，定时写硬盘
*劣势：
无法满足数据高可用性，可能会丢失数据
子进程来写硬盘，如果数据集过大的时候可能会影响主服务运行几百毫秒到一秒
//redis.conf
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#
#   Note: you can disable saving completely by commenting out all "save" lines.
#
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty string argument
#   like in the following example:
#
#   save ""

save 900 1
save 300 10
save 60 10000

把这三行注释掉之后，再启动redis服务，则所有设置的值，只能作缓存用。
在服务停掉之后，都会丢失掉了。
//------------------------------------------------------------------------------------------------
//9-3 Redis的持久化的AOF的方式
AOF
*优势：
--每一秒写入日志
--每次修改都写入日志：效率低，但是案例
--不同步

包含一个格式清晰，易于修改的日志文件

*劣势：
相同数据集，日志文件较RDB大
效率低于RDB

############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check http://redis.io/topics/persistence for more information.

appendonly no

# The name of the append only file (default: "appendonly.aof")

appendfilename "appendonly.aof"

# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no

修改appendonly no为yes即开启了AOF持久化方式。另外建议将使用appendfsync always方式。

可以修改生成的appendonly.aof文件，来修改持久化数据，当redis服务下次重启时，就会加载修改后日志文件数据。
//------------------------------------------------------------------------------------------------
//使用Jedis操作Redis样例 <https://blog.csdn.net/zmx729618/article/details/56670800>
//JedisTest.java
package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.junit.Test;

public class JedisTest {
    //1. 设置IP地址和端口
    private Jedis jedis = new Jedis("192.168.100.128", 6379);

    /**
     * redis存储字符串
     */
    @Test
    public void testString() {
        //-----添加数据----------
        jedis.set("name", "xinxin");//向key-->name中放入了value-->xinxin
        System.out.println(jedis.get("name"));//执行结果：xinxin

        jedis.append("name", " is my lover"); //拼接
        System.out.println(jedis.get("name"));

        jedis.del("name");  //删除某个键
        System.out.println(jedis.get("name"));
        //设置多个键值对
        jedis.mset("name", "liuling", "age", "23", "qq", "476777XXX");
        jedis.incr("age"); //进行加1操作
        System.out.println(jedis.get("name") + "-" + jedis.get("age") + "-" + jedis.get("qq"));
    }

    /**
     * redis操作Map
     */
    @Test
    public void testMap() {
        //-----添加数据----------
        Map<String, String> map = new HashMap<>();
        map.put("name", "xinxin");
        map.put("age", "22");
        map.put("qq", "123456");
        jedis.hmset("user", map);
        //取出user中的name，执行结果:[minxr]-->注意结果是一个泛型的List
        //第一个参数是存入redis中map对象的key，后面跟的是放入map中的对象的key，后面的key可以跟多个，是可变参数
        List<String> rsmap = jedis.hmget("user", "name", "age", "qq");
        System.out.println(String.format("jedis.hmget(\"user\", \"name\", \"age\", \"qq\"): %s", rsmap));

        System.out.println(String.format("jedis.exists(\"user\"): %b", jedis.exists("user")));//是否存在key为user的记录 返回true
        //删除map中的某个键值
        jedis.hdel("user", "age");
        System.out.println(String.format("jedis.hexists(\"user\", \"age\"): %b", jedis.hexists("user", "age")));//user中是否包括age
        System.out.println(String.format("jedis.hmget(\"user\", \"age\"): %s", jedis.hmget("user", "age"))); //因为删除了，所以返回的是null
        System.out.println(String.format("jedis.hlen(\"user\"): %d", jedis.hlen("user"))); //返回key为user的键中存放的值的个数2
        System.out.println(String.format("jedis.hkeys(\"user\"): %s", jedis.hkeys("user")));//返回map对象中的所有key
        System.out.println(String.format("jedis.hvals(\"user\"): %s", jedis.hvals("user")));//返回map对象中的所有value

        Iterator<String> iter = jedis.hkeys("user").iterator();
        while (iter.hasNext()) {
            String key = iter.next();
            System.out.println("By hkeys set iterator: " + key + ":" + jedis.hmget("user", key));//hmget返回的是List，因为传入的是可变参数
        }

        Map<String, String> userMap = jedis.hgetAll("user");
        for (Map.Entry<String, String> userEntry : userMap.entrySet()) {
            System.out.println("By hgetAll map.entry: " + userEntry.getKey() + ":" + userEntry.getValue());
        }
    }
    
    /**
     * jedis操作List
     */
    @Test
    public void testList() {
        //开始前，先移除所有的内容
        jedis.del("java framework");
        System.out.println(jedis.lrange("java framework", 0, -1));
        //先向key java framework中存放三条数据
        jedis.lpush("java framework", "spring");
        jedis.lpush("java framework", "struts");
        jedis.lpush("java framework", "hibernate");
        //再取出所有数据jedis.lrange是按范围取出，
        // 第一个是key，第二个是起始位置，第三个是结束位置，jedis.llen获取长度 -1表示取得所有
        System.out.println(jedis.lrange("java framework", 0, -1));

        jedis.del("java framework");
        jedis.rpush("java framework", "spring");
        jedis.rpush("java framework", "struts");
        jedis.rpush("java framework", "hibernate");
        System.out.println(jedis.lrange("java framework", 0, -1));

        System.out.println(jedis.llen("java framework"));

        System.out.println(jedis.type("java framework"));
    }
    
    /**
     * jedis操作Set
     */
    @Test
    public void testSet() {
        //添加
        jedis.del("user");
        jedis.sadd("user", "liuling");
        jedis.sadd("user", "xinxin");
        jedis.sadd("user", "ling");
        jedis.sadd("user", "zhangxinxin");
        jedis.sadd("user", "who");
        //移除noname
        jedis.srem("user", "who");
        System.out.println(jedis.smembers("user"));//获取所有加入的value
        System.out.println(jedis.sismember("user", "who"));//判断 who 是否是user集合的元素
        System.out.println(String.format("srandmember: %s", jedis.srandmember("user")));
        System.out.println(String.format("srandmember: %s", jedis.srandmember("user")));
        System.out.println(jedis.scard("user"));//返回集合的元素个数
    }

    /**
     * jedis排序
     */
    @Test
    public void testSort() {
        //注意，此处的rpush和lpush是List的操作。是一个双向链表（但从表现来看的）
        jedis.del("a");//先清除数据，再加入数据进行测试
        jedis.rpush("a", "1");
        jedis.lpush("a", "6");
        jedis.lpush("a", "3");
        jedis.lpush("a", "9");
        System.out.println(jedis.lrange("a", 0, -1));// [9, 3, 6, 1]
        System.out.println(jedis.sort("a")); //[1, 3, 6, 9]  //输入排序后结果
        System.out.println(jedis.lrange("a", 0, -1));
    }
}
输出：
//testString
xinxin
xinxin is my lover
null
liuling-24-476777XXX

//testMap
jedis.hmget("user", "name", "age", "qq"): [xinxin, 22, 123456]
jedis.exists("user"): true
jedis.hexists("user", "age"): false
jedis.hmget("user", "age"): [null]
jedis.hlen("user"): 2
jedis.hkeys("user"): [qq, name]
jedis.hvals("user"): [123456, xinxin]
By hkeys set iterator: qq:[123456]
By hkeys set iterator: name:[xinxin]
By hgetAll map.entry: qq:123456
By hgetAll map.entry: name:xinxin

//testList
[]
[hibernate, struts, spring]
[spring, struts, hibernate]
3
list

//testSet
[zhangxinxin, liuling, xinxin, ling]
false
srandmember: ling
srandmember: liuling
4

//testSort
[9, 3, 6, 1]
[1, 3, 6, 9]
[9, 3, 6, 1]
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//1-2 神器初试 https://www.imooc.com/video/16212
//15秒内完成main函数编码
import java.util.Date;

public class Main {
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(new Date());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//3-1 列操作 https://www.imooc.com/video/16218

public enum Status {
    // 1xx Informational
    100: "Continue"
    102: "Processing"
    103: "Checkpoint"

    // 2xx Success
    200: "OK"
    201: "Created"
    202: "Accepted"

    private int code;

    Status(int code) {
        this.code = code;
    }
}
修改后效果：
public enum Status {
    // 1xx Informational
    CONTINUE(100),
    PROCESSING(102),
    CHECKPOINT(103),

    // 2xx Success
    OK(200),
    CREATED(201),
    ACCEPTED(202);

    private int code;

    Status(int code) {
        this.code = code;
    }
}
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//3-3 postfix https://www.imooc.com/video/16220
常用：
.fori
.sout
.field
.try
.return
.nn
.format
.var
.iter
.if
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//3-4 alter enter https://www.imooc.com/video/16221
String name = "zhangsan";
int age = 24;
"name: " + name + ", age: " + age.sout -> System.out.println("name: " + name + ", age: " + age);
System.out.println("name: " + name + ", age: " + age); (alter + enter: Replace '+' with String.format()) -> System.out.printf("name: %s, age: %d%n", name, age);
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//8-1 文件操作
ctrl + alt + insert ：在当前目录中创建新文件...
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//8-2 文本操作
ctrl + c ：在文件上即可复制文件名
//------------------------------------------------------------------------------------------------
//IntelliJ Idea 使用技巧 
//8-3 结构图 https://www.imooc.com/video/16232
ctrl + h : 查看类的层级
ctrl + alt + h ：查看函数调用层次
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//1-2 Spring Boot的角色 https://www.imooc.com/video/16347
Spring Framework -> Spring Boot -> Spring Cloud
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//2-2 第一个Spring Boot应用（一） https://www.imooc.com/video/16351
通过https://start.spring.io/ 生成一个Spring Boot工程

*编写REST程序
*运行Spring Boot应用
*使用HTTP请求工具：PostMan

场景说明：
*定义用户模型，包括属性：用户ID和名称
*客户端发送POST请求，创建用户（Web MVC）
*客户端发送GET请求，获取所有用户（Web Flux）

//User.java
package com.imooc.firstappdemo.domain;

/**
 * 用户模型
 */
public class User {
    private int id;
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
            "id=" + id +
            ", name='" + name + '\'' +
            '}';
    }
}

//UserRepository.java
package com.imooc.firstappdemo.repository;

import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.springframework.stereotype.Repository;

import com.imooc.firstappdemo.domain.User;

/**
 * {@link User} {@link Repository}
 */
@Repository //@Repository即以Bean对象构造UserRepository，并完成在UserController中的变量注入
public class UserRepository {

    /**
     * 采用内存型的存储方式 -> Map
     */
    private final ConcurrentMap<Integer, User> repository = new ConcurrentHashMap<>();

    private final static AtomicInteger idGenerator = new AtomicInteger();

    /**
     * 保存用户对象
     * @param user {@link User} 对象
     * @return 如果保存成功，返回<code>true</code>
     *          否则，返回<code>false</code>
     */
    public boolean save(User user) {
        //ID 从1开始
        Integer id = idGenerator.incrementAndGet();
        //设置 ID
        user.setId(id);
        return repository.put(id, user) == null;
    }

    public Collection<User> findAll() {
        return repository.values();
    }
}


//UserController.java
package com.imooc.firstappdemo.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.imooc.firstappdemo.domain.User;
import com.imooc.firstappdemo.repository.UserRepository;

@RestController
public class UserController {

    private final UserRepository userRepository;

    @Autowired
    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @PostMapping("/person/save")
    public User save(@RequestParam String name) {
        User user = new User();
        user.setName(name);
        if (userRepository.save(user)) {
            System.out.println(String.format("用户对象: %s 保存成功！", user));
        }
        return user;
    }
}

//RouterFunctionConfiguration.java
package com.imooc.firstappdemo.config;

import reactor.core.publisher.Flux;

import java.util.Collection;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;

import com.imooc.firstappdemo.domain.User;
import com.imooc.firstappdemo.repository.UserRepository;

/**
 * 路由器函数配置
 */
@Configuration //逐一替换xml配置文件
public class RouterFunctionConfiguration {

    /**
     * Servlet
     * 请求接口：ServletRequest 或者 HttpServletRequest
     * 响应接口：ServletResponse 或者 HttpServletResponse
     * Spring 5.0 重新定义了服务请求和响应接口：
     * 请求接口：ServerRequest
     * 响应接口：ServerResponse
     * 既可支持Servlet规范，也可以支持自定义，比如Netty (Web Server)
     * 以本例：
     * 定义GET请求，并且返回所有的用户对象 URL: /person/find/all
     * Flux是0 - N个对象集合
     * Mono是0 - 1个对象集合
     * Reactive中的Flux或者Mono，它是异步处理（非阻塞）
     * 集合对象基本上是同步处理（阻塞）
     * Flux 或者 Mono都是Publisher
     */
    @Bean
    @Autowired //方法参数注入、Property注入（set/get）、参数注入、构造器注入
    public RouterFunction<ServerResponse> personFindAll(UserRepository userRepository) {
        return RouterFunctions.route(RequestPredicates.GET("/person/find/all"),
            request -> {
                //返回所有用户对象
                Collection<User> users = userRepository.findAll();
                Flux<User> userFlux = Flux.fromIterable(users);
                return ServerResponse.ok().body(userFlux, User.class);
            });
    }
}

//FirstAppDemoApplication.java
package com.imooc.firstappdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FirstAppDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(FirstAppDemoApplication.class, args);
    }
}

//pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.imooc</groupId>
    <artifactId>first-app-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>

    <name>first-app-demo</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//2-3 第一个Spring Boot应用（二）https://www.imooc.com/video/16352
使用Postman测试POST请求：
http://localhost:8080/person/save 将会得到400 Bad Request
http://localhost:8080/person/save?name=bigben 使用post正常返回，调用到了java端
{
    "id": 1,
    "name": "bigben"
}
http://localhost:8080/person/save?name=yan 使用post正常返回，调用到了java端
{
    "id": 2,
    "name": "yan"
}
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//2-4 第一个Spring Boot应用（三）https://www.imooc.com/video/16353
使用Postman测试GET请求：
http://localhost:8080/person/find/all
返回：
[
    {
        "id": 1,
        "name": "bigben"
    },
    {
        "id": 2,
        "name": "yan"
    }
]
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//3-1 Spring Boot构建应用-命令行方式 https://www.imooc.com/video/16355

//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//3-2 Spring Boot多模块 Srping Boot项目 https://www.imooc.com/video/16354
重构
*调整主（父）工程类型（<packaging>）
*创建子模块工程（<module>）
    *模型层：model
    *持久层：persistence
    *表示层：web
*子模块依赖管理（<dependencyManagement>）

//first-app-demo pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.imooc</groupId>
    <artifactId>first-app-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <modules>
        <module>web</module>
        <module>persistence</module>
        <module>model</module>
    </modules>

    <!--修改成pom-->
    <!--
        模型层：model
        持久层：persistence
        表示层：web
        web 依赖于 persistence，persistence 依赖于 model
        web UserController -> UserRepository -> User
    -->
    <packaging>pom</packaging>

    <name>first-app-demo</name>
    <description>Demo project for Spring Boot</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>

//web module
//保留RouterFunctionConfiguration.java
//保留FirstAppDemoApplication.java
//web pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>first-app-demo</artifactId>
        <groupId>com.imooc</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>web</artifactId>

    <dependencies>
        <!--增加了这个persistence依赖后，UserController依赖UserRepository，才不会报错-->
        <dependency>
            <groupId>com.imooc</groupId>
            <artifactId>persistence</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>
</project>

//persistence module
//保留UserRepository.java
//persistence pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>first-app-demo</artifactId>
        <groupId>com.imooc</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>persistence</artifactId>

    <dependencies>
        <!--增加了这个model依赖后，UserRepository依赖User，才不会报错-->
        <dependency>
            <groupId>com.imooc</groupId>
            <artifactId>model</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>
</project>

//model module
//保留User.java
//model pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>first-app-demo</artifactId>
        <groupId>com.imooc</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>model</artifactId>
</project>
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//3-3 Spring Boot项目打包 https://www.imooc.com/video/16356
打包方式：
*构建JAR包
*构建WAR包
指定Main-Class

//生成jar包方式：
cmd中执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
第一次执行会报错：
[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.1.0.RELEASE:repackage (repackage) on project model: Execution repackage of goal org.springframework.boot:spring-boot-maven-plugin:2.1.0.RELEASE:repackage failed: Unable to find main class -> [Help 1]

在first-app-demo的pom.xml中build中增加configuration的mainClass：
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <mainClass>com.imooc.firstappdemo.FirstAppDemoApplication</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>

第二次执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
又报错：
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:compile (default-compile) on project persistence: Compilation failure: Compilation failure:
[ERROR] /E:/Program Files/JetBrains/JavaProject/first-app-demo/persistence/src/main/java/com/imooc/firstappdemo/repository/UserRepository.java:[10,37] 程序包com.imooc.firstappdemo.domain不存在
[ERROR] /E:/Program Files/JetBrains/JavaProject/first-app-demo/persistence/src/main/java/com/imooc/firstappdemo/repository/UserRepository.java:[21,42] 找不到符号
[ERROR]   符号:   类 User
[ERROR]   位置: 类 com.imooc.firstappdemo.repository.UserRepository
[ERROR] /E:/Program Files/JetBrains/JavaProject/first-app-demo/persistence/src/main/java/com/imooc/firstappdemo/repository/UserRepository.java:[31,25] 找不到符号
[ERROR]   符号:   类 User
[ERROR]   位置: 类 com.imooc.firstappdemo.repository.UserRepository
[ERROR] /E:/Program Files/JetBrains/JavaProject/first-app-demo/persistence/src/main/java/com/imooc/firstappdemo/repository/UserRepository.java:[39,23] 找不到符号
[ERROR]   符号:   类 User
[ERROR]   位置: 类 com.imooc.firstappdemo.repository.UserRepository
[ERROR] -> [Help 1]

在first-app-demo的pom.xml中build中再增加dependencies：
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <dependencies>
                <dependency>
                    <groupId>com.imooc</groupId>
                    <artifactId>model</artifactId>
                    <version>0.0.1-SNAPSHOT</version>
                </dependency>
            </dependencies>
            <configuration>
                <mainClass>com.imooc.firstappdemo.FirstAppDemoApplication</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>

第三次执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
又报错：
[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.1.0.RELEASE:repackage (repackage) on project first-app-demo: Execution repackage of goal org.springframework.boot:spring-boot-maven-plugin:2.1.0.RELEASE:repackage failed: Plugin org.springframework.boot:spring-boot-maven-plugin:2.1.0.RELEASE or one of its dependencies could not be resolved: Could not find artifact com.imooc:model:jar:0.0.1-SNAPSHOT -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/PluginResolutionException

将mvn -Dmaven.test.skip -U clean package修改为mvn -Dmaven.test.skip -U clean install依旧报错。（install是将jar包先放入本地仓储）

换种方式，将first-app-demo的pom.xml中build节点放入web的pom.xml中：
//web pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>first-app-demo</artifactId>
        <groupId>com.imooc</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>web</artifactId>

    <dependencies>
        <!--增加了这个persistence依赖后，UserController依赖UserRepository，才不会报错-->
        <dependency>
            <groupId>com.imooc</groupId>
            <artifactId>persistence</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <dependencies>
                    <dependency>
                        <groupId>com.imooc</groupId>
                        <artifactId>model</artifactId>
                        <version>0.0.1-SNAPSHOT</version>
                    </dependency>
                </dependencies>
                <configuration>
                    <mainClass>com.imooc.firstappdemo.FirstAppDemoApplication</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

再次执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
显示make成功。

进入web/target目录，执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo\web\target>java -jar web-0.0.1-SNAPSHOT.jar
可使用POSTMAN正常访问。

//修改为war包方式：
修改生成jar包为war包，在web pom.xml中增加如下：
<!--将packaging值（默认：jar）调整成 war-->
<packaging>war</packaging>

再次执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
报错：
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-war-plugin:3.2.2:war (default-war) on project web: Error assembling WAR: webxml attribute is required (or pre-existing WEB-INF/web.xml if executing in update mode) -> [Help 1]

需要符合maven war包规范，增加如下web.xml：
E:\Program Files\JetBrains\JavaProject\first-app-demo\web\src\main\webapp\WEB-INF\web.xml
再次执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean package
即可执行成功。

进入web/target目录，执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo\web\target>java -jar web-0.0.1-SNAPSHOT.war
可使用POSTMAN正常访问。
//------------------------------------------------------------------------------------------------
//Spring Boot 2.0深度实践
//3-4 Spring Boot运行模式 https://www.imooc.com/video/16357
模式类型：
*IDEA方式：开发环境开发和调试
*JAR/WAR方式：生产环境启动和运行
*Maven插件方式：没有图形界面时，命令行运行

执行如下命令：
E:\Program Files\JetBrains\JavaProject\first-app-demo>mvn -Dmaven.test.skip -U clean install
执行成功，并可以看到，把生成的war包放到maven仓储：
[INFO] Installing E:\Program Files\JetBrains\JavaProject\first-app-demo\web\target\web-0.0.1-SNAPSHOT.war to E:\Program Files\JetBrains\JavaProject\Maven\repository\com\imooc\web\0.0.1-SNAPSHOT\web-0.0.1-SNAPSHOT.war
[INFO] Installing E:\Program Files\JetBrains\JavaProject\first-app-demo\web\pom.xml to E:\Program Files\JetBrains\JavaProject\Maven\repository\com\imooc\web\0.0.1-SNAPSHOT\web-0.0.1-SNAPSHOT.pom

执行如下命令可以直接启动application：
E:\Program Files\JetBrains\JavaProject\first-app-demo\web>mvn spring-boot:run
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//1-1 SpringBoot简介 https://www.imooc.com/video/16783
使用场景：
*有Spring的地方都行
*J2EE/web项目
*微服务

源代码：https://github.com/leechenxiang/imooc-springboot-starter
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//3-1 SpringBoot 构造并返回一个json对象 https://www.imooc.com/video/16786
//ImoocApplication.java
package com.imooc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ImoocApplication {

    public static void main(String[] args) {
        SpringApplication.run(ImoocApplication.class, args);
    }
}

//UserController.java
package com.imooc.controller;

import java.util.Date;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.pojo.User;

//@Controller //SpringMVC方式
@RestController // @RestController = @Controller + @ResponseBody
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/getUser") //这里如果仍使用hello，则提示已经在HelloController中已经有hello映射，需要改为另外的映射名称
//    @ResponseBody //表明返回的对象都是是Json字符串或是Json对象，类使用@Controller，则这里必须加@ResponseBody；如果类使用@RestController，则这里不用加
    public User getUser() { //函数名称可以随意定，与@RequestMapping里的映射名称没有关系
        User user = new User();
        user.setName("imooc");
        user.setAge(18);
        user.setBirthday(new Date());
        user.setPassword("imooc");
//        user.setDesc(null);//不设置则为null
        return user;
    }

    @RequestMapping("/getUserJson") //这里如果仍使用hello，则提示已经在HelloController中已经有hello映射，需要改为另外的映射名称
//    @ResponseBody //表明返回的对象都是是Json字符串或是Json对象，类使用@Controller，则这里必须加@ResponseBody；如果类使用@RestController，则这里不用加
    public IMoocJSONResult getUserJson() { //函数名称可以随意定，与@RequestMapping里的映射名称没有关系
        User user = new User();
        user.setName("imooc");
        user.setAge(18);
        user.setBirthday(new Date());
        user.setPassword("imooc");
//        user.setDesc(null);//不设置则为null
        return IMoocJSONResult.ok(user);
    }
}

//HelloController.java
package com.imooc.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @RequestMapping("/hello")
    public Object hello() {
        return "hello springboot~~";
    }
}

使用http://localhost:8080/user/getUser 访问
Response：
{
"status": 200,
"msg": "OK",
"data":{
"name": "imooc",
"password": "imooc",
"age": 18,
"birthday": "2018-12-02T06:35:32.126+0000",
"desc": null
},
"ok": null
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//3-2 Jackson基本演绎法 https://www.imooc.com/video/16787

//通过注释控制Json对象的显示控制
package com.imooc.pojo;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;

public class User {
    private String name;

    @JsonIgnore
    private String password;
    private Integer age;
    @JsonFormat(pattern="yyyy-MM-dd a hh:mm:ss", locale="zh", timezone="GMT+8")
    private Date birthday;

    @JsonInclude(Include.NON_NULL)
    private String desc;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//4-1 SpringBoot 使用devtools进行热部署 https://www.imooc.com/video/16717

//pom.xml
<!-- 热部署 -->
<!-- devtools可以实现页面热部署（即页面修改后会立即生效，
    这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现） -->
<!-- 实现类文件热部署（类文件修改后不会立即生效），实现对属性文件的热部署。 -->
<!-- 即devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），
    注意：因为其采用的虚拟机机制，该项重启是很快的 -->
<!-- （1）base classloader （Base类加载器）：加载不改变的Class，例如：第三方提供的jar包。 -->
<!-- （2）restart classloader（Restart类加载器）：加载正在开发的Class。 -->
<!-- 为什么重启很快，因为重启的时候只是加载了在开发的Class，没有重新加载第三方的jar包。 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <!-- optional=true, 依赖不会传递, 该项目依赖devtools;
        之后依赖boot项目的项目如果想要使用devtools, 需要重新引入 -->
    <optional>true</optional>
</dependency>

//application.properties
#关闭缓存, 即时刷新
#spring.freemarker.cache=false
spring.thymeleaf.cache=true

#热部署生效
spring.devtools.restart.enabled=true
#设置重启的目录,添加那个目录的文件需要restart
spring.devtools.restart.additional-paths=src/main/java
# 为mybatis设置，生产环境可删除
#restart.include.mapper=/mapper-[\\w-\\.]+jar
#restart.include.pagehelper=/pagehelper-[\\w-\\.]+jar
##排除那个目录的文件不需要restart
##spring.devtools.restart.exclude=static/**,public/**
##classpath目录下的WEB-INF文件夹内容修改不重启
##spring.devtools.restart.exclude=WEB-INF/**        */

需要依赖Idea的自动编译，编出class文件，才能实现热部署：https://blog.csdn.net/java_zhaoyu/article/details/81940407?utm_source=blogxgwz7
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//5-1 SpringBoot 资源文件属性配置 https://www.imooc.com/video/16718
*资源文件中的属性配置与映射到实体类

//resource.properties
com.imooc.opensource.name=imooc
com.imooc.opensource.website=www.imooc.com
com.imooc.opensource.language=java

//Resource.java
package com.imooc.pojo;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@ConfigurationProperties(prefix = "com.imooc.opensource")
@PropertySource(value = "classpath:resource.properties")
public class Resource {
    private String name;
    private String website;
    private String language;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getWebsite() {
        return website;
    }

    public void setWebsite(String website) {
        this.website = website;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }
}

//HelloController.java
package com.imooc.controller;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.pojo.Resource;

@RestController
public class HelloController {

    @Autowired
    private Resource resource;

    @RequestMapping("/hello")
    public Object hello() {
        return "hello springboot~~";
    }

    @RequestMapping("/getResource")
    public IMoocJSONResult getResource() {
        Resource bean = new Resource();
        BeanUtils.copyProperties(resource, bean);
        return IMoocJSONResult.ok(bean);
    }
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//5-2 SpringBoot 资源文件配置server https://www.imooc.com/video/16719
*资源文件中配置tomcat相关属性

############################################################
#
# Server 服务端相关配置
#
############################################################
# 配置api端口号
server.port=8088
# 配置context-path, 一般来说这个配置在正式发布的时候不配置
#server.context-path=/IMooc server.context-path已经被废弃
server.servlet.context-path=/IMooc
# 错误页，指定发生错误时，跳转的URL --> BasicErrorController
#server.error.path=/error
# session最大超时时间(分钟)，默认为30分钟
server.session-timeout=60
# 该服务绑定IP地址，启动服务器时如本机不是该IP地址则抛出异常启动失败,
# 只有特殊需求的情况下才配置, 具体根据各自的业务来设置 查看本地IP后，使用http://192.168.100.102:8088/IMooc/hello访问
#server.address=192.168.100.102

############################################################
# Server - tomcat 相关常用配置
############################################################
# tomcat最大线程数, 默认为200
#server.tomcat.max-threads=250
# tomcat的URI编码
server.tomcat.uri-encoding=UTF-8
# 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹
#（如：C:\Users\Shanhy\AppData\Local\Temp）
#server.tomcat.basedir=H:/springboot-tomcat-tmp
# 打开Tomcat的Access日志，并可以设置日志格式的方法：
#server.tomcat.access-log-enabled=true
#server.tomcat.access-log-pattern=
# accesslog目录，默认在basedir/logs
#server.tomcat.accesslog.directory=
# 日志文件目录
#logging.path=H:/springboot-tomcat-tmp
# 日志文件名称，默认为spring.log
#logging.file=myapp.log

E:\Program Files\Apache Maven\apache-maven-repository\org\springframework\boot\spring-boot-autoconfigure\2.1.1.RELEASE\spring-boot-autoconfigure-2.1.1.RELEASE.jar!\META-INF\spring-configuration-metadata.json
中可以看到：
{
  "name": "server.context-path",
  "type": "java.lang.String",
  "description": "Context path of the application.",
  "deprecated": true,
  "deprecation": {
    "level": "error",
    "replacement": "server.servlet.context-path"
  }
}

使用 http://localhost:8088/IMooc/hello 访问
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//6-1 SpringBoot整合freemarker https://www.imooc.com/video/16720
*SpringBoot整合freemarker

//pom.xml
<!--引入freemarker模板依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-freemarker</artifactId>
</dependency>

//application.properties
############################################################
#
# freemarker 静态资源配置
#
############################################################
#设定ftl文件路径
spring.freemarker.template-loader-path=classpath:/templates
# 关闭缓存, 即时刷新, 上线生产环境需要改为true
spring.freemarker.cache=false
spring.freemarker.charset=UTF-8
spring.freemarker.check-template-location=true
spring.freemarker.content-type=text/html
spring.freemarker.expose-request-attributes=true
spring.freemarker.expose-session-attributes=true
spring.freemarker.request-context-attribute=request
spring.freemarker.suffix=.ftl

//FreemarkerController.java
package com.imooc.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.RequestMapping;

import com.imooc.pojo.Resource;

@Controller
@RequestMapping("ftl")
public class FreemarkerController {

    @Autowired
    private Resource resource;

    @RequestMapping("/index")
    public String index(ModelMap map) {
        map.addAttribute("resource", resource);
        return "freemarker/index";
    }

    @RequestMapping("/center")
    public String center() {
        return "freemarker/center/center";
    }
}

//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//6-2 SpringBoot整合Thymeleaf https://www.imooc.com/video/16721
*SpringBoot整合thymeleaf

//pom.xml
<!--引入thymeleaf模板依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

//application.properties
############################################################
#
# thymeleaf 静态资源配置
#
############################################################
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.servlet.content-type=text/html
#spring.thymeleaf.content-type=text/html 已经被废弃
# 关闭缓存, 即时刷新, 上线生产环境需要改为true
spring.thymeleaf.cache=false

//ThymeleafController.java
package com.imooc.controller;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.imooc.pojo.User;

@Controller
@RequestMapping("th")
public class ThymeleafController {

    @RequestMapping("/index")
    public String index(ModelMap map) {
        map.addAttribute("name", "bigben");
        return "thymeleaf/index";
    }

    @RequestMapping("center")
    public String center() {
        return "thymeleaf/center/center";
    }

    @RequestMapping("test")
    public String test(ModelMap map) {

        User u = new User();
        u.setName("superadmin");
        u.setAge(10);
        u.setPassword("123465");
        u.setBirthday(new Date());
        u.setDesc("<font color='green'><b>hello imooc</b></font>");

        map.addAttribute("user", u);

        User u1 = new User();
        u1.setAge(19);
        u1.setName("imooc");
        u1.setPassword("123456");
        u1.setBirthday(new Date());

        User u2 = new User();
        u2.setAge(17);
        u2.setName("LeeCX");
        u2.setPassword("123456");
        u2.setBirthday(new Date());

        List<User> userList = new ArrayList<>();
        userList.add(u);
        userList.add(u1);
        userList.add(u2);

        map.addAttribute("userList", userList);

        return "thymeleaf/test";
    }

    @PostMapping("postform")
    public String postform(User u) {

        System.out.println("姓名：" + u.getName());
        System.out.println("年龄：" + u.getAge());

        return "redirect:/th/test";
    }
}

//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//6-3 Thymeleaf常用标签的使用方法 https://www.imooc.com/video/16722
*基本使用方式
*对象引用方式
*时间类型转换
*text与utext
*URL
*引用静态资源文件js/css

*条件判断th:if
*th:unless与th:if
*循环th:each
*text与utext
*th:swith与th:case

//application.properties
############################################################
#
# 配置i18n 资源文件，供thymeleaf 读取
#
############################################################
spring.messages.basename=i18n/messages
#spring.messages.cache-seconds=3600 已经被废弃
spring.messages.cache-duration=3600
spring.messages.encoding=UTF-8


#设定静态文件路径，js,css等
spring.mvc.static-path-pattern=/static/**

//thymeleaf/test.html
<!DOCTYPE html>
<html xmlns:th="http://www.w3.org/1999/xhtml">
<head lang="en">
    <meta charset="UTF-8" />
    <title></title>
    
     <!--<script th:src="@{/static/js/test.js}"></script>-->
    
</head>
<body>

<div>
    用户姓名：<input th:id="${user.name}" th:name="${user.name}" th:value="${user.name}"/>
    <br/>
    用户年龄：<input th:value="${user.age}"/>
    <br/>
    用户生日：<input th:value="${user.birthday}"/>
    <br/>
    用户生日：<input th:value="${#dates.format(user.birthday, 'yyyy-MM-dd')}"/>
    <br/>
</div>

<br/>

<div th:object="${user}">
    用户姓名：<input th:id="*{name}" th:name="*{name}" th:value="*{name}"/>
    <br/>
    用户年龄：<input th:value="*{age}"/>
    <br/>
    用户生日：<input th:value="*{#dates.format(birthday, 'yyyy-MM-dd hh:mm:ss')}"/>
    <br/>
</div>

<br/>

text 与 utext ：<br/>
<span th:text="${user.desc}">abc</span>
<br/>
<span th:utext="${user.desc}">abc</span>
<br/>
<br/>

URL:<br/>
<a href="" th:href="@{http://www.imooc.com}">网站地址</a>
<br/>

<br/>
<form th:action="@{/th/postform}" th:object="${user}" method="post" th:method="post">
    <input type="text" th:field="*{name}"/>
    <input type="text" th:field="*{age}"/>
    <input type="submit"/>
</form>
<br/>

<br/>
<div th:if="${user.age} == 18">十八岁的天空</div>
<div th:if="${user.age} gt 18">你老了</div>
<div th:if="${user.age} lt 18">你很年轻</div>
<div th:if="${user.age} ge 18">大于等于</div>
<div th:if="${user.age} le 18">小于等于</div>
<br/>

<br/>
<select>
     <option >选择框</option>
     <option th:selected="${user.name eq 'lee'}">lee</option>
     <option th:selected="${user.name eq 'imooc'}">imooc</option>
     <option th:selected="${user.name eq 'LeeCX'}">LeeCX</option>
</select>
<br/>

<br/>
<table>
    <tr>
        <th>姓名</th>
        <th>年龄</th>
        <th>年龄备注</th>
        <th>生日</th>
    </tr>
    <tr th:each="person:${userList}">
        <td th:text="${person.name}"></td>
        <td th:text="${person.age}"></td>
        <td th:text="${person.age gt 18} ? 你老了 : 你很年轻">18岁</td>
        <td th:text="${#dates.format(user.birthday, 'yyyy-MM-dd hh:mm:ss')}"></td>
    </tr>
</table>
<br/>

<br/>
<div th:switch="${user.name}">
  <p th:case="'lee'">lee</p>
  <p th:case="#{roles.manager}">普通管理员</p>
  <p th:case="#{roles.superadmin}">超级管理员</p>
  <p th:case="*">其他用户</p>
</div>
<br/>

</body>
</html>
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//7-1 SpringBoot配置全局的异常捕获-web页面跳转 https://www.imooc.com/video/16723
*页面跳转形式
*ajax形式
*统一返回异常的形式

使用http://localhost:8080/err/error
//ErrorController.java
package com.imooc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import com.imooc.pojo.IMoocJSONResult;

@Controller
@RequestMapping("err")
public class ErrorController {

    @RequestMapping("/error")
    public String error() {
        int a = 1 / 0;
        return "thymeleaf/error";
    }

    @RequestMapping("/ajaxerror")
    public String ajaxerror() {
        return "thymeleaf/ajaxerror";
    }

    @RequestMapping("/getAjaxerror")
    @ResponseBody
    public IMoocJSONResult getAjaxerror() {
        int a = 1 / 0;
        return IMoocJSONResult.ok();
    }
}

//IMoocExceptionHandler.java
package com.imooc.exception;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

import com.imooc.pojo.IMoocJSONResult;

@ControllerAdvice
public class IMoocExceptionHandler {

    public static final String IMOOC_ERROR_VIEW = "error";

//    @ExceptionHandler(value = Exception.class)
//    public Object errorHandler(HttpServletRequest reqest, 
//            HttpServletResponse response, Exception e) throws Exception {
//        
//        e.printStackTrace();
//        
//        ModelAndView mav = new ModelAndView();
//        mav.addObject("exception", e);
//        mav.addObject("url", reqest.getRequestURL());
//        mav.setViewName(IMOOC_ERROR_VIEW);
//        return mav;
//    }

    @ExceptionHandler(value = Exception.class)
    public Object errorHandler(HttpServletRequest reqest,
                               HttpServletResponse response, Exception e) throws Exception {

        e.printStackTrace();

        if (isAjax(reqest)) {
            return IMoocJSONResult.errorException(e.getMessage());
        } else {
            ModelAndView mav = new ModelAndView();
            mav.addObject("exception", e);
            mav.addObject("url", reqest.getRequestURL());
            mav.setViewName(IMOOC_ERROR_VIEW);
            return mav;
        }
    }

    /**
     * @Title: IMoocExceptionHandler.java
     * @Package com.imooc.exception
     * @Description: 判断是否是ajax请求
     * Copyright: Copyright (c) 2017
     * Company:FURUIBOKE.SCIENCE.AND.TECHNOLOGY
     * @author leechenxiang
     * @date 2017年12月3日 下午1:40:39
     * @version V1.0
     */
    public static boolean isAjax(HttpServletRequest httpRequest) {
        return (httpRequest.getHeader("X-Requested-With") != null
            && "XMLHttpRequest"
            .equals(httpRequest.getHeader("X-Requested-With").toString()));
    }
}

//error.html
<!DOCTYPE html>
<html xmlns:th="http://www.w3.org/1999/xhtml">
<head lang="en">
    <meta charset="UTF-8" />
    <title>捕获全局异常</title>
</head>
<body>
    <h1 style="color: red">发生错误：</h1>
    <div th:text="${url}"></div>
    <div th:text="${exception.message}"></div>
</body>
</html>
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//7-2 SpringBoot配置全局的异常捕获-ajax形式 https://www.imooc.com/video/16724

使用http://localhost:8080/err/ajaxerror
//IMoocAjaxExceptionHandler.java 注释掉IMoocExceptionHandler类的@ControllerAdvice
package com.imooc.exception;

import javax.servlet.http.HttpServletRequest;

import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.imooc.pojo.IMoocJSONResult;

@RestControllerAdvice
public class IMoocAjaxExceptionHandler {

    @ExceptionHandler(value = Exception.class)
    public IMoocJSONResult defaultErrorHandler(HttpServletRequest req, 
            Exception e) throws Exception {

        e.printStackTrace();
        return IMoocJSONResult.errorException(e.getMessage());
    }
}

//ajaxerror.js
$.ajax({
        url: "/err/getAjaxerror",
        type: "POST",
        async: false,
        success: function(data) {
            debugger;
            if(data.status == 200 && data.msg == "OK") {
                alert("success");
            } else {
                alert("发生异常：" + data.msg);
            }
        },
        error: function (response, ajaxOptions, thrownError) {
            debugger;
            alert("error");       
        }
    });
    
会走到function(data)函数的debugger
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//7-3 SpringBoot配置全局的异常捕获-同时兼容web和ajax https://www.imooc.com/video/16725

使用http://localhost:8080/err/error
或
使用http://localhost:8080/err/ajaxerror 会走到ajaxerror.js的error: function函数中

com.imooc.exception.IMoocExceptionHandler#isAjax函数会判断是否ajax形式，走到对应的ajax和web异常处理
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//7-3 整合MyBatis - 使用generatorConfig生成mapper以及pojo https://www.imooc.com/video/16726
*使用generatorConfig生成mapper以及pojo
*实现基于mybatis的CRUD功能
*整合mybatis-pagehelper实现分页
*自定义mapper的实现

Mybatis开源框架：https://github.com/abel533/MyBatis-Spring-Boot

//sys_user建表语句：
create table sys_user
(
    id varchar(20) not null,
    username varchar(50) not null comment '用户名，登录名',
    password varchar(30) null comment '密码',
    nickname varchar(50) null comment '昵称',
    age int null comment '年龄',
    sex int null comment '性别',
    job int null,
    face_image varchar(1000) null,
    province varchar(10) null,
    city varchar(10) null,
    district varchar(10) null,
    address varchar(50) null,
    auth_salt varchar(10) null,
    last_login_ip varchar(32) null,
    last_login_time timestamp null,
    is_delete int null,
    regist_time timestamp null,
    PRIMARY KEY(id)
);

//GeneratorDisplay.java 用来读取sys_user表生成SysUserMapper.xml、SysUser.java、SysUserMapper.java
package com.imooc.utils;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

public class GeneratorDisplay {

    public void generator() throws Exception {

        List<String> warnings = new ArrayList<String>();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File("generatorConfig.xml");
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
            callback, warnings);
        myBatisGenerator.generate(null);

    }

    public static void main(String[] args) {
        try {
            GeneratorDisplay generatorSqlmap = new GeneratorDisplay();
            generatorSqlmap.generator();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

//generatorConfiguration.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="MysqlContext" targetRuntime="MyBatis3Simple" defaultModelType="flat">
        <property name="beginningDelimiter" value="`"/>
        <property name="endingDelimiter" value="`"/>

        <plugin type="tk.mybatis.mapper.generator.MapperPlugin">
            <property name="mappers" value="com.imooc.utils.MyMapper"/>
        </plugin>

        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8"
                        userId="root"
                        password="root123">
        </jdbcConnection>

        <!-- 对于生成的pojo所在包 -->
        <javaModelGenerator targetPackage="com.imooc.pojo" targetProject="src/main/java"/>

        <!-- 对于生成的mapper所在目录 -->
        <sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/>

        <!-- 配置mapper对应的java映射 -->
        <javaClientGenerator targetPackage="com.imooc.mapper" targetProject="src/main/java"
                             type="XMLMAPPER"/>


        <table tableName="sys_user"></table>

    </context>
</generatorConfiguration>
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//8-1 整合MyBatis - 实现基于mybatis的CRUD功能 https://www.imooc.com/video/16788

这里把devtools给注掉了，在整合mybatis时，如果加载devtools时，如果ctrl+F9会提示tk.mybatis.mapper.provider.EmptyProvider中缺少selectOne方法，没找到解决方法。
<!--<dependency>-->
    <!--<groupId>org.springframework.boot</groupId>-->
    <!--<artifactId>spring-boot-devtools</artifactId>-->
    <!--&lt;!&ndash; optional=true, 依赖不会传递, 该项目依赖devtools;-->
        <!--之后依赖boot项目的项目如果想要使用devtools, 需要重新引入 &ndash;&gt;-->
    <!--<optional>true</optional>-->
<!--</dependency>-->

//UserService.java
package com.imooc.service;

import java.util.List;

import com.imooc.pojo.SysUser;

public interface UserService {
    void saveUser(SysUser user) throws Exception;

    void updateUser(SysUser user);

    void deleteUser(String userId);

    SysUser queryUserById(String userId);

    List<SysUser> queryUserList(SysUser user);

    List<SysUser> queryUserListPaged(SysUser user, Integer page, Integer pageSize);

    SysUser queryUserByIdCustom(String userId);
}


//MyBatisCRUDController.java
package com.imooc.controller;

import java.util.Date;
import java.util.List;

import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.pojo.SysUser;
import com.imooc.service.UserService;

@RestController
@RequestMapping("mybatis")
public class MyBatisCRUDController {

    @Autowired
    private UserService userService;

    @Autowired
    private Sid sid;

    @RequestMapping("/saveUser")
    public IMoocJSONResult saveUser() throws Exception {

        String userId = sid.nextShort();

        SysUser user = new SysUser();
        user.setId(userId);
        user.setUsername("imooc" + new Date());
        user.setNickname("imooc" + new Date());
        user.setPassword("abc123");
        user.setIsDelete(0);
        user.setRegistTime(new Date());

        userService.saveUser(user);

        return IMoocJSONResult.ok("保存成功");
    }

    @RequestMapping("/updateUser")
    public IMoocJSONResult updateUser() {

        SysUser user = new SysUser();
        user.setId("10011001");
        user.setUsername("10011001-updated" + new Date());
        user.setNickname("10011001-updated" + new Date());
        user.setPassword("10011001-updated");
        user.setIsDelete(0);
        user.setRegistTime(new Date());

        userService.updateUser(user);

        return IMoocJSONResult.ok("保存成功");
    }

    @RequestMapping("/deleteUser")
    public IMoocJSONResult deleteUser(String userId) {

        userService.deleteUser(userId);

        return IMoocJSONResult.ok("删除成功");
    }

    @RequestMapping("/queryUserById")
    public IMoocJSONResult queryUserById(String userId) {

        return IMoocJSONResult.ok(userService.queryUserById(userId));
    }

    @RequestMapping("/queryUserList")
    public IMoocJSONResult queryUserList() {

        SysUser user = new SysUser();
        user.setUsername("imooc");
        user.setNickname("lee");

        List<SysUser> userList = userService.queryUserList(user);

        return IMoocJSONResult.ok(userList);
    }

    @RequestMapping("/queryUserListPaged")
    public IMoocJSONResult queryUserListPaged(Integer page) {

        if (page == null) {
            page = 1;
        }

        int pageSize = 5;

        SysUser user = new SysUser();
    //        user.setNickname("lee");

        List<SysUser> userList = userService.queryUserListPaged(user, page, pageSize);

        return IMoocJSONResult.ok(userList);
    }
//
//    @RequestMapping("/queryUserByIdCustom")
//    public IMoocJSONResult queryUserByIdCustom(String userId) {
//
//        return IMoocJSONResult.ok(userService.queryUserByIdCustom(userId));
//    }
//
    @RequestMapping("/saveUserTransactional")
    public IMoocJSONResult saveUserTransactional() {

        String userId = sid.nextShort();

        SysUser user = new SysUser();
        user.setId(userId);
        user.setUsername("lee" + new Date());
        user.setNickname("lee" + new Date());
        user.setPassword("abc123");
        user.setIsDelete(0);
        user.setRegistTime(new Date());

        userService.saveUserTransactional(user);

        return IMoocJSONResult.ok("保存成功");
    }

    @RequestMapping("/queryUserByIdCustom")
    public IMoocJSONResult queryUserByIdCustom(String userId) {
        return IMoocJSONResult.ok(userService.queryUserByIdCustom(userId));
    }
}


//UserServiceImpl.java
package com.imooc.service.impl;

import tk.mybatis.mapper.entity.Example;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.thymeleaf.util.StringUtils;

import com.github.pagehelper.PageHelper;
import com.imooc.mapper.SysUserMapper;
import com.imooc.mapper.SysUserMapperCustom;
import com.imooc.pojo.SysUser;
import com.imooc.service.UserService;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private SysUserMapper userMapper;

    @Autowired
    private SysUserMapperCustom userMapperCustom;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveUser(SysUser user) throws Exception {
        userMapper.insert(user);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void updateUser(SysUser user) {
        //Selective只会更新有值的属性，无值属性则不更新。如果不带Selective则会把user中的null对象值也更新到数据库对象中
//        userMapper.updateByPrimaryKey(user);
        userMapper.updateByPrimaryKeySelective(user);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void deleteUser(String userId) {
        userMapper.deleteByPrimaryKey(userId);
    }

    @Override
    @Transactional(propagation = Propagation.SUPPORTS)
    public SysUser queryUserById(String userId) {
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return userMapper.selectByPrimaryKey(userId);
    }

    @Override
    @Transactional(propagation = Propagation.SUPPORTS)
    public List<SysUser> queryUserList(SysUser user) {
        try {
            Thread.sleep(11000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Example example = new Example(SysUser.class);
        Example.Criteria criteria = example.createCriteria();

        if (!StringUtils.isEmptyOrWhitespace(user.getUsername())) {
//            criteria.andEqualTo("username", user.getUsername());
            criteria.andLike("username", "%" + user.getUsername() + "%");
        }

        if (!StringUtils.isEmptyOrWhitespace(user.getNickname())) {
            criteria.andLike("nickname", "%" + user.getNickname() + "%");
        }
        List<SysUser> userList = userMapper.selectByExample(example);
        return userList;
    }

    @Override
    @Transactional(propagation = Propagation.SUPPORTS)
    public List<SysUser> queryUserListPaged(SysUser user, Integer page, Integer pageSize) {
        // 开始分页
        PageHelper.startPage(page, pageSize);

        Example example = new Example(SysUser.class);
        Example.Criteria criteria = example.createCriteria();

        if (!StringUtils.isEmptyOrWhitespace(user.getNickname())) {
            criteria.andLike("nickname", "%" + user.getNickname() + "%");
        }
        example.orderBy("registTime").desc();
        List<SysUser> userList = userMapper.selectByExample(example);

        return userList;
    }

    @Override
    @Transactional(propagation = Propagation.SUPPORTS)
    public SysUser queryUserByIdCustom(String userId) {
        List<SysUser> userList = userMapperCustom.queryUserSimplyInfoById(userId);
        if (userList != null && !userList.isEmpty()) {
            return userList.get(0);
        }

        return null;
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveUserTransactional(SysUser user) {
        userMapper.insert(user);
        int a = 1 / 0;
        user.setIsDelete(1);
        userMapper.updateByPrimaryKeySelective(user);
    }
}


//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//8-4 整合MyBatis - 自定义mapper的实现 https://www.imooc.com/video/16789

//SysUserMapper.java
package com.imooc.mapper;

import org.springframework.stereotype.Component;

import com.imooc.pojo.SysUser;
import com.imooc.utils.MyMapper;

@Component
public interface SysUserMapper extends MyMapper<SysUser> {
}

//SysUserMapper.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.imooc.mapper.SysUserMapper">
  <resultMap id="BaseResultMap" type="com.imooc.pojo.SysUser">
    <!--
      WARNING - @mbg.generated
    -->
    <id column="id" jdbcType="VARCHAR" property="id" />
    <result column="username" jdbcType="VARCHAR" property="username" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="nickname" jdbcType="VARCHAR" property="nickname" />
    <result column="age" jdbcType="INTEGER" property="age" />
    <result column="sex" jdbcType="INTEGER" property="sex" />
    <result column="job" jdbcType="INTEGER" property="job" />
    <result column="face_image" jdbcType="VARCHAR" property="faceImage" />
    <result column="province" jdbcType="VARCHAR" property="province" />
    <result column="city" jdbcType="VARCHAR" property="city" />
    <result column="district" jdbcType="VARCHAR" property="district" />
    <result column="address" jdbcType="VARCHAR" property="address" />
    <result column="auth_salt" jdbcType="VARCHAR" property="authSalt" />
    <result column="last_login_ip" jdbcType="VARCHAR" property="lastLoginIp" />
    <result column="last_login_time" jdbcType="TIMESTAMP" property="lastLoginTime" />
    <result column="is_delete" jdbcType="INTEGER" property="isDelete" />
    <result column="regist_time" jdbcType="TIMESTAMP" property="registTime" />
  </resultMap>
</mapper>

//SysUserMapperCustom.java
package com.imooc.mapper;

import java.util.List;

import org.springframework.stereotype.Component;

import com.imooc.pojo.SysUser;

@Component
public interface SysUserMapperCustom {
    List<SysUser> queryUserSimplyInfoById(String id);
}

//SysUserMapperCustom.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.imooc.mapper.SysUserMapperCustom">

    <!-- 查询简单的用户信息 -->
    <select id="queryUserSimplyInfoById" resultType="com.imooc.pojo.SysUser"
            parameterType="java.lang.String">
        select 
            *
        from 
            sys_user
        where 
            id = #{id,jdbcType=VARCHAR}
    </select>
</mapper>

//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//8-5 整合MyBatis - 引入事务执行回滚 https://www.imooc.com/video/16731
*事务的隔离级别：
DEFAULT READ_UNCOMMITTED READ_COMMITTED REPEATABLE_READ SERIALIZABLE
*事务的传播行为：
REQUIRED SUPPORTS MANDATORY REQUIRES_NEW NOT_SUPPORTED NEVER NESTED

//增加@Transactional
@Override
@Transactional(propagation = Propagation.REQUIRED)
public void saveUserTransactional(SysUser user) {
    userMapper.insert(user);
    int a = 1 / 0;
    user.setIsDelete(1);
    userMapper.updateByPrimaryKeySelective(user);
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//9-1 SpringBoot整合缓存Redis https://www.imooc.com/video/16790
*pom.xml中需要引入相关依赖
*资源文件中对redis进行配置
*引入redis工具类

//RedisController.java
package com.imooc.controller;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.pojo.SysUser;
import com.imooc.pojo.User;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;

@RestController
@RequestMapping("redis")
public class RedisController {

    @Autowired
    private StringRedisTemplate strRedis;

    @Autowired
    private RedisOperator redis;

    @RequestMapping("/test")
    public IMoocJSONResult test() {
        ValueOperations<String, String> valueOperations = strRedis.opsForValue();
//        valueOperations.set("imooc-cache", "hello 慕课网~~~");
//        return IMoocJSONResult.ok(valueOperations.get("imooc-cache"));

        SysUser user = new SysUser();
        user.setId("1001110");
        user.setUsername("lee");
        user.setNickname("lee");
        user.setPassword("abc123");
        user.setIsDelete(0);
        user.setRegistTime(new Date());
        valueOperations.set("json:user", JsonUtils.objectToJson(user));

        SysUser jsonUser = JsonUtils.jsonToPojo(valueOperations.get("json:user"), SysUser.class);
        return IMoocJSONResult.ok(jsonUser);
    }

    @RequestMapping("/getJsonList")
    public IMoocJSONResult getJsonList() {
        User user = new User();
        user.setAge(18);
        user.setName("慕课网");
        user.setPassword("123456");
        user.setBirthday(new Date());

        User u1 = new User();
        u1.setAge(19);
        u1.setName("imooc");
        u1.setPassword("123456");
        u1.setBirthday(new Date());

        User u2 = new User();
        u2.setAge(17);
        u2.setName("hello imooc");
        u2.setPassword("123456");
        u2.setBirthday(new Date());

        List<User> userList = new ArrayList<>();
        userList.add(user);
        userList.add(u1);
        userList.add(u2);

        redis.set("json:info:userlist", JsonUtils.objectToJson(userList), 2000);

        String userListJson = redis.get("json:info:userlist");
        List<User> userListBorn = JsonUtils.jsonToList(userListJson, User.class);

        return IMoocJSONResult.ok(userListBorn);
    }
}


#关闭缓存, 即时刷新
#spring.freemarker.cache=false
#spring.thymeleaf.cache=true

#热部署生效
spring.devtools.restart.enabled=false
#设置重启的目录,添加那个目录的文件需要restart
spring.devtools.restart.additional-paths=src/main/java
# 为mybatis设置，生产环境可删除
restart.include.mapper=/mapper-[\\w-\\.]+jar
restart.include.pagehelper=/pagehelper-[\\w-\\.]+jar
#排除那个目录的文件不需要restart
spring.devtools.restart.exclude=static/**,public/**,WEB-INF/**      */
#classpath目录下的WEB-INF文件夹内容修改不重启
#spring.devtools.restart.exclude=WEB-INF/**     */
#
############################################################
#
# REDIS 配置
#
############################################################
# Redis数据库索引（默认为0）
spring.redis.database=1
# Redis服务器地址
spring.redis.host=192.168.100.129
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
#spring.redis.pool.max-active=1000
spring.redis.jedis.pool.max-idle=1000
# 连接池最大阻塞等待时间（使用负值表示没有限制）
#spring.redis.pool.max-wait=-1
spring.redis.jedis.pool.max-wait=-1
# 连接池中的最大空闲连接
#spring.redis.pool.max-idle=10
# 连接池中的最小空闲连接
#spring.redis.pool.min-idle=2
spring.redis.jedis.pool.min-idle=2
# 连接超时时间（毫秒）
spring.redis.timeout=1000
#
#
#
############################################################
#
# 配置数据源相关    使用阿里巴巴的 druid 数据源
#
############################################################
#spring.datasource.url=jdbc:mysql://localhost:3306/leecx
spring.datasource.url=jdbc:mysql://localhost:3306/hibernate?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF-8&useSSL=false
spring.datasource.username=root
spring.datasource.password=root123
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.druid.initial-size=1
spring.datasource.druid.min-idle=1
spring.datasource.druid.max-active=20
spring.datasource.druid.test-on-borrow=true
spring.datasource.druid.stat-view-servlet.allow=true
#
#
############################################################
#
# mybatis 配置
#
############################################################
# mybatis 配置
mybatis.type-aliases-package=com.imooc.pojo
mybatis.mapper-locations=classpath:mapper/*.xml     */
# 通用 Mapper 配置
mapper.mappers=com.imooc.utils.MyMapper
mapper.not-empty=false
mapper.identity=MYSQL
# 分页插件配置
pagehelper.helperDialect=mysql
pagehelper.reasonable=true
pagehelper.supportMethodsArguments=true
pagehelper.params=count=countSql


############################################################
#
# 配置i18n 资源文件，供thymeleaf 读取
#
############################################################
spring.messages.basename=i18n/messages
#spring.messages.cache-seconds=3600 已经被废弃
spring.messages.cache-duration=3600
spring.messages.encoding=UTF-8


#设定静态文件路径，js,css等
spring.mvc.static-path-pattern=/static/**

############################################################
#
# freemarker 静态资源配置
#
############################################################
#设定ftl文件路径
spring.freemarker.template-loader-path=classpath:/templates
# 关闭缓存, 即时刷新, 上线生产环境需要改为true
spring.freemarker.cache=false
spring.freemarker.charset=UTF-8
spring.freemarker.check-template-location=true
spring.freemarker.content-type=text/html
spring.freemarker.expose-request-attributes=true
spring.freemarker.expose-session-attributes=true
spring.freemarker.request-context-attribute=request
spring.freemarker.suffix=.ftl


############################################################
#
# thymeleaf 静态资源配置
#
############################################################
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.servlet.content-type=text/html
#spring.thymeleaf.content-type=text/html 已经被废弃
# 关闭缓存, 即时刷新, 上线生产环境需要改为true
spring.thymeleaf.cache=false


############################################################
#
# Server 服务端相关配置
#
############################################################
# 配置api端口号
#server.port=8080
# 配置context-path, 一般来说这个配置在正式发布的时候不配置
#server.context-path=/IMooc server.context-path已经被废弃
#server.servlet.context-path=/IMooc
# 错误页，指定发生错误时，跳转的URL --> BasicErrorController
#server.error.path=/error
# session最大超时时间(分钟)，默认为30分钟
server.session-timeout=60
# 该服务绑定IP地址，启动服务器时如本机不是该IP地址则抛出异常启动失败,
# 只有特殊需求的情况下才配置, 具体根据各自的业务来设置 查看本地IP后，使用http://192.168.100.102:8088/IMooc/hello访问
#server.address=192.168.100.102

############################################################
# Server - tomcat 相关常用配置
############################################################
# tomcat最大线程数, 默认为200
#server.tomcat.max-threads=250
# tomcat的URI编码
server.tomcat.uri-encoding=UTF-8
# 存放Tomcat的日志、Dump等文件的临时文件夹，默认为系统的tmp文件夹
#（如：C:\Users\Shanhy\AppData\Local\Temp）
#server.tomcat.basedir=H:/springboot-tomcat-tmp
# 打开Tomcat的Access日志，并可以设置日志格式的方法：
#server.tomcat.access-log-enabled=true
#server.tomcat.access-log-pattern=
# accesslog目录，默认在basedir/logs
#server.tomcat.accesslog.directory=
# 日志文件目录
#logging.path=H:/springboot-tomcat-tmp
# 日志文件名称，默认为spring.log
#logging.file=myapp.log
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//9-2 SpringBoot使用已封装好的redis工具类进行操作 https://www.imooc.com/video/16791

访问：http://localhost:8080/redis/getJsonList
//RedisOperator.java
package com.imooc.utils;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

/**
 * 
 * @Title: RedisOperator.java
 * @Package com.itzixi.web.component
 * @Description: 使用redisTemplate的操作实现类 Copyright: Copyright (c) 2016
 *               Company:FURUIBOKE.SCIENCE.AND.TECHNOLOGY
 * 
 * @author leechenxiang
 * @date 2017年9月29日 下午2:25:03
 * @version V1.0
 */
@Component
public class RedisOperator {
    
//    @Autowired
//    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    // Key（键），简单的key-value操作

    /**
     * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。
     * 
     * @param key
     * @return
     */
    public long ttl(String key) {
        return redisTemplate.getExpire(key);
    }
    
    /**
     * 实现命令：expire 设置过期时间，单位秒
     * 
     * @param key
     * @return
     */
    public void expire(String key, long timeout) {
        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);
    }
    
    /**
     * 实现命令：INCR key，增加key一次
     * 
     * @param key
     * @return
     */
    public long incr(String key, long delta) {
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key
     */
    public Set<String> keys(String pattern) {
        return redisTemplate.keys(pattern);
    }

    /**
     * 实现命令：DEL key，删除一个key
     * 
     * @param key
     */
    public void del(String key) {
        redisTemplate.delete(key);
    }

    // String（字符串）

    /**
     * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key）
     * 
     * @param key
     * @param value
     */
    public void set(String key, String value) {
        redisTemplate.opsForValue().set(key, value);
    }

    /**
     * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒）
     * 
     * @param key
     * @param value
     * @param timeout
     *            （以秒为单位）
     */
    public void set(String key, String value, long timeout) {
        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    }

    /**
     * 实现命令：GET key，返回 key所关联的字符串值。
     * 
     * @param key
     * @return value
     */
    public String get(String key) {
        return (String)redisTemplate.opsForValue().get(key);
    }

    // Hash（哈希表）

    /**
     * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value
     * 
     * @param key
     * @param field
     * @param value
     */
    public void hset(String key, String field, Object value) {
        redisTemplate.opsForHash().put(key, field, value);
    }

    /**
     * 实现命令：HGET key field，返回哈希表 key中给定域 field的值
     * 
     * @param key
     * @param field
     * @return
     */
    public String hget(String key, String field) {
        return (String) redisTemplate.opsForHash().get(key, field);
    }

    /**
     * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
     * 
     * @param key
     * @param fields
     */
    public void hdel(String key, Object... fields) {
        redisTemplate.opsForHash().delete(key, fields);
    }

    /**
     * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。
     * 
     * @param key
     * @return
     */
    public Map<Object, Object> hgetall(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    // List（列表）

    /**
     * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long lpush(String key, String value) {
        return redisTemplate.opsForList().leftPush(key, value);
    }

    /**
     * 实现命令：LPOP key，移除并返回列表 key的头元素。
     * 
     * @param key
     * @return 列表key的头元素。
     */
    public String lpop(String key) {
        return (String)redisTemplate.opsForList().leftPop(key);
    }

    /**
     * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long rpush(String key, String value) {
        return redisTemplate.opsForList().rightPush(key, value);
    }
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//10-1 SpringBoot整合定时任务task https://www.imooc.com/video/16734
*使用注解@EnableScheduling开启定时任务，会自动扫描
*定义@Component作为组件被容器扫描

//ImoocApplication.java
package com.imooc;

import tk.mybatis.spring.annotation.MapperScan;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//扫描mybatis mapper包路径
@MapperScan(basePackages = "com.imooc.mapper")
//扫描所有需要的包，包含一些自用的工具类包所在的路径
@ComponentScan(basePackages = {"com.imooc", "org.n3r.idworker"})
//开户定时任务，会自动扫描到@Scheduled函数进行执行
@EnableScheduling
public class ImoocApplication {

    public static void main(String[] args) {
        SpringApplication.run(ImoocApplication.class, args);
    }
}

//TestTask.java
package com.imooc.tasks;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class TestTask {
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss");

    //定义每过3秒执行任务
    @Scheduled(fixedRate = 3000)
    public void reportCurrentTime() {
        System.out.println("现在时间：" + DATE_FORMAT.format(new Date()));
    }

    //定义每过5秒执行任务
    @Scheduled(fixedRate = 5000)
    public void reportCurrentTime2() {
        System.out.println("现在时间2：" + DATE_FORMAT.format(new Date()));
    }
}
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//10-2 SpringBoot整合定时任务 定时任务表达式简单讲解与应用 https://www.imooc.com/video/16792
*表达式生成地址：http://cron.qqe2.com

//cron表达式
@Scheduled(cron = "4-40 * * * * ?") //每分钟的4秒到40秒执行
秒 分钟 小时 日 月 星期 只支持这6段，不支持年
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//11-1 SpringBoot整合异步任务以及使用场景 https://www.imooc.com/video/16793
*使用注解@EnableAsync开启异步，会自动扫描
*定义@Component @Async作为组件被容器扫描执行
*使用场景：
--发送短信
--发送邮件
--App消息推送
--节省运维凌晨发布任务时间提供效率

//ImoocApplication.java
package com.imooc;

import tk.mybatis.spring.annotation.MapperScan;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
//扫描mybatis mapper包路径
@MapperScan(basePackages = "com.imooc.mapper")
//扫描所有需要的包，包含一些自用的工具类包所在的路径
@ComponentScan(basePackages = {"com.imooc", "org.n3r.idworker"})
//开户定时任务
//@EnableScheduling
//开启异步任务
@EnableAsync
public class ImoocApplication {

    public static void main(String[] args) {
        SpringApplication.run(ImoocApplication.class, args);
    }
}

//AsyncTask.java
package com.imooc.tasks;

import java.util.concurrent.Future;

import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Component;

@Component
public class AsyncTask {
    @Async
    public Future<Boolean> doTask1() throws InterruptedException {
        long start = System.currentTimeMillis();
        Thread.sleep(1000);
        long end = System.currentTimeMillis();
        System.out.printf("任务1耗时：%d毫秒", end - start);
        return new AsyncResult<>(true);
    }

    @Async
    public Future<Boolean> doTask2() throws InterruptedException {
        long start = System.currentTimeMillis();
        Thread.sleep(700);
        long end = System.currentTimeMillis();
        System.out.printf("任务2耗时：%d毫秒", end - start);
        return new AsyncResult<>(true);
    }

    @Async
    public Future<Boolean> doTask3() throws InterruptedException {
        long start = System.currentTimeMillis();
        Thread.sleep(600);
        long end = System.currentTimeMillis();
        System.out.printf("任务3耗时：%d毫秒", end - start);
        return new AsyncResult<>(true);
    }
}


//DoTask.java
package com.imooc.tasks;

import java.util.concurrent.Future;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("task")
public class DoTask {
    @Autowired
    private AsyncTask asyncTask;

    @RequestMapping("test1")
    public String test1() throws Exception {
        long start = System.currentTimeMillis();

        Future<Boolean> a = asyncTask.doTask1();
        Future<Boolean> b = asyncTask.doTask2();
        Future<Boolean> c = asyncTask.doTask3();//如果注释掉@Async，则三个运行任务的函数变成同步任务，总耗时为2300毫秒

        while (!a.isDone() || !b.isDone() || !c.isDone()) {
            if (a.isDone() && b.isDone() && c.isDone()) {
                break;
            }
        }

        long end = System.currentTimeMillis();

        String times = String.format("任务全部完成，总耗时：%d毫秒", end - start);
        System.out.println(times);
        return times;
    }
}

访问的URL：http://localhost:8080/task/test1
任务全部完成，总耗时：1001毫秒
//------------------------------------------------------------------------------------------------
//SpringBoot开发常用技术整合
//12-1 SpringBoot拦截器的使用 https://www.imooc.com/video/16794
*使用注解@Configuration配置拦截器
*继承WebMvcConfigurerAdapter
*重写addInterceptors添加需要的拦截器地址

//MyWebMvcConfigurer.java
package com.imooc.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import com.imooc.controller.interceptor.OneInterceptor;
import com.imooc.controller.interceptor.TwoInterceptor;

@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer { //原视频教程里用到的WebMvcConfigurerAdapter已废弃，可以用WebMvcConfigurer替换
//public class MyWebMvcConfigurer extends WebMvcConfigurerAdapter {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        /**
         * 拦截器按照顺序执行
         */
        registry.addInterceptor(new OneInterceptor()).addPathPatterns("/one/**");// /*/**则所有的调用都可以拦截
        registry.addInterceptor(new TwoInterceptor()).addPathPatterns("/two/**")
                                                     .addPathPatterns("/one/**");//可以级联增加多个PathPattern
//        super.addInterceptors(registry); //WebMvcConfigurerAdapter::addInterceptors()方法为空实现，所以不需要调用
    }
}

//OneController.java
package com.imooc.controller.interceptor;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.imooc.pojo.User;

@Controller
@RequestMapping("one")
public class OneController {

    @RequestMapping("/index")
    public String index(ModelMap map) {
        map.addAttribute("name", "imooc22");
        return "thymeleaf/index";
    }

    @RequestMapping("center")
    public String center() {
        return "thymeleaf/center/center";
    }

    @RequestMapping("test")
    public String test(ModelMap map) {

        User user = new User();
        user.setAge(18);
        user.setName("manager");
        user.setPassword("123456");
        user.setBirthday(new Date());

        map.addAttribute("user", user);


        User u1 = new User();
        u1.setAge(19);
        u1.setName("imooc");
        u1.setPassword("123456");
        u1.setBirthday(new Date());

        User u2 = new User();
        u2.setAge(17);
        u2.setName("LeeCX");
        u2.setPassword("123456");
        u2.setBirthday(new Date());

        List<User> userList = new ArrayList<>();
        userList.add(user);
        userList.add(u1);
        userList.add(u2);

        map.addAttribute("userList", userList);

        return "thymeleaf/test";
    }

    @PostMapping("postform")
    public String postform(User user) {
        System.out.println(user.getName());
        return "redirect:/th/test";
    }
}

//OneInterceptor.java
package com.imooc.controller.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.utils.JsonUtils;

public class OneInterceptor implements HandlerInterceptor {

    /**
     * 在请求处理之前进行调用（Controller方法调用之前）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object object) throws Exception {

        System.out.println("被one拦截，放行...");
        return true; //true则可以正常访问url

        /*if (true) {
            returnErrorResponse(response, IMoocJSONResult.errorMsg("被one拦截..."));
        }
        
        return false;*/
    }

    /**
     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object object, ModelAndView mv)
        throws Exception {
        // TODO Auto-generated method stub

    }

    /**
     * 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行
     * （主要是用于进行资源清理工作）
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object object, Exception ex)
        throws Exception {
        // TODO Auto-generated method stub

    }

    public void returnErrorResponse(HttpServletResponse response, IMoocJSONResult result)
        throws IOException, UnsupportedEncodingException {
        OutputStream out = null;
        try {
            response.setCharacterEncoding("utf-8");
            response.setContentType("text/json");
            out = response.getOutputStream();
            out.write(JsonUtils.objectToJson(result).getBytes("utf-8"));
            out.flush();
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }
}

//TwoController.java
package com.imooc.controller.interceptor;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.imooc.pojo.User;

@Controller
@RequestMapping("two")
public class TwoController {

    @RequestMapping("/index")
    public String index(ModelMap map) {
        map.addAttribute("name", "itzixi22");
        return "thymeleaf/index";
    }

    @RequestMapping("center")
    public String center() {
        return "thymeleaf/center/center";
    }

    @RequestMapping("test")
    public String test(ModelMap map) {

        User user = new User();
        user.setAge(18);
        user.setName("manager");
        user.setPassword("123456");
        user.setBirthday(new Date());

        map.addAttribute("user", user);


        User u1 = new User();
        u1.setAge(19);
        u1.setName("itzixi");
        u1.setPassword("123456");
        u1.setBirthday(new Date());

        User u2 = new User();
        u2.setAge(17);
        u2.setName("LeeCX");
        u2.setPassword("123456");
        u2.setBirthday(new Date());

        List<User> userList = new ArrayList<>();
        userList.add(user);
        userList.add(u1);
        userList.add(u2);

        map.addAttribute("userList", userList);

        return "thymeleaf/test";
    }

    @PostMapping("postform")
    public String postform(User user) {
        System.out.println(user.getName());
        return "redirect:/th/test";
    }
}

//TwoInterceptor.java
package com.imooc.controller.interceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import com.imooc.pojo.IMoocJSONResult;
import com.imooc.utils.JsonUtils;

public class TwoInterceptor implements HandlerInterceptor {

    final static Logger log = LoggerFactory.getLogger(TwoInterceptor.class);

    /**
     * 在请求处理之前进行调用（Controller方法调用之前）
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object object) throws Exception {

        if (true) {
            returnErrorResponse(response, IMoocJSONResult.errorMsg("被two拦截..."));
        }

        System.out.println("被two拦截...");

        return false; //这里return false，则不会继续进行url的访问
    }

    /**
     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object object, ModelAndView mv)
        throws Exception {
        // TODO Auto-generated method stub

    }

    /**
     * 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object object, Exception ex)
        throws Exception {
        // TODO Auto-generated method stub

    }

    public void returnErrorResponse(HttpServletResponse response, IMoocJSONResult result) throws IOException, UnsupportedEncodingException {
        OutputStream out = null;
        try {
            response.setCharacterEncoding("utf-8");
            response.setContentType("text/json");
            out = response.getOutputStream();
            out.write(JsonUtils.objectToJson(result).getBytes("utf-8"));
            out.flush();
        } finally {
            if (out != null) {
                out.close();
            }
        }
    }
}

访问url：http://localhost:8080/one/index
//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------

